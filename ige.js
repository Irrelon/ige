(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeCuboidSmartTexture', function () {
	var IgeCuboidSmartTexture = {
		render: function (ctx, entity) {
			var poly = entity.localIsoBoundsPoly();
			
			ctx.strokeStyle = '#a200ff';
			
			poly.render(ctx);
		}
	};
	
	return IgeCuboidSmartTexture;
});
},{"irrelon-appcore":125}],2:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFontSmartTexture', function () {
	/**
	 * Provides native canvas font rendering supporting multi-line
	 * text and alignment options.
	 */
	var IgeFontSmartTexture = {
		measureTextWidth: function (text, entity) {
			if (entity._nativeFont) {
				var lineArr = [],
					lineIndex,
					measuredWidth,
					maxWidth = 0,
					canvas = document.createElement('canvas'),
					ctx = canvas.getContext('2d');
				
				// Handle multi-line text
				if (text.indexOf('\n') > -1) {
					// Split each line into an array item
					lineArr = text.split('\n');
				} else {
					// Store the text as a single line
					lineArr.push(text);
				}
	
				ctx.font = entity._nativeFont;
				ctx.textBaseline = 'middle';
	
				if (entity._nativeStroke) {
					ctx.lineWidth = entity._nativeStroke;
	
					if (entity._nativeStrokeColor) {
						ctx.strokeStyle = entity._nativeStrokeColor;
					} else {
						ctx.strokeStyle = entity._colorOverlay;
					}
				}
				
				for (lineIndex = 0; lineIndex < lineArr.length; lineIndex++) {
					// Measure text
					measuredWidth = ctx.measureText(lineArr[lineIndex]).width;
					
					if (measuredWidth > maxWidth) {
						maxWidth = measuredWidth;
					}
				}
				
				return maxWidth;
			}
			
			return -1;
		},
		
		render: function (ctx, entity) {
			if (entity._nativeFont && entity._renderText) {
				var text = entity._renderText,
					lineArr = [],
					textSize,
					renderStartY,
					renderY,
					lineHeight,
					i;
	
				ctx.font = entity._nativeFont;
	
				if (entity._colorOverlay) {
					ctx.fillStyle = entity._colorOverlay;
				}
	
				// Text alignment
				if (entity._textAlignX === 0) {
					ctx.textAlign = 'left';
					ctx.translate(-entity._bounds2d.x2, 0);
				}
	
				if (entity._textAlignX === 1) {
					ctx.textAlign = 'center';
					//ctx.translate(-entity._bounds2d.x2, 0);
				}
	
				if (entity._textAlignX === 2) {
					ctx.textAlign = 'right';
					ctx.translate(entity._bounds2d.x2, 0);
				}
	
				if (entity._nativeStroke) {
					ctx.lineWidth = entity._nativeStroke;
	
					if (entity._nativeStrokeColor) {
						ctx.strokeStyle = entity._nativeStrokeColor;
					} else {
						ctx.strokeStyle = entity._colorOverlay;
					}
				}
	
				// Handle multi-line text
				if (text.indexOf('\n') > -1) {
					// Split each line into an array item
					lineArr = text.split('\n');
				} else {
					// Store the text as a single line
					lineArr.push(text);
				}
	
				// vertical text alignment
				if (entity._textAlignY === 0) {
					ctx.textBaseline = 'top';
					renderStartY = -(entity._bounds2d.y / 2);
				}
				if (entity._textAlignY === 1) {
					ctx.textBaseline = 'middle';
					renderStartY = -(entity._textLineSpacing / 2) * (lineArr.length - 1);
				}
				if (entity._textAlignY === 2) {
					ctx.textBaseline = 'bottom';
					renderStartY = entity._bounds2d.y / 2 - entity._textLineSpacing * (lineArr.length - 1);
				}
				// Justified - lines spaced out evenly according to height
				if (entity._textAlignY === 3) {
					ctx.textBaseline = 'middle';
					lineHeight = Math.floor(entity._bounds2d.y / lineArr.length);
					renderStartY = -((lineHeight + (entity._textLineSpacing)) / 2) * (lineArr.length - 1);
				}
	
				for (i = 0; i < lineArr.length; i++) {
					if (entity._textAlignY === 3) {
						renderY = renderStartY + (lineHeight * i) + (entity._textLineSpacing * (i));
					} else {
						renderY = renderStartY + entity._textLineSpacing * i;
					}
	
					// Measure text
					textSize = ctx.measureText(lineArr[i]);
	
					// Check if we should stroke the text too
					if (entity._nativeStroke) {
						ctx.strokeText(lineArr[i], 0, renderY);
					}
	
					// Draw text
					ctx.fillText(lineArr[i], 0, renderY);
				}
			}
		}
	};
	
	return IgeFontSmartTexture;
});
},{"irrelon-appcore":125}],3:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTileMap2dSmartTexture', function (IgePoint2d) {
	var IgeTileMap2dSmartTexture = {
		render: function (ctx, entity) {
			var tileWidth = entity._tileWidth,
				tileHeight = entity._tileHeight,
				bounds2d = entity.bounds2d(),
				gridSize = entity._gridSize,
				x = 0, y = 0;
			
			/*ctx.save();
			 var triggerPoly = entity.tileMapHitPolygon();
			 
			 ctx.strokeStyle = '#00ff00';
			 ctx.fillStyle = '#ff99f4';
			 
			 if (entity._processTriggerHitTests()) {
			 ctx.fillStyle = '#ff26e8';
			 }
			 
			 if (entity._mountMode === 0) {
			 ctx.translate(bounds2d.x2, bounds2d.y2);
			 }
			 
			 if (entity._mountMode === 1) {
			 ctx.translate(-entity._translate.x, -entity._translate.y);
			 triggerPoly.render(ctx, true);
			 }
			 
			 //
			 ctx.restore();*/
			
			if (entity._drawGrid) {
				ctx.strokeStyle = entity._gridColor;
				var gridMaxX = x + tileWidth * gridSize.x,
					gridMaxY = y + tileHeight * gridSize.y,
					index,
					gStart,
					gEnd;
				
				x = 0;
				y = 0;
				
				for (index = 0; index <= gridSize.y; index++) {
					gStart = new IgePoint2d(x, y + (tileHeight * index));
					gEnd = new IgePoint2d(gridMaxX, y + (tileHeight * index));
					
					if (entity._mountMode === 1) {
						// Iso grid
						gStart = gStart.toIso();
						gEnd = gEnd.toIso();
					}
					
					ctx.beginPath();
					ctx.moveTo(gStart.x, gStart.y);
					ctx.lineTo(gEnd.x, gEnd.y);
					ctx.stroke();
				}
				
				for (index = 0; index <= gridSize.x; index++) {
					gStart = new IgePoint2d(x + (tileWidth * index), y);
					gEnd = new IgePoint2d(x + (tileWidth * index), gridMaxY);
					
					if (entity._mountMode === 1) {
						// Iso grid
						gStart = gStart.toIso();
						gEnd = gEnd.toIso();
					}
					
					ctx.beginPath();
					ctx.moveTo(gStart.x, gStart.y);
					ctx.lineTo(gEnd.x, gEnd.y);
					ctx.stroke();
				}
			}
			
			if (entity._highlightOccupied) {
				ctx.fillStyle = '#ff0000';
				for (y in entity.map._mapData) {
					if (entity.map._mapData[y]) {
						for (x in entity.map._mapData[y]) {
							if (entity.map._mapData[y][x]) {
								// Tile is occupied
								tilePoint = new IgePoint2d(tileWidth * x, tileHeight * y);
								
								// TODO: Abstract out the tile drawing method so that it can be overridden for other projections etc
								if (entity._mountMode === 0) {
									// 2d
									ctx.fillRect(
										tilePoint.x,
										tilePoint.y,
										tileWidth,
										tileHeight
									);
								}
								
								if (entity._mountMode === 1) {
									// iso
									tilePoint.thisToIso();
									
									ctx.beginPath();
									ctx.moveTo(tilePoint.x, tilePoint.y);
									ctx.lineTo(tilePoint.x + tileWidth, tilePoint.y + tileHeight / 2);
									ctx.lineTo(tilePoint.x, tilePoint.y + tileHeight);
									ctx.lineTo(tilePoint.x - tileWidth, tilePoint.y + tileHeight / 2);
									ctx.lineTo(tilePoint.x, tilePoint.y);
									ctx.fill();
								}
							}
						}
					}
				}
			}
			
			if (entity._highlightTileRect) {
				ctx.fillStyle = '#e4ff00';
				for (y = entity._highlightTileRect.y; y < entity._highlightTileRect.y + entity._highlightTileRect.height; y++) {
					for (x = entity._highlightTileRect.x; x < entity._highlightTileRect.x + entity._highlightTileRect.width; x++) {
						// Tile is occupied
						tilePoint = new IgePoint2d(tileWidth * x, tileHeight * y);
						
						// TODO: Abstract out the tile drawing method so that it can be overridden for other projections etc
						if (entity._mountMode === 0) {
							// 2d
							ctx.fillRect(
								tilePoint.x,
								tilePoint.y,
								tileWidth,
								tileHeight
							);
						}
						
						if (entity._mountMode === 1) {
							// iso
							tilePoint.thisToIso();
							
							ctx.beginPath();
							ctx.moveTo(tilePoint.x, tilePoint.y - tileHeight / 2);
							ctx.lineTo(tilePoint.x + tileWidth, tilePoint.y);
							ctx.lineTo(tilePoint.x, tilePoint.y + tileHeight / 2);
							ctx.lineTo(tilePoint.x - tileWidth, tilePoint.y);
							ctx.lineTo(tilePoint.x, tilePoint.y - tileHeight / 2);
							ctx.fill();
						}
					}
				}
			}
			
			if (entity._drawMouse) {
				// Get mouse position
				var mousePos = entity.mousePos(),
					mouseTile = entity.mouseToTile(),
					tilePoint,
					text,
					textMeasurement;
				
				if (mouseTile.x >= 0 && mouseTile.y >= 0 && mouseTile.x < gridSize.x && mouseTile.y < gridSize.y) {
					// Paint the tile the mouse is currently intersecting
					ctx.fillStyle = entity._hoverColor || '#6000ff';
					if (entity._mountMode === 0) {
						// 2d
						ctx.fillRect(
							(mouseTile.x * tileWidth),
							(mouseTile.y * tileHeight),
							tileWidth,
							tileHeight
						);
					}
					
					if (entity._mountMode === 1) {
						// iso
						tilePoint = mouseTile
							.clone()
							.thisMultiply(tileWidth, tileHeight, 0)
							.thisToIso();
						
						tilePoint.y += tileHeight / 2;
						
						ctx.beginPath();
						ctx.moveTo(tilePoint.x, tilePoint.y - tileHeight / 2);
						ctx.lineTo(tilePoint.x + tileWidth, tilePoint.y);
						ctx.lineTo(tilePoint.x, tilePoint.y + tileHeight / 2);
						ctx.lineTo(tilePoint.x - tileWidth, tilePoint.y);
						ctx.lineTo(tilePoint.x, tilePoint.y - tileHeight / 2);
						ctx.fill();
					}
					
					if (entity._drawMouseData) {
						text = 'Tile X: ' + mouseTile.x + ' Y: ' + mouseTile.y;
						textMeasurement = ctx.measureText(text);
						ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
						ctx.fillRect(Math.floor(mousePos.x - textMeasurement.width / 2 - 5), Math.floor(mousePos.y - 40), Math.floor(textMeasurement.width + 10), 14);
						ctx.fillStyle = '#ffffff';
						ctx.fillText(text, Math.floor(mousePos.x - textMeasurement.width / 2), Math.floor(mousePos.y - 30));
					}
				}
			}
		}
	};
	
	return IgeTileMap2dSmartTexture;
});
},{"irrelon-appcore":125}],4:[function(_dereq_,module,exports){
_dereq_('./components/stackTrace/lib_stack.js');
_dereq_('./core/IgeBase.js');
_dereq_('./core/$ige.js');
_dereq_('./core/$game.js');
_dereq_('./core/$time.js');
_dereq_('./core/$textures.js');
_dereq_('./core/IgeClass.js');
_dereq_('./core/IgeEventingClass.js');
_dereq_('./core/IgePoint2d.js');
_dereq_('./core/IgePoint3d.js');
_dereq_('./core/IgePoly2d.js');
_dereq_('./core/IgeRect.js');
_dereq_('./core/IgeMatrix2d.js');
_dereq_('./components/IgeTimeComponent.js');
_dereq_('./components/IgeAnimationComponent.js');
_dereq_('./components/IgeVelocityComponent.js');
_dereq_('./components/IgeTweenComponent.js');
_dereq_('./components/IgePathComponent.js');
_dereq_('./components/IgeInputComponent.js');
_dereq_('./components/IgeGamePadComponent.js');
_dereq_('./components/IgeMousePanComponent.js');
_dereq_('./components/IgeMouseZoomComponent.js');
_dereq_('./components/IgeTiledComponent.js');
_dereq_('./components/IgeUiManagerComponent.js');
_dereq_('./components/entityManager/IgeEntityManager.js');
_dereq_('./components/IgeEntityManagerComponent.js');
_dereq_('./components/editor/IgeEditorComponent.js');
_dereq_('./components/editor/IgeEditorTranslateComponent.js');
_dereq_('./components/editor/IgeEditorRotateComponent.js');
_dereq_('./components/physics/box2d/lib_box2d.js');
_dereq_('./components/physics/cannon/lib_cannon.js');
_dereq_('./components/physics/cannon/IgeCannonComponent.js');
_dereq_('./components/network/IgeTimeSyncExtension.js');
_dereq_('./components/network/stream/IgeStreamComponent.js');
_dereq_('./components/network/socket.io/client/socket.io.min.js');
_dereq_('./components/network/socket.io/IgeSocketIoClient.js');
_dereq_('./components/network/socket.io/IgeSocketIoComponent.js');
_dereq_('./components/network/net.io/net.io-client/index.js');
_dereq_('./components/network/net.io/IgeNetIoClient.js');
_dereq_('./components/network/net.io/IgeNetIoClientComponent.js');
_dereq_('./components/chat/IgeChatClient.js');
_dereq_('./components/chat/IgeChatComponent.js');
_dereq_('./components/cocoonjs/IgeCocoonJsComponent.js');
_dereq_('./extensions/IgeUiPositionExtension.js');
_dereq_('./extensions/IgeUiStyleExtension.js');
_dereq_('./core/$requestAnimFrame.js');
_dereq_('./core/IgeFSM.js');
_dereq_('./core/IgeSceneGraph.js');
_dereq_('./core/IgeBaseScene.js');
_dereq_('./core/IgeDummyCanvas.js');
_dereq_('./core/IgeDummyContext.js');
_dereq_('./core/IgePathNode.js');
_dereq_('./core/IgePathFinder.js');
_dereq_('./core/IgeTween.js');
_dereq_('./core/IgeTexture.js');
_dereq_('./core/IgeCellSheet.js');
_dereq_('./core/IgeSpriteSheet.js');
_dereq_('./core/IgeFontSheet.js');
_dereq_('./assets/IgeFontSmartTexture.js');
_dereq_('./core/IgeObject.js');
_dereq_('./core/IgeEntity.js');
_dereq_('./core/IgeUiEntity.js');
_dereq_('./core/IgeUiElement.js');
_dereq_('./core/IgeFontEntity.js');
_dereq_('./core/IgeParticleEmitter.js');
_dereq_('./core/IgeParticle.js');
_dereq_('./core/IgeMap2d.js');
_dereq_('./core/IgeTileMap2d.js');
_dereq_('./core/IgeTextureMap.js');
_dereq_('./assets/IgeTileMap2dSmartTexture.js');
_dereq_('./core/IgeCollisionMap2d.js');
_dereq_('./core/IgeCamera.js');
_dereq_('./core/IgeViewport.js');
_dereq_('./core/IgeScene2d.js');
_dereq_('./core/IgeQuest.js');
_dereq_('./core/IgeInterval.js');
_dereq_('./core/IgeTimeout.js');
_dereq_('./assets/IgeCuboidSmartTexture.js');
_dereq_('./primitives/IgeCuboid.js');
_dereq_('./core/IgeArray.js');
_dereq_('./components/audio/IgeAudioComponent.js');
_dereq_('./components/audio/IgeAudio.js');
_dereq_('./components/physics/box2d/IgeBox2dComponent.js');
_dereq_('./components/physics/box2d/IgeBox2dMultiWorldComponent.js');
_dereq_('./components/physics/box2d/IgeBox2dWorld.js');
_dereq_('./components/physics/box2d/IgeBox2dDebugPainter.js');
_dereq_('./components/physics/box2d/IgeEntityBox2d.js');
_dereq_('./components/physics/cannon/IgeEntityCannon.js');
_dereq_('./ui/IgeUiDropDown.js');
_dereq_('./ui/IgeUiButton.js');
_dereq_('./ui/IgeUiRadioButton.js');
_dereq_('./ui/IgeUiProgressBar.js');
_dereq_('./ui/IgeUiTextBox.js');
_dereq_('./ui/IgeUiLabel.js');
_dereq_('./ui/IgeUiTooltip.js');
_dereq_('./ui/IgeUiMenu.js');
_dereq_('./ui/IgeUiTimeStream.js');
_dereq_('./core/IgeFilters.js');
_dereq_('./filters/convolute.js');
_dereq_('./filters/greyScale.js');
_dereq_('./filters/brighten.js');
_dereq_('./filters/threshold.js');
_dereq_('./filters/sharpen.js');
_dereq_('./filters/blur.js');
_dereq_('./filters/emboss.js');
_dereq_('./filters/edgeDetect.js');
_dereq_('./filters/edgeEnhance.js');
_dereq_('./filters/outlineDetect.js');
_dereq_('./filters/colorOverlay.js');
_dereq_('./filters/sobel.js');
_dereq_('./filters/invert.js');
_dereq_('./filters/glowMask.js');
_dereq_('./core/IgeEngine.js');
},{"./assets/IgeCuboidSmartTexture.js":1,"./assets/IgeFontSmartTexture.js":2,"./assets/IgeTileMap2dSmartTexture.js":3,"./components/IgeAnimationComponent.js":5,"./components/IgeEntityManagerComponent.js":6,"./components/IgeGamePadComponent.js":7,"./components/IgeInputComponent.js":8,"./components/IgeMousePanComponent.js":9,"./components/IgeMouseZoomComponent.js":10,"./components/IgePathComponent.js":11,"./components/IgeTiledComponent.js":12,"./components/IgeTimeComponent.js":13,"./components/IgeTweenComponent.js":14,"./components/IgeUiManagerComponent.js":15,"./components/IgeVelocityComponent.js":16,"./components/audio/IgeAudio.js":17,"./components/audio/IgeAudioComponent.js":18,"./components/chat/IgeChatClient.js":19,"./components/chat/IgeChatComponent.js":20,"./components/cocoonjs/IgeCocoonJsComponent.js":21,"./components/editor/IgeEditorComponent.js":22,"./components/editor/IgeEditorRotateComponent.js":23,"./components/editor/IgeEditorTranslateComponent.js":24,"./components/entityManager/IgeEntityManager.js":25,"./components/network/IgeTimeSyncExtension.js":26,"./components/network/net.io/IgeNetIoClient.js":27,"./components/network/net.io/IgeNetIoClientComponent.js":28,"./components/network/net.io/net.io-client/index.js":29,"./components/network/socket.io/IgeSocketIoClient.js":30,"./components/network/socket.io/IgeSocketIoComponent.js":31,"./components/network/socket.io/client/socket.io.min.js":32,"./components/network/stream/IgeStreamComponent.js":33,"./components/physics/box2d/IgeBox2dComponent.js":34,"./components/physics/box2d/IgeBox2dDebugPainter.js":35,"./components/physics/box2d/IgeBox2dMultiWorldComponent.js":36,"./components/physics/box2d/IgeBox2dWorld.js":37,"./components/physics/box2d/IgeEntityBox2d.js":38,"./components/physics/box2d/lib_box2d.js":39,"./components/physics/cannon/IgeCannonComponent.js":40,"./components/physics/cannon/IgeEntityCannon.js":41,"./components/physics/cannon/lib_cannon.js":42,"./components/stackTrace/lib_stack.js":43,"./core/$game.js":44,"./core/$ige.js":45,"./core/$requestAnimFrame.js":46,"./core/$textures.js":47,"./core/$time.js":48,"./core/IgeArray.js":49,"./core/IgeBase.js":50,"./core/IgeBaseScene.js":51,"./core/IgeCamera.js":52,"./core/IgeCellSheet.js":53,"./core/IgeClass.js":54,"./core/IgeCollisionMap2d.js":55,"./core/IgeDummyCanvas.js":56,"./core/IgeDummyContext.js":57,"./core/IgeEngine.js":58,"./core/IgeEntity.js":59,"./core/IgeEventingClass.js":60,"./core/IgeFSM.js":61,"./core/IgeFilters.js":62,"./core/IgeFontEntity.js":63,"./core/IgeFontSheet.js":64,"./core/IgeInterval.js":65,"./core/IgeMap2d.js":66,"./core/IgeMatrix2d.js":68,"./core/IgeObject.js":69,"./core/IgeParticle.js":70,"./core/IgeParticleEmitter.js":71,"./core/IgePathFinder.js":72,"./core/IgePathNode.js":73,"./core/IgePoint2d.js":74,"./core/IgePoint3d.js":75,"./core/IgePoly2d.js":76,"./core/IgeQuest.js":77,"./core/IgeRect.js":78,"./core/IgeScene2d.js":79,"./core/IgeSceneGraph.js":80,"./core/IgeSpriteSheet.js":81,"./core/IgeTexture.js":83,"./core/IgeTextureMap.js":85,"./core/IgeTileMap2d.js":86,"./core/IgeTimeout.js":87,"./core/IgeTween.js":88,"./core/IgeUiElement.js":89,"./core/IgeUiEntity.js":90,"./core/IgeViewport.js":91,"./extensions/IgeUiPositionExtension.js":92,"./extensions/IgeUiStyleExtension.js":93,"./filters/blur.js":94,"./filters/brighten.js":95,"./filters/colorOverlay.js":96,"./filters/convolute.js":97,"./filters/edgeDetect.js":98,"./filters/edgeEnhance.js":99,"./filters/emboss.js":100,"./filters/glowMask.js":101,"./filters/greyScale.js":102,"./filters/invert.js":103,"./filters/outlineDetect.js":104,"./filters/sharpen.js":105,"./filters/sobel.js":106,"./filters/threshold.js":107,"./primitives/IgeCuboid.js":108,"./ui/IgeUiButton.js":110,"./ui/IgeUiDropDown.js":111,"./ui/IgeUiLabel.js":114,"./ui/IgeUiMenu.js":115,"./ui/IgeUiProgressBar.js":116,"./ui/IgeUiRadioButton.js":117,"./ui/IgeUiTextBox.js":120,"./ui/IgeUiTimeStream.js":121,"./ui/IgeUiTooltip.js":123}],5:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeAnimationComponent', function ($ige, $time, IgeEventingClass) {
	/**
	 * The animation component class. Handles defining and controlling
	 * frame-based animations based on cells from a texture.
	 * @event started - The animation starts.
	 * @event stopped - The animation ends or is stopped.
	 * @event loopComplete - The animation has completed a full cycle (shown all frames).
	 * @event complete - The animation has completed all assigned loop cycles.
	 */
	var IgeAnimationComponent = IgeEventingClass.extend({
		classId: 'IgeAnimationComponent',
		componentId: 'animation',
		
		/**
		 * @constructor
		 * @param {Object} entity The parent object that this component is being added to.
		 * @param {Object=} options An optional object that is passed to the component when it is being initialised.
		 */
		init: function (entity, options) {
			this._entity = entity;
			this._anims = {};
			
			// Add the animation behaviour to the entity
			entity.addBehaviour('tween', this._update);
		},
		
		/**
		 * Defines an animation specifying the frames to use, the
		 * frames per second to animate at and if the animation
		 * should loop and if so, how many times.
		 * @param {String} id The unique animation id.
		 * @param {Array} frames An array of cell numbers to animate through.
		 * @param {Number} fps The speed of the animation (frames per second).
		 * @param {Number} loop The number of times to loop the animation, or -1 to loop forever. Defaults to -1.
		 * @param {Boolean} convertIdsToIndex If true will convert cell ids to cell indexes to speed
		 * up animation processing. This is true by default but should be disabled if you intend to
		 * change the assigned texture of the entity that this animation is applied to after you have
		 * defined the animation since the frame indexes will likely map to incorrect cells on a
		 * different texture.
		 * @example #Define an animation
		 *     // Create an entity, add the animation component and define
		 *     // an animation using frames 1, 2, 3 and 4, with an FPS of
		 *     // 25 and looping forever (-1)
		 *     var entity = new IgeEntity()
		 *         .addComponent(IgeAnimationComponent)
		 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
		 * @return {*}
		 */
		define: function (id, frames, fps, loop, convertIdsToIndex) {
			if (frames && frames.length) {
				var i, frame;
				this._anims.length = this._anims.length || 0;
				
				if (convertIdsToIndex === undefined) {
					convertIdsToIndex = true; // Default the flag to true if undefined
				}
				
				if (convertIdsToIndex) {
					// Check each frame for string values
					for (i = 0; i < frames.length; i++) {
						frame = frames[i];
						
						if (typeof(frame) === 'string') {
							if (this._entity._texture) {
								// The frame has a cell id so convert to an index
								frame = this._entity._texture.cellIdToIndex(frame);
								frames[i] = frame;
							} else {
								this.log('You can increase the performance of id-based cell animations by specifying the animation.define AFTER you have assigned your sprite sheet to the entity on entity with ID: ' + this._entity.id(), 'warning');
								break;
							}
						}
					}
				}
				
				// Store the animation
				var frameTime = ((1000 / fps)|0);
				this._anims[id] = {
					frames: frames,
					frameTime: frameTime,
					loop: loop !== undefined ? loop : -1, // Default to infinite loop (-1)
					frameCount: frames.length,
					totalTime: frames.length * frameTime,
					currentDelta: 0,
					currentLoop: 0
				};
				
				this._anims.length++;
			} else {
				this.log('Cannot define an animation without a frame array!', 'error');
			}
			return this._entity;
		},
		
		addFrame: function (id, frameId) {
			if (this._anims[id]) {
				var anim = this._anims[id];
				
				if (typeof(frameId) === 'string') {
					frameId = this._entity._texture.cellIdToIndex(frameId);
				}
				
				anim.frames.push(frameId);
				anim.frameCount++;
				anim.totalTime = anim.frames.length * anim.frameTime;
			}
		},
		
		removeFrame: function (id, frameIndex) {
			if (this._anims[id]) {
				var anim = this._anims[id];
				
				anim.frames.splice(frameIndex, 1);
				anim.frameCount--;
				anim.totalTime = anim.frames.length * anim.frameTime;
			}
		},
		
		/**
		 * Creates an array of frames starting at the "from" and ending at the "to"
		 * parameters. Useful for creating linear frame lists instead of having to
		 * specifiy each frame in between the from and to frame numbers.
		 * @param {Integer} from The frame to start at.
		 * @param {Integer} to The frame to end at.
		 * @returns {Array} The frame array.
		 */
		generateFrameArray: function (from, to) {
			var arr = [];
			
			while (from < to) {
				arr.push(from);
				from++;
			}
			
			return arr;
		},
		
		/**
		 * Removes a previously defined animation from the entity.
		 * @param {String} id The id of the animation to remove.
		 * @returns {*}
		 */
		remove: function (id) {
			delete this._anims[id];
			this._anims.length--;
			
			return this._entity;
		},
		
		/**
		 * Returns true if the specified animation has been defined.
		 * @param {String} id The id of the animation to check for.
		 * @returns {Boolean} True if the animation has been defined.
		 */
		defined: function (id) {
			return Boolean(this._anims[id]);
		},
		
		/**
		 * Sets the specified animation's FPS.
		 * @param {String} id The ID of the animation to alter the FPS for.
		 * @param {Number=} fps The number of frames per second the animation
		 * should play at.
		 * @example #Set the specified animation's FPS
		 *     // Create an entity, add the animation component and define
		 *     // an animation with an FPS of 25
		 *     var entity = new IgeEntity()
		 *         .addComponent(IgeAnimationComponent)
		 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
		 *
		 *     // Change the FPS to 12
		 *     entity.animation.setFps('anim1', 12);
		 * @return {*}
		 */
		setFps: function (id, fps) {
			if (this._anims) {
				var anim = this._anims[id];
				
				if (anim) {
					anim.frameTime = ((1000 / fps)|0);
					anim.totalTime = anim.frameCount * anim.frameTime;
				}
			}
			
			return this._entity;
		},
		
		/**
		 * Sets all the animations assigned to an entity to the specified FPS.
		 * @param {Number=} fps The number of frames per second the animations
		 * should play at.
		 * @example #Set all entity animations to specified FPS
		 *     // Create an entity, add the animation component and define
		 *     // a couple of animations with an FPS of 25
		 *     var entity = new IgeEntity()
		 *         .addComponent(IgeAnimationComponent)
		 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
		 *         .animation.define('anim2', [5, 6, 7, 8], 25, -1);
		 *
		 *     // Change the FPS of all animations to 12
		 *     entity.animation.setAllFps(12);
		 * @return {*}
		 */
		setAllFps: function (fps) {
			var id;
			
			if (this._anims) {
				for (id in this._anims) {
					if (this._anims.hasOwnProperty(id)) {
						this.setFps(id, fps);
					}
				}
			}
			
			return this._entity;
		},
		
		/**
		 * Checks the current animation state, either started
		 * or stopped.
		 * @return {Boolean} True if an animation is currently playing
		 * or false if not.
		 */
		playing: function () {
			return this._playing;
		},
		
		/**
		 * Starts an animation from the beginning frame.
		 * @param {String} animId The id of the animation to start.
		 * @param {Object=} options An object with some option properties.
		 * @example #Start an animation
		 *     // Create an entity, add the animation component, define
		 *     // an animation and then start it
		 *     var entity = new IgeEntity()
		 *         .addComponent(IgeAnimationComponent)
		 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
		 *
		 *     entity.animation.start('anim1');
		 *
		 * @example #Start an animation with callbacks for animation events
		 *     // Create an entity, add the animation component, define
		 *     // an animation and then start it
		 *     var entity = new IgeEntity()
		 *         .addComponent(IgeAnimationComponent)
		 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
		 *
		 *     // In each animation callback...
		 *     // this = the entity's animation component instance
		 *     // anim = the animation component's _anim object
		 *     // this._entity = the entity the animation is attached to
		 *
		 *     entity.animation.start('anim1', {
	 *     		onLoop: function (anim) {
	 *     			console.log('Animation looped', this, anim);	
	 *     		},
	 *     		onStopped: function (anim) {
	 *     			console.log('Animation stopped', this, anim);	
	 *     		},
	 *     		onComplete: function (anim) {
	 *     			console.log('Animation completed', this, anim);	
	 *     		}
	 *     });
		 *
		 * @example #Start an animation with callbacks for animation events via event listeners
		 *     // Create an entity, add the animation component, define
		 *     // an animation and then start it
		 *     var entity = new IgeEntity()
		 *         .addComponent(IgeAnimationComponent)
		 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
		 *
		 *     // In each animation callback...
		 *     // this = the entity's animation component instance
		 *     // anim = the animation component's _anim object
		 *     // this._entity = the entity the animation is attached to
		 *
		 *     entity.animation.on('started', function (anim) {
	 *     		console.log('Animation started', this, anim);	
	 *     });
		 *
		 *     entity.animation.on('loopComplete', function (anim) {
	 *     		console.log('Animation looped', this, anim);	
	 *     });
		 *
		 *     entity.animation.on('stopped', function (anim) {
	 *     		console.log('Animation stopped', this, anim);	
	 *     });
		 *
		 *     entity.animation.on('complete', function (anim) {
	 *     		console.log('Animation complete', this, anim);	
	 *     });
		 *
		 *     entity.animation.start('anim1');
		 * @return {*}
		 */
		start: function (animId, options) {
			if (this._anims) {
				var anim = this._anims[animId];
				
				if (anim) {
					anim.currentDelta = 0;
					anim.currentLoop = 0;
					anim.startTime = $time._currentTime;
					
					this._anim = anim;
					this._animId = animId;
					
					// Check for any callbacks in the options object
					if (options !== undefined) {
						this._completeCallback = options.onComplete;
						this._loopCallback = options.onLoop;
						this._stoppedCallback = options.onStopped;
					}
					
					this._playing = true;
					
					this.emit('started', anim);
				} else {
					this.log('Cannot set animation to "' + animId + '" because the animation does not exist!', 'warning');
				}
			} else {
				this.log('Cannot set animation to "' + animId + '" because no animations have been defined with defineAnim(...);', 'warning');
			}
			
			return this._entity;
		},
		
		/**
		 * Starts an animation only if the passed animation is not already
		 * started.
		 * @param {String} animId The id of the animation to start.
		 * @param {Object=} options An object with some option properties.
		 * @example #Select an animation
		 *     // Create an entity, add the animation component, define
		 *     // an animation and then select it
		 *     var entity = new IgeEntity()
		 *         .addComponent(IgeAnimationComponent)
		 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
		 *
		 *     entity.animation.select('anim1');
		 *
		 *     // Selecting the same animation twice will NOT reset the
		 *     // animation because it is already playing. This is how
		 *     // select() differs from start()
		 *     entity.animation.select('anim1');
		 * @return {*}
		 */
		select: function (animId, options) {
			if (this._animId !== animId) {
				this.start(animId, options);
			}
			
			return this._entity;
		},
		
		/**
		 * Stops the current animation.
		 * @example #Stop the current animation
		 *     entity.animation.stop();
		 * @return {*}
		 */
		stop: function () {
			if (this._stoppedCallback) {
				this._stoppedCallback.call(this, this._anim);
			}
			
			this.emit('stopped', this._anim);
			
			this._playing = false;
			
			delete this._anim;
			delete this._animId;
			
			delete this._completeCallback;
			delete this._loopCallback;
			delete this._stoppedCallback;
			
			return this._entity;
		},
		
		/**
		 * Handles the animation processing each update.
		 * @param {CanvasRenderingContext2D} ctx The rendering context to use when doing draw operations.
		 * @param {Number} tickDelta The current $ige.engine._tickDelta passed down the scenegraph.
		 */
		_update: function (ctx, tickDelta) {
			var self = this.animation;
			
			// Just in case someone forgets to pass it in their update call!
			tickDelta = tickDelta || $time._tickDelta;
			
			if (self._anim) {
				var anim = self._anim,
					multiple,
					cell,
					frame;
				
				// Advance the internal animation timer
				anim.currentDelta += tickDelta;
				
				// Check if the animation timer is greater than the total animation time
				if (anim.currentDelta > anim.totalTime) {
					// Check if we have a single loop animation
					if (!anim.loop) {
						if (self._completeCallback) {
							self._completeCallback.call(self, anim);
						}
						self.emit('complete', anim);
						self.stop();
					} else {
						// Check if we have an infinite loop
						if (anim.loop === -1) {
							// Loop back round to the beginning
							multiple = anim.currentDelta / anim.totalTime;
							if (Math.abs(multiple) > 1) {
								anim.currentDelta -= ((multiple|0) * anim.totalTime); // Bitwise floor
							}
							
							if (self._loopCallback) {
								self._loopCallback.call(self, anim);
							}
							self.emit('loopComplete', anim);
						} else {
							anim.currentLoop++;
							if (anim.loop > 0 && anim.currentLoop <= anim.loop) {
								// Loop back round to the beginning
								multiple = anim.currentDelta / anim.totalTime;
								if (Math.abs(multiple) > 1) {
									anim.currentDelta -= ((multiple|0) * anim.totalTime); // Bitwise floor
								}
								
								if (self._loopCallback) {
									self._loopCallback.call(self, anim);
								}
								self.emit('loopComplete', anim);
							} else {
								// The animation has ended
								if (self._completeCallback) {
									self._completeCallback.call(self, anim);
								}
								self.emit('complete', anim);
								self.stop();
							}
						}
					}
				}
				
				frame = ((anim.currentDelta / anim.frameTime)|0);
				
				if (frame >= anim.frameCount) {
					frame = anim.frameCount - 1;
				}
				
				cell = anim.frames[frame];
				
				// Set the current frame
				if (typeof(cell) === 'string') {
					self._entity.cellById(cell);
				} else {
					self._entity.cell(cell);
				}
			}
		}
	});
	
	return IgeAnimationComponent;
});
},{"irrelon-appcore":125}],6:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEntityManagerComponent', function ($ige, IgeClass, IgePoint3d, IgeRect) {
	var IgeEntityManagerComponent = IgeClass.extend({
		classId: 'IgeEntityManagerComponent',
		componentId: 'entityManager',
		
		/**
		 * @constructor
		 * @param {Object} entity The parent object that this component is being added to.
		 * @param {Object=} options An optional object that is passed to the component when it is being initialised.
		 */
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			// Check we are being added to a tile map
			if (!this._entity.pointToTile) {
				this.log('Warning, IgeEntityManagerComponent is only meant to be added to a tile map!', 'warning');
			}
			
			this._maps = [];
			this._overwatchMode = 0;
			this._removeMode = 0;
			this._createArr = [];
			this._removeArr = [];
			
			entity.addBehaviour('entityManager', this._behaviour);
		},
		
		/**
		 * Adds a map that will be used to read data and convert
		 * to entities as the visible map area is moved.
		 * @param {IgeTileMap2d=} map
		 * @return {*}
		 */
		addMap: function (map) {
			if (map !== undefined) {
				this._maps.push(map);
			}
			
			return this._entity;
		},
		
		/**
		 * Gets / sets the boolean flag determining if the entity
		 * manager is enabled or not.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		active: function (val) {
			if (val !== undefined) {
				this._active = val;
				return this._entity;
			}
			
			return this._active;
		},
		
		/**
		 * Gets / sets the number of entities the entity manager can
		 * create per tick. If the number of entities that need to be
		 * created is greater than this number they will be queued
		 * and processed on the next tick.
		 * @param val
		 * @return {*}
		 */
		maxCreatePerTick: function (val) {
			if (val !== undefined) {
				this._maxCreatePerTick = val;
				return this._entity;
			}
			
			return this._maxCreatePerTick;
		},
		
		/**
		 * Gets / sets the number of entities the entity manager can
		 * remove per tick. If the number of entities that need to be
		 * removed is greater than this number they will be queued
		 * and processed on the next tick.
		 * @param val
		 * @return {*}
		 */
		maxRemovePerTick: function (val) {
			if (val !== undefined) {
				this._maxRemovePerTick = val;
				return this._entity;
			}
			
			return this._maxRemovePerTick;
		},
		
		/**
		 * Gets / sets the overwatch mode for the entity manager. This
		 * is the mode that the manager will use when monitoring the
		 * entities under it's control to determine if any should be
		 * removed or not.
		 * @param {Number=} val Overwatch mode, defaults to 0.
		 * @return {*}
		 */
		overwatchMode: function (val) {
			if (val !== undefined) {
				this._overwatchMode = val;
				return this._entity;
			}
			
			return this._overwatchMode;
		},
		
		/**
		 * Adds a callback method that is called before an entity is
		 * created and asks the callback to return true if the entity
		 * should be allowed to be created, or false if not.
		 * @param {Function=} val The callback method.
		 * @return {*}
		 */
		createCheck: function (val) {
			if (val !== undefined) {
				this._createCheck = val;
				return this._entity;
			}
			
			return this._createCheck;
		},
		
		/**
		 * Adds a callback method that is called to allow you to execute
		 * the required code to create the desired entity from the map
		 * data you are being passed.
		 * @param {Function=} val The callback method.
		 * @return {*}
		 */
		createEntityFromMapData: function (val) {
			if (val !== undefined) {
				this._createEntityFromMapData = val;
				return this._entity;
			}
			
			return this._createEntityFromMapData;
		},
		
		/**
		 * Adds a callback method that is called before an entity is removed
		 * and if the callback returns true then the entity will be removed
		 * or if false, will not.
		 * @param {Function=} val The callback method.
		 * @return {*}
		 */
		removeCheck: function (val) {
			if (val !== undefined) {
				this._removeCheck = val;
				return this._entity;
			}
			
			return this._removeCheck;
		},
		
		/**
		 * Get / sets the entity that will be used to determine the
		 * center point of the area to manage. This allows the
		 * area to become dynamic based on this entity's position.
		 * @param entity
		 * @return {*}
		 */
		trackTranslate: function (entity) {
			if (entity !== undefined) {
				this._trackTranslateTarget = entity;
				return this;
			}
			
			return this._trackTranslateTarget;
		},
		
		/**
		 * Stops tracking the current tracking target's translation.
		 */
		unTrackTranslate: function () {
			delete this._trackTranslateTarget;
		},
		
		/**
		 * Gets / sets the center position of the management area.
		 * @param {Number=} x
		 * @param {Number=} y
		 * @return {*}
		 */
		areaCenter: function (x, y) {
			if (x !== undefined && y !== undefined) {
				// Adjust the passed x, y to account for this
				// texture map's translation
				var ent = this._entity,
					offset;
				
				if (ent._mode === 0) {
					// 2d mode
					offset = ent._translate;
				}
				
				if (ent._mode === 1) {
					// Iso mode
					offset = ent._translate.toIso();
				}
				
				x -= offset.x;
				y -= offset.y;
				
				this._areaCenter = new IgePoint3d(x, y, 0);
				return this._entity;
			}
			
			return this._areaCenter;
		},
		
		/**
		 * Gets / sets the area rectangle of the management area where
		 * entities outside this area are considered for removal and map
		 * data that falls inside this area is considered for entity
		 * creation.
		 * @param {Number=} x
		 * @param {Number=} y
		 * @param {Number=} width
		 * @param {Number=} height
		 * @return {*}
		 */
		areaRect: function (x, y, width, height) {
			if (x !== undefined && y !== undefined && width !== undefined && height !== undefined) {
				this._areaRect = new IgeRect(x, y, width, height);
				return this._entity;
			}
			
			return this._areaRect;
		},
		
		areaRectAutoSize: function (val, options) {
			if (val !== undefined) {
				this._areaRectAutoSize = val;
				this._areaRectAutoSizeOptions = options;
				return this._entity;
			}
			
			return this._areaRectAutoSize;
		},
		
		/**
		 * Returns the current management area.
		 * @return {IgeRect}
		 */
		currentArea: function () {
			var entTranslate;
			
			// Check if we are tracking an entity that is used to
			// set the center point of the area
			if (this._trackTranslateTarget) {
				// Calculate which tile our character is currently "over"
				if (this._trackTranslateTarget.isometric() === true) {
					entTranslate = this._trackTranslateTarget._translate.toIso();
				} else {
					entTranslate = this._trackTranslateTarget._translate;
				}
				
				this.areaCenter(entTranslate.x, entTranslate.y);
			}
			
			var areaRect = this._areaRect,
				areaCenter = this._areaCenter;
			
			if (areaRect && areaCenter) {
				return new IgeRect(Math.floor(areaRect.x + areaCenter.x), Math.floor(areaRect.y + areaCenter.y), Math.floor(areaRect.width), Math.floor(areaRect.height));
			} else {
				return new IgeRect(0, 0, 0, 0);
			}
		},
		
		/**
		 * Gets / sets the mode that entities will be removed with.
		 * If set to 0 (default) the entities will be removed via a
		 * call to their destroy() method. If set to 1, entities will
		 * be unmounted via a call to unMount(). This means that their
		 * associated box2d bodies will not be removed from the
		 * simulation if in mode 1.
		 * @param val
		 * @return {*}
		 */
		removeMode: function (val) {
			if (val !== undefined) {
				this._removeMode = val;
				return this._entity;
			}
			
			return this._removeMode;
		},
		
		/**
		 * The behaviour method executed each tick.
		 * @param ctx
		 * @private
		 */
		_behaviour: function (ctx) {
			var self = this.entityManager,
				currentArea,
				currentAreaTiles,
				arr = this._children,
				arrCount = arr.length,
				item,
				maps = self._maps,
				map,
				mapIndex,
				mapData,
				currentTile,
				renderX, renderY,
				renderWidth, renderHeight,
				x, y,
				tileData,
				renderSize,
				ratio;
			
			if ((!self._areaRect || $ige.engine._resized) && self._areaRectAutoSize) {
				self._resizeEvent();
			}
			
			currentArea = self.currentArea();
			
			if (self._areaCenter && self._areaRect && !currentArea.compare(self._lastArea)) {
				////////////////////////////////////
				// ENTITY REMOVAL CHECKS          //
				////////////////////////////////////
				
				/*// Check if the area metrics have changed
				 if (this._overwatchMode === 0 && (!currentArea.compare(self._lastArea))) {
				 // Overwatch mode is zero so only scan for entities to remove
				 // if the area metrics have changed.
				 }
				 
				 if (self._overwatchMode === 1) {
				 // Actively scan every tick for entities to remove
				 while (arrCount--) {
				 item = arr[arrCount];
				 
				 // Check if the item has an aabb method
				 if (item.aabb) {
				 // Check the entity to see if its bounds are "inside" the
				 // manager's visible area
				 if (!currentArea.intersects(item.aabb())) {
				 // The item is outside the manager's area so
				 // ask the removeCheck callback if we should
				 // remove the entity
				 if (!self._removeCheck || self._removeCheck(item)) {
				 // Queue the entity for removal
				 self._removeArr.push(item);
				 }
				 }
				 }
				 }
				 }*/
				
				currentTile = this.pointToTile(self._areaCenter);
				renderX = currentTile.x;
				renderY = currentTile.y;
				renderWidth = Math.ceil(currentArea.width / this._tileWidth);
				renderHeight = Math.ceil(currentArea.height / this._tileHeight);
				
				currentArea.x -= (this._tileWidth);
				currentArea.y -= (this._tileHeight / 2);
				currentArea.width += (this._tileWidth * 2);
				currentArea.height += (this._tileHeight);
				
				// Check if we are rendering in 2d or isometric mode
				if (this._mountMode === 0) {
					// 2d
					currentAreaTiles = new IgeRect(
						renderX - Math.floor(renderWidth / 2) - 1,
						renderY - Math.floor(renderHeight / 2) - 1,
						renderX + Math.floor(renderWidth / 2) + 1 - (renderX - Math.floor(renderWidth / 2) - 1),
						renderY + Math.floor(renderHeight / 2) + 1 - (renderY - Math.floor(renderHeight / 2) - 1)
					);
				}
				
				if (this._mountMode === 1) {
					// Isometric
					renderSize = Math.abs(renderWidth) > Math.abs(renderHeight) ? renderWidth : renderHeight;
					ratio = 0.6;
					currentAreaTiles = new IgeRect(
						renderX - Math.floor(renderSize * ratio),
						renderY - Math.floor(renderSize * ratio),
						renderX + Math.floor(renderSize * ratio) + 1 - (renderX - Math.floor(renderSize * ratio)),
						renderY + Math.floor(renderSize * ratio) + 1 - (renderY - Math.floor(renderSize * ratio))
					);
				}
				
				// Generate the bounds rectangle
				if (this._drawBounds) {
					ctx.strokeStyle = '#ff0000';
					ctx.strokeRect(currentArea.x, currentArea.y, currentArea.width, currentArea.height);
					
					this._highlightTileRect = currentAreaTiles;
				}
				
				////////////////////////////////////
				// ENTITY REMOVAL CHECKS          //
				////////////////////////////////////
				//this._highlightTileRect = currentAreaTiles;
				
				map = this.map;
				while (arrCount--) {
					item = arr[arrCount];
					
					if (!self._removeCheck || self._removeCheck(item)) {
						if (!currentAreaTiles.intersects(item._occupiedRect)) {
							// The item is outside the manager's area so
							// ask the removeCheck callback if we should
							// remove the entity
							
							// Queue the entity for removal
							self._removeArr.push(item);
						}
					}
				}
				
				////////////////////////////////////
				// ENTITY CREATION CHECKS         //
				////////////////////////////////////
				for (mapIndex in maps) {
					if (maps.hasOwnProperty(mapIndex)) {
						map = maps[mapIndex];
						mapData = map.map._mapData;
						// TODO: This can be optimised further by only checking the area that has changed
						
						for (y = currentAreaTiles.y; y < currentAreaTiles.y + currentAreaTiles.height; y++) {
							if (mapData[y]) {
								for (x = currentAreaTiles.x; x < currentAreaTiles.x + currentAreaTiles.width; x++) {
									// Grab the tile data to paint
									tileData = mapData[y][x];
									
									if (tileData) {
										if (!self._createCheck || self._createCheck(map, x, y, tileData)) {
											// Queue the entity for creation
											self._createArr.push([map, x, y, tileData]);
										}
									}
								}
							}
						}
					}
				}
				
				self._lastArea = currentArea;
				
				// Process the entity queues
				self.processQueues();
			}
		},
		
		processQueues: function () {
			var createArr = this._createArr,
				createCount = createArr.length,
				createLimit = this._maxCreatePerTick !== undefined ? this._maxCreatePerTick : 0,
				createEntityFunc = this._createEntityFromMapData,
				removeArr = this._removeArr,
				removeCount = removeArr.length,
				removeLimit = this._maxRemovePerTick !== undefined ? this._maxRemovePerTick : 0,
				i;
			
			if (createLimit && createCount > createLimit) { createCount = createLimit; }
			if (removeLimit && removeCount > removeLimit) { removeCount = removeLimit; }
			
			// Process remove queue
			for (i = 0; i < removeCount; i++) {
				if (this._removeMode === 0) {
					// Pop the first item off the array and destroy it
					removeArr.shift().destroy();
				}
			}
			
			// Process creation
			for (i = 0; i < createCount; i++) {
				// Pop the first item off the array and pass it as arguments
				// to the entity creation method assigned to this manager
				createEntityFunc.apply(this, createArr.shift());
			}
		},
		
		/**
		 * Handles screen resize events.
		 * @param event
		 * @private
		 */
		_resizeEvent: function (event) {
			// Set width / height of scene to match parent
			if (this._areaRectAutoSize) {
				var geom = this._entity._parent._bounds2d,
					additionX = 0, additionY = 0;
				
				if (this._areaRectAutoSizeOptions) {
					if (this._areaRectAutoSizeOptions.bufferMultiple) {
						additionX = (geom.x * this._areaRectAutoSizeOptions.bufferMultiple.x) - geom.x;
						additionY = (geom.y * this._areaRectAutoSizeOptions.bufferMultiple.y) - geom.y;
					}
					
					if (this._areaRectAutoSizeOptions.bufferPixels) {
						additionX = this._areaRectAutoSizeOptions.bufferPixels.x;
						additionY = this._areaRectAutoSizeOptions.bufferPixels.y;
					}
				}
				
				this.areaRect(-Math.floor((geom.x + additionX) / 2), -Math.floor((geom.y + additionY) / 2), geom.x + additionX, geom.y + additionY);
				
				// Check if caching is enabled
				if (this._caching > 0) {
					this._resizeCacheCanvas();
				}
			}
		}
	});
	
	return IgeEntityManagerComponent;
});
},{"irrelon-appcore":125}],7:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeGamePadComponent', function ($ige, IgeEventingClass) {
	var IgeGamePadComponent = IgeEventingClass.extend({
		classId: 'IgeGamePadComponent',
		componentId: 'gamePad',
		
		init: function (entity, options) {
			var self = this;
			
			this._entity = entity;
			this._options = options;
			this.gamepadAvailable = null;
			
			// A number of typical buttons recognized by Gamepad API and mapped to
			// standard controls. Any extraneous buttons will have larger indexes.
			this.TYPICAL_BUTTON_COUNT = 16;
			
			// A number of typical axes recognized by Gamepad API and mapped to
			// standard controls. Any extraneous buttons will have larger indexes.
			this.TYPICAL_AXIS_COUNT = 4;
			
			// Whether were requestAnimationFrameing like its 1999.
			this.ticking = false;
			
			// The canonical list of attached gamepads, without holes (always
			// starting at [0]) and unified between Firefox and Chrome.
			this.gamepads = [];
			
			// Remembers the connected gamepads at the last check; used in Chrome
			// to figure out when gamepads get connected or disconnected, since no
			// events are fired.
			this.prevRawGamepadTypes = [];
			
			// Previous timestamps for gamepad state; used in Chrome to not bother with
			// analyzing the polled data if nothing changed (timestamp is the same
			// as last time).
			this.prevTimestamps = [];
			
			if ($ige.isClient) {
				// As of writing, it seems impossible to detect Gamepad API support
				// in Firefox, hence we need to hardcode it in the third clause.
				// (The preceding two clauses are for Chrome.)
				this.gamepadAvailable = !!navigator.webkitGetGamepads ||
					!!navigator.webkitGamepads ||
					(navigator.userAgent.indexOf('Firefox/') != -1);
				
				if (!this.gamepadAvailable) {
					// It doesn't seem Gamepad API is available  show a message telling
					// the visitor about it.
					this.emit('notSupported');
				} else {
					// Firefox supports the connect/disconnect event, so we attach event
					// handlers to those.
					window.addEventListener('MozGamepadConnected', function () { self.onGamepadConnect.apply(self, arguments); }, false);
					window.addEventListener('MozGamepadDisconnected', function () { self.onGamepadDisconnect.apply(self, arguments); }, false);
					
					// Since Chrome only supports polling, we initiate polling loop straight
					// away. For Firefox, we will only do it if we get a connect event.
					if (!!navigator.webkitGamepads || !!navigator.webkitGetGamepads) {
						this.startPolling();
					}
				}
				
				entity.addBehaviour('gamePadComponent', this._behaviour);
			}
		},
		
		onGamepadConnect: function(event) {
			// Add the new gamepad on the list of gamepads to look after.
			this.gamepads.push(event.gamepad);
			
			// Start the polling loop to monitor button changes.
			this.startPolling();
			
			// Ask the tester to update the screen to show more gamepads.
			this.emit('change');
		},
		
		/**
		 * React to the gamepad being disconnected.
		 */
		onGamepadDisconnect: function(event) {
			// Remove the gamepad from the list of gamepads to monitor.
			for (var i in this.gamepads) {
				if (this.gamepads[i].index == event.gamepad.index) {
					this.gamepads.splice(i, 1);
					break;
				}
			}
			
			// If no gamepads are left, stop the polling loop.
			if (this.gamepads.length == 0) {
				this.stopPolling();
			}
			
			// Ask the tester to update the screen to remove the gamepad.
			this.emit('change');
		},
		
		/**
		 * Starts a polling loop to check for gamepad state.
		 */
		startPolling: function() {
			this.ticking = true;
		},
		
		/**
		 * Stops a polling loop by setting a flag which will prevent the next
		 * requestAnimationFrame() from being scheduled.
		 */
		stopPolling: function() {
			this.ticking = false;
		},
		
		/**
		 * A function called with each requestAnimationFrame(). Polls the gamepad
		 * status and schedules another poll.
		 */
		_behaviour: function() {
			this.gamePad.pollStatus();
		},
		
		/**
		 * Checks for the gamepad status. Monitors the necessary data and notices
		 * the differences from previous state (buttons for Chrome/Firefox,
		 * new connects/disconnects for Chrome). If differences are noticed, asks
		 * to update the display accordingly. Should run as close to 60 frames per
		 * second as possible.
		 */
		pollStatus: function() {
			// Poll to see if gamepads are connected or disconnected. Necessary
			// only on Chrome.
			this.pollGamepads();
			
			for (var i in this.gamepads) {
				var gamepad = this.gamepads[i];
				
				// Dont do anything if the current timestamp is the same as previous
				// one, which means that the state of the gamepad hasnt changed.
				// This is only supported by Chrome right now, so the first check
				// makes sure were not doing anything if the timestamps are empty
				// or undefined.
				if (gamepad.timestamp && (gamepad.timestamp == this.prevTimestamps[i])) {
					continue;
				}
				this.prevTimestamps[i] = gamepad.timestamp;
			}
		},
		
		// This function is called only on Chrome, which does not yet support
		// connection/disconnection events, but requires you to monitor
		// an array for changes.
		pollGamepads: function() {
			// Get the array of gamepads  the first method (getGamepads)
			// is the most modern one and is supported by Firefox 28+ and
			// Chrome 35+. The second one (webkitGetGamepads) is a deprecated method
			// used by older Chrome builds.
			var rawGamepads =
				(navigator.getGamepads && navigator.getGamepads()) ||
				(navigator.webkitGetGamepads && navigator.webkitGetGamepads());
			
			if (rawGamepads) {
				// We dont want to use rawGamepads coming straight from the browser,
				// since it can have holes (e.g. if you plug two gamepads, and then
				// unplug the first one, the remaining one will be at index [1]).
				this.gamepads = [];
				
				// We only refresh the display when we detect some gamepads are new
				// or removed; we do it by comparing raw gamepad table entries to
				// undefined.
				var gamepadsChanged = false;
				
				for (var i = 0; i < rawGamepads.length; i++) {
					if (typeof rawGamepads[i] != this.prevRawGamepadTypes[i]) {
						gamepadsChanged = true;
						this.prevRawGamepadTypes[i] = typeof rawGamepads[i];
					}
					
					if (rawGamepads[i]) {
						this.gamepads.push(rawGamepads[i]);
					}
				}
				
				// Ask the tester to refresh the visual representations of gamepads
				// on the screen.
				if (gamepadsChanged) {
					this.emit('change');
				}
			}
		}
	});
	
	return IgeGamePadComponent;
});
},{"irrelon-appcore":125}],8:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeInputComponent', function ($ige, IgeEventingClass, IgePoint3d) {
	var IgeInputComponent = IgeEventingClass.extend({
		classId: 'IgeInputComponent',
		componentId: 'input',
		
		init: function () {
			// Setup the input objects to hold the current input state
			this._eventQueue = [];
			this._eventControl = {
				_cancelled: false,
				stopPropagation: function () {
					this._cancelled = true;
				}
			};
			
			this.tick();
			
			this.mouse = {
				// Virtual codes
				dblClick: -302,
				down: -301,
				up: -300,
				move: -259,
				wheel: -258,
				wheelUp: -257,
				wheelDown: -256,
				x: -255,
				y: -254,
				button1: -253,
				button2: -252,
				button3: -251
			};
			
			this.pad1 = {
				// Virtual codes
				button1: -250,
				button2: -249,
				button3: -248,
				button4: -247,
				button5: -246,
				button6: -245,
				button7: -244,
				button8: -243,
				button9: -242,
				button10: -241,
				button11: -240,
				button12: -239,
				button13: -238,
				button14: -237,
				button15: -236,
				button16: -235,
				button17: -234,
				button18: -233,
				button19: -232,
				button20: -231,
				stick1: -230,
				stick2: -229,
				stick1Up: -228,
				stick1Down: -227,
				stick1Left: -226,
				stick1Right: -225,
				stick2Up: -224,
				stick2Down: -223,
				stick2Left: -222,
				stick2Right: -221
			};
			
			this.pad2 = {
				// Virtual codes
				button1: -220,
				button2: -219,
				button3: -218,
				button4: -217,
				button5: -216,
				button6: -215,
				button7: -214,
				button8: -213,
				button9: -212,
				button10: -211,
				button11: -210,
				button12: -209,
				button13: -208,
				button14: -207,
				button15: -206,
				button16: -205,
				button17: -204,
				button18: -203,
				button19: -202,
				button20: -201,
				stick1: -200,
				stick2: -199,
				stick1Up: -198,
				stick1Down: -197,
				stick1Left: -196,
				stick1Right: -195,
				stick2Up: -194,
				stick2Down: -193,
				stick2Left: -192,
				stick2Right: -191
			};
			
			// Keycodes from http://www.asciitable.com/
			// and general console.log efforts :)
			this.key = {
				// Virtual codes
				'shift': -3,
				'ctrl': -2,
				'alt': -1,
				// Read codes
				'backspace': 8,
				'tab': 9,
				'enter': 13,
				'escape': 27,
				'space': 32,
				'pageUp': 33,
				'pageDown': 34,
				'end': 35,
				'home': 36,
				'left': 37,
				'up': 38,
				'right': 39,
				'down': 40,
				'insert': 45,
				'del': 46,
				'0': 48,
				'1': 49,
				'2': 50,
				'3': 51,
				'4': 52,
				'5': 53,
				'6': 54,
				'7': 55,
				'8': 56,
				'9': 57,
				'a': 65,
				'b': 66,
				'c': 67,
				'd': 68,
				'e': 69,
				'f': 70,
				'g': 71,
				'h': 72,
				'i': 73,
				'j': 74,
				'k': 75,
				'l': 76,
				'm': 77,
				'n': 78,
				'o': 79,
				'p': 80,
				'q': 81,
				'r': 82,
				's': 83,
				't': 84,
				'u': 85,
				'v': 86,
				'w': 87,
				'x': 88,
				'y': 89,
				'z': 90
			};
			
			this._controlMap = [];
			this._state = [];
			
			// Set default values for the mouse position
			this._state[this.mouse.x] = 0;
			this._state[this.mouse.y] = 0;
		},
		
		debug: function (val) {
			if (val !== undefined) {
				this._debug = val;
				return this;
			}
			
			return this._debug;
		},
		
		/**
		 * Sets up the event listeners on the main window and front
		 * buffer DOM objects.
		 * @private
		 */
		setupListeners: function (canvas) {
			this.log('Setting up input event listeners...');
			
			this._canvas = canvas;
			
			// Setup the event listeners
			var self = this;
			
			// Define event functions and keep references for later removal
			this._evRef = {
				'mousedown': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseDown(event); },
				'mouseup': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseUp(event); },
				'mousemove': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseMove(event); },
				'mousewheel': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseWheel(event); },
				
				'touchmove': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseMove(event); },
				'touchstart': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseDown(event); },
				'touchend': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseUp(event); },
				
				'contextmenu': function (event) { event.preventDefault(); event.igeType = 'mouse'; self._rationalise(event); self._contextMenu(event); },
				
				'keydown': function (event) { event.igeType = 'key'; self._rationalise(event); self._keyDown(event); },
				'keyup': function (event) { event.igeType = 'key'; self._rationalise(event); self._keyUp(event); }
			};
			
			// Listen for mouse events
			canvas.addEventListener('mousedown', this._evRef.mousedown, false);
			canvas.addEventListener('mouseup', this._evRef.mouseup, false);
			canvas.addEventListener('mousemove', this._evRef.mousemove, false);
			canvas.addEventListener('mousewheel', this._evRef.mousewheel, false);
			
			// Touch events
			canvas.addEventListener('touchmove', this._evRef.touchmove, false);
			canvas.addEventListener('touchstart', this._evRef.touchstart, false);
			canvas.addEventListener('touchend', this._evRef.touchend, false);
			
			// Kill the context menu on right-click, urgh!
			canvas.addEventListener('contextmenu', this._evRef.contextmenu, false);
			
			// Listen for keyboard events
			window.addEventListener('keydown', this._evRef.keydown, false);
			window.addEventListener('keyup', this._evRef.keyup, false);
		},
		
		destroyListeners: function () {
			this.log('Removing input event listeners...');
			
			// Remove the event listeners
			var canvas = this._canvas;
			
			// Listen for mouse events
			canvas.removeEventListener('mousedown', this._evRef.mousedown, false);
			canvas.removeEventListener('mouseup', this._evRef.mouseup, false);
			canvas.removeEventListener('mousemove', this._evRef.mousemove, false);
			canvas.removeEventListener('mousewheel', this._evRef.mousewheel, false);
			
			// Touch events
			canvas.removeEventListener('touchmove', this._evRef.touchmove, false);
			canvas.removeEventListener('touchstart', this._evRef.touchstart, false);
			canvas.removeEventListener('touchend', this._evRef.touchend, false);
			
			// Kill the context menu on right-click, urgh!
			canvas.removeEventListener('contextmenu', this._evRef.contextmenu, false);
			
			// Listen for keyboard events
			window.removeEventListener('keydown', this._evRef.keydown, false);
			window.removeEventListener('keyup', this._evRef.keyup, false);
		},
		
		/**
		 * Fires an input event that didn't occur on the main canvas, as if it had
		 * occurred on the main canvas, allowing you to pass through events like
		 * mousedown and mouseup that occurred elsewhere on the DOM but might be
		 * useful for the engine to be aware of, such as if you are dragging an entity
		 * and then the mouse goes off-canvas and the button is released.
		 * @param {String} eventName The lowercase name of the event to fire e.g. mousedown.
		 * @param {Object} eventObj The event object that was passed by the DOM.
		 */
		fireManualEvent: function (eventName, eventObj) {
			if (eventName && eventObj) {
				if (this._evRef[eventName]) {
					this._evRef[eventName](eventObj);
				} else {
					this.log('Cannot fire manual event "' + eventName + '" because no listener exists in the engine for this event type!', 'warning');
				}
			} else {
				this.log('Cannot fire manual event because both eventName and eventObj params are required.', 'warning');
			}
		},
		
		/**
		 * Sets igeX and igeY properties in the event object that
		 * can be relied on to provide the x, y co-ordinates of the
		 * mouse event including the canvas offset.
		 * @param {Event} event The event object.
		 * @param {Boolean} touch If the event was a touch event or
		 * not.
		 * @private
		 */
		_rationalise: function (event, touch) {
			// Check if we want to prevent default behaviour
			if (event.igeType === 'key') {
				if (event.keyCode === 8) { // Backspace
					// Check if the event occurred on the body
					var elem = event.srcElement || event.target;
					
					if (elem.tagName.toLowerCase() === 'body') {
						// The event occurred on our body element so prevent
						// default behaviour. This allows other elements on
						// the page to retain focus such as text boxes etc
						// and allows them to behave normally.
						event.preventDefault();
					}
				}
			}
			
			if (event.igeType === 'touch') {
				event.preventDefault();
			}
			
			if (touch) {
				event.button = 0; // Emulate left mouse button
				
				// Handle touch changed
				if (event.changedTouches && event.changedTouches.length) {
					event.igePageX = event.changedTouches[0].pageX;
					event.igePageY = event.changedTouches[0].pageY;
				}
			} else {
				event.igePageX = event.pageX;
				event.igePageY = event.pageY;
			}
			
			event.igeX = (event.igePageX - $ige.engine._canvasPosition().left);
			event.igeY = (event.igePageY - $ige.engine._canvasPosition().top);
			
			this.emit('inputEvent', event);
		},
		
		
		/**
		 * Emits the "mouseDown" event.
		 * @param event
		 * @private
		 */
		_mouseDown: function (event) {
			if (this._debug) {
				console.log('Mouse Down', event);
			}
			// Update the mouse position within the viewports
			this._updateMouseData(event);
			
			var mx = event.igeX - $ige.engine._bounds2d.x2,
				my = event.igeY - $ige.engine._bounds2d.y2,
				self = this;
			
			if (event.button === 0) {
				this._state[this.mouse.button1] = true;
			}
			
			if (event.button === 1) {
				this._state[this.mouse.button2] = true;
			}
			
			if (event.button === 2) {
				this._state[this.mouse.button3] = true;
			}
			
			this.mouseDown = event;
			
			if (!self.emit('preMouseDown', [event, mx, my, event.button + 1])) {
				this.queueEvent(this, function () {
					self.emit('mouseDown', [event, mx, my, event.button + 1]);
				});
			}
		},
		
		/**
		 * Emits the "mouseUp" event.
		 * @param event
		 * @private
		 */
		_mouseUp: function (event) {
			if (this._debug) {
				console.log('Mouse Up', event);
			}
			// Update the mouse position within the viewports
			this._updateMouseData(event);
			
			var mx = event.igeX - $ige.engine._bounds2d.x2,
				my = event.igeY - $ige.engine._bounds2d.y2,
				self = this;
			
			if (event.button === 0) {
				this._state[this.mouse.button1] = false;
			}
			
			if (event.button === 1) {
				this._state[this.mouse.button2] = false;
			}
			
			if (event.button === 2) {
				this._state[this.mouse.button3] = false;
			}
			
			this.mouseUp = event;
			
			if (!self.emit('preMouseUp', [event, mx, my, event.button + 1])) {
				this.queueEvent(this, function () {
					self.emit('mouseUp', [event, mx, my, event.button + 1]);
				});
			}
		},
		
		_contextMenu: function (event) {
			if (this._debug) {
				console.log('Context Menu', event);
			}
			// Update the mouse position within the viewports
			this._updateMouseData(event);
			
			var mx = event.igeX - $ige.engine._bounds2d.x2,
				my = event.igeY - $ige.engine._bounds2d.y2,
				self = this;
			
			if (event.button === 0) {
				this._state[this.mouse.button1] = false;
			}
			
			if (event.button === 1) {
				this._state[this.mouse.button2] = false;
			}
			
			if (event.button === 2) {
				this._state[this.mouse.button3] = false;
			}
			
			this.contextMenu = event;
			
			if (!self.emit('preContextMenu', [event, mx, my, event.button + 1])) {
				this.queueEvent(this, function () {
					self.emit('contextMenu', [event, mx, my, event.button + 1]);
				});
			}
		},
		
		/**
		 * Emits the "mouseMove" event.
		 * @param event
		 * @private
		 */
		_mouseMove: function (event) {
			// Update the mouse position within the viewports
			$ige.engine._mouseOverVp = this._updateMouseData(event);
			
			var mx = event.igeX - $ige.engine._bounds2d.x2,
				my = event.igeY - $ige.engine._bounds2d.y2,
				self = this;
			
			this._state[this.mouse.x] = mx;
			this._state[this.mouse.y] = my;
			
			this.mouseMove = event;
			
			if (!self.emit('preMouseMove', [event, mx, my, event.button + 1])) {
				this.queueEvent(this, function () {
					self.emit('mouseMove', [event, mx, my, event.button + 1]);
				});
			}
		},
		
		/**
		 * Emits the "mouseWheel" event.
		 * @param event
		 * @private
		 */
		_mouseWheel: function (event) {
			// Update the mouse position within the viewports
			this._updateMouseData(event);
			
			var mx = event.igeX - $ige.engine._bounds2d.x2,
				my = event.igeY - $ige.engine._bounds2d.y2,
				self = this;
			
			this._state[this.mouse.wheel] = event.wheelDelta;
			
			if (event.wheelDelta > 0) {
				this._state[this.mouse.wheelUp] = true;
			} else {
				this._state[this.mouse.wheelDown] = true;
			}
			
			this.mouseWheel = event;
			
			if (!self.emit('preMouseWheel', [event, mx, my, event.button + 1])) {
				this.queueEvent(this, function () {
					self.emit('mouseWheel', [event, mx, my, event.button + 1]);
				});
			}
		},
		
		/**
		 * Emits the "keyDown" event.
		 * @param event
		 * @private
		 */
		_keyDown: function (event) {
			var self = this;
			
			this._state[event.keyCode] = true;
			
			if (this._debug) {
				console.log('Key Down', event);
			}
			
			if (!self.emit('preKeyDown', [event, event.keyCode])) {
				this.queueEvent(this, function () {
					self.emit('keyDown', [event, event.keyCode]);
				});
			}
		},
		
		/**
		 * Emits the "keyUp" event.
		 * @param event
		 * @private
		 */
		_keyUp: function (event) {
			var self = this;
			
			this._state[event.keyCode] = false;
			
			if (this._debug) {
				console.log('Key Up', event);
			}
			
			if (!self.emit('preKeyUp', [event, event.keyCode])) {
				this.queueEvent(this, function () {
					self.emit('keyUp', [event, event.keyCode]);
				});
			}
		},
		
		/**
		 * Loops the mounted viewports and updates their respective mouse
		 * co-ordinates so that mouse events can work out where on a viewport
		 * they occurred.
		 *
		 * @param event
		 * @return {*}
		 * @private
		 */
		_updateMouseData: function (event) {
			// Loop the viewports and check if the mouse is inside
			var arr = $ige.engine._children,
				arrCount = arr.length,
				vp, vpUpdated,
				mx = (event.igeX - $ige.engine._bounds2d.x2) - $ige.engine._translate.x,
				my = (event.igeY - $ige.engine._bounds2d.y2) - $ige.engine._translate.y;
			
			$ige.engine._mousePos.x = mx;
			$ige.engine._mousePos.y = my;
			
			while (arrCount--) {
				vp = arr[arr.length - (arrCount + 1)];
				// Check if the mouse is inside this viewport's bounds
				// TODO: Update this code to take into account viewport rotation and camera rotation
				if (mx > vp._translate.x - vp._bounds2d.x / 2 && mx < vp._translate.x + vp._bounds2d.x / 2) {
					if (my > vp._translate.y - vp._bounds2d.y / 2 && my < vp._translate.y + vp._bounds2d.y / 2) {
						// Mouse is inside this viewport
						vp._mousePos = new IgePoint3d(
							Math.floor((mx - vp._translate.x) / vp.camera._scale.x + vp.camera._translate.x),
							Math.floor((my - vp._translate.y) / vp.camera._scale.y + vp.camera._translate.y),
							0
						);
						
						vpUpdated = vp;
						
						// Record the viewport that this event occurred on in the
						// event object
						event.igeViewport = vp;
						break;
					}
				}
			}
			
			return vpUpdated;
		},
		
		/**
		 * Defines an action that will be emitted when the specified event type
		 * occurs.
		 * @param actionName
		 * @param eventCode
		 */
		mapAction: function (actionName, eventCode) {
			this._controlMap[actionName] = eventCode;
		},
		
		/**
		 * Returns the passed action's input state value.
		 * @param actionName
		 */
		actionVal: function (actionName) {
			return this._state[this._controlMap[actionName]];
		},
		
		/**
		 * Returns true if the passed action's input is pressed or it's state
		 * is not zero.
		 * @param actionName
		 */
		actionState: function (actionName) {
			var val = this._state[this._controlMap[actionName]];
			return !!val; // "Not not" to convert to boolean true/false
		},
		
		/**
		 * Returns an input's current value.
		 * @param actionName
		 * @return {*}
		 */
		val: function (inputId) {
			return this._state[inputId];
		},
		
		/**
		 * Returns an input's current state as a boolean.
		 * @param stateId
		 * @return {Boolean}
		 */
		state: function (inputId) {
			return !!this._state[inputId];
		},
		
		/**
		 * Stops further event propagation for this tick.
		 * @return {*}
		 */
		stopPropagation: function () {
			this._eventControl._cancelled = true;
			return this;
		},
		
		/**
		 * Adds an event method to the eventQueue array. The array is
		 * processed during each tick after the scenegraph has been
		 * rendered.
		 * @param context
		 * @param ev
		 */
		queueEvent: function (context, ev, data) {
			if (ev !== undefined) {
				this._eventQueue.push([context, ev, data]);
			}
			
			return this;
		},
		
		/**
		 * Called by the engine after ALL other tick methods have processed.
		 * Call originates in IgeEngine.js. Allows us to reset any flags etc.
		 */
		tick: function () {
			// If we have an event queue, process it
			var arr = this._eventQueue,
				arrCount = arr.length,
				evc = this._eventControl;
			
			while (arrCount--) {
				arr[arrCount][1].apply(arr[arrCount][0], [evc, arr[arrCount][2]]);
				if (evc._cancelled) {
					// The last event queue method stopped propagation so cancel all further
					// event processing (the last event took control of the input)
					break;
				}
			}
			
			// Reset all the flags and variables for the next tick
			this._eventQueue = [];
			this._eventControl._cancelled = false;
			this.dblClick = false; // TODO: Add double-click event handling
			this.mouseMove = false;
			this.mouseDown = false;
			this.mouseUp = false;
			this.mouseWheel = false;
		},
		
		/**
		 * Emit an event by name. Overrides the IgeEventingClass emit method and
		 * checks for propagation stopped by calling $ige.engine.input.stopPropagation().
		 * @param {Object} eventName The name of the event to emit.
		 * @param {Object || Array} args The arguments to send to any listening methods.
		 * If you are sending multiple arguments, use an array containing each argument.
		 * @return {Number}
		 */
		emit: function (eventName, args) {
			if (this._eventListeners) {
				// Check if the event has any listeners
				if (this._eventListeners[eventName]) {
					
					// Fire the listeners for this event
					var eventCount = this._eventListeners[eventName].length,
						eventCount2 = this._eventListeners[eventName].length - 1,
						evc = this._eventControl,
						finalArgs, i, cancelFlag, eventIndex, tempEvt, retVal;
					
					// If there are some events, ensure that the args is ready to be used
					if (eventCount) {
						finalArgs = [];
						if (typeof(args) === 'object' && args !== null && args[0] !== null) {
							for (i in args) {
								if (args.hasOwnProperty(i)) {
									finalArgs[i] = args[i];
								}
							}
						} else {
							finalArgs = [args];
						}
						
						// Loop and emit!
						cancelFlag = false;
						
						this._eventListeners._processing = true;
						while (eventCount--) {
							if (evc._cancelled) {
								// The stopPropagation() method was called, cancel all other event calls
								break;
							}
							eventIndex = eventCount2 - eventCount;
							tempEvt = this._eventListeners[eventName][eventIndex];
							
							// If the sendEventName flag is set, overwrite the arguments with the event name
							if (tempEvt.sendEventName) { finalArgs = [eventName]; }
							
							// Call the callback
							retVal = tempEvt.call.apply(tempEvt.context || this, finalArgs);
							
							// If the retVal === true then store the cancel flag and return to the emitting method
							if (retVal === true || evc._cancelled === true) {
								// The receiver method asked us to send a cancel request back to the emitter
								cancelFlag = true;
							}
							
							// Check if we should now cancel the event
							if (tempEvt.oneShot) {
								// The event has a oneShot flag so since we have fired the event,
								// lets cancel the listener now
								this.off(eventName, tempEvt);
							}
						}
						this._eventListeners._processing = false;
						
						// Now process any event removal
						this._processRemovals();
						
						if (cancelFlag) {
							return 1;
						}
						
					}
					
				}
			}
		}
	});
	
	return IgeInputComponent;
});
},{"irrelon-appcore":125}],9:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeMousePanComponent', function ($ige, IgeEventingClass) {
	/**
	 * When added to a viewport, automatically adds mouse panning
	 * capabilities to the viewport's camera.
	 */
	var IgeMousePanComponent = IgeEventingClass.extend({
		classId: 'IgeMousePanComponent',
		componentId: 'mousePan',
		
		/**
		 * @constructor
		 * @param {IgeObject} entity The object that the component is added to.
		 * @param {Object=} options The options object that was passed to the component during
		 * the call to addComponent.
		 */
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			// Set the pan component to inactive to start with
			this._enabled = false;
			this._startThreshold = 5; // The number of pixels the mouse should move to activate a pan
		},
		
		/**
		 * Gets / sets the number of pixels after a mouse down that the mouse
		 * must move in order to activate a pan operation. Defaults to 5.
		 * @param val
		 * @return {*}
		 */
		startThreshold: function (val) {
			if (val !== undefined) {
				this._startThreshold = val;
				return this._entity;
			}
			
			return this._startThreshold;
		},
		
		/**
		 * Gets / sets the rectangle that the pan operation will be limited
		 * to using an IgeRect instance.
		 * @param {IgeRect=} rect
		 * @return {*}
		 */
		limit: function (rect) {
			if (rect !== undefined) {
				this._limit = rect;
				return this._entity;
			}
			
			return this._limit;
		},
		
		/**
		 * Gets / sets the enabled flag. If set to true, pan
		 * operations will be processed. If false, no panning will
		 * occur.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		enabled: function (val) {
			var self = this;
			
			if (val !== undefined) {
				this._enabled = val;
				
				// Reset pan values.
				// This prevents problems if mouse pan is disabled mid-pan.
				this._panPreStart = false;
				this._panStarted  = false;
				
				if (this._enabled) {
					// Listen for the mouse events we need to operate a mouse pan
					this._entity.mouseDown(function (event) { self._mouseDown(event); });
					this._entity.mouseMove(function (event) { self._mouseMove(event); });
					this._entity.mouseUp(function (event) { self._mouseUp(event); });
				} else {
					// Remove the pan start data
					delete this._panStartMouse;
					delete this._panStartCamera;
				}
				
				return this._entity;
			}
			
			return this._enabled;
		},
		
		/**
		 * Handles the mouseDown event. Records the starting position of the
		 * camera pan and the current camera translation.
		 * @param event
		 * @private
		 */
		_mouseDown: function (event) {
			if (!this._panStarted && this._enabled && event.igeViewport.id() === this._entity.id()) {
				// Record the mouse down position - pan pre-start
				var curMousePos = $ige.engine._mousePos;
				this._panStartMouse = curMousePos.clone();
				
				this._panStartCamera = {
					x: this._entity.camera._translate.x,
					y: this._entity.camera._translate.y
				};
				
				this._panPreStart = true;
				this._panStarted = false;
			}
		},
		
		/**
		 * Handles the mouse move event. Translates the camera as the mouse
		 * moves across the screen.
		 * @param event
		 * @private
		 */
		_mouseMove: function (event) {
			if (this._enabled) {
				// Pan the camera if the mouse is down
				if (this._panStartMouse) {
					var curMousePos = $ige.engine._mousePos,
						panCords = {
							x: this._panStartMouse.x - curMousePos.x,
							y: this._panStartMouse.y - curMousePos.y
						}, distX = Math.abs(panCords.x), distY = Math.abs(panCords.y),
						panFinalX = (panCords.x / this._entity.camera._scale.x) + this._panStartCamera.x,
						panFinalY = (panCords.y / this._entity.camera._scale.y) + this._panStartCamera.y;
					
					// Check if we have a limiter on the rectangle area
					// that we should allow panning inside.
					if (this._limit) {
						// Check the pan co-ordinates against
						// the limiter rectangle
						if (panFinalX < this._limit.x) {
							panFinalX = this._limit.x;
						}
						
						if (panFinalX > this._limit.x + this._limit.width) {
							panFinalX = this._limit.x + this._limit.width;
						}
						
						if (panFinalY < this._limit.y) {
							panFinalY = this._limit.y;
						}
						
						if (panFinalY > this._limit.y + this._limit.height) {
							panFinalY = this._limit.y + this._limit.height;
						}
					}
					
					if (this._panPreStart) {
						// Check if we've reached the start threshold
						if (distX > this._startThreshold || distY > this._startThreshold) {
							this._entity.camera.translateTo(
								panFinalX,
								panFinalY,
								0
							);
							this.emit('panStart');
							this._panPreStart = false;
							this._panStarted = true;
							
							this.emit('panMove');
						}
					} else {
						// Pan has already started
						this._entity.camera.translateTo(
							panFinalX,
							panFinalY,
							0
						);
						
						this.emit('panMove');
					}
				}
			}
		},
		
		/**
		 * Handles the mouse up event. Finishes the camera translate and
		 * removes the starting pan data.
		 * @param event
		 * @private
		 */
		_mouseUp: function (event) {
			if (this._enabled) {
				// End the pan
				if (this._panStarted) {
					if (this._panStartMouse) {
						var curMousePos = $ige.engine._mousePos,
							panCords = {
								x: this._panStartMouse.x - curMousePos.x,
								y: this._panStartMouse.y - curMousePos.y
							},
							panFinalX = (panCords.x / this._entity.camera._scale.x) + this._panStartCamera.x,
							panFinalY = (panCords.y / this._entity.camera._scale.y) + this._panStartCamera.y;
						
						// Check if we have a limiter on the rectangle area
						// that we should allow panning inside.
						if (this._limit) {
							// Check the pan co-ordinates against
							// the limiter rectangle
							if (panFinalX < this._limit.x) {
								panFinalX = this._limit.x;
							}
							
							if (panFinalX > this._limit.x + this._limit.width) {
								panFinalX = this._limit.x + this._limit.width;
							}
							
							if (panFinalY < this._limit.y) {
								panFinalY = this._limit.y;
							}
							
							if (panFinalY > this._limit.y + this._limit.height) {
								panFinalY = this._limit.y + this._limit.height;
							}
						}
						
						this._entity.camera.translateTo(
							panFinalX,
							panFinalY,
							0
						);
						
						// Remove the pan start data to end the pan operation
						delete this._panStartMouse;
						delete this._panStartCamera;
						
						this.emit('panEnd');
						this._panStarted = false;
					}
				} else {
					delete this._panStartMouse;
					delete this._panStartCamera;
					this._panStarted = false;
				}
			}
		}
	});
	
	return IgeMousePanComponent;
});
},{"irrelon-appcore":125}],10:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeMouseZoomComponent', function ($ige, IgeEventingClass) {
	/**
	 * When added to a viewport, automatically adds mouse zooming
	 * capabilities to the viewport's camera.
	 */
	var IgeMouseZoomComponent = IgeEventingClass.extend({
		classId: 'IgeMouseZoomComponent',
		componentId: 'mouseZoom',
		
		/**
		 * @constructor
		 * @param {IgeObject} entity The object that the component is added to.
		 * @param {Object=} options The options object that was passed to the component during
		 * the call to addComponent.
		 */
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			// Set the zoom component to inactive to start with
			this._enabled = false;
		},
		
		/**
		 * Sets / gets the enabled flag. If set to true, zoom
		 * operations will be processed. If false, no zooming will
		 * occur.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		enabled: function (val) {
			var self = this;
			
			if (val !== undefined) {
				this._enabled = val;
				
				if (this._enabled) {
					// Listen for the mouse events we need to operate a mouse pan
					this._entity.mouseDown(function (event) { self._mouseDown(event); });
					this._entity.mouseMove(function (event) { self._mouseMove(event); });
					this._entity.mouseUp(function (event) { self._mouseUp(event); });
				} else {
					// Remove the zoom start data
					delete this._zoomStartMouse;
					delete this._zoomStartCamera;
				}
				
				return this._entity;
			}
			
			return this._enabled;
		},
		
		/**
		 * Handles the mouseDown event. Records the starting position of the
		 * camera zoom and the current camera translation.
		 * @param event
		 * @private
		 */
		_mouseDown: function (event) {
			if (this._enabled && event.igeViewport.id() === this._entity.id()) {
				// Record the mouse down position - zoom starting
				var curMousePos = $ige.engine._mousePos;
				this._zoomStartMouse = {
					x: curMousePos.x,
					y: curMousePos.y
				};
				
				this._zoomStartCamera = {
					x: this._entity.camera._scale.x,
					y: this._entity.camera._scale.y
				};
			}
		},
		
		/**
		 * Handles the mouse move event. Scales the camera as the mouse
		 * moves across the screen.
		 * @param event
		 * @private
		 */
		_mouseMove: function (event) {
			if (this._enabled) {
				// Zoom the camera if the mouse is down
				if (this._zoomStartMouse) {
					var curMousePos = $ige.engine._mousePos,
						zoomCords = {
							x: -(this._zoomStartMouse.x - curMousePos.x) / 100,
							y: -(this._zoomStartMouse.y - curMousePos.y) / 100
						};
					
					this._entity.camera.scaleTo(
						zoomCords.x + this._zoomStartCamera.x > 0.02 ? zoomCords.x + this._zoomStartCamera.x : 0.02,
						zoomCords.x + this._zoomStartCamera.x > 0.02 ? zoomCords.x + this._zoomStartCamera.x : 0.02,
						0
					);
				}
			}
		},
		
		/**
		 * Handles the mouse up event. Finishes the camera scale and
		 * removes the starting zoom data.
		 * @param event
		 * @private
		 */
		_mouseUp: function (event) {
			if (this._enabled) {
				// End the zoom
				if (this._zoomStartMouse) {
					var curMousePos = $ige.engine._mousePos,
						zoomCords = {
							x: -(this._zoomStartMouse.x - curMousePos.x) / 100,
							y: -(this._zoomStartMouse.y - curMousePos.y) / 100
						};
					
					this._entity.camera.scaleTo(
						zoomCords.x + this._zoomStartCamera.x > 0.02 ? zoomCords.x + this._zoomStartCamera.x : 0.02,
						zoomCords.x + this._zoomStartCamera.x > 0.02 ? zoomCords.x + this._zoomStartCamera.x : 0.02,
						0
					);
					
					// Remove the zoom start data to end the zoom operation
					delete this._zoomStartMouse;
					delete this._zoomStartCamera;
				}
			}
		}
	});
	
	return IgeMouseZoomComponent;
});
},{"irrelon-appcore":125}],11:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgePathComponent', function ($ige, $time, IgeEventingClass, IgePoint3d) {
	/**
	 * Handles entity path traversal.
	 */
	var IgePathComponent = IgeEventingClass.extend({
		classId: 'IgePathComponent',
		componentId: 'path',
		
		init: function (entity, options) {
			this._entity = entity;
			this._points = [];
			this._speed = 1 / 1000;
			
			this._previousPointFrom = 0;
			this._currentPointFrom = 0;
			this._previousPointTo = 0;
			this._currentPointTo = 0;
			
			// Add the path behaviour to the entity
			entity.addBehaviour('path', this._updateBehaviour, false);
		},
		
		/**
		 * Gets / sets the tile map that will be used when calculating paths.
		 * @param {IgeTileMap2d} val The tileMap to use for path calculations.
		 * @returns {*}
		 */
		tileMap: function (val) {
			if (val !== undefined) {
				this._tileMap = val;
				return this;
			}
			
			return this._tileMap;
		},
		
		/**
		 * Gets / sets the path finder class instance used to generate paths.
		 * @param {IgePathFinder} val The pathfinder class instance to use to generate paths.
		 * @returns {*}
		 */
		finder: function (val) {
			if (val !== undefined) {
				this._finder = val;
				return this;
			}
			
			return this._finder;
		},
		
		/**
		 * Gets / sets the dynamic mode enabled flag. If dynamic mode is enabled
		 * then at the end of every path point (reaching a tile along the path)
		 * the path finder will evaluate the path by looking ahead and seeing if
		 * the path has changed (the tiles along the path have now been marked as
		 * cannot path on). If any tile along the path up to the look-ahead value
		 * has been blocked, the path will auto re-calculate to avoid the new block.
		 *
		 * For dynamic mode to work you need to supply a path-finder instance by
		 * calling .finder(), a tile checker method by calling .tileChecker() and
		 * the number of look-ahead steps by calling .lookAheadSteps(). See the
		 * doc for those methods for usage and required arguments.
		 * @param {Boolean} enable If set to true, enables dynamic mode.
		 * @returns {*}
		 */
		dynamic: function (enable) {
			if (enable !== undefined) {
				this._dynamic = enable;
				return this;
			}
			
			return this._dynamic;
		},
		
		/**
		 * Gets / sets the tile checker method used when calculating paths.
		 * @param {Function=} val The method to call when checking if a tile is valid
		 * to traverse when calculating paths.
		 * @returns {*}
		 */
		tileChecker: function (val) {
			if (val !== undefined) {
				var self = this;
				
				this._tileChecker = function () { return val.apply(self._entity, arguments); };
				return this;
			}
			
			return this._tileChecker;
		},
		
		lookAheadSteps: function (val) {
			if (val !== undefined) {
				this._lookAheadSteps = val;
				return this;
			}
			
			return this._lookAheadSteps;
		},
		
		/**
		 * Gets / sets the flag determining if a path can use N, S, E and W movement.
		 * @param {Boolean=} val Set to true to allow, false to disallow.
		 * @returns {*}
		 */
		allowSquare: function (val) {
			if (val !== undefined) {
				this._allowSquare = val;
				return this;
			}
			
			return this._allowSquare;
		},
		
		/**
		 * Gets / sets the flag determining if a path can use NW, SW, NE and SE movement.
		 * @param {Boolean=} val Set to true to allow, false to disallow.
		 * @returns {*}
		 */
		allowDiagonal: function (val) {
			if (val !== undefined) {
				this._allowDiagonal = val;
				return this;
			}
			
			return this._allowDiagonal;
		},
		
		/**
		 * Clears any existing path points and sets the path the entity will traverse
		 * from start to finish.
		 * @param {Number} fromX The x tile to path from.
		 * @param {Number} fromY The y tile to path from.
		 * @param {Number} fromZ The z tile to path from.
		 * @param {Number} toX The x tile to path to.
		 * @param {Number} toY The y tile to path to.
		 * @param {Number} toZ The z tile to path to.
		 * @param {Boolean=} findNearest If the destination is unreachable, when set to
		 * true this option will allow the pathfinder to return the closest path to the
		 * destination tile.
		 * @returns {*}
		 */
		set: function (fromX, fromY, fromZ, toX, toY, toZ, findNearest) {
			// Clear existing path
			this.clear();
			
			// Create a new path
			var path = this._finder.generate(
				this._tileMap,
				new IgePoint3d(fromX, fromY, fromZ),
				new IgePoint3d(toX, toY, toZ),
				this._tileChecker,
				this._allowSquare,
				this._allowDiagonal,
				findNearest
			);
			
			this.addPoints(path);
			
			return this;
		},
		
		add: function (x, y, z, findNearest) {
			// Get the endPoint of the current path
			var endPoint = this.getEndPoint(),
				shift = true;
			
			if (!endPoint) {
				// There is no existing path, detect current tile position
				endPoint = this._entity._parent.pointToTile(this._entity._translate);
				shift = false;
			}
			
			// Create a new path
			var path = this._finder.generate(
				this._tileMap,
				endPoint,
				new IgePoint3d(x, y, z),
				this._tileChecker,
				this._allowSquare,
				this._allowDiagonal,
				findNearest
			);
			
			if (shift) {
				// Remove the first tile, it's the last one on the list already
				path.shift();
			}
			
			this.addPoints(path);
			
			return this;
		},
		
		/**
		 * Adds a path array containing path points (IgePoint3d instances) to the points queue.
		 * @param {Array} path An array of path points.
		 * @return {*}
		 */
		addPoints: function (path) {
			if (path !== undefined) {
				// Check the path array has items in it!
				if (path.length) {
					this._points = this._points.concat(path);
					this._calculatePathData();
				} else {
					this.log('Cannot add an empty path to the path queue!', 'warning');
				}
			}
			
			return this;
		},
		
		/**
		 * Gets the path node point that the entity is travelling from.
		 * @return {IgePoint3d} A new point representing the travelled from node.
		 */
		getFromPoint: function () {
			return this._points[this._currentPointFrom];
		},
		
		/**
		 * Gets the path node point that the entity is travelling to.
		 * @return {IgePoint3d} A new point representing the travelling to node.
		 */
		getToPoint: function () {
			return this._points[this._currentPointTo];
		},
		
		/**
		 * Gets the current direction.
		 * @example #Get the direction of movement along the current path
		 *     // Create an entity and add the path component
		 *     var entity = new IgeEntity()
		 *         .addComponent(IgePathComponent);
		 *
		 *     // Create a path and add it to the entity
		 *     // ...
		 *     // Now get the current direction
		 *     var direction = entity.path.currentDirection();
		 * @return {String} A string such as N, S, E, W, NW, NE, SW, SE.
		 * If there is currently no direction then the return value is a blank string.
		 */
		getDirection: function () {
			if (!this._finished) {
				var cell = this.getToPoint(),
					dir = '';
				
				if (cell) {
					dir = cell.direction;
					
					if (this._entity._mode === 1) {
						// Convert direction for isometric
						switch (dir) {
							case 'E':
								dir = 'SE';
								break;
							
							case 'S':
								dir = 'SW';
								break;
							
							case 'W':
								dir = 'NW';
								break;
							
							case 'N':
								dir = 'NE';
								break;
							
							case 'NE':
								dir = 'E';
								break;
							
							case 'SW':
								dir = 'W';
								break;
							
							case 'NW':
								dir = 'N';
								break;
							
							case 'SE':
								dir = 'S';
								break;
						}
					}
				}
			} else {
				dir = '';
			}
			
			return dir;
		},
		
		/**
		 * Gets / sets the time towards the end of the path when the path
		 * component will emit a "almostComplete" event.
		 * @param {Number=} ms The time in milliseconds to emit the event
		 * on before the end of the path.
		 * @return {*}
		 */
		warnTime: function (ms) {
			if (ms !== undefined) {
				this._warnTime = ms;
				return this;
			}
			
			return this._warnTime;
		},
		
		/**
		 * Gets / sets the flag determining if the entity moving along
		 * the path will stop automatically at the end of the path.
		 * @param {Boolean=} val If true, will stop at the end of the path.
		 * @return {*}
		 */
		autoStop: function (val) {
			if (val !== undefined) {
				this._autoStop = val;
				return this;
			}
			
			return this._autoStop;
		},
		
		/**
		 * Gets / sets the speed at which the entity will traverse the path in pixels
		 * per second (world space).
		 * @param {Number=} val
		 * @return {*}
		 */
		speed: function (val) {
			if (val !== undefined) {
				this._speed = val / 1000;
				
				if (this._active) {
					this.stop();
					this.start(this._startTime);
				}
				return this;
			}
			
			return this._speed;
		},
		
		/**
		 * Starts path traversal.
		 * @param {Number=} startTime The time to start path traversal. Defaults
		 * to new Date().getTime() if no
		 * value is presented.
		 * @return {*}
		 */
		start: function (startTime) {
			if (!this._active) {
				this._active = true;
				this._finished = false;
				this._startTime = startTime || $time._currentTime;
				
				this._calculatePathData();
				this.emit('started', this._entity);
			} else {
				this._finished = false;
			}
			
			return this;
		},
		
		/**
		 * Returns the last point of the last path in the path queue.
		 * @return {IgePoint3d}
		 */
		getEndPoint: function () {
			return this._points[this._points.length - 1];
		},
		
		/**
		 * Pauses path traversal but does not clear the path queue or any path data.
		 * @return {*}
		 */
		pause: function () {
			this._active = false;
			this._paused = true;
			this._pauseTime = $time._currentTime;
			
			this.emit('paused', this._entity);
			return this;
		},
		
		/**
		 * Clears all path queue and path data.
		 * @return {*}
		 */
		clear: function () {
			if (this._active) {
				this.stop();
			}
			
			this._previousPointFrom = 0;
			this._currentPointFrom = 0;
			this._previousPointTo = 0;
			this._currentPointTo = 0;
			this._points = [];
			
			this.emit('cleared', this._entity);
			return this;
		},
		
		/**
		 * Stops path traversal but does not clear the path
		 * queue or any path data.
		 * @return {*}
		 */
		stop: function () {
			//this.log('Setting pathing as inactive...');
			this._active = false;
			this._finished = true;
			this.emit('stopped', this._entity);
			
			return this;
		},
		
		/**
		 * Gets / sets the flag determining if the path component
		 * should draw the current path of the entity to the canvas
		 * on each tick. Useful for debugging paths.
		 * @param {Boolean=} val If true, will draw the path.
		 * @return {*}
		 */
		drawPath: function (val) {
			if (val !== undefined) {
				this._drawPath = val;
				
				if (val) {
					this._entity.addBehaviour('path', this._tickBehaviour, true);
				} else {
					this._entity.removeBehaviour('path', true);
				}
				
				return this;
			}
			
			return this._drawPath;
		},
		
		/**
		 * Gets / sets the flag that determines if the path that
		 * is drawn gets some added glow effects or not. Pure eye
		 * candy, completely pointless otherwise.
		 * @param {Boolean=} val If true will add glow effects to the path.
		 * @return {*}
		 */
		drawPathGlow: function (val) {
			if (val !== undefined) {
				this._drawPathGlow = val;
				return this;
			}
			
			return this._drawPathGlow;
		},
		
		/**
		 * Gets / sets the flag that determines if the path that
		 * is drawn gets some added labels or not.
		 * @param {Boolean=} val If true will draw labels on each path point.
		 * @return {*}
		 */
		drawPathText: function (val) {
			if (val !== undefined) {
				this._drawPathText = val;
				return this;
			}
			
			return this._drawPathText;
		},
		
		multiplyPoint: function (point) {
			return point.multiply(
				this._entity._parent._tileWidth,
				this._entity._parent._tileHeight,
				1
			);
		},
		
		dividePoint: function (point) {
			return point.divide(
				this._entity._parent._tileWidth,
				this._entity._parent._tileHeight,
				1
			);
		},
		
		transformPoint: function (point) {
			return new IgePoint3d(
				point.x + this._entity._parent._tileWidth / 2,
				point.y + this._entity._parent._tileHeight / 2,
				point.z
			);
		},
		
		unTransformPoint: function (point) {
			return new IgePoint3d(
				point.x - this._entity._parent._tileWidth / 2,
				point.y - this._entity._parent._tileHeight / 2,
				point.z
			);
		},
		
		/**
		 * The behaviour method executed each tick.
		 * @param {CanvasRenderingContext2d} ctx The canvas that is currently being
		 * rendered to.
		 * @private
		 */
		_updateBehaviour: function (ctx) {
			var path = this.path,
				currentTime = $time._currentTime,
				progressTime = currentTime - path._startTime;
			
			// Check if we should be processing paths
			if (path._active && path._totalDistance !== 0 && currentTime >= path._startTime && (progressTime <= path._totalTime || !path._finished)) {
				var distanceTravelled = (path._speed) * progressTime,
					totalDistance = 0,
					pointArr = path._points,
					pointCount = pointArr.length,
					pointIndex,
					pointFrom,
					pointTo,
					newPoint,
					dynamicResult;
				
				// Loop points along the path and determine which points we are traversing between
				for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
					totalDistance += pointArr[pointIndex]._distanceToNext;
					
					if (totalDistance > distanceTravelled) {
						// Found points we are traversing
						path._finished = false;
						path._currentPointFrom = pointIndex;
						path._currentPointTo = pointIndex + 1;
						pointFrom = pointArr[pointIndex];
						pointTo = pointArr[pointIndex + 1];
						break;
					}
				}
				
				// Check if we have points to traverse between
				if (pointFrom && pointTo) {
					if (path._currentPointFrom !== path._previousPointFrom) {
						// Emit point complete
						path.emit('pointComplete', [this, pointArr[path._previousPointFrom].x, pointArr[path._previousPointFrom].y, pointArr[path._currentPointFrom].x, pointArr[path._currentPointFrom].y]);
					}
					
					// Check if we are in dynamic mode and if so, ensure our path is still valid
					if (path._dynamic) {
						dynamicResult = path._processDynamic(pointFrom, pointTo, pointArr[pointCount - 1]);
						if (dynamicResult === true) {
							// Re-assign the points to the new ones that the dynamic path
							// spliced into our points array
							pointFrom = pointArr[path._currentPointFrom];
							pointTo = pointArr[path._currentPointTo];
							
							path.emit('pathRecalculated', [this, pointArr[path._previousPointFrom].x, pointArr[path._previousPointFrom].y, pointArr[path._currentPointFrom].x, pointArr[path._currentPointFrom].y]);
						}
						
						if (dynamicResult === -1) {
							// Failed to find a new dynamic path
							path._finished = true;
						}
					}
					
					// Calculate position along vector between the two points
					newPoint = path._positionAlongVector(
						pointFrom,
						pointTo,
						path._speed,
						pointFrom._deltaTimeToNext - (pointFrom._absoluteTimeToNext - progressTime)
					);
					
					newPoint = path.multiplyPoint(newPoint);
					newPoint = path.transformPoint(newPoint);
					
					// Translate the entity to the new path point
					this.translateToPoint(newPoint);
					
					path._previousPointFrom = path._currentPointFrom;
					path._previousPointTo = path._currentPointTo;
				} else {
					pointTo = pointArr[pointCount - 1];
					
					newPoint = path.multiplyPoint(pointTo);
					newPoint = path.transformPoint(newPoint);
					
					path._previousPointFrom = pointCount - 1;
					path._previousPointTo = pointCount - 1;
					path._currentPointFrom = pointCount - 1;
					path._currentPointTo = pointCount - 1;
					
					this.translateToPoint(newPoint);
					
					path._finished = true;
					path.emit('pathComplete', [this, pointArr[path._previousPointFrom].x, pointArr[path._previousPointFrom].y]);
				}
			} else if(path._active && path._totalDistance == 0 && !path._finished) {
				path._finished = true;
			}
		},
		
		_processDynamic: function (pointFrom, pointTo, destinationPoint) {
			var self = this,
				tileMapData,
				tileCheckData,
				newPathPoints;
			
			// We are in dynamic mode, check steps ahead to see if they
			// have been blocked or not
			tileMapData = self._tileMap.map._mapData;
			tileCheckData = tileMapData[pointTo.y] && tileMapData[pointTo.y][pointTo.x] ? tileMapData[pointTo.y][pointTo.x] : null;
			
			if (!self._tileChecker(tileCheckData, pointTo.x, pointTo.y, null, null, null, true)) {
				// The new destination tile is blocked, recalculate path
				newPathPoints = self._finder.generate(
					self._tileMap,
					new IgePoint3d(pointFrom.x, pointFrom.y, pointFrom.z),
					new IgePoint3d(destinationPoint.x, destinationPoint.y, destinationPoint.z),
					self._tileChecker,
					self._allowSquare,
					self._allowDiagonal,
					false
				);
				
				if (newPathPoints.length) {
					self.replacePoints(self._currentPointFrom, self._points.length - self._currentPointFrom, newPathPoints);
					return true;
				} else {
					// Cannot generate valid path, delete this path
					self.emit('dynamicFail', [this, new IgePoint3d(pointFrom.x, pointFrom.y, pointFrom.z), new IgePoint3d(destinationPoint.x, destinationPoint.y, destinationPoint.z)]);
					self.clear();
					
					return -1;
				}
			}
			
			return false;
		},
		
		_calculatePathData: function () {
			var totalDistance = 0,
				startPoint,
				pointFrom,
				pointTo,
				i;
			
			
			if(this._currentPointFrom === 0) {
				// always set the first point to be the current position
				startPoint = this._entity._translate.clone();
				startPoint = this.unTransformPoint(startPoint);
				startPoint = this.dividePoint(startPoint);
				this._points[0] = startPoint;
			}
			
			// Calculate total distance to travel
			for (i = 1; i < this._points.length; i++) {
				pointFrom = this._points[i - 1];
				pointTo = this._points[i];
				pointFrom._distanceToNext = Math.distance(pointFrom.x, pointFrom.y, pointTo.x, pointTo.y);
				
				totalDistance += Math.abs(pointFrom._distanceToNext);
				
				pointFrom._deltaTimeToNext = pointFrom._distanceToNext / this._speed;
				pointFrom._absoluteTimeToNext = totalDistance / this._speed;
			}
			
			this._totalDistance = totalDistance;
			this._totalTime = totalDistance / this._speed;
			
			return this;
		},
		
		/**
		 * Replaces a number of points in the current queue with the new points passed.
		 * @param {Number} fromIndex The from index.
		 * @param {Number} replaceLength The number of points to replace.
		 * @param {Array} newPoints The array of new points to insert.
		 */
		replacePoints: function (fromIndex, replaceLength, newPoints) {
			var args = [fromIndex, replaceLength].concat(newPoints);
			this._points.splice.apply(this._points, args);
			this._calculatePathData();
		},
		
		_tickBehaviour: function (ctx) {
			if ($ige.isClient) {
				var self = this.path,
					entity = this,
					currentPath = self._points,
					oldTracePathPoint,
					tracePathPoint,
					pathPointIndex,
					tempPathText;
				
				if (currentPath.length) {
					if (currentPath && self._drawPath) {
						// Draw the current path
						ctx.save();
						
						oldTracePathPoint = undefined;
						
						for (pathPointIndex = 0; pathPointIndex < currentPath.length; pathPointIndex++) {
							ctx.strokeStyle = '#0096ff';
							ctx.fillStyle = '#0096ff';
							
							tracePathPoint = new IgePoint3d(
								currentPath[pathPointIndex].x,
								currentPath[pathPointIndex].y,
								currentPath[pathPointIndex].z
							);
							
							tracePathPoint = self.multiplyPoint(tracePathPoint);
							tracePathPoint = self.transformPoint(tracePathPoint);
							
							if (entity._parent._mountMode === 1) {
								tracePathPoint = tracePathPoint.toIso();
							}
							
							if (!oldTracePathPoint) {
								// The starting point of the path
								ctx.beginPath();
								ctx.arc(tracePathPoint.x, tracePathPoint.y, 5, 0, Math.PI*2, true);
								ctx.closePath();
								ctx.fill();
							} else {
								// Not the starting point
								if (self._drawPathGlow) {
									ctx.globalAlpha = 0.1;
									for (var k = 3; k >= 0 ; k--) {
										ctx.lineWidth = (k + 1) * 4 - 3.5;
										ctx.beginPath();
										ctx.moveTo(oldTracePathPoint.x, oldTracePathPoint.y);
										ctx.lineTo(tracePathPoint.x, tracePathPoint.y);
										
										if (pathPointIndex < self._currentPointTo) {
											ctx.strokeStyle = '#666666';
											ctx.fillStyle = '#333333';
										}
										if (k === 0) {
											ctx.globalAlpha = 1;
										}
										
										ctx.stroke();
									}
								} else {
									ctx.beginPath();
									ctx.moveTo(oldTracePathPoint.x, oldTracePathPoint.y);
									ctx.lineTo(tracePathPoint.x, tracePathPoint.y);
									
									if (pathPointIndex < self._currentPointTo) {
										ctx.strokeStyle = '#666666';
										ctx.fillStyle = '#333333';
									}
									
									ctx.stroke();
								}
								
								if (pathPointIndex === self._currentPointTo) {
									ctx.save();
									ctx.fillStyle = '#24b9ea';
									ctx.fillRect(tracePathPoint.x - 5, tracePathPoint.y - 5, 10, 10);
									
									if (self._drawPathText) {
										ctx.fillStyle = '#eade24';
										
										if (self._drawPathGlow) {
											// Apply shadow to the text
											ctx.shadowOffsetX = 1;
											ctx.shadowOffsetY = 2;
											ctx.shadowBlur    = 4;
											ctx.shadowColor   = 'rgba(0, 0, 0, 1)';
										}
										
										tempPathText = 'Entity: ' + entity.id();
										ctx.fillText(tempPathText, tracePathPoint.x - Math.floor(ctx.measureText(tempPathText).width / 2), tracePathPoint.y + 16);
										
										tempPathText = 'Point (' + currentPath[pathPointIndex].x + ', ' + currentPath[pathPointIndex].y + ')';
										ctx.fillText(tempPathText, tracePathPoint.x - Math.floor(ctx.measureText(tempPathText).width / 2), tracePathPoint.y + 28);
										
										tempPathText = 'Abs (' + Math.floor(entity._translate.x) + ', ' + Math.floor(entity._translate.y) + ')';
										ctx.fillText(tempPathText, tracePathPoint.x - Math.floor(ctx.measureText(tempPathText).width / 2), tracePathPoint.y + 40);
									}
									
									ctx.restore();
								} else {
									ctx.fillRect(tracePathPoint.x - 2.5, tracePathPoint.y - 2.5, 5, 5);
								}
							}
							
							oldTracePathPoint = tracePathPoint;
						}
						
						ctx.restore();
					}
				}
			}
		},
		
		getPreviousPoint: function (val) {
			return this._points[this._currentPointFrom - val];
		},
		
		getNextPoint: function (val) {
			return this._points[this._currentPointTo + val];
		},
		
		/**
		 * Calculates the position of the entity along a vector based on the speed
		 * of the entity and the delta time.
		 * @param {IgePoint3d} p1 Vector start point
		 * @param {IgePoint3d} p2 Vector end point
		 * @param {Number} speed Speed along the vector
		 * @param {Number} deltaTime The time between the last update and now.
		 * @return {IgePoint3d}
		 * @private
		 */
		_positionAlongVector: function (p1, p2, speed, deltaTime) {
			var newPoint,
				p1X = p1.x,
				p1Y = p1.y,
				p2X = p2.x,
				p2Y = p2.y,
				deltaX = (p2X - p1X),
				deltaY = (p2Y - p1Y),
				magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
				normalisedX = deltaX / magnitude,
				normalisedY = deltaY / magnitude;
			
			if (deltaX !== 0 || deltaY !== 0) {
				newPoint = new IgePoint3d(
					p1X + (normalisedX * (speed * deltaTime)),
					p1Y + (normalisedY * (speed * deltaTime)),
					0
				);
			} else {
				newPoint = new IgePoint3d(0, 0, 0);
			}
			
			return newPoint;
		}
	});
	
	return IgePathComponent;
});
},{"irrelon-appcore":125}],12:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTiledComponent', function ($ige, IgeClass, IgeCellSheet, IgeTileMap2d, IgeTextureMap) {
	/**
	 * Loads slightly modified Tiled-format json map data into the Isogenic Engine.
	 */
	var IgeTiledComponent = IgeClass.extend({
		classId: 'IgeTiledComponent',
		componentId: 'tiled',
		
		/**
		 * @constructor
		 * @param entity
		 * @param options
		 */
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
		},
		
		/**
		 * Loads a .js Tiled json-format file and converts to IGE format,
		 * then calls the callback with the newly created scene and the
		 * various layers as IgeTextureMap instances.
		 * @param url
		 * @param callback
		 */
		loadJson: function (url, callback) {
			var self = this,
				scriptElem;
			
			if (typeof(url) === 'string') {
				if ($ige.isClient) {
					scriptElem = document.createElement('script');
					scriptElem.src = url;
					scriptElem.onload = function () {
						self.log('Tiled data loaded, processing...');
						self._processData(tiled, callback);
					};
					document.getElementsByTagName('head')[0].appendChild(scriptElem);
				} else {
					this.log('URL-based Tiled data is only available client-side. If you want to load Tiled map data on the server please include the map file in your ServerConfig.js file and then specify the map\'s data object instead of the URL.', 'error');
				}
			} else {
				self._processData(url, callback);
			}
		},
		
		_processData: function (data, callback) {
			var mapClass = $ige.isServer === true ? IgeTileMap2d : IgeTextureMap,
				mapWidth = data.width,
				mapHeight = data.height,
				layerArray = data.layers,
				layerCount = layerArray.length,
				layer,
				layerType,
				layerData,
				layerDataCount,
				maps = [],
				layersById = {},
				tileSetArray = data.tilesets,
				tileSetCount = tileSetArray.length,
				tileSetItem,
				tileSetsTotal = tileSetCount,
				tileSetsLoaded = 0,
				textureCellLookup = [],
				currentTexture,
				currentCell,
				onLoadFunc,
				image,
				textures = [],
				allTexturesLoadedFunc,
				i, k, x, y, z,
				ent;
			
			// Define the function to call when all textures have finished loading
			allTexturesLoadedFunc = function () {
				// Create a map for each layer
				for (i = 0; i < layerCount; i++) {
					layer = layerArray[i];
					layerType = layer.type;
					
					// Check if the layer is a tile layer or an object layer
					if (layerType === 'tilelayer') {
						layerData = layer.data;
						
						maps[i] = new mapClass()
							.id(layer.name)
							.tileWidth(data.tilewidth)
							.tileHeight(data.tilewidth)
							.depth(i);
						
						maps[i].type = layerType;
						
						// Check if the layer should be isometric mounts enabled
						if (data.orientation === 'isometric') {
							maps[i].isometricMounts(true);
						}
						
						layersById[layer.name] = maps[i];
						tileSetCount = tileSetArray.length;
						
						if ($ige.isClient) {
							for (k = 0; k < tileSetCount; k++) {
								maps[i].addTexture(textures[k]);
							}
						}
						
						// Loop through the layer data and paint the tiles
						layerDataCount = layerData.length;
						
						for (y = 0; y < mapHeight; y++) {
							for (x = 0; x < mapWidth; x++) {
								z = x + (y * mapWidth);
								
								if (layerData[z] > 0 && layerData[z] !== 2147483712) {
									if ($ige.isClient) {
										// Paint the tile
										currentTexture = textureCellLookup[layerData[z]];
										if (currentTexture) {
											currentCell = layerData[z] - (currentTexture._tiledStartingId - 1);
											maps[i].paintTile(x, y, maps[i]._textureList.indexOf(currentTexture), currentCell);
										}
									} else {
										// Server-side we don't paint tiles on a texture map
										// we just mark the map data so that it can be used
										// to do things like path-finding and auto-creating
										// static physics objects.
										maps[i].occupyTile(x, y, 1, 1, layerData[z]);
									}
								}
							}
						}
					}
					
					if (layerType === 'objectgroup') {
						maps[i] = layer;
						layersById[layer.name] = maps[i];
					}
				}
				
				callback(maps, layersById);
			};
			
			if ($ige.isClient) {
				onLoadFunc = function (textures, tileSetCount, tileSetItem) {
					return function () {
						var i, cc,
							cs = new IgeCellSheet(tileSetItem.image, this.width / tileSetItem.tilewidth, this.height / tileSetItem.tileheight)
								.id(tileSetItem.name)
								.on('loaded', function () {
									cc = this.cellCount();
									
									this._tiledStartingId = tileSetItem.firstgid;
									// Fill the lookup array
									for (i = 0; i < cc; i++) {
										textureCellLookup[this._tiledStartingId + i] = this;
									}
									
									textures.push(this);
									
									tileSetsLoaded++;
									
									if (tileSetsLoaded === tileSetsTotal) {
										// All textures loaded, fire processing function
										allTexturesLoadedFunc();
									}
								});
					};
				};
				
				// Load the tile sets as textures
				while (tileSetCount--) {
					// Load the image into memory first so we can read the total width and height
					image = new Image();
					
					tileSetItem = tileSetArray[tileSetCount];
					image.onload = onLoadFunc(textures, tileSetCount, tileSetItem);
					image.src = tileSetItem.image;
				}
			} else {
				// We're on the server so no textures are actually loaded
				allTexturesLoadedFunc();
			}
		}
	});
	
	return IgeTiledComponent;
});
},{"irrelon-appcore":125}],13:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTimeComponent', function ($ige, $time, IgeEventingClass) {
	var IgeTimeComponent = IgeEventingClass.extend({
		classId: 'IgeTimeComponent',
		componentId: 'time',
		
		/**
		 * @constructor
		 * @param {Object} entity The parent object that this component is being added to.
		 * @param {Object=} options An optional object that is passed to the component when it is being initialised.
		 */
		init: function (entity, options) {
			this._entity = entity;
			this._timers = [];
			this._additions = [];
			this._removals = [];
			
			// Add the animation behaviour to the entity
			entity.addBehaviour('time', this._update);
		},
		
		addTimer: function (timer) {
			if (timer) {
				if (!this._updating) {
					this._timers.push(timer);
				} else {
					this._additions.push(timer);
				}
			}
			
			return this;
		},
		
		removeTimer: function (timer) {
			if (timer) {
				if (!this._updating) {
					this._timers.pull(timer);
				} else {
					this._removals.push(timer);
				}
			}
			
			return this;
		},
		// TODO cannot use ige here - need to use appCore instead and $ige.engine.time === this?
		// perhaps we need to brak timing out into its own module?
		_update: function () {
			// Get the ige tick delta and tell our timers / intervals that an update has occurred
			var self = this.time,
				delta = $time._tickDelta,
				arr = self._timers,
				arrCount = arr.length;
			
			while (arrCount--) {
				arr[arrCount]
					.addTime(delta)
					.update();
			}
			
			// Process removing any timers that were scheduled for removal
			self._processRemovals();
			
			// Now process any additions to the timers that were scheduled to be added
			self._processAdditions();
			
			return self;
		},
		
		_processAdditions: function () {
			var arr = this._additions,
				arrCount = arr.length;
			
			if (arrCount) {
				while (arrCount--) {
					this._timers.push(arr[arrCount]);
				}
				
				this._additions = [];
			}
			
			return this;
		},
		
		_processRemovals: function () {
			var arr = this._removals,
				arrCount = arr.length;
			
			if (arrCount) {
				while (arrCount--) {
					this._timers.pull(arr[arrCount]);
				}
				
				this._removals = [];
			}
			
			return this;
		}
	});
	
	return IgeTimeComponent;
});
},{"irrelon-appcore":125}],14:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTweenComponent', function ($ige, $time, IgeClass) {
	/**
	 * This component is already included in the IgeEngine (ige)
	 * instance and is not designed for use in any other way!
	 * It handles global tween processing on all tweening values.
	 */
	var IgeTweenComponent = IgeClass.extend({
		classId: 'IgeTweenComponent',
		componentId: 'tween',
		
		init: function (entity, options) {
			this._entity = entity;
			this._transform = entity.transform;
			
			// Setup the array that will hold our active tweens
			this._tweens = [];
			
			// Add the tween behaviour to the entity
			entity.addBehaviour('tween', this.update);
		},
		
		/**
		 * Start tweening particular properties for the object.
		 * @param {IgeTween} tween The tween to start.
		 * @return {Number} The index of the added tween or -1 on error.
		 */
		start: function (tween) {
			if (tween._startTime > $time._currentTime) {
				// The tween is scheduled for later
				// Push the tween into the IgeTweenComponent's _tweens array
				this._tweens.push(tween);
			} else {
				// The tween should start immediately
				tween._currentStep = 0;
				
				// Setup the tween's step
				if (this._setupStep(tween, false)) {
					// Push the tween into the IgeTweenComponent's _tweens array
					this._tweens.push(tween);
				}
			}
			
			// Enable tweening on the IgeTweenComponent
			this.enable();
			
			// Return the tween
			return tween;
		},
		
		_setupStep: function (tween, newTime) {
			var targetObj = tween._targetObj,
				step = tween._steps[tween._currentStep],
				propertyNameAndValue, // = tween._propertyObj
				durationMs,
				endTime,
				easing,
				propertyIndex,
				targetData = [];
			
			if (step) {
				propertyNameAndValue = step.props;
			}
			
			if (targetObj) {
				// Check / fill some option defaults
				if (tween._currentStep === 0 && !newTime) {
					// Because we are on step zero we can check for a start time
					if (tween._startTime === undefined) {
						tween._startTime = $time._currentTime;
					}
				} else {
					// We're not on step zero anymore so the new step start time
					// is NOW!
					tween._startTime = $time._currentTime;
				}
				
				durationMs = step.durationMs ? step.durationMs : tween._durationMs;
				tween._selectedEasing = step.easing ? step.easing : tween._easing;
				
				// Calculate the end time
				tween._endTime = tween._startTime + durationMs;
				
				for (propertyIndex in propertyNameAndValue) {
					if (propertyNameAndValue.hasOwnProperty(propertyIndex)) {
						targetData.push({
							targetObj: targetObj,
							propName: propertyIndex,
							deltaVal: propertyNameAndValue[propertyIndex] - (step.isDelta ? 0 : targetObj[propertyIndex]), // The diff between end and start values
							oldDelta: 0 // Var to save the old delta in order to get the actual difference data.
						});
					}
				}
				
				tween._targetData = targetData;
				tween._destTime = tween._endTime - tween._startTime;
				
				return tween; // Return the tween
			} else {
				this.log('Cannot start tweening properties of the specified object "' + obj + '" because it does not exist!', 'error');
			}
		},
		
		/**
		 * Removes the specified tween from the active tween list.
		 * @param {IgeTween} tween The tween to stop.
		 */
		stop: function (tween) {
			// Store the new tween details in the item
			this._tweens.pull(tween);
			
			if (!this._tweens.length) {
				// Disable tweening on this item as there are
				// no more tweens to process
				this.disable();
			}
			
			return this;
		},
		
		/**
		 * Stop all tweening for the object.
		 */
		stopAll: function () {
			// Disable tweening
			this.disable();
			
			// Remove all tween details
			delete this._tweens;
			this._tweens = [];
			
			return this;
		},
		
		/**
		 * Enable tweening for the object.
		 */
		enable: function () {
			// Check if the item is currently tweening
			if (!this._tweening) {
				// Set the item to tweening
				this._tweening = true;
			}
			
			return this;
		},
		
		/**
		 * Disable tweening for the object.
		 */
		disable: function () {
			// Check if the item is currently tweening
			if (this._tweening) {
				// Set the item to not tweening
				this._tweening = false;
			}
			
			return this;
		},
		
		/**
		 * Process tweening for the object.
		 */
		update: function (ctx) {
			var thisTween = this.tween;
			if (thisTween._tweens && thisTween._tweens.length) {
				var currentTime = $time._tickStart,
					tweens = thisTween._tweens,
					tweenCount = tweens.length,
					tween,
					deltaTime,
					destTime,
					easing,
					item,
					targetProp,
					targetPropVal,
					targets,
					targetIndex,
					stepIndex,
					stopped,
					currentDelta;
				
				// Loop the item's tweens
				while (tweenCount--) {
					tween = tweens[tweenCount];
					stopped = false;
					
					// Check if we should be starting this tween yet
					if (tween._started || currentTime >= tween._startTime) {
						if (!tween._started) {
							// Check if the tween's step is -1 indicating no step
							// data has been set up yet
							if (tween._currentStep === -1) {
								// Setup the tween step now
								tween._currentStep = 0;
								thisTween._setupStep(tween, false);
							}
							
							// Check if we have a beforeTween callback to fire
							if (typeof(tween._beforeTween) === 'function') {
								// Fire the beforeTween callback
								tween._beforeTween(tween);
								
								// Delete the callback so we don't store it any longer
								delete tween._beforeTween;
							}
							
							// Check if we have a beforeStep callback to fire
							if (typeof(tween._beforeStep) === 'function') {
								// Fire the beforeStep callback
								if (tween._stepDirection) {
									stepIndex = tween._steps.length - (tween._currentStep + 1);
								} else {
									stepIndex = tween._currentStep;
								}
								tween._beforeStep(tween, stepIndex);
							}
							
							tween._started = true;
						}
						
						deltaTime = currentTime - tween._startTime; // Delta from start time to current time
						destTime = tween._destTime;
						easing = tween._selectedEasing;
						
						// Check if the tween has reached it's destination based upon
						// the current time
						if (deltaTime >= destTime) {
							// The tween time indicates the tween has ended so set to
							// the ending value
							targets = tween._targetData;
							
							for (targetIndex in targets) {
								if (targets.hasOwnProperty(targetIndex)) {
									item = targets[targetIndex];
									targetProp = item.targetObj;
									targetPropVal = targetProp[item.propName];
									
									// Check if the destination time is not zero
									// because otherwise the easing method will provide
									// a divide by zero error resulting in a NaN value
									if (destTime !== 0) {
										// Add the delta amount to destination
										currentDelta = thisTween.easing[easing](
											destTime,
											item.deltaVal,
											destTime
										);
									} else {
										currentDelta = item.deltaVal;
									}
									
									targetPropVal += currentDelta - item.oldDelta;
									
									// Round the value to correct floating point operation imprecision
									var roundingPrecision = Math.pow(10, 15-(targetPropVal.toFixed(0).toString().length));
									targetProp[item.propName] = Math.round(targetPropVal * roundingPrecision)/roundingPrecision;
								}
							}
							
							// Check if we have a afterStep callback to fire
							if (typeof(tween._afterStep) === 'function') {
								// Fire the afterStep
								if (tween._stepDirection) {
									stepIndex = tween._steps.length - (tween._currentStep + 1);
								} else {
									stepIndex = tween._currentStep;
								}
								tween._afterStep(tween, stepIndex);
							}
							
							if (tween._steps.length === tween._currentStep + 1) {
								// The tween has ended, is the tween repeat mode enabled?
								if (tween._repeatMode) {
									// We have a repeat mode, lets check for a count
									if (tween._repeatCount !== -1) {
										// Check if the repeat count has reached the
										// number of repeats we wanted
										tween._repeatedCount++;
										if (tween._repeatCount === tween._repeatedCount) {
											// The tween has ended
											stopped = true;
										}
									}
									
									if (!stopped) {
										// Work out what mode we're running on
										if (tween._repeatMode === 1) {
											tween._currentStep = 0;
										}
										
										if (tween._repeatMode === 2) {
											// We are on "reverse loop" mode so now
											// reverse the tween's steps and then
											// start from step zero
											tween._stepDirection = !tween._stepDirection;
											tween._steps.reverse();
											
											tween._currentStep = 1;
										}
										
										// Check if we have a stepsComplete callback to fire
										if (typeof(tween._stepsComplete) === 'function') {
											// Fire the stepsComplete callback
											tween._stepsComplete(tween, tween._currentStep);
										}
										
										// Check if we have a beforeStep callback to fire
										if (typeof(tween._beforeStep) === 'function') {
											// Fire the beforeStep callback
											if (tween._stepDirection) {
												stepIndex = tween._steps.length - (tween._currentStep + 1);
											} else {
												stepIndex = tween._currentStep;
											}
											tween._beforeStep(tween, stepIndex);
										}
										
										thisTween._setupStep(tween, true);
									}
								} else {
									stopped = true;
								}
								
								if (stopped) {
									// Now stop tweening this tween
									tween.stop();
									
									// If there is a callback, call it
									if (typeof(tween._afterTween) === 'function') {
										// Fire the afterTween callback
										tween._afterTween(tween);
										
										// Delete the callback so we don't store it any longer
										delete tween._afterTween;
									}
								}
							} else {
								// Start the next step
								tween._currentStep++;
								
								// Check if we have a beforeStep callback to fire
								if (typeof(tween._beforeStep) === 'function') {
									// Fire the beforeStep callback
									if (tween._stepDirection) {
										stepIndex = tween._steps.length - (tween._currentStep + 1);
									} else {
										stepIndex = tween._currentStep;
									}
									tween._beforeStep(tween, stepIndex);
								}
								
								thisTween._setupStep(tween, true);
							}
							
							if (typeof(tween._afterChange) === 'function') {
								tween._afterChange(tween, stepIndex);
							}
						} else {
							// The tween is still active, process the tween by passing it's details
							// to the selected easing method
							targets = tween._targetData;
							
							for (targetIndex in targets) {
								if (targets.hasOwnProperty(targetIndex)) {
									item = targets[targetIndex];
									var currentDelta = thisTween.easing[easing](
										deltaTime,
										item.deltaVal,
										destTime
									);
									item.targetObj[item.propName] += currentDelta - item.oldDelta;
									item.oldDelta = currentDelta;
								}
							}
							
							if (typeof(tween._afterChange) === 'function') {
								tween._afterChange(tween, stepIndex);
							}
						}
					}
				}
			}
		},
		
		/** tweenEasing - Contains all the tween easing functions. {
		category:"property",
		type:"object",
	} **/
		easing: {
			// Easing equations converted from AS to JS from original source at
			// http://robertpenner.com/easing/
			none: function(t, c, d) {
				return c*t/d;
			},
			inQuad: function(t, c, d) {
				return c*(t/=d)*t;
			},
			outQuad: function(t, c, d) {
				return -c *(t/=d)*(t-2);
			},
			inOutQuad: function(t, c, d) {
				if((t/=d/2) < 1) { return c/2*t*t; }
				return -c/2 *((--t)*(t-2) - 1);
			},
			inCubic: function(t, c, d) {
				return c*(t/=d)*t*t;
			},
			outCubic: function(t, c, d) {
				return c*((t=t/d-1)*t*t + 1);
			},
			inOutCubic: function(t, c, d) {
				if((t/=d/2) < 1) { return c/2*t*t*t; }
				return c/2*((t-=2)*t*t + 2);
			},
			outInCubic: function(t, c, d) {
				if(t < d/2) { return this.outCubic(t*2, c/2, d); }
				return this.inCubic((t*2)-d, c/2, c/2, d);
			},
			inQuart: function(t, c, d) {
				return c*(t/=d)*t*t*t;
			},
			outQuart: function(t, c, d) {
				return -c *((t=t/d-1)*t*t*t - 1);
			},
			inOutQuart: function(t, c, d) {
				if((t/=d/2) < 1) { return c/2*t*t*t*t; }
				return -c/2 *((t-=2)*t*t*t - 2);
			},
			outInQuart: function(t, c, d) {
				if(t < d/2) { return this.outQuart(t*2, c/2, d); }
				return this.inQuart((t*2)-d, c/2, c/2, d);
			},
			inQuint: function(t, c, d) {
				return c*(t/=d)*t*t*t*t;
			},
			outQuint: function(t, c, d) {
				return c*((t=t/d-1)*t*t*t*t + 1);
			},
			inOutQuint: function(t, c, d) {
				if((t/=d/2) < 1) { return c/2*t*t*t*t*t; }
				return c/2*((t-=2)*t*t*t*t + 2);
			},
			outInQuint: function(t, c, d) {
				if(t < d/2) { return this.outQuint(t*2, c/2, d); }
				return this.inQuint((t*2)-d, c/2, c/2, d);
			},
			inSine: function(t, c, d) {
				return -c * Math.cos(t/d *(Math.PI/2)) + c;
			},
			outSine: function(t, c, d) {
				return c * Math.sin(t/d *(Math.PI/2));
			},
			inOutSine: function(t, c, d) {
				return -c/2 *(Math.cos(Math.PI*t/d) - 1);
			},
			outInSine: function(t, c, d) {
				if(t < d/2) { return this.outSine(t*2, c/2, d); }
				return this.inSine((t*2)-d, c/2, c/2, d);
			},
			inExpo: function(t, c, d) {
				return(t === 0) ? 0 : c * Math.pow(2, 10 *(t/d - 1)) - c * 0.001;
			},
			outExpo: function(t, c, d) {
				return(t === d) ? c : c * 1.001 *(-Math.pow(2, -10 * t/d) + 1);
			},
			inOutExpo: function(t, c, d) {
				if(t === 0) { return 0; }
				if(t === d) { return c; }
				if((t/=d/2) < 1) { return c/2 * Math.pow(2, 10 *(t - 1)) - c * 0.0005; }
				return c/2 * 1.0005 *(-Math.pow(2, -10 * --t) + 2);
			},
			outInExpo: function(t, c, d) {
				if(t < d/2) { return this.outExpo(t*2, c/2, d); }
				return this.inExpo((t*2)-d, c/2, c/2, d);
			},
			inCirc: function(t, c, d) {
				return -c *(Math.sqrt(1 -(t/=d)*t) - 1);
			},
			outCirc: function(t, c, d) {
				return c * Math.sqrt(1 -(t=t/d-1)*t);
			},
			inOutCirc: function(t, c, d) {
				if((t/=d/2) < 1) { return -c/2 *(Math.sqrt(1 - t*t) - 1); }
				return c/2 *(Math.sqrt(1 -(t-=2)*t) + 1);
			},
			outInCirc: function(t, c, d) {
				if(t < d/2) { return this.outCirc(t*2, c/2, d); }
				return this.inCirc((t*2)-d, c/2, c/2, d);
			},
			inElastic: function(t, c, d, a, p) {
				var s;
				if(t===0) {return 0;}
				if((t/=d)===1) { return c; }
				if(!p) { p=d*0.3; }
				if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
				return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p ));
			},
			outElastic: function(t, c, d, a, p) {
				var s;
				if(t===0) { return 0; }
				if((t/=d)===1) { return c; }
				if(!p) { p=d*0.3; }
				if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
				return(a*Math.pow(2,-10*t) * Math.sin((t*d-s)*(2*Math.PI)/p ) + c);
			},
			inOutElastic: function(t, c, d, a, p) {
				var s;
				if(t===0) { return 0; }
				if((t/=d/2)===2) { return c; }
				if(!p) { p=d*(0.3*1.5); }
				if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
				if(t < 1) { return -0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p)); }
				return a*Math.pow(2,-10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p )*0.5 + c;
			},
			outInElastic: function(t, c, d, a, p) {
				if(t < d/2) { return this.outElastic(t*2, c/2, d, a, p); }
				return this.inElastic((t*2)-d, c/2, c/2, d, a, p);
			},
			inBack: function(t, c, d, s) {
				if(s === undefined) { s = 1.70158; }
				return c*(t/=d)*t*((s+1)*t - s);
			},
			outBack: function(t, c, d, s) {
				if(s === undefined) { s = 1.70158; }
				return c*((t=t/d-1)*t*((s+1)*t + s) + 1);
			},
			inOutBack: function(t, c, d, s) {
				if(s === undefined) { s = 1.70158; }
				if((t/=d/2) < 1) { return c/2*(t*t*(((s*=(1.525))+1)*t - s)); }
				return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
			},
			outInBack: function(t, c, d, s) {
				if(t < d/2) { return this.outBack(t*2, c/2, d, s); }
				return this.inBack((t*2)-d, c/2, c/2, d, s);
			},
			inBounce: function(t, c, d) {
				return c - this.outBounce(d-t, 0, c, d);
			},
			outBounce: function(t, c, d) {
				if((t/=d) <(1/2.75)) {
					return c*(7.5625*t*t);
				} else if(t <(2/2.75)) {
					return c*(7.5625*(t-=(1.5/2.75))*t + 0.75);
				} else if(t <(2.5/2.75)) {
					return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375);
				} else {
					return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375);
				}
			},
			inOutBounce: function(t, c, d) {
				if(t < d/2) {
					return this.inBounce(t*2, 0, c, d) * 0.5;
				} else {
					return this.outBounce(t*2-d, 0, c, d) * 0.5 + c*0.5;
				}
			},
			outInBounce: function(t, c, d) {
				if(t < d/2) { return this.outBounce(t*2, c/2, d); }
				return this.inBounce((t*2)-d, c/2, c/2, d);
			}
		}
	});
	
	return IgeTweenComponent;
});
},{"irrelon-appcore":125}],15:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiManagerComponent', function ($ige, IgeClass) {
	var IgeUiManagerComponent = IgeClass.extend({
		classId: 'IgeUiManagerComponent',
		componentId: 'ui',
		
		init: function (entity, options) {
			var self = this;
			
			this._entity = entity;
			this._options = options;
			
			this._focus = null; // The element that currently has focus
			this._caret = null; // The caret position within the focused element
			this._register = [];
			this._styles = {};
			this._elementsByStyle = {};
			
			$ige.engine.input.on('keyDown', function (event) { self._keyDown(event); });
		},
		
		/**
		 * Get / set a style by name.
		 * @param {String} name The unique name of the style.
		 * @param {Object=} data The style properties and values to assign to the
		 * style.
		 * @returns {*}
		 */
		style: function (name, data) {
			if (name !== undefined) {
				if (data !== undefined) {
					// Set the data against the name, update any elements using the style
					this._styles[name] = data;
					return this;
				}
				
				// Get the data and return
				return this._styles[name];
			}
			
			return this;
		},
		
		/**
		 * Registers a UI element with the UI manager.
		 * @param elem
		 */
		registerElement: function (elem) {
			this._register.push(elem);
		},
		
		/**
		 * Un-registers a UI element with the UI manager.
		 * @param elem
		 */
		unRegisterElement: function (elem) {
			this._register.pull(elem);
			
			// Kill any styles defined for this element id
			delete this._styles['#' + elem._id];
			
			delete this._styles['#' + elem._id + ':active'];
			delete this._styles['#' + elem._id + ':focus'];
			delete this._styles['#' + elem._id + ':hover'];
		},
		
		/**
		 * Registers a UI element against a style for quick lookup.
		 * @param elem
		 */
		registerElementStyle: function (elem) {
			if (elem && elem._styleClass) {
				this._elementsByStyle[elem._styleClass] = this._elementsByStyle[elem._styleClass] || [];
				this._elementsByStyle[elem._styleClass].push(elem);
			}
		},
		
		/**
		 * Un-registers a UI element from a style.
		 * @param elem
		 */
		unRegisterElementStyle: function (elem) {
			if (elem && elem._styleClass) {
				this._elementsByStyle[elem._styleClass] = this._elementsByStyle[elem._styleClass] || [];
				this._elementsByStyle[elem._styleClass].push(elem);
			}
		},
		
		canFocus: function (elem) {
			return elem._allowFocus;
		},
		
		focus: function (elem) {
			if (elem !== undefined) {
				if (elem !== this._focus) {
					// The element is not our current focus so focus to it
					var previousFocus = this._focus;
					
					// Tell the current focused element that it is about to loose focus
					if (!previousFocus || !previousFocus.emit('blur', elem)) {
						if (previousFocus) {
							previousFocus._focused = false;
							previousFocus.blur();
						}
						
						// The blur was not cancelled
						if (!elem.emit('focus', previousFocus)) {
							// The focus was not cancelled
							this._focus = elem;
							elem._focused = true;
							
							return true;
						}
					}
				} else {
					// We are already focused
					return true;
				}
			}
			
			return false;
		},
		
		blur: function (elem) {
			//console.log('blur', elem._id, elem);
			if (elem !== undefined) {
				if (elem === this._focus) {
					// The element is currently focused
					// Tell the current focused element that it is about to loose focus
					if (!elem.emit('blur')) {
						// The blur was not cancelled
						this._focus = null;
						elem._focused = false;
						elem._updateStyle();
						
						return true;
					}
				}
			}
			
			return false;
		},
		
		_keyUp: function (event) {
			// Direct the key event to the focused element
			if (this._focus) {
				this._focus.emit('keyUp', event);
				$ige.engine.input.stopPropagation();
			}
		},
		
		_keyDown: function (event) {
			// Direct the key event to the focused element
			if (this._focus) {
				this._focus.emit('keyDown', event);
				$ige.engine.input.stopPropagation();
			}
		}
	});
	
	return IgeUiManagerComponent;
});
},{"irrelon-appcore":125}],16:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeVelocityComponent', function ($ige, $time, IgeClass, IgePoint3d) {
	// TODO: Doc this class!
	var IgeVelocityComponent = IgeClass.extend({
		classId: 'IgeVelocityComponent',
		componentId: 'velocity',
		
		init: function (entity, options) {
			this._entity = entity;
			
			this._velocity = new IgePoint3d(0, 0, 0);
			this._friction = new IgePoint3d(1, 1, 1);
			
			// Add the velocity behaviour to the entity
			entity.addBehaviour('velocity', this._behaviour);
		},
		
		/**
		 * The behaviour method executed each tick.
		 * @param ctx
		 * @private
		 */
		_behaviour: function (ctx) {
			this.velocity.tick(ctx);
		},
		
		byAngleAndPower: function (radians, power, relative) {
			var vel = this._velocity,
				x = Math.cos(radians) * power,
				y = Math.sin(radians) * power,
				z = 0;
			
			if (!relative) {
				vel.x = x;
				vel.y = y;
				vel.z = z;
			} else {
				vel.x += x;
				vel.y += y;
				vel.z += z;
			}
			
			return this._entity;
		},
		
		xyz: function (x, y, z, relative) {
			var vel = this._velocity;
			
			if (!relative) {
				vel.x = x;
				vel.y = y;
				vel.z = z;
			} else {
				vel.x += x;
				vel.y += y;
				vel.z += z;
			}
			
			return this._entity;
		},
		
		x: function (x, relative) {
			var vel = this._velocity;
			
			if (!relative) {
				vel.x = x;
			} else {
				vel.x += x;
			}
			
			return this._entity;
		},
		
		y: function (y, relative) {
			var vel = this._velocity;
			
			if (!relative) {
				vel.y = y;
			} else {
				vel.y += y;
			}
			
			return this._entity;
		},
		
		z: function (z, relative) {
			var vel = this._velocity;
			
			if (!relative) {
				vel.z = y;
			} else {
				vel.z += z;
			}
			
			return this._entity;
		},
		
		vector3: function (vector, relative) {
			if (typeof(vector.scale) !== 'number') {
				vector.scale = 1; // Default to 1
			}
			
			var vel = this._velocity,
				x = vector.x,
				y = vector.y,
				z = vector.z;
			
			if (!relative) {
				vel.x = x;
				vel.y = y;
				vel.z = z;
			} else {
				vel.x += x;
				vel.y += y;
				vel.z += z;
			}
			
			return this._entity;
		},
		
		friction: function (val) {
			var finalFriction = 1 - val;
			
			if (finalFriction < 0) {
				finalFriction = 0;
			}
			
			this._friction = new IgePoint3d(finalFriction, finalFriction, finalFriction);
			
			return this._entity;
		},
		
		linearForce: function (degrees, power) {
			power /= 1000;
			var radians = (degrees * Math.PI / 180),
				x = Math.cos(radians) * power,
				y = Math.sin(radians) * power,
				z = x * y;
			this._linearForce = new IgePoint3d(x, y, z);
			
			return this._entity;
		},
		
		linearForceXYZ: function (x, y, z) {
			this._linearForce = new IgePoint3d(x, y, z);
			return this._entity;
		},
		
		linearForceVector3: function (vector, power, relative) {
			var force = this._linearForce = this._linearForce || new IgePoint3d(0, 0, 0),
				x = vector.x / 1000,
				y = vector.y / 1000,
				z = vector.z / 1000;
			
			if (!relative) {
				force.x = x || 0;
				force.y = y || 0;
				force.z = z || 0;
			} else {
				force.x += x || 0;
				force.y += y || 0;
				force.z += z || 0;
			}
			
			return this._entity;
		},
		
		_applyLinearForce: function (delta) {
			if (this._linearForce) {
				var vel = this._velocity;
				
				vel.x += (this._linearForce.x * delta);
				vel.y += (this._linearForce.y * delta);
				vel.z += (this._linearForce.z * delta);
			}
		},
		
		_applyFriction: function () {
			var vel = this._velocity,
				fric = this._friction;
			
			vel.x *= fric.x;
			vel.y *= fric.y;
			vel.z *= fric.z;
		},
		
		tick: function (ctx) {
			var delta = $time._tickDelta,
				vel = this._velocity,
				x, y, z;
			
			if (delta) {
				this._applyLinearForce(delta);
				//this._applyFriction();
				
				x = vel.x * delta;
				y = vel.y * delta;
				z = vel.z * delta;
				
				if (x || y || z) {
					this._entity.translateBy(x, y, z);
				}
			}
		}
	});
	
	return IgeVelocityComponent;
});
},{"irrelon-appcore":125}],17:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeAudio', function ($ige, IgeEventingClass) {
	var IgeAudio = IgeEventingClass.extend({
		classId: 'IgeAudio',
		
		init: function (url) {
			if (url) {
				this.load(url);
			}
		},
		
		/**
		 * Gets / sets the current object id. If no id is currently assigned and no
		 * id is passed to the method, it will automatically generate and assign a
		 * new id as a 16 character hexadecimal value typed as a string.
		 * @param {String=} id The id to set to.
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		id: function (id) {
			if (id !== undefined) {
				// Check if this ID already exists in the object register
				if ($ige.engine._register[id]) {
					if ($ige.engine._register[id] === this) {
						// We are already registered as this id
						return this;
					}
					
					// Already an object with this ID!
					this.log('Cannot set ID of object to "' + id + '" because that ID is already in use by another object!', 'error');
				} else {
					// Check if we already have an id assigned
					if (this._id && $ige.engine._register[this._id]) {
						// Unregister the old ID before setting this new one
						$ige.engine.unRegister(this);
					}
					
					this._id = id;
					
					// Now register this object with the object register
					$ige.engine.register(this);
					
					return this;
				}
			}
			
			if (!this._id) {
				// The item has no id so generate one automatically
				if (this._url) {
					// Generate an ID from the URL string of the audio file
					// this instance is using. Useful for always reproducing
					// the same ID for the same file :)
					this._id = $ige.engine.newIdFromString(this._url);
				} else {
					// We don't have a URL so generate a random ID
					this._id = $ige.engine.newIdHex();
				}
				$ige.engine.register(this);
			}
			
			return this._id;
		},
		
		/**
		 * Loads an audio file from the given url.
		 * @param {String} url The url to load the audio file from.
		 * @param {Function=} callback Optional callback method to call when the audio
		 * file has loaded or on error.
		 */
		load: function (url, callback) {
			var self = this,
				request = new XMLHttpRequest();
			
			request.open('GET', url, true);
			request.responseType = 'arraybuffer';
			
			// Decode asynchronously
			request.onload = function() {
				self._data = request.response;
				self._url = url;
				self._loaded(callback);
			};
			
			request.onerror = function (err) {
				callback.apply(self, [err]);
			};
			
			request.send();
		},
		
		_loaded: function (callback) {
			var self = this;
			
			$ige.engine.audio.decode(self._data, function(err, buffer) {
				if (!err) {
					self._buffer = buffer;
					$ige.engine.audio.log('Audio file (' + self._url + ') loaded successfully');
					
					if (callback) { callback.apply(self, [false]); }
				} else {
					self.log('Failed to decode audio data from: ' + self._url, 'warning');
					if (callback) { callback.apply(self, [err]); }
				}
			});
		},
		
		/**
		 * Plays the audio.
		 */
		play: function () {
			var self = this,
				bufferSource;
			
			if (self._buffer) {
				bufferSource = $ige.engine.audio._ctx.createBufferSource();
				bufferSource.buffer = self._buffer;
				bufferSource.connect($ige.engine.audio._ctx.destination);
				bufferSource.start(0);
			}
		}
	});
	
	return IgeAudio;
});
},{"irrelon-appcore":125}],18:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeAudioComponent', function ($ige, IgeEventingClass, IgeAudio) {
	/**
	 * Manages audio mixing and output.
	 */
	var IgeAudioComponent = IgeEventingClass.extend({
		classId: 'IgeAudioComponent',
		componentId: 'audio',
		
		init: function (entity, options) {
			this._active = false;
			this._disabled = false;
			this._ctx = this.getContext();
			
			if (!this._ctx) {
				this.log('No web audio API support, cannot play sounds!', 'warning');
				this._disabled = true;
				return;
			}
			
			this.log('Web audio API connected successfully');
		},
		
		/**
		 * Gets / sets the active flag to enable or disable audio support.
		 * @param {Boolean=} val True to enable audio support.
		 * @returns {*}
		 */
		active: function (val) {
			if (val !== undefined && !this._disabled) {
				this._active = val;
				return this;
			}
			
			return this._active;
		},
		
		/**
		 * Returns an audio context.
		 * @returns {*}
		 */
		getContext: function () {
			var ctxProto = window.AudioContext || window.webkitAudioContext;
			
			if (ctxProto) {
				return new ctxProto();
			} else {
				return undefined;
			}
		},
		
		/**
		 * Loads an audio file from the given url and assigns it the id specified.
		 * @param {String} url The url to load the audio from.
		 * @param {String=} id The id to assign the audio.
		 */
		load: function (url, id) {
			var audio = new IgeAudio(url);
			
			if (id) {
				audio.id(id);
			}
		},
		
		/**
		 * Decodes audio data and calls back with an audio buffer.
		 * @param {ArrayBuffer} data The audio data to decode.
		 * @param {Function} callback The callback to pass the buffer to.
		 */
		decode: function (data, callback) {
			this._ctx.decodeAudioData(data, function (buffer) {
				callback(false, buffer);
			}, function (err) {
				callback(err);
			});
		},
		
		/**
		 * Plays audio by its assigned id.
		 * @param {String} id The id of the audio file to play.
		 */
		play: function (id) {
			var audio = $ige.engine.$(id);
			if (audio) {
				if (audio.prototype.play) {
					audio.play();
				} else {
					this.log('Trying to play audio with id "" but object with this id is not an IgeAudio instance, or does not implement the .play() method!', 'warnign');
				}
			}
		}
	});
	
	return IgeAudioComponent;
});
},{"irrelon-appcore":125}],19:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeChatClient', function ($ige) {
	/**
	 * The client-side chat component. Handles all client-side
	 * chat methods and events.
	 */
	var IgeChatClient = {
		/**
		 * Asks the serve to let us join the room specified.
		 * @param {String} roomId The room id of the room to join.
		 */
		joinRoom: function (roomId) {
			$ige.engine.network.send('igeChatJoinRoom', roomId);
		},
		
		sendToRoom: function (roomId, message, to) {
			var msg;
			
			if (roomId !== undefined && message !== undefined) {
				msg = {
					roomId: roomId,
					text: message,
					to: to
				};
				
				$ige.engine.network.send('igeChatMsg', msg);
			}
		},
		
		_onMessageFromServer: function (data) {
			var self = $ige.engine.chat;
			
			// Emit the event and if it wasn't cancelled (by returning true) then
			// process this ourselves
			if (!self.emit('messageFromServer', [data])) {
				console.log('Server sent us a message in the room "' + data.roomId + '" from the user id "' + data.from + '":', data.text);
			}
		},
		
		_onJoinedRoom: function (data) {
			var self = $ige.engine.chat;
			
			// Emit the event and if it wasn't cancelled (by returning true) then
			// process this ourselves
			if (!self.emit('joinedRoom', [data])) {
				if (data.joined === true) {
					console.log('Server says we have joined room:', data.roomId);
				} else {
					console.log('Server says we failed to join room:', data.roomId);
				}
			}
		},
		
		_onLeftRoom: function (data) {
			var self = $ige.engine.chat;
			
			// Emit the event and if it wasn't cancelled (by returning true) then
			// process this ourselves
			if (!self.emit('leftRoom', [data])) {
				console.log('We have left room:', data);
			}
		},
		
		_onServerSentRoomList: function (data) {
			var self = $ige.engine.chat;
			
			// Emit the event and if it wasn't cancelled (by returning true) then
			// process this ourselves
			if (!self.emit('roomList', [data])) {
				console.log('Server sent room list:', data);
			}
		},
		
		_onServerSentRoomUserList: function (data) {
			var self = $ige.engine.chat;
			
			// Emit the event and if it wasn't cancelled (by returning true) then
			// process this ourselves
			if (!self.emit('roomUserList', [data])) {
				console.log('Server sent room user list:', data);
			}
		},
		
		_onRoomCreated: function (data) {
			var self = $ige.engine.chat;
			
			// Emit the event and if it wasn't cancelled (by returning true) then
			// process this ourselves
			if (!self.emit('roomCreated', [data])) {
				console.log('Server told us room was created:', data);
			}
		},
		
		_onRoomRemoved: function (data) {
			var self = $ige.engine.chat;
			
			// Emit the event and if it wasn't cancelled (by returning true) then
			// process this ourselves
			if (!self.emit('roomRemoved', [data])) {
				console.log('Server told us room was removed:', data);
			}
		}
	};
	
	return IgeChatClient;
});
},{"irrelon-appcore":125}],20:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeChatComponent', function ($ige, IgeEventingClass) {
	var IgeChatComponent = IgeEventingClass.extend({
		classId: 'IgeChatComponent',
		componentId: 'chat',
		
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			this._rooms = {};
			
			/* CEXCLUDE */
			if ($ige.isServer) {
				this.implement(IgeChatServer);
				
				// Define the chat system network commands
				this._entity
					.network.define('igeChatMsg', this._onMessageFromClient)
					.network.define('igeChatJoinRoom', this._onJoinRoomRequestFromClient)
					.network.define('igeChatLeaveRoom', this._onLeaveRoomRequestFromClient)
					.network.define('igeChatRoomList', this._onClientWantsRoomList)
					.network.define('igeChatRoomUserList', this._onClientWantsRoomUserList)
					.network.define('igeChatRoomCreated')
					.network.define('igeChatRoomRemoved');
			}
			/* CEXCLUDE */
			
			if ($ige.isClient) {
				this.implement(IgeChatClient);
				
				// Define the chat system network command listeners
				this._entity
					.network.define('igeChatMsg', this._onMessageFromServer)
					.network.define('igeChatJoinRoom', this._onJoinedRoom)
					.network.define('igeChatLeaveRoom', this._onLeftRoom)
					.network.define('igeChatRoomList', this._onServerSentRoomList)
					.network.define('igeChatRoomUserList', this._onServerSentRoomUserList)
					.network.define('igeChatRoomCreated', this._onRoomCreated)
					.network.define('igeChatRoomRemoved', this._onRoomRemoved);
			}
			
			this.log('Chat component initiated!');
		}
	});
	
	return IgeChatComponent;
});
},{"irrelon-appcore":125}],21:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeCocoonJsComponent', function (IgeEventingClass) {
	var IgeCocoonJsComponent = IgeEventingClass.extend({
		classId: 'IgeCocoonJsComponent',
		componentId: 'cocoonJs',
		
		init: function () {
			this.detected = typeof(ext) !== 'undefined' && typeof(ext.IDTK_APP) !== 'undefined';
			
			if (this.detected) {
				this.log('CocoonJS support enabled!');
			}
		},
		
		// TODO: Finish keyboard implementation
		showInputDialog: function(title, message, initialValue, type, cancelText, okText) {
			if (this.detected) {
				title = title || '';
				message = message || '';
				initialValue = initialValue || '';
				type = type || 'text';
				cancelText = cancelText || 'Cancel';
				okText = okText || 'OK';
				
				ext.IDTK_APP.makeCall(
					'showTextDialog',
					title,
					message,
					initialValue,
					type,
					cancelText,
					okText
				);
			} else {
				this.log('Cannot open CocoonJS input dialog! CocoonJS is not detected!', 'error');
			}
		},
		
		/**
		 * Asks the API to load the url and show the web view.
		 * @param url
		 */
		showWebView: function (url) {
			if (this.detected) {
				// Forward a JS call to the webview IDTK API
				ext.IDTK_APP.makeCall("forward", "ext.IDTK_APP.makeCall('loadPath', '" + url + "')");
				ext.IDTK_APP.makeCall("forward", "ext.IDTK_APP.makeCall('show');");
			}
		},
		
		/**
		 * Asks the API to hide the web view.
		 */
		hideWebView: function () {
			if (this.detected) {
				// Forward a JS call to the webview IDTK API
				ext.IDTK_APP.makeCall("forward", "ext.IDTK_APP.makeCall('hide');");
			}
		}
	});
	
	return IgeCocoonJsComponent;
});
},{"irrelon-appcore":125}],22:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEditorComponent', function ($ige, $time, IgeEventingClass, IgeEditorTranslateComponent, IgeEditorRotateComponent) {
	/**
	 * The IGE interactive editor component. Allows modification of a simulation
	 * in realtime via a GUI.
	 */
	var IgeEditorComponent = IgeEventingClass.extend({
		classId: 'IgeEditorComponent',
		componentId: 'editor',
		
		/**
		 * @constructor
		 * @param {IgeObject} entity The object that the component is added to.
		 * @param {Object=} options The options object that was passed to the
		 * component during the call to addComponent.
		 */
		init: function (entity, options) {
			var self = this;
			
			this._entity = entity;
			this._options = options;
			this._showStats = 0;
			
			this._templateCache = {};
			this._cacheTemplates = true;
			
			this.ui = {};
			
			this._interceptMouse = false;
			
			// Hook the input component's keyUp and check for the = symbol... if there, toggle editor
			this._activateKeyHandle = $ige.engine.input.on('keyUp', function (event) {
				if (event.keyIdentifier === "U+00BB") {
					// = key pressed, toggle the editor
					self.toggle();
					
					// Return true to stop this event from being emitted by the engine to the scenegraph
					return true;
				}
			});
			
			// Hook the input component's keyUp and check for the - symbol... if there, toggle stats
			this._activateKeyHandle = $ige.engine.input.on('keyUp', function (event) {
				if (event.keyIdentifier === "U+00BD") {
					// Toggle the stats
					self.toggleStats();
					
					// Return true to stop this event from being emitted by the engine to the scenegraph
					return true;
				}
			});
			
			// Hook the engine's input system and take over mouse interaction
			this._mouseUpHandle = $ige.engine.input.on('preMouseUp', function (event) {
				if (self._enabled && self._interceptMouse) {
					self.emit('mouseUp', event);
					
					// Return true to stop this event from being emitted by the engine to the scenegraph
					return true;
				}
			});
			
			this._mouseDownHandle = $ige.engine.input.on('preMouseDown', function (event) {
				if (self._enabled && self._interceptMouse) {
					self.emit('mouseDown', event);
					
					// Return true to stop this event from being emitted by the engine to the scenegraph
					return true;
				}
			});
			
			this._mouseMoveHandle = $ige.engine.input.on('preMouseMove', function (event) {
				if (self._enabled && self._interceptMouse) {
					self.emit('mouseMove', event);
					
					// Return true to stop this event from being emitted by the engine to the scenegraph
					return true;
				}
			});
			
			this._contextMenuHandle = $ige.engine.input.on('preContextMenu', function (event) {
				if (self._enabled && self._interceptMouse) {
					self.emit('contextMenu', event);
					
					// Return true to stop this event from being emitted by the engine to the scenegraph
					return true;
				}
			});
			
			// Load jsRender for HTML template support
			$ige.engine.requireScript(igeRoot + 'components/editor/vendor/jsRender.js');
			
			// Load jQuery, the editor will use it for DOM manipulation simplicity
			$ige.engine.requireScript(igeRoot + 'components/editor/vendor/jquery.2.0.3.min.js');
			
			$ige.engine.on('allRequireScriptsLoaded', function () {
				// Stop drag-drop of files over the page from doing a redirect and leaving the page
				$(function () {
					$('body')
						.on('dragover', function (e) {
							e.preventDefault();
						})
						.on('drop', function (e) {
							e.preventDefault();
						});
				});
				
				// Load editor html into the DOM
				self.loadHtml(igeRoot + 'components/editor/root.html', function (html) {
					// Add the html
					$('body').append($(html));
					
					$ige.engine.requireScript(igeRoot + 'components/editor/vendor/jsrender-helpers.js');
					
					// Object mutation observer polyfill
					$ige.engine.requireScript(igeRoot + 'components/editor/vendor/observe.js');
					
					// Load plugin styles
					$ige.engine.requireStylesheet(igeRoot + 'components/editor/vendor/glyphicons/css/halflings.css');
					$ige.engine.requireStylesheet(igeRoot + 'components/editor/vendor/glyphicons/css/glyphicons.css');
					$ige.engine.requireStylesheet(igeRoot + 'components/editor/vendor/treeview_simple/css/style.css');
					
					// Load the editor stylesheet
					$ige.engine.requireStylesheet(igeRoot + 'components/editor/css/editor.css');
					
					// Listen for scenegraph tree selection updates
					$ige.engine.on('sgTreeSelectionChanged', function (objectId) {
						self._objectSelected($ige.engine.$(objectId));
					});
					
					// Wait for all required files to finish loading
					$ige.engine.on('allRequireScriptsLoaded', function () {
						// Load UI scripts
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/ui/dialogs/dialogs.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/ui/scenegraph/scenegraph.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/ui/menu/menu.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/ui/toolbox/toolbox.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/ui/panels/panels.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/ui/textures/textures.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/ui/textureEditor/textureEditor.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/ui/animationEditor/animationEditor.js');
						
						// Load jquery plugins
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/vendor/autoback.jquery.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/vendor/tree/tree.jquery.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/vendor/tabs/tabs.jquery.js');
						$ige.engine.sync($ige.engine.requireScript, igeRoot + 'components/editor/vendor/treeview_simple/treeview_simple.jquery.js');
						
						$ige.engine.on('syncComplete', function () {
							// Observe changes to the engine to update our display
							setInterval(function () {
								// Update the stats counters
								$('#editorFps').html($time._fps + ' fps');
								$('#editorDps').html($time._dps + ' dps');
								$('#editorDpf').html($time._dpf + ' dpf');
								$('#editorUd').html($time._updateTime + ' ud/ms');
								$('#editorRd').html($time._renderTime + ' rd/ms');
								$('#editorTd').html($time._tickTime + ' td/ms');
							}, 1000);
							
							// Add auto-backing
							$('.backed').autoback();
							
							// Call finished on all ui instances
							for (var i in self.ui) {
								if (self.ui.hasOwnProperty(i)) {
									if (self.ui[i].ready) {
										self.ui[i].ready();
									}
								}
							}
							
							// Enable tabs
							$('.tabGroup').tabs();
							
							// Enable the stats toggle button
							$('#statsToggle').on('click', function () {
								$ige.engine.editor.toggleStats();
							});
							
							// Enable the editor toggle button
							$('#editorToggle').on('click', function () {
								$ige.engine.editor.toggle();
							});
							
							self._ready = true;
							self.emit('ready');
						}, null, true);
					}, null, true);
				});
			}, null, true);
			
			// Set the component to inactive to start with
			this._enabled = false;
			this._show = false;
			
			// Set object create defaults
			this.objectDefault = {
				'IgeTextureMap': {
					drawGrid: 100
				}
			};
			
			this.log('Init complete');
		},
		
		ready: function (callback) {
			if (callback) {
				if (this._ready) {
					return callback();
				}
				
				this.on('ready', callback);
			}
			
			return this._ready;
		},
		
		interceptMouse: function (val) {
			this._interceptMouse = val;
		},
		
		/**
		 * Gets / sets the enabled flag. If set to true,
		 * operations will be processed. If false, no operations will
		 * occur.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		enabled: function (val) {
			var self = this;
			
			if (val !== undefined) {
				this._enabled = val;
				return this._entity;
			}
			
			return this._enabled;
		},
		
		toggle: function () {
			var elem = $('#editorToggle');
			
			if (elem.hasClass('active')) {
				$ige.engine.editor.hide();
			} else {
				$ige.engine.editor.show();
			}
		},
		
		show: function () {
			this.enabled(true);
			this._show = true;
			
			$('#editorToggle')
				.html('Editor On')
				.removeClass('active')
				.addClass('active');
			
			$('.editorElem.toggleHide').addClass('shown');
		},
		
		hide: function () {
			this.enabled(false);
			this._show = false;
			
			$('#editorToggle')
				.html('Editor Off')
				.removeClass('active');
			
			$('.editorElem.toggleHide').removeClass('shown');
		},
		
		toggleStats: function () {
			this.ready(function () {
				var elem = $('#statsToggle');
				
				if (elem.hasClass('active')) {
					$ige.engine.editor.hideStats();
				} else {
					$ige.engine.editor.showStats();
				}
			});
		},
		
		showStats: function () {
			this.ready(function () {
				$('#statsToggle')
					.html('Stats On')
					.removeClass('active')
					.addClass('active');
				
				$('.counter').show();
			});
		},
		
		hideStats: function () {
			this.ready(function () {
				$('#statsToggle')
					.html('Stats Off')
					.removeClass('active');
				
				$('.counter').hide();
			});
		},
		
		loadHtml: function (url, callback) {
			$.ajax({
				url: url,
				success: callback,
				dataType: 'html'
			});
		},
		
		template: function (url, callback) {
			var self = this;
			
			if (!this._cacheTemplates || !this._templateCache[url]) {
				this.log('Loading template data from: ' + url);
				$.ajax(url, {
					async: true,
					dataType: 'text',
					complete: function (xhr, status) {
						if (status === 'success') {
							// Convert the text into a jsRender template object
							var template = jsviews.templates(xhr.responseText);
							
							if (self._cacheTemplates) {
								self._templateCache[url] = template;
							}
							
							if (callback) { callback(false, template); }
						} else {
							if (callback) { callback(true, status); }
						}
					}
				});
			} else {
				if (callback) { callback(false, this._templateCache[url]); }
			}
		},
		
		renderTemplate: function (url, data, callback) {
			this.template(url, function (err, template) {
				if (!err) {
					callback(err, $($.parseHTML(template.render(data))));
				} else {
					callback(err);
				}
			});
		},
		
		selectObject: function (id) {
			if (id !== undefined) {
				if (id) {
					this._selectedObject = $ige.engine.$(id);
					this._objectSelected(this._selectedObject);
				} else {
					delete this._selectedObject;
				}
			}
		},
		
		_objectSelected: function (obj) {
			if (obj) {
				$ige.engine.editor.ui.panels.showPanelByInstance(obj);
				this._selectedObjectClassList = $ige.engine.getClassDerivedList(obj);
				
				// Update active-for selectors
				$('[data-active-for]')
					.removeClass('disabled')
					.addClass('disabled');
				
				var classArr = this._selectedObjectClassList,
					i;
				
				for (i = 0; i < classArr.length; i++) {
					$('[data-active-for~="' + classArr[i] + '"]')
						.removeClass('disabled');
				}
				
				this.emit('selectedObject', obj.id());
			}
		},
		
		destroySelected: function () {
			if (this._selectedObject) {
				this._selectedObject.destroy();
				this.selectObject(null);
			}
		},
		
		createObject: function (classId, select) {
			if (this._selectedObject) {
				var newObj = $ige.engine.newClassInstance(classId);
				newObj.mount(this._selectedObject);
				this.ui.scenegraph.updateSceneGraph();
				
				if (select) {
					this.selectObject(newObj.id());
					this.ui.toolbox.select('toolSelect');
				}
				
				// Set some object defaults if there are any
				if (this.objectDefault[classId]) {
					for (var i in this.objectDefault[classId]) {
						if (this.objectDefault[classId].hasOwnProperty(i)) {
							if (this.objectDefault[classId][i] instanceof Array) {
								newObj[i].apply(newObj, this.objectDefault[classId][i]);
							} else {
								newObj[i].call(newObj, this.objectDefault[classId][i]);
							}
						}
					}
				}
			}
		},
		
		/**
		 * Updates the stats HTML overlay with the latest data.
		 * @private
		 */
		_statsTick: function () {
			var self = $ige.engine.editor,
				i,
				watchCount,
				watchItem,
				itemName,
				res,
				html = '';
			
			// Check if the stats output is enabled
			if (self._showStats && !self._statsPauseUpdate) {
				switch (self._showStats) {
					case 1:
						/*if (self._watch && self._watch.length) {
						 watchCount = self._watch.length;
						 
						 for (i = 0; i < watchCount; i++) {
						 watchItem = self._watch[i];
						 
						 if (typeof(watchItem) === 'string') {
						 itemName = watchItem;
						 try {
						 eval('res = ' + watchItem);
						 } catch (err) {
						 res = '<span style="color:#ff0000;">' + err + '</span>';
						 }
						 } else {
						 itemName = watchItem.name;
						 res = watchItem.value;
						 }
						 html += i + ' (<a href="javascript:$ige.engine.watchStop(' + i + '); $ige.engine._statsPauseUpdate = false;" style="color:#cccccc;" onmouseover="$ige.engine._statsPauseUpdate = true;" onmouseout="$ige.engine._statsPauseUpdate = false;">Remove</a>): <span style="color:#7aff80">' + itemName + '</span>: <span style="color:#00c6ff">' + res + '</span><br />';
						 }
						 html += '<br />';
						 }*/
						/*html += '<div class="sgButton" title="Show / Hide SceneGraph Tree" onmouseup="$ige.engine.toggleShowEditor();">Scene</div> <span class="met" title="Frames Per Second">' + self._fps + ' fps</span> <span class="met" title="Draws Per Second">' + self._dps + ' dps</span> <span class="met" title="Draws Per Frame">' + self._dpf + ' dpt</span> <span class="met" title="Update Delta (How Long the Last Update Took)">' + self._updateTime + ' ms\/ud</span> <span class="met" title="Render Delta (How Long the Last Render Took)">' + self._renderTime + ' ms\/rd</span> <span class="met" title="Tick Delta (How Long the Last Tick Took)">' + self._tickTime + ' ms\/pt</span>';
						 
						 if (self.network) {
						 // Add the network latency too
						 html += ' <span class="met" title="Network Latency (Time From Server to This Client)">' + self.network._latency + ' ms\/net</span>';
						 }
						 
						 self._statsDiv.innerHTML = html;*/
						
						
						break;
				}
			}
		},
		
		addToSgTree: function (item) {
			var elem = document.createElement('li'),
				arr,
				arrCount,
				i,
				mouseUp,
				dblClick,
				timingString;
			
			mouseUp = function (event) {
				event.stopPropagation();
				
				var elems = document.getElementsByClassName('sgItem selected');
				for (i = 0; i < elems.length; i++) {
					elems[i].className = 'sgItem';
				}
				
				this.className += ' selected';
				$ige.engine._sgTreeSelected = this.id;
				
				$ige._currentViewport.drawBounds(true);
				if (this.id !== 'ige') {
					$ige._currentViewport.drawBoundsLimitId(this.id);
				} else {
					$ige._currentViewport.drawBoundsLimitId('');
				}
				
				$ige.engine.emit('sgTreeSelectionChanged', $ige.engine._sgTreeSelected);
			};
			
			dblClick = function (event) {
				event.stopPropagation();
			};
			
			//elem.addEventListener('mouseover', mouseOver, false);
			//elem.addEventListener('mouseout', mouseOut, false);
			elem.addEventListener('mouseup', mouseUp, false);
			elem.addEventListener('dblclick', dblClick, false);
			
			elem.id = item.id;
			elem.innerHTML = item.text;
			elem.className = 'sgItem';
			
			if ($ige.engine._sgTreeSelected === item.id) {
				elem.className += ' selected';
			}
			
			if (igeConfig.debug._timing) {
				if ($ige.engine._timeSpentInTick[item.id]) {
					timingString = '<span>' + $ige.engine._timeSpentInTick[item.id] + 'ms</span>';
					/*if ($ige.engine._timeSpentLastTick[item.id]) {
					 if (typeof($ige.engine._timeSpentLastTick[item.id].ms) === 'number') {
					 timingString += ' | LastTick: ' + $ige.engine._timeSpentLastTick[item.id].ms;
					 }
					 }*/
					
					elem.innerHTML += ' ' + timingString;
				}
			}
			
			document.getElementById(item.parentId + '_items').appendChild(elem);
			
			if (item.items) {
				// Create a ul inside the li
				elem = document.createElement('ul');
				elem.id = item.id + '_items';
				document.getElementById(item.id).appendChild(elem);
				
				arr = item.items;
				arrCount = arr.length;
				
				for (i = 0; i < arrCount; i++) {
					$ige.engine.addToSgTree(arr[i]);
				}
			}
		},
		
		toggleShowEditor: function () {
			this._showSgTree = !this._showSgTree;
			
			if (this._showSgTree) {
				// Create the scenegraph tree
				var self = this,
					elem1 = document.createElement('div'),
					elem2,
					canvasBoundingRect;
				
				canvasBoundingRect = $ige.engine._canvasPosition();
				
				elem1.id = 'igeSgTree';
				elem1.style.top = (parseInt(canvasBoundingRect.top) + 5) + 'px';
				elem1.style.left = (parseInt(canvasBoundingRect.left) + 5) + 'px';
				elem1.style.height = ($ige.engine._bounds2d.y - 30) + 'px';
				elem1.style.overflow = 'auto';
				elem1.addEventListener('mousemove', function (event) {
					event.stopPropagation();
				});
				elem1.addEventListener('mouseup', function (event) {
					event.stopPropagation();
				});
				elem1.addEventListener('mousedown', function (event) {
					event.stopPropagation();
				});
				
				elem2 = document.createElement('ul');
				elem2.id = 'sceneGraph_items';
				elem1.appendChild(elem2);
				
				document.body.appendChild(elem1);
				
				// Create the IGE console
				var consoleHolderElem = document.createElement('div'),
					consoleElem = document.createElement('input'),
					classChainElem = document.createElement('div'),
					dociFrame = document.createElement('iframe');
				
				consoleHolderElem.id = 'igeSgConsoleHolder';
				consoleHolderElem.innerHTML = '<div><b>Console</b>: Double-Click a SceneGraph Object to Script it Here</div>';
				
				consoleElem.type = 'text';
				consoleElem.id = 'igeSgConsole';
				
				classChainElem.id = 'igeSgItemClassChain';
				
				dociFrame.id = 'igeSgDocPage';
				dociFrame.name = 'igeSgDocPage';
				
				consoleHolderElem.appendChild(consoleElem);
				consoleHolderElem.appendChild(classChainElem);
				consoleHolderElem.appendChild(dociFrame);
				
				document.body.appendChild(consoleHolderElem);
				
				this.sgTreeUpdate();
				
				// Now add a refresh button to the scene button
				var button = document.createElement('input');
				button.type = 'button';
				button.id = 'igeSgRefreshTree'
				button.style.position = 'absolute';
				button.style.top = '0px';
				button.style.right = '0px'
				button.value = 'Refresh';
				
				button.addEventListener('click', function () {
					self.sgTreeUpdate();
				}, false);
				
				document.getElementById('igeSgTree').appendChild(button);
				
				// Add basic editor controls
				var editorRoot = document.createElement('div'),
					editorModeTranslate = document.createElement('input'),
					editorModeRotate = document.createElement('input'),
					editorModeScale = document.createElement('input'),
					editorStatus = document.createElement('span');
				
				editorRoot.id = 'igeSgEditorRoot';
				editorStatus.id = 'igeSgEditorStatus';
				
				editorModeTranslate.type = 'button';
				editorModeTranslate.id = 'igeSgEditorTranslate';
				editorModeTranslate.value = 'Translate';
				editorModeTranslate.addEventListener('click', function () {
					// Disable other modes
					$ige.engine.editorRotate.enabled(false);
					
					if ($ige.engine.editorTranslate.enabled()) {
						$ige.engine.editorTranslate.enabled(false);
						self.log('Editor: Translate mode disabled');
					} else {
						$ige.engine.editorTranslate.enabled(true);
						self.log('Editor: Translate mode enabled');
					}
				});
				
				editorModeRotate.type = 'button';
				editorModeRotate.id = 'igeSgEditorRotate';
				editorModeRotate.value = 'Rotate';
				editorModeRotate.addEventListener('click', function () {
					// Disable other modes
					$ige.engine.editorTranslate.enabled(false);
					
					if ($ige.engine.editorRotate.enabled()) {
						$ige.engine.editorRotate.enabled(false);
						self.log('Editor: Rotate mode disabled');
					} else {
						$ige.engine.editorRotate.enabled(true);
						self.log('Editor: Rotate mode enabled');
					}
				});
				
				editorModeScale.type = 'button';
				editorModeScale.id = 'igeSgEditorScale';
				editorModeScale.value = 'Scale';
				
				editorRoot.appendChild(editorModeTranslate);
				editorRoot.appendChild(editorModeRotate);
				editorRoot.appendChild(editorModeScale);
				editorRoot.appendChild(editorStatus);
				
				document.body.appendChild(editorRoot);
				
				// Add the translate component to the ige instance
				$ige.engine.addComponent(IgeEditorTranslateComponent);
				$ige.engine.addComponent(IgeEditorRotateComponent);
				
				// Schedule tree updates every second
				$ige.engine._sgTreeUpdateInterval = setInterval(function () { self.sgTreeUpdate(); }, 1000);
			} else {
				// Kill interval
				clearInterval($ige.engine._sgTreeUpdateInterval);
				
				var child = document.getElementById('igeSgTree');
				child.parentNode.removeChild(child);
				
				child = document.getElementById('igeSgConsoleHolder');
				child.parentNode.removeChild(child);
				
				child = document.getElementById('igeSgEditorRoot');
				child.parentNode.removeChild(child);
				
				$ige.engine.removeComponent('editorTranslate');
				$ige.engine.removeComponent('editorRotate');
			}
		},
		
		sgTreeUpdate: function () {
			// Update the scenegraph tree
			document.getElementById('sceneGraph_items').innerHTML = '';
			
			// Get the scenegraph data
			this.addToSgTree(this.getSceneGraphData(this, true));
		},
	});
	
	return IgeEditorComponent;
});
},{"irrelon-appcore":125}],23:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEditorRotateComponent', function (IgeEventingClass) {
	/**
	 * When added to a viewport, automatically adds entity rotate
	 * capabilities to the selected entity in the scenegraph viewer.
	 */
	var IgeEditorRotateComponent = IgeEventingClass.extend({
		classId: 'IgeEditorRotateComponent',
		componentId: 'editorRotate',
		
		/**
		 * @constructor
		 * @param {IgeObject} entity The object that the component is added to.
		 * @param {Object=} options The options object that was passed to the component during
		 * the call to addComponent.
		 */
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			// Set the rotate component to inactive to start with
			this._enabled = false;
			this._startThreshold = 1; // The number of pixels the mouse should move to activate
		},
		
		/**
		 * Gets / sets the number of pixels after a mouse down that the mouse
		 * must move in order to activate the operation. Defaults to 1.
		 * @param val
		 * @return {*}
		 */
		startThreshold: function (val) {
			if (val !== undefined) {
				this._startThreshold = val;
				return this._entity;
			}
			
			return this._startThreshold;
		},
		
		/**
		 * Gets / sets the rectangle that the operation will be limited
		 * to using an IgeRect instance.
		 * @param {IgeRect=} rect
		 * @return {*}
		 */
		limit: function (rect) {
			if (rect !== undefined) {
				this._limit = rect;
				return this._entity;
			}
			
			return this._limit;
		},
		
		/**
		 * Gets / sets the enabled flag. If set to true,
		 * operations will be processed. If false, no operations will
		 * occur.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		enabled: function (val) {
			var self = this;
			
			if (val !== undefined) {
				this._enabled = val;
				
				// Reset rotate values.
				// This prevents problems if the component is disabled mid-operation.
				this._opPreStart = false;
				this._opStarted  = false;
				
				if (this._enabled) {
					if ($ige.engine._sgTreeSelected && $ige.engine._sgTreeSelected !== 'ige') {
						this._targetEntity = $ige.engine.$($ige.engine._sgTreeSelected);
						
						if (this._targetEntity.classId() == 'IgeViewport') {
							// Disable translation mode
							this.log('Editor: Mouse rotate disabled');
							this.enabled(false);
						} else {
							// Listen for the mouse events we need to operate
							$ige.engine.input.on('mouseDown', function (event) { self._mouseDown(event); });
							$ige.engine.input.on('mouseMove', function (event) { self._mouseMove(event); });
							$ige.engine.input.on('mouseUp', function (event) { self._mouseUp(event); });
							this.log('Editor: Mouse rotate enabled');
						}
					}
				} else {
					// Remove the operation start data
					delete this._opStartMouse;
					delete this._opStartRotate;
				}
				
				return this._entity;
			}
			
			return this._enabled;
		},
		
		/**
		 * Handles the mouseDown event. Records the starting position of the
		 * operation and the current operation translation.
		 * @param event
		 * @private
		 */
		_mouseDown: function (event) {
			if (!this._opStarted && this._enabled && this._targetEntity) {
				// Record the mouse down position - pre-start
				var curMousePos = $ige.engine._mousePos;
				this._opStartMouse = curMousePos.clone();
				
				this._opStartRotate = {
					x: Math.degrees(this._targetEntity._rotate.z)
				};
				
				this._opPreStart = true;
				this._opStarted = false;
				
				document.getElementById('igeSgEditorStatus').innerHTML = 'Degrees: ' + Math.degrees(this._targetEntity._rotate.z);
			}
		},
		
		/**
		 * Handles the mouse move event. Rotates the entity as the mouse
		 * moves across the screen.
		 * @param event
		 * @private
		 */
		_mouseMove: function (event) {
			if (this._enabled && this._targetEntity) {
				// Rotate the camera if the mouse is down
				if (this._opStartMouse) {
					var curMousePos = $ige.engine._mousePos,
						rotateCords = {
							x: this._opStartMouse.x - curMousePos.x
						},
						distX = rotateCords.x - this._opStartRotate.x;
					
					if (this._opPreStart) {
						// Check if we've reached the start threshold
						if (Math.abs(distX) > this._startThreshold) {
							this._targetEntity.rotateTo(
								this._targetEntity._rotate.x,
								this._targetEntity._rotate.y,
								Math.radians(-distX)
							);
							this.emit('rotateStart');
							this._opPreStart = false;
							this._opStarted = true;
							
							this.emit('rotateMove');
						}
					} else {
						// Rotate has already started
						this._targetEntity.rotateTo(
							this._targetEntity._rotate.x,
							this._targetEntity._rotate.y,
							Math.radians(-distX)
						);
						
						this.emit('rotateMove');
					}
					
					document.getElementById('igeSgEditorStatus').innerHTML = 'Degrees: ' + Math.degrees(this._targetEntity._rotate.z);
				}
			}
		},
		
		/**
		 * Handles the mouse up event. Finishes the entity rotate and
		 * removes the starting operation data.
		 * @param event
		 * @private
		 */
		_mouseUp: function (event) {
			if (this._enabled && this._targetEntity) {
				// End the rotate
				if (this._opStarted) {
					if (this._opStartMouse) {
						var curMousePos = $ige.engine._mousePos,
							rotateCords = {
								x: this._opStartMouse.x - curMousePos.x
							},
							distX = rotateCords.x - this._opStartRotate.x;
						
						this._targetEntity.rotateTo(
							this._targetEntity._rotate.x,
							this._targetEntity._rotate.y,
							Math.radians(-distX)
						);
						
						document.getElementById('igeSgEditorStatus').innerHTML = 'Degrees: ' + Math.degrees(this._targetEntity._rotate.z);
						
						// Remove the rotate start data to end the rotate operation
						delete this._opStartMouse;
						delete this._opStartRotate;
						
						this.emit('rotateEnd');
						this._opStarted = false;
					}
				} else {
					delete this._opStartMouse;
					delete this._opStartRotate;
					this._opStarted = false;
				}
			}
		}
	});
	
	return IgeEditorRotateComponent;
});
},{"irrelon-appcore":125}],24:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEditorTranslateComponent', function (IgeEventingClass) {
	/**
	 * When added to a viewport, automatically adds entity translate
	 * capabilities to the selected entity in the scenegraph viewer.
	 */
	var IgeEditorTranslateComponent = IgeEventingClass.extend({
		classId: 'IgeEditorTranslateComponent',
		componentId: 'editorTranslate',
		
		/**
		 * @constructor
		 * @param {IgeObject} entity The object that the component is added to.
		 * @param {Object=} options The options object that was passed to the component during
		 * the call to addComponent.
		 */
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			// Set the pan component to inactive to start with
			this._enabled = false;
			this._startThreshold = 1; // The number of pixels the mouse should move to activate
		},
		
		/**
		 * Gets / sets the number of pixels after a mouse down that the mouse
		 * must move in order to activate the operation. Defaults to 1.
		 * @param val
		 * @return {*}
		 */
		startThreshold: function (val) {
			if (val !== undefined) {
				this._startThreshold = val;
				return this._entity;
			}
			
			return this._startThreshold;
		},
		
		/**
		 * Gets / sets the rectangle that the operation will be limited
		 * to using an IgeRect instance.
		 * @param {IgeRect=} rect
		 * @return {*}
		 */
		limit: function (rect) {
			if (rect !== undefined) {
				this._limit = rect;
				return this._entity;
			}
			
			return this._limit;
		},
		
		/**
		 * Gets / sets the enabled flag. If set to true,
		 * operations will be processed. If false, no operations will
		 * occur.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		enabled: function (val) {
			var self = this;
			
			if (val !== undefined) {
				this._enabled = val;
				
				// Reset pan values.
				// This prevents problems if the component is disabled mid-operation.
				this._opPreStart = false;
				this._opStarted  = false;
				
				if (this._enabled) {
					if ($ige.engine._sgTreeSelected) {
						this._targetEntity = $ige.engine.$($ige.engine._sgTreeSelected);
						
						if (this._targetEntity.classId() == 'IgeViewport') {
							// Disable translation mode
							this.log('Editor: Mouse translate disabled');
							this.enabled(false);
						} else {
							// Listen for the mouse events we need to operate
							$ige.engine.input.on('mouseDown', function (event) { self._mouseDown(event); });
							$ige.engine.input.on('mouseMove', function (event) { self._mouseMove(event); });
							$ige.engine.input.on('mouseUp', function (event) { self._mouseUp(event); });
							this.log('Editor: Mouse translate enabled');
						}
					}
				} else {
					// Remove the operation start data
					delete this._opStartMouse;
					delete this._opStartTranslate;
				}
				
				return this._entity;
			}
			
			return this._enabled;
		},
		
		/**
		 * Handles the mouseDown event. Records the starting position of the
		 * operation and the current operation translation.
		 * @param event
		 * @private
		 */
		_mouseDown: function (event) {
			if (!this._opStarted && this._enabled && this._targetEntity) {
				// Record the mouse down position - pre-start
				var curMousePos = $ige.engine._mousePos;
				this._opStartMouse = curMousePos.clone();
				
				this._opStartTranslate = {
					x: this._targetEntity._translate.x,
					y: this._targetEntity._translate.y
				};
				
				this._opPreStart = true;
				this._opStarted = false;
				
				document.getElementById('igeSgEditorStatus').innerHTML = 'X: ' + this._targetEntity._translate.x + ' Y:' + this._targetEntity._translate.y;
			}
		},
		
		/**
		 * Handles the mouse move event. Translates the entity as the mouse
		 * moves across the screen.
		 * @param event
		 * @private
		 */
		_mouseMove: function (event) {
			if (this._enabled && this._targetEntity) {
				// Pan the camera if the mouse is down
				if (this._opStartMouse) {
					var curMousePos = $ige.engine._mousePos,
						panCords = {
							x: this._opStartMouse.x - curMousePos.x,
							y: this._opStartMouse.y - curMousePos.y
						}, distX = Math.abs(panCords.x), distY = Math.abs(panCords.y),
						panFinalX = this._opStartTranslate.x - (panCords.x / $ige._currentViewport.camera._scale.x),
						panFinalY = this._opStartTranslate.y - (panCords.y / $ige._currentViewport.camera._scale.y);
					
					// Check if we have a limiter on the rectangle area
					// that we should allow panning inside.
					if (this._limit) {
						// Check the pan co-ordinates against
						// the limiter rectangle
						if (panFinalX < this._limit.x) {
							panFinalX = this._limit.x;
						}
						
						if (panFinalX > this._limit.x + this._limit.width) {
							panFinalX = this._limit.x + this._limit.width;
						}
						
						if (panFinalY < this._limit.y) {
							panFinalY = this._limit.y;
						}
						
						if (panFinalY > this._limit.y + this._limit.height) {
							panFinalY = this._limit.y + this._limit.height;
						}
					}
					
					if (this._opPreStart) {
						// Check if we've reached the start threshold
						if (distX > this._startThreshold || distY > this._startThreshold) {
							this._targetEntity.translateTo(
								panFinalX,
								panFinalY,
								0
							);
							this.emit('panStart');
							this._opPreStart = false;
							this._opStarted = true;
							
							this.emit('panMove');
						}
					} else {
						// Pan has already started
						this._targetEntity.translateTo(
							panFinalX,
							panFinalY,
							0
						);
						
						this.emit('panMove');
					}
					
					document.getElementById('igeSgEditorStatus').innerHTML = 'X: ' + panFinalX + ' Y:' + panFinalY;
				}
			}
		},
		
		/**
		 * Handles the mouse up event. Finishes the entity translate and
		 * removes the starting operation data.
		 * @param event
		 * @private
		 */
		_mouseUp: function (event) {
			if (this._enabled && this._targetEntity) {
				// End the pan
				if (this._opStarted) {
					if (this._opStartMouse) {
						var curMousePos = $ige.engine._mousePos,
							panCords = {
								x: this._opStartMouse.x - curMousePos.x,
								y: this._opStartMouse.y - curMousePos.y
							},
							panFinalX = this._opStartTranslate.x - (panCords.x / $ige._currentViewport.camera._scale.x),
							panFinalY = this._opStartTranslate.y - (panCords.y / $ige._currentViewport.camera._scale.y);
						
						// Check if we have a limiter on the rectangle area
						// that we should allow panning inside.
						if (this._limit) {
							// Check the pan co-ordinates against
							// the limiter rectangle
							if (panFinalX < this._limit.x) {
								panFinalX = this._limit.x;
							}
							
							if (panFinalX > this._limit.x + this._limit.width) {
								panFinalX = this._limit.x + this._limit.width;
							}
							
							if (panFinalY < this._limit.y) {
								panFinalY = this._limit.y;
							}
							
							if (panFinalY > this._limit.y + this._limit.height) {
								panFinalY = this._limit.y + this._limit.height;
							}
						}
						
						this._targetEntity.translateTo(
							panFinalX,
							panFinalY,
							0
						);
						
						document.getElementById('igeSgEditorStatus').innerHTML = 'X: ' + panFinalX + ' Y:' + panFinalY;
						
						// Remove the pan start data to end the pan operation
						delete this._opStartMouse;
						delete this._opStartTranslate;
						
						this.emit('panEnd');
						this._opStarted = false;
					}
				} else {
					delete this._opStartMouse;
					delete this._opStartTranslate;
					this._opStarted = false;
				}
			}
		}
	});
	
	return IgeEditorTranslateComponent;
});

},{"irrelon-appcore":125}],25:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEntityManager', function (IgeEventingClass) {
	var IgeEntityManager = IgeEventingClass.extend({
		classId: 'IgeEntityManager',
		componentId: 'entityManager',
		
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			// Create queue arrays that will store entities waiting to
			// be mounted or unmounted
			this._mountQueue = [];
			this._unMountQueue = [];
			this._maxMountsPerOp = 0;
			this._maxUnMountsPerOp = 0;
			
			// Create the _orphans array on the entity
			entity._orphans = [];
			
			// Set a method (behaviour) that will be called on every update
			entity.addBehaviour('entManager', this._updateBehaviour, false);
		},
		
		/**
		 * Called each update frame from the component parent and calls various private
		 * methods to ensure that entities that should be mounted are mounted and those
		 * that are to be unmounted are unmounted.
		 * @private
		 */
		_updateBehaviour: function (ctx) {
			// Draw visible area rect
			var rect = $ige._currentViewport.viewArea();
			
			/*new IgeEntity()
			 .id('visArea')
			 .texture(this.gameTexture.simpleBox)
			 .opacity(0.5)
			 .mount($ige.engine.$('objectScene'));*/
			
			/*$ige.engine.$('visArea')
			 .translateTo(rect.x + (rect.width / 2), rect.y + (rect.height / 2), 0)
			 .height(rect.height)
			 .width(rect.width);*/
			
			// Get our instance back
			var self = this.entityManager;
			
			self._updateOrphans();
			self._updateChildren();
			
			self._processMountQueue();
			self._processUnMountQueue();
		},
		
		/**
		 * Checks all the mounted entities of our component parent are still supposed
		 * to be in the scenegraph and if not, adds them to the un-mount queue. Also
		 * marks any entities that are non-managed but also off-screen as inView = false.
		 * @private
		 */
		_updateOrphans: function () {
			var arr = this._entity._children,
				arrCount = arr.length,
				viewportArr = $ige.engine._children,
				vpCount = viewportArr.length,
				item,
				itemAabb,
				vpIndex,
				inVisibleArea;
			
			while (arrCount--) {
				item = arr[arrCount];
				
				if (item._managed) {
					if (item.aabb) {
						if (item._mode === 1 || (item._parent && item._parent._mountMode === 1)) {
							itemAabb = item.bounds3dPolygon().aabb();
						} else {
							itemAabb = item.aabb();
						}
						
						inVisibleArea = false;
						
						// Check the entity to see if its bounds are "inside" any
						// viewport's visible area
						for (vpIndex = 0; vpIndex < vpCount; vpIndex++) {
							if (viewportArr[vpIndex].viewArea().intersects(itemAabb)) {
								inVisibleArea = true;
								break;
							}
						}
						
						if (!inVisibleArea) {
							// Check for managed mode 1 (static entities that can be unmounted)
							// or managed mode 2 (dynamic and should just be marked as inView = false)
							if (item._managed === 1) {
								// The entity is not inside the viewport visible area
								// and is managed mode 1 (static) so unmount it
								this._unMountQueue.push(item);
							} else if (item._managed === 2) {
								// The entity is dynamic so mark is as inView = false
								item._inView = false;
							}
						} else if (item._managed === 2) {
							// The entity is dynamic so mark is as inView = true
							item._inView = true;
						}
					} else {
						this._unMountQueue.push(item);
					}
				}
			}
		},
		
		/**
		 * Checks all the un-mounted entities of our component parent to see if they are
		 * now inside the visible area of a viewport and if so, queues them for re-mounting.
		 * @private
		 */
		_updateChildren: function () {
			var arr = this._entity._orphans,
				arrCount = arr.length,
				viewportArr = $ige.engine._children,
				vpCount = viewportArr.length,
				item,
				itemAabb,
				vpIndex,
				inVisibleArea;
			
			while (arrCount--) {
				item = arr[arrCount];
				
				if (item._managed) {
					if (item.aabb) {
						if (item._mode === 1 || (item._parent && item._parent._mountMode === 1)) {
							itemAabb = item.bounds3dPolygon().aabb();
						} else {
							itemAabb = item.aabb();
						}
						
						inVisibleArea = false;
						
						// Check the entity to see if its bounds are "inside" any
						// viewport's visible area
						for (vpIndex = 0; vpIndex < vpCount; vpIndex++) {
							if (viewportArr[vpIndex].viewArea().intersects(itemAabb)) {
								inVisibleArea = true;
								break;
							}
						}
						
						if (inVisibleArea) {
							// Check for managed mode 1 (static entities that can be mounted)
							// or managed mode 2 (dynamic and should just be marked as inView = true)
							if (item._managed === 1) {
								// The entity is inside the viewport visible area
								// and is managed mode 1 (static) so mount it
								this._mountQueue.push(item);
							} else if (item._managed === 2) {
								// The entity is dynamic so mark is as inView = true
								item._inView = true;
							}
						}
					} else {
						this._mountQueue.push(item);
					}
				}
			}
		},
		
		/**
		 * Loops any entities queued for mounting and mounts them.
		 * @private
		 */
		_processMountQueue: function () {
			var arr = this._mountQueue,
				arrCount = arr.length,
				item;
			
			while (arrCount--) {
				item = arr[arrCount];
				
				this._entity._orphans.pull(item);
				item.mount(this._entity);
			}
			
			this._mountQueue = [];
		},
		
		/**
		 * Loops any entities queued for un-mounting and un-mounts them.
		 * @private
		 */
		_processUnMountQueue: function () {
			var arr = this._unMountQueue,
				arrCount = arr.length,
				item;
			
			while (arrCount--) {
				item = arr[arrCount];
				item.unMount();
				
				this._entity._orphans.push(item);
			}
			
			this._unMountQueue = [];
		}
	});
	
	return IgeEntityManager;
});
},{"irrelon-appcore":125}],26:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTimeSyncExtension', function ($ige, $time) {
	/**
	 * Adds client/server time sync capabilities to the network system.
	 * This handles calculating the time difference between the clock
	 * on the server and the clock on connected clients.
	 */
	var IgeTimeSyncExtension = {
		/**
		 * Gets / sets the number of milliseconds between client/server
		 * clock sync events. The shorter the time, the more accurate the
		 * client simulation will be but the more network traffic you
		 * will transceive. Default value of ten seconds (10000) is usually
		 * enough to provide very accurate results without over-using the
		 * bandwidth.
		 * @param val
		 * @return {*}
		 */
		timeSyncInterval: function (val) {
			if (val !== undefined) {
				this._timeSyncInterval = val;
				return this._entity;
			}
			
			return this._timeSyncInterval;
		},
		
		/* CEXCLUDE */
		timeSyncStart: function () {
			if ($ige.isServer) {
				this._timeSyncStarted = true;
				
				// Send a time sync request now so we
				// have a starting value to work with
				this._sendTimeSync();
				
				var self = this;
				
				this.log('Starting client/server clock sync...');
				this._timeSyncTimer = setInterval(function () {
					self._sendTimeSync();
				}, this._timeSyncInterval);
			}
			
			return this._entity;
		},
		
		timeSyncStop: function () {
			this.log('Stopping client/server clock sync...');
			clearInterval(this._timeSyncTimer);
			this._timeSyncStarted = false;
			
			return this._entity;
		},
		/* CEXCLUDE */
		
		_sendTimeSync: function (data, clientId) {
			if (!data) {
				data = $time._currentTime;
			}
			
			// Send the time sync command
			this.send('_igeNetTimeSync', data, clientId);
		},
		
		/**
		 * Converts a timestamp on the client to approx. time
		 * on the server using the difference in client/server
		 * clocks and the network latency between this client
		 * and the server.
		 * @param {Number} time The client timestamp (usually
		 * the result of new Date().getTime() or
		 * $time.currentTime()).
		 */
		timeToServerTime: function (time) {
			if (time !== undefined) {
				return time + this._latency;
			}
			
			return this._latency;
		},
		
		_onTimeSync: function (data, clientId) {
			var localTime = Math.floor($time._currentTime),
				sendTime,
				roundTrip,
				direction;
			
			if ($ige.isClient) {
				sendTime = parseInt(data, 10);
				
				this._latency = localTime - sendTime;
				
				/*if (localTime < sendTime) {
				 direction = 'behind';
				 } else if (localTime > sendTime) {
				 direction = 'in front of';
				 } else {
				 direction = 'same as';
				 }
				 
				 this.log('Time sync, client clock ' + (localTime - sendTime) + 'ms ' + direction + ' server, send timestamp: ' + sendTime + ', local timestamp: ' + localTime);*/
				
				// Send a response with out current clock time to the server
				this._sendTimeSync([data, localTime]);
			}
			
			/* CEXCLUDE */
			if ($ige.isServer) {
				sendTime = parseInt(data[1], 10);
				roundTrip = (localTime - parseInt(data[0], 10));
				
				/*if (localTime < sendTime) {
				 direction = 'behind';
				 } else if (localTime > sendTime) {
				 direction = 'in front of';
				 } else {
				 direction = 'same as';
				 }
				 
				 this.log('Time sync, server clock ' + (localTime - sendTime) + 'ms ' + direction + ' client, roundtrip: ' + roundTrip + 'ms, send timestamp: ' + parseInt(data[0], 10) + ', local timestamp: ' + localTime);*/
				
				this._timeSyncLog[clientId] = localTime - sendTime;
			}
			/* CEXCLUDE */
		}
	};
	
	return IgeTimeSyncExtension;
});
},{"irrelon-appcore":125}],27:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeNetIoClient', function ($ige, $time, NetIo) {
	/**
	 * The client-side net.io component. Handles all client-side
	 * networking systems.
	 */
	var IgeNetIoClient = {
		version: '1.0.0',
		_initDone: false,
		_idCounter: 0,
		_requests: {},
		_state: 0,
		
		/**
		 * Gets the current socket id.
		 * @returns {String} The id of the socket connection to the server.
		 */
		id: function () {
			return this._id || '';
		},
		
		/**
		 * Starts the network for the client.
		 * @param {*} url The game server URL.
		 * @param {Function=} callback A callback method to call once the
		 * network has started.
		 */
		start: function (url, callback) {
			if (this._state === 3) {
				// We're already connected
				if (typeof(callback) === 'function') {
					callback();
				}
			} else {
				var self = this;
				
				self._startCallback = callback;
				
				if (typeof(url) !== 'undefined') {
					this._url = url;
				}
				
				this.log('Connecting to net.io server at "' + this._url + '"...');
				
				if (typeof(WebSocket) !== 'undefined') {
					this._io = new NetIo.Client(url);
					self._state = 1; // Connecting
					
					// Define connect listener
					this._io.on('connect', function (clientId) {
						self._state = 2; // Connected
						self._id = clientId;
						self._onConnectToServer.apply(self, arguments);
					});
					
					// Define message listener
					this._io.on('message', function (data) {
						if (!self._initDone) {
							var i, commandCount = 0;
							
							// Check if the data is an init packet
							if (data.cmd === 'init') {
								// Set flag to show we've now received an init command
								self._initDone = true;
								self._state = 3; // Connected and init done
								
								// Setup the network commands storage
								self._networkCommandsLookup = data.ncmds;
								
								// Fill the reverse lookup on the commands
								for (i in self._networkCommandsLookup) {
									if (self._networkCommandsLookup.hasOwnProperty(i)) {
										self._networkCommandsIndex[self._networkCommandsLookup[i]] = i;
										commandCount++;
									}
								}
								
								// Setup default commands
								self.define('_igeRequest', function () { self._onRequest.apply(self, arguments); });
								self.define('_igeResponse', function () { self._onResponse.apply(self, arguments); });
								self.define('_igeNetTimeSync', function () { self._onTimeSync.apply(self, arguments); });
								
								self.log('Received network command list with count: ' + commandCount);
								
								// Setup time scale and current time
								$ige.engine.timeScale(parseFloat(data.ts));
								$time._currentTime = parseInt(data.ct);
								
								// Now fire the start() callback
								if (typeof(self._startCallback) === 'function') {
									self._startCallback();
									delete self._startCallback;
								}
							}
						} else {
							self._onMessageFromServer.apply(self, arguments);
						}
					});
					
					// Define disconnect listener
					this._io.on('disconnect', function () {
						self._state = 0; // Disconnected
						self._onDisconnectFromServer.apply(self, arguments);
					});
					
					// Define error listener
					this._io.on('error', function () {
						self._onError.apply(self, arguments);
					});
				}
			}
		},
		
		stop: function () {
			// Check we are connected
			if (self._state === 3) {
				this._io.disconnect('Client requested disconnect');
			}
		},
		
		/**
		 * Gets / sets a network command and callback. When a network command
		 * is received by the client, the callback set up for that command will
		 * automatically be called and passed the data from the incoming network
		 * packet.
		 * @param {String} commandName The name of the command to define.
		 * @param {Function} callback A function to call when the defined network
		 * command is received by the network.
		 * @return {*}
		 */
		define: function (commandName, callback) {
			if (commandName !== undefined && callback !== undefined) {
				// Check if this command has been defined by the server
				//if (this._networkCommandsLookup[commandName] !== undefined) {
					this._networkCommands[commandName] = callback;
				/*} else {
					this.log('Cannot define network command "' + commandName + '" because it does not exist on the server. Please edit your server code and define the network command there before trying to define it on the client!', 'error');
				}*/
				
				return this._entity;
			} else {
				this.log('Cannot define network command either the commandName or callback parameters were undefined!', 'error');
			}
		},
		
		/**
		 * Sends a network message with the given command name
		 * and data.
		 * @param commandName
		 * @param data
		 */
		send: function (commandName, data, callback) {
			if (callback) {
				// Send a network request instead of a command
				this.request(commandName, data, callback);
			} else {
				var commandIndex = this._networkCommandsLookup[commandName],
					ciEncoded;
				
				if (commandIndex !== undefined) {
					if (this.debug()) {
						console.log('Sending "' + commandName + '" (index ' + commandIndex + ') with data:', data);
						this._debugCounter++;
					}
					ciEncoded = String.fromCharCode(commandIndex);
					this._io.send([ciEncoded, data]);
				} else {
					this.log('Cannot send network packet with command "' + commandName + '" because the command has not been defined!', 'error');
				}
			}
		},
		
		/**
		 * Sends a network request. This is different from a standard
		 * call to send() because the recipient code will be able to
		 * respond by calling $ige.engine.network.response(). When the response
		 * is received, the callback method that was passed in the
		 * callback parameter will be fired with the response data.
		 * @param {String} commandName
		 * @param {Object} data
		 * @param {Function} callback
		 */
		request: function (commandName, data, callback) {
			// Build the request object
			var req = {
				id: this.newIdHex(),
				cmd: commandName,
				data: data,
				callback: callback,
				timestamp: new Date().getTime()
			};
			
			// Store the request object
			this._requests[req.id] = req;
			
			// Send the network request packet
			this.send(
				'_igeRequest',
				{
					id: req.id,
					cmd: commandName,
					data: req.data
				}
			);
		},
		
		/**
		 * Sends a response to a network request.
		 * @param {String} requestId
		 * @param {Object} data
		 */
		response: function (requestId, data) {
			// Grab the original request object
			var req = this._requests[requestId];
			
			if (req) {
				// Send the network response packet
				this.send(
					'_igeResponse',
					{
						id: requestId,
						cmd: req.commandName,
						data: data
					}
				);
				
				// Remove the request as we've now responded!
				delete this._requests[requestId];
			}
		},
		
		/**
		 * Generates a new 16-character hexadecimal unique ID
		 * @return {String}
		 */
		newIdHex: function () {
			this._idCounter++;
			return (this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17))).toString(16);
		},
		
		_onRequest: function (data) {
			var self = this,
				responseCallback = function (err, returnData) {
					self.response(data.id, {
						err: err,
						data: returnData
					});
				};
			
			// The message is a network request so fire
			// the command event with the request id and
			// the request data
			this._requests[data.id] = data;
			
			if (this.debug()) {
				console.log('onRequest', data);
				this._debugCounter++;
			}
			
			if (this._networkCommands[data.cmd]) {
				this._networkCommands[data.cmd](data.data, responseCallback);
			}
			
			this.emit(data.cmd, [data.data, responseCallback]);
		},
		
		_onResponse: function (data) {
			var id,
				req;
			
			// The message is a network response
			// to a request we sent earlier
			id = data.id;
			
			// Get the original request object from
			// the request id
			req = this._requests[id];
			
			if (this.debug()) {
				console.log('onResponse', data);
				this._debugCounter++;
			}
			
			if (req) {
				// Fire the request callback!
				if (req.callback) {
					req.callback(data.data.err, data.data.data);
				}
				
				// Delete the request from memory
				delete this._requests[id];
			}
		},
		
		/**
		 * Called when the network connects to the server.
		 * @private
		 */
		_onConnectToServer: function () {
			this.log('Connected to server!');
			this.emit('connected');
		},
		
		/**
		 * Called when data from the server is received on the client.
		 * @param data
		 * @private
		 */
		_onMessageFromServer: function (data) {
			var ciDecoded = data[0].charCodeAt(0),
				commandName = this._networkCommandsIndex[ciDecoded];
			
			if (this._networkCommands[commandName]) {
				if (this.debug()) {
					console.log('Received "' + commandName + '" (index ' + ciDecoded + ') with data:', data[1]);
					this._debugCounter++;
				}
				
				this._networkCommands[commandName](data[1]);
			}
			
			this.emit(commandName, data[1]);
		},
		
		/**
		 * Called when the client is disconnected from the server.
		 * @param data
		 * @private
		 */
		_onDisconnectFromServer: function (data) {
			if (data === 'booted') {
				this.log('Server rejected our connection because it is not accepting connections at this time!', 'warning');
			} else {
				this.log('Disconnected from server!');
			}
			this.emit('disconnected');
		},
		
		/**
		 * Called when the client has an error with the connection.
		 * @param {Object} data
		 * @private
		 */
		_onError: function (data) {
			this.log('Error with connection: ' + data.reason, 'error');
		}
	};
	
	return IgeNetIoClient;
});
},{"irrelon-appcore":125}],28:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeNetIoComponent', function ($ige, IgeEventingClass, IgeTimeSyncExtension, IgeNetIoClient) {
	var IgeNetIoComponent = IgeEventingClass.extend([
		{extension: IgeTimeSyncExtension, overwrite: false}
	], {
		classId: 'IgeNetIoComponent',
		componentId: 'network',
		
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			// Setup the network commands storage
			this._networkCommands = {};
			this._networkCommandsIndex = [];
			this._networkCommandsLookup = {};
			
			// Set some defaults
			this._port = 8000;
			this._debug = false;
			this._debugCounter = 0;
			this._debugMax = 0;
			this._clientRooms = {};
			
			// Time sync defaults
			this._timeSyncInterval = 10000; // Sync the client/server clocks every ten seconds by default
			this._timeSyncLog = {};
			this._latency = 0;
			
			this._netio = IgeNetIoClient;
			this.implement(IgeNetIoClient);
			
			this.log('Network component initiated with Net.IO version: ' + this._netio.version);
		},
		
		/**
		 * Gets / sets debug flag that determines if debug output
		 * is logged to the console.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		debug: function (val) {
			if (val !== undefined) {
				this._debug = val;
				return this._entity;
			}
			
			// Check the debug counter settings
			if (this._debugMax > 0 && this._debugCounter >= this._debugMax) {
				this._debug = false;
				this._debugCounter = 0;
			}
			
			return this._debug;
		},
		
		/**
		 * Gets / sets the maximum number of debug messages that
		 * should be allowed to be output to the console before
		 * debugging is automatically turned off. This is useful
		 * if you want to sample a certain number of outputs and
		 * then automatically disable output so your console is
		 * not flooded.
		 * @param {Number=} val Number of debug messages to allow
		 * to be output to the console. Set to zero to allow
		 * infinite amounts.
		 * @return {*}
		 */
		debugMax: function (val) {
			if (val !== undefined) {
				this._debugMax = val;
				return this._entity;
			}
			
			return this._debugMax;
		}
	});
	
	return IgeNetIoComponent;
});
},{"irrelon-appcore":125}],29:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('NetIo', function ($ige, IgeClass, IgeEventingClass) {
	// Our namespace
	var NetIo = {};
	
	/**
	 * Define the debug options object.
	 * @type {Object}
	 * @private
	 */
	NetIo._debug = {
		_enabled: true,
		_node: typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined',
		_level: ['log', 'warning', 'error'],
		_stacks: false,
		_throwErrors: true,
		_trace: {
			setup: false,
			enabled: false,
			match: ''
		},
		enabled: function (val) {
			if (val !== undefined) {
				this._enabled = val;
				return this;
			}
			
			return this._enabled;
		}
	};
	
	/**
	 * Define the class system.
	 * @type {*}
	 */
	NetIo.Class = IgeClass;
	
	NetIo.EventingClass = IgeEventingClass;
	
	NetIo.Client = NetIo.EventingClass.extend({
		classId: 'NetIo.Client',
		
		init: function (url, options) {
			this.log('Net.io client starting...');
			this._options = options || {};
			this._socket = null;
			this._state = 0;
			this._debug = false;
			this._connectionAttempts = 0;
			
			// Set some default options
			if (this._options.connectionRetry === undefined) {
				this._options.connectionRetry = true;
			}
			if (this._options.connectionRetryMax === undefined) {
				this._options.connectionRetryMax = 10;
			}
			if (this._options.reconnect === undefined) {
				this._options.reconnect = true;
			}
			
			// If we were passed a url, connect to it
			if (url !== undefined) {
				this.connect(url);
			}
		},
		
		/**
		 * Gets / sets the debug flag. If set to true, net.io
		 * will output debug data about every network event as
		 * it occurs to the console.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		debug: function (val) {
			if (val !== undefined) {
				this._debug = val;
				return this;
			}
			
			return this._debug;
		},
		
		connect: function (url) {
			this.log('Connecting to server at ' + url);
			var self = this;
			
			// Set the state to connecting
			this._state = 1;
			
			// Replace http:// with ws://
			url = url.replace('http://', 'ws://');
			
			// Create new websocket to the url
			this._socket = new WebSocket(url, 'netio1');
			
			// Setup event listeners
			this._socket.onopen = function () {
				self._onOpen.apply(self, arguments);
			};
			this._socket.onmessage = function () {
				self._onData.apply(self, arguments);
			};
			this._socket.onclose = function () {
				self._onClose.apply(self, arguments);
			};
			this._socket.onerror = function () {
				self._onError.apply(self, arguments);
			};
		},
		
		disconnect: function (reason) {
			this._socket.close(1000, reason);
		},
		
		send: function (data) {
			this._socket.send(this._encode(data));
		},
		
		_onOpen: function () {
			this._state = 2;
		},
		
		_onData: function (data) {
			// Decode packet and emit message event
			var packet = this._decode(data.data);
			
			// Output debug if required
			if (this._debug) {
				console.log('Incoming data (event, decoded data):', data, packet);
			}
			
			if (packet._netioCmd) {
				// The packet is a netio command
				switch (packet._netioCmd) {
					case 'id':
						// Store the new id in the socket
						this.id = packet.data;
						
						// Now we have an id, set the state to connected
						this._state = 3;
						
						// Emit the connect event
						this.emit('connect', this.id);
						break;
					
					case 'close':
						// The server told us our connection has been closed
						// so store the reason the server gave us!
						this._disconnectReason = packet.data;
						break;
				}
			} else {
				// The packet is normal data
				this.emit('message', [packet]);
			}
		},
		
		_onClose: function (code, reason, wasClean) {
			// If we are already connected and have an id...
			if (this._state === 3) {
				this._state = 0;
				this.emit('disconnect', {reason: this._disconnectReason, wasClean: wasClean, code: code});
			}
			
			// If we are connected but have no id...
			if (this._state === 2) {
				this._state = 0;
				this.emit('disconnect', {reason: this._disconnectReason, wasClean: wasClean, code: code});
			}
			
			// If we were trying to connect...
			if (this._state === 1) {
				this._state = 0;
				this.emit('error', {reason: 'Cannot establish connection, is server running?'});
			}
			
			// Remove the last disconnect reason
			delete this._disconnectReason;
		},
		
		_onError: function () {
			this.log('An error occurred with the net.io socket!', 'error', arguments);
			this.emit('error', arguments);
		},
		
		_encode: function (data) {
			return JSON.stringify(data);
		},
		
		_decode: function (data) {
			return JSON.parse(data);
		}
	});
	
	return NetIo;
});
},{"irrelon-appcore":125}],30:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeSocketIoClient', function ($ige) {
	/**
	 * The client-side socket.io component. Handles all client-side
	 * networking systems.
	 */
	var IgeSocketIoClient = {
		_initDone: false,
		_idCounter: 0,
		_requests: {},
		
		/**
		 * Gets the current socket id.
		 * @returns {String} The id of the socket connection to the server.
		 */
		id: function () {
			if (this._io && this._io.socket) {
				return this._io.socket.sessionid;
			} else {
				return '';
			}
		},
		
		/**
		 * Starts the network for the client.
		 * @param {*} data The game server URL.
		 * @param {Function=} callback A callback method to call once the
		 * network has started.
		 */
		start: function (data, callback) {
			var self = this;
			
			// Check if the io library exists and use ioNoDom otherwise
			if (typeof(io) === 'undefined') {
				io = ioNoDom;
			}
			
			self._startCallback = callback;
			
			if (typeof(data) !== 'undefined') {
				this._port = data;
			}
			
			this.log('Connecting to socket.io server at "' + this._port + '"...');
			
			this._io = io.connect(data);
			
			// Define connect listener
			this._io.on('connect', function () {
				self._onConnectToServer.apply(self, arguments);
			});
			
			// Define message listener
			this._io.on('message', function (data) {
				if (!self._initDone) {
					var i, commandCount = 0;
					
					// Check if the data is an init packet
					if (data.cmd === 'init') {
						// Set flag to show we've now received an init command
						self._initDone = true;
						
						// Setup the network commands storage
						self._networkCommandsLookup = data.ncmds;
						
						// Fill the reverse lookup on the commands
						for (i in self._networkCommandsLookup) {
							if (self._networkCommandsLookup.hasOwnProperty(i)) {
								self._networkCommandsIndex[self._networkCommandsLookup[i]] = i;
								commandCount++;
							}
						}
						
						// Setup default command listeners
						self.define('_igeRequest', function () { self._onRequest.apply(self, arguments); });
						self.define('_igeResponse', function () { self._onResponse.apply(self, arguments); });
						self.define('_igeNetTimeSync', function () { self._onTimeSync.apply(self, arguments); });
						
						self.log('Received network command list with count: ' + commandCount);
						
						// Now fire the start() callback
						if (typeof(self._startCallback) === 'function') {
							self._startCallback();
							delete self._startCallback;
						}
					}
				}
				
				self._onMessageFromServer.apply(self, arguments);
			});
			
			// Define disconnect listener
			this._io.on('disconnect', function () {
				self._onDisconnectFromServer.apply(self, arguments);
			});
		},
		
		/**
		 * Gets / sets a network command and callback. When a network command
		 * is received by the client, the callback set up for that command will
		 * automatically be called and passed the data from the incoming network
		 * packet.
		 * @param {String} commandName The name of the command to define.
		 * @param {Function} callback A function to call when the defined network
		 * command is received by the network.
		 * @return {*}
		 */
		define: function (commandName, callback) {
			if (commandName !== undefined && callback !== undefined) {
				// Check if this command has been defined by the server
				if (this._networkCommandsLookup[commandName] !== undefined) {
					this._networkCommands[commandName] = callback;
				} else {
					this.log('Cannot define network command "' + commandName + '" because it does not exist on the server. Please edit your server code and define the network command there before trying to define it on the client!', 'error');
				}
				
				return this._entity;
			} else {
				this.log('Cannot define network command either the commandName or callback parameters were undefined!', 'error');
			}
		},
		
		/**
		 * Sends a network message with the given command name
		 * and data.
		 * @param commandName
		 * @param data
		 */
		send: function (commandName, data, callback) {
			if (callback) {
				// Send a network request instead of a command
				this.request(commandName, data, callback);
			} else {
				var commandIndex = this._networkCommandsLookup[commandName];
				
				if (commandIndex !== undefined) {
					this._io.json.send([commandIndex, data]);
				} else {
					this.log('Cannot send network packet with command "' + commandName + '" because the command has not been defined!', 'error');
				}
			}
		},
		
		/**
		 * Sends a network request. This is different from a standard
		 * call to send() because the recipient code will be able to
		 * respond by calling $ige.engine.network.response(). When the response
		 * is received, the callback method that was passed in the
		 * callback parameter will be fired with the response data.
		 * @param {String} commandName
		 * @param {Object} data
		 * @param {Function} callback
		 */
		request: function (commandName, data, callback) {
			// Build the request object
			var req = {
				id: this.newIdHex(),
				cmd: commandName,
				data: data,
				callback: callback,
				timestamp: new Date().getTime()
			};
			
			// Store the request object
			this._requests[req.id] = req;
			
			// Send the network request packet
			this.send(
				'_igeRequest',
				{
					id: req.id,
					cmd: commandName,
					data: req.data
				}
			);
		},
		
		/**
		 * Sends a response to a network request.
		 * @param {String} requestId
		 * @param {Object} data
		 */
		response: function (requestId, data) {
			// Grab the original request object
			var req = this._requests[requestId];
			
			if (req) {
				// Send the network response packet
				this.send(
					'_igeResponse',
					{
						id: requestId,
						cmd: req.commandName,
						data: data
					}
				);
				
				// Remove the request as we've now responded!
				delete this._requests[requestId];
			}
		},
		
		/**
		 * Generates a new 16-character hexadecimal unique ID
		 * @return {String}
		 */
		newIdHex: function () {
			this._idCounter++;
			return (this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17))).toString(16);
		},
		
		_onRequest: function (data) {
			var self = this,
				responseCallback = function (err, returnData) {
					self.response(data.id, {
						err: err,
						data: returnData
					});
				};
			
			// The message is a network request so fire
			// the command event with the request id and
			// the request data
			this._requests[data.id] = data;
			
			if (this.debug()) {
				console.log('onRequest', data);
				this._debugCounter++;
			}
			
			if (this._networkCommands[data.cmd]) {
				this._networkCommands[data.cmd](data.data, responseCallback);
			}
			
			this.emit(data.cmd, [data.data, responseCallback]);
		},
		
		_onResponse: function (data) {
			var id,
				req;
			
			// The message is a network response
			// to a request we sent earlier
			id = data.id;
			
			// Get the original request object from
			// the request id
			req = this._requests[id];
			
			if (this.debug()) {
				console.log('onResponse', data);
				this._debugCounter++;
			}
			
			if (req) {
				// Fire the request callback!
				if (req.callback) {
					req.callback(data.data.err, data.data.data);
				}
				
				// Delete the request from memory
				delete this._requests[id];
			}
		},
		
		/**
		 * Called when the network connects to the server.
		 * @private
		 */
		_onConnectToServer: function () {
			this.log('Connected to server!');
			this.emit('connected');
		},
		
		/**
		 * Called when data from the server is received on the client.
		 * @param data
		 * @private
		 */
		_onMessageFromServer: function (data) {
			var commandName = this._networkCommandsIndex[data[0]];
			if (this._networkCommands[commandName]) {
				this._networkCommands[commandName](data[1]);
			}
			this.emit(commandName, data[1]);
		},
		
		/**
		 * Called when the client is disconnected from the server.
		 * @param data
		 * @private
		 */
		_onDisconnectFromServer: function (data) {
			if (data === 'booted') {
				this.log('Server rejected our connection because it is not accepting connections at this time!', 'warning');
			} else {
				this.log('Disconnected from server!');
			}
			this.emit('disconnected');
		}
	};
	
	return IgeSocketIoClient;
});
},{"irrelon-appcore":125}],31:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeSocketIoComponent', function ($ige, IgeEventingClass, IgeTimeSyncExtension) {
	var IgeSocketIoComponent = IgeEventingClass.extend([
		{extension: IgeTimeSyncExtension, overwrite: false}
	], {
		classId: 'IgeSocketIoComponent',
		componentId: 'network',
		
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			// Setup the network commands storage
			this._networkCommands = {};
			this._networkCommandsIndex = [];
			this._networkCommandsLookup = {};
			
			// Set some defaults
			this._port = 8000;
			this._debug = false;
			this._debugMax = 0;
			this._clientRooms = {};
			
			// Time sync defaults
			this._timeSyncInterval = 10000; // Sync the client/server clocks every ten seconds by default
			this._timeSyncLog = {};
			this._latency = 0;
			
			/* CEXCLUDE */
			if ($ige.isServer) {
				this.implement(IgeSocketIoServer);
				this._socketio = _dereq_('../../../' + modulePath + 'socket.io');
				this._acceptConnections = false;
			}
			/* CEXCLUDE */
			
			if ($ige.isClient) {
				this._socketio = IgeSocketIoClient;
				this.implement(IgeSocketIoClient);
			}
			
			this.log('Network component initiated with socket.io version: ' + this._socketio.version);
		},
		
		/**
		 * Gets / sets debug flag that determines if debug output
		 * is logged to the console.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		debug: function (val) {
			if (val !== undefined) {
				this._debug = val;
				return this._entity;
			}
			
			// Check the debug counter settings
			if (this._debugMax > 0 && this._debugCounter >= this._debugMax) {
				this._debug = false;
				this._debugCounter = 0;
			}
			
			return this._debug;
		},
		
		/**
		 * Gets / sets the maximum number of debug messages that
		 * should be allowed to be output to the console before
		 * debugging is automatically turned off. This is useful
		 * if you want to sample a certain number of outputs and
		 * then automatically disable output so your console is
		 * not flooded.
		 * @param {Number=} val Number of debug messages to allow
		 * to be output to the console. Set to zero to allow
		 * infinite amounts.
		 * @return {*}
		 */
		debugMax: function (val) {
			if (val !== undefined) {
				this._debugMax = val;
				return this._entity;
			}
			
			return this._debugMax;
		}
	});
	
	return IgeSocketIoComponent;
});
},{"irrelon-appcore":125}],32:[function(_dereq_,module,exports){
/*! Socket.IO.min.js build:0.9.11, production. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */
var io="undefined"==typeof module?{}:module.exports;(function(){(function(a,b){var c=a;c.version="0.9.11",c.protocol=1,c.transports=[],c.j=[],c.sockets={},c.connect=function(a,d){var e=c.util.parseUri(a),f,g;b&&b.location&&(e.protocol=e.protocol||b.location.protocol.slice(0,-1),e.host=e.host||(b.document?b.document.domain:b.location.hostname),e.port=e.port||b.location.port),f=c.util.uniqueUri(e);var h={host:e.host,secure:"https"==e.protocol,port:e.port||("https"==e.protocol?443:80),query:e.query||""};c.util.merge(h,d);if(h["force new connection"]||!c.sockets[f])g=new c.Socket(h);return!h["force new connection"]&&g&&(c.sockets[f]=g),g=g||c.sockets[f],g.of(e.path.length>1?e.path:"")}})("object"==typeof module?module.exports:this.io={},this),function(a,b){var c=a.util={},d=/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,e=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];c.parseUri=function(a){var b=d.exec(a||""),c={},f=14;while(f--)c[e[f]]=b[f]||"";return c},c.uniqueUri=function(a){var c=a.protocol,d=a.host,e=a.port;return"document"in b?(d=d||document.domain,e=e||(c=="https"&&document.location.protocol!=="https:"?443:document.location.port)):(d=d||"localhost",!e&&c=="https"&&(e=443)),(c||"http")+"://"+d+":"+(e||80)},c.query=function(a,b){var d=c.chunkQuery(a||""),e=[];c.merge(d,c.chunkQuery(b||""));for(var f in d)d.hasOwnProperty(f)&&e.push(f+"="+d[f]);return e.length?"?"+e.join("&"):""},c.chunkQuery=function(a){var b={},c=a.split("&"),d=0,e=c.length,f;for(;d<e;++d)f=c[d].split("="),f[0]&&(b[f[0]]=f[1]);return b};var f=!1;c.load=function(a){if("document"in b&&document.readyState==="complete"||f)return a();c.on(b,"load",a,!1)},c.on=function(a,b,c,d){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,d)},c.request=function(a){if(a&&"undefined"!=typeof XDomainRequest&&!c.ua.hasCORS)return new XDomainRequest;if("undefined"!=typeof XMLHttpRequest&&(!a||c.ua.hasCORS))return new XMLHttpRequest;if(!a)try{return new(window[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(b){}return null},"undefined"!=typeof window&&c.load(function(){f=!0}),c.defer=function(a){if(!c.ua.webkit||"undefined"!=typeof importScripts)return a();c.load(function(){setTimeout(a,100)})},c.merge=function(b,d,e,f){var g=f||[],h=typeof e=="undefined"?2:e,i;for(i in d)d.hasOwnProperty(i)&&c.indexOf(g,i)<0&&(typeof b[i]!="object"||!h?(b[i]=d[i],g.push(d[i])):c.merge(b[i],d[i],h-1,g));return b},c.mixin=function(a,b){c.merge(a.prototype,b.prototype)},c.inherit=function(a,b){function c(){}c.prototype=b.prototype,a.prototype=new c},c.isArray=Array.isArray||function(a){return Object.prototype.toString.call(a)==="[object Array]"},c.intersect=function(a,b){var d=[],e=a.length>b.length?a:b,f=a.length>b.length?b:a;for(var g=0,h=f.length;g<h;g++)~c.indexOf(e,f[g])&&d.push(f[g]);return d},c.indexOf=function(a,b,c){for(var d=a.length,c=c<0?c+d<0?0:c+d:c||0;c<d&&a[c]!==b;c++);return d<=c?-1:c},c.toArray=function(a){var b=[];for(var c=0,d=a.length;c<d;c++)b.push(a[c]);return b},c.ua={},c.ua.hasCORS="undefined"!=typeof XMLHttpRequest&&function(){try{var a=new XMLHttpRequest}catch(b){return!1}return a.withCredentials!=undefined}(),c.ua.webkit="undefined"!=typeof navigator&&/webkit/i.test(navigator.userAgent),c.ua.iDevice="undefined"!=typeof navigator&&/iPad|iPhone|iPod/i.test(navigator.userAgent)}("undefined"!=typeof io?io:module.exports,this),function(a,b){function c(){}a.EventEmitter=c,c.prototype.on=function(a,c){return this.$events||(this.$events={}),this.$events[a]?b.util.isArray(this.$events[a])?this.$events[a].push(c):this.$events[a]=[this.$events[a],c]:this.$events[a]=c,this},c.prototype.addListener=c.prototype.on,c.prototype.once=function(a,b){function d(){c.removeListener(a,d),b.apply(this,arguments)}var c=this;return d.listener=b,this.on(a,d),this},c.prototype.removeListener=function(a,c){if(this.$events&&this.$events[a]){var d=this.$events[a];if(b.util.isArray(d)){var e=-1;for(var f=0,g=d.length;f<g;f++)if(d[f]===c||d[f].listener&&d[f].listener===c){e=f;break}if(e<0)return this;d.splice(e,1),d.length||delete this.$events[a]}else(d===c||d.listener&&d.listener===c)&&delete this.$events[a]}return this},c.prototype.removeAllListeners=function(a){return a===undefined?(this.$events={},this):(this.$events&&this.$events[a]&&(this.$events[a]=null),this)},c.prototype.listeners=function(a){return this.$events||(this.$events={}),this.$events[a]||(this.$events[a]=[]),b.util.isArray(this.$events[a])||(this.$events[a]=[this.$events[a]]),this.$events[a]},c.prototype.emit=function(a){if(!this.$events)return!1;var c=this.$events[a];if(!c)return!1;var d=Array.prototype.slice.call(arguments,1);if("function"==typeof c)c.apply(this,d);else{if(!b.util.isArray(c))return!1;var e=c.slice();for(var f=0,g=e.length;f<g;f++)e[f].apply(this,d)}return!0}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(exports,nativeJSON){function f(a){return a<10?"0"+a:a}function date(a,b){return isFinite(a.valueOf())?a.getUTCFullYear()+"-"+f(a.getUTCMonth()+1)+"-"+f(a.getUTCDate())+"T"+f(a.getUTCHours())+":"+f(a.getUTCMinutes())+":"+f(a.getUTCSeconds())+"Z":null}function quote(a){return escapable.lastIndex=0,escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i instanceof Date&&(i=date(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";return e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g,e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));return e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g,e}}"use strict";if(nativeJSON&&nativeJSON.parse)return exports.JSON={parse:nativeJSON.parse,stringify:nativeJSON.stringify};var JSON=exports.JSON={},cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")},JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return j=eval("("+text+")"),typeof reviver=="function"?walk({"":j},""):j;throw new SyntaxError("JSON.parse")}}("undefined"!=typeof io?io:module.exports,typeof JSON!="undefined"?JSON:undefined),function(a,b){var c=a.parser={},d=c.packets=["disconnect","connect","heartbeat","message","json","event","ack","error","noop"],e=c.reasons=["transport not supported","client not handshaken","unauthorized"],f=c.advice=["reconnect"],g=b.JSON,h=b.util.indexOf;c.encodePacket=function(a){var b=h(d,a.type),c=a.id||"",i=a.endpoint||"",j=a.ack,k=null;switch(a.type){case"error":var l=a.reason?h(e,a.reason):"",m=a.advice?h(f,a.advice):"";if(l!==""||m!=="")k=l+(m!==""?"+"+m:"");break;case"message":a.data!==""&&(k=a.data);break;case"event":var n={name:a.name};a.args&&a.args.length&&(n.args=a.args),k=g.stringify(n);break;case"json":k=g.stringify(a.data);break;case"connect":a.qs&&(k=a.qs);break;case"ack":k=a.ackId+(a.args&&a.args.length?"+"+g.stringify(a.args):"")}var o=[b,c+(j=="data"?"+":""),i];return k!==null&&k!==undefined&&o.push(k),o.join(":")},c.encodePayload=function(a){var b="";if(a.length==1)return a[0];for(var c=0,d=a.length;c<d;c++){var e=a[c];b+="\ufffd"+e.length+"\ufffd"+a[c]}return b};var i=/([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;c.decodePacket=function(a){var b=a.match(i);if(!b)return{};var c=b[2]||"",a=b[5]||"",h={type:d[b[1]],endpoint:b[4]||""};c&&(h.id=c,b[3]?h.ack="data":h.ack=!0);switch(h.type){case"error":var b=a.split("+");h.reason=e[b[0]]||"",h.advice=f[b[1]]||"";break;case"message":h.data=a||"";break;case"event":try{var j=g.parse(a);h.name=j.name,h.args=j.args}catch(k){}h.args=h.args||[];break;case"json":try{h.data=g.parse(a)}catch(k){}break;case"connect":h.qs=a||"";break;case"ack":var b=a.match(/^([0-9]+)(\+)?(.*)/);if(b){h.ackId=b[1],h.args=[];if(b[3])try{h.args=b[3]?g.parse(b[3]):[]}catch(k){}}break;case"disconnect":case"heartbeat":}return h},c.decodePayload=function(a){if(a.charAt(0)=="\ufffd"){var b=[];for(var d=1,e="";d<a.length;d++)a.charAt(d)=="\ufffd"?(b.push(c.decodePacket(a.substr(d+1).substr(0,e))),d+=Number(e)+1,e=""):e+=a.charAt(d);return b}return[c.decodePacket(a)]}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(a,b){function c(a,b){this.socket=a,this.sessid=b}a.Transport=c,b.util.mixin(c,b.EventEmitter),c.prototype.heartbeats=function(){return!0},c.prototype.onData=function(a){this.clearCloseTimeout(),(this.socket.connected||this.socket.connecting||this.socket.reconnecting)&&this.setCloseTimeout();if(a!==""){var c=b.parser.decodePayload(a);if(c&&c.length)for(var d=0,e=c.length;d<e;d++)this.onPacket(c[d])}return this},c.prototype.onPacket=function(a){return this.socket.setHeartbeatTimeout(),a.type=="heartbeat"?this.onHeartbeat():(a.type=="connect"&&a.endpoint==""&&this.onConnect(),a.type=="error"&&a.advice=="reconnect"&&(this.isOpen=!1),this.socket.onPacket(a),this)},c.prototype.setCloseTimeout=function(){if(!this.closeTimeout){var a=this;this.closeTimeout=setTimeout(function(){a.onDisconnect()},this.socket.closeTimeout)}},c.prototype.onDisconnect=function(){return this.isOpen&&this.close(),this.clearTimeouts(),this.socket.onDisconnect(),this},c.prototype.onConnect=function(){return this.socket.onConnect(),this},c.prototype.clearCloseTimeout=function(){this.closeTimeout&&(clearTimeout(this.closeTimeout),this.closeTimeout=null)},c.prototype.clearTimeouts=function(){this.clearCloseTimeout(),this.reopenTimeout&&clearTimeout(this.reopenTimeout)},c.prototype.packet=function(a){this.send(b.parser.encodePacket(a))},c.prototype.onHeartbeat=function(a){this.packet({type:"heartbeat"})},c.prototype.onOpen=function(){this.isOpen=!0,this.clearCloseTimeout(),this.socket.onOpen()},c.prototype.onClose=function(){var a=this;this.isOpen=!1,this.socket.onClose(),this.onDisconnect()},c.prototype.prepareUrl=function(){var a=this.socket.options;return this.scheme()+"://"+a.host+":"+a.port+"/"+a.resource+"/"+b.protocol+"/"+this.name+"/"+this.sessid},c.prototype.ready=function(a,b){b.call(this)}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(a,b,c){function d(a){this.options={port:80,secure:!1,document:"document"in c?document:!1,resource:"socket.io",transports:b.transports,"connect timeout":1e4,"try multiple transports":!0,reconnect:!0,"reconnection delay":500,"reconnection limit":Infinity,"reopen delay":3e3,"max reconnection attempts":10,"sync disconnect on unload":!1,"auto connect":!0,"flash policy port":10843,manualFlush:!1},b.util.merge(this.options,a),this.connected=!1,this.open=!1,this.connecting=!1,this.reconnecting=!1,this.namespaces={},this.buffer=[],this.doBuffer=!1;if(this.options["sync disconnect on unload"]&&(!this.isXDomain()||b.util.ua.hasCORS)){var d=this;b.util.on(c,"beforeunload",function(){d.disconnectSync()},!1)}this.options["auto connect"]&&this.connect()}function e(){}a.Socket=d,b.util.mixin(d,b.EventEmitter),d.prototype.of=function(a){return this.namespaces[a]||(this.namespaces[a]=new b.SocketNamespace(this,a),a!==""&&this.namespaces[a].packet({type:"connect"})),this.namespaces[a]},d.prototype.publish=function(){this.emit.apply(this,arguments);var a;for(var b in this.namespaces)this.namespaces.hasOwnProperty(b)&&(a=this.of(b),a.$emit.apply(a,arguments))},d.prototype.handshake=function(a){function f(b){b instanceof Error?(c.connecting=!1,c.onError(b.message)):a.apply(null,b.split(":"))}var c=this,d=this.options,g=["http"+(d.secure?"s":"")+":/",d.host+":"+d.port,d.resource,b.protocol,b.util.query(this.options.query,"t="+ +(new Date))].join("/");if(this.isXDomain()&&!b.util.ua.hasCORS){var h=document.getElementsByTagName("script")[0],i=document.createElement("script");i.src=g+"&jsonp="+b.j.length,h.parentNode.insertBefore(i,h),b.j.push(function(a){f(a),i.parentNode.removeChild(i)})}else{var j=b.util.request();j.open("GET",g,!0),this.isXDomain()&&(j.withCredentials=!0),j.onreadystatechange=function(){j.readyState==4&&(j.onreadystatechange=e,j.status==200?f(j.responseText):j.status==403?c.onError(j.responseText):(c.connecting=!1,!c.reconnecting&&c.onError(j.responseText)))},j.send(null)}},d.prototype.getTransport=function(a){var c=a||this.transports,d;for(var e=0,f;f=c[e];e++)if(b.Transport[f]&&b.Transport[f].check(this)&&(!this.isXDomain()||b.Transport[f].xdomainCheck(this)))return new b.Transport[f](this,this.sessionid);return null},d.prototype.connect=function(a){if(this.connecting)return this;var c=this;return c.connecting=!0,this.handshake(function(d,e,f,g){function h(a){c.transport&&c.transport.clearTimeouts(),c.transport=c.getTransport(a);if(!c.transport)return c.publish("connect_failed");c.transport.ready(c,function(){c.connecting=!0,c.publish("connecting",c.transport.name),c.transport.open(),c.options["connect timeout"]&&(c.connectTimeoutTimer=setTimeout(function(){if(!c.connected){c.connecting=!1;if(c.options["try multiple transports"]){var a=c.transports;while(a.length>0&&a.splice(0,1)[0]!=c.transport.name);a.length?h(a):c.publish("connect_failed")}}},c.options["connect timeout"]))})}c.sessionid=d,c.closeTimeout=f*1e3,c.heartbeatTimeout=e*1e3,c.transports||(c.transports=c.origTransports=g?b.util.intersect(g.split(","),c.options.transports):c.options.transports),c.setHeartbeatTimeout(),h(c.transports),c.once("connect",function(){clearTimeout(c.connectTimeoutTimer),a&&typeof a=="function"&&a()})}),this},d.prototype.setHeartbeatTimeout=function(){clearTimeout(this.heartbeatTimeoutTimer);if(this.transport&&!this.transport.heartbeats())return;var a=this;this.heartbeatTimeoutTimer=setTimeout(function(){a.transport.onClose()},this.heartbeatTimeout)},d.prototype.packet=function(a){return this.connected&&!this.doBuffer?this.transport.packet(a):this.buffer.push(a),this},d.prototype.setBuffer=function(a){this.doBuffer=a,!a&&this.connected&&this.buffer.length&&(this.options.manualFlush||this.flushBuffer())},d.prototype.flushBuffer=function(){this.transport.payload(this.buffer),this.buffer=[]},d.prototype.disconnect=function(){if(this.connected||this.connecting)this.open&&this.of("").packet({type:"disconnect"}),this.onDisconnect("booted");return this},d.prototype.disconnectSync=function(){var a=b.util.request(),c=["http"+(this.options.secure?"s":"")+":/",this.options.host+":"+this.options.port,this.options.resource,b.protocol,"",this.sessionid].join("/")+"/?disconnect=1";a.open("GET",c,!1),a.send(null),this.onDisconnect("booted")},d.prototype.isXDomain=function(){var a=c.location.port||("https:"==c.location.protocol?443:80);return this.options.host!==c.location.hostname||this.options.port!=a},d.prototype.onConnect=function(){this.connected||(this.connected=!0,this.connecting=!1,this.doBuffer||this.setBuffer(!1),this.emit("connect"))},d.prototype.onOpen=function(){this.open=!0},d.prototype.onClose=function(){this.open=!1,clearTimeout(this.heartbeatTimeoutTimer)},d.prototype.onPacket=function(a){this.of(a.endpoint).onPacket(a)},d.prototype.onError=function(a){a&&a.advice&&a.advice==="reconnect"&&(this.connected||this.connecting)&&(this.disconnect(),this.options.reconnect&&this.reconnect()),this.publish("error",a&&a.reason?a.reason:a)},d.prototype.onDisconnect=function(a){var b=this.connected,c=this.connecting;this.connected=!1,this.connecting=!1,this.open=!1;if(b||c)this.transport.close(),this.transport.clearTimeouts(),b&&(this.publish("disconnect",a),"booted"!=a&&this.options.reconnect&&!this.reconnecting&&this.reconnect())},d.prototype.reconnect=function(){function e(){if(a.connected){for(var b in a.namespaces)a.namespaces.hasOwnProperty(b)&&""!==b&&a.namespaces[b].packet({type:"connect"});a.publish("reconnect",a.transport.name,a.reconnectionAttempts)}clearTimeout(a.reconnectionTimer),a.removeListener("connect_failed",f),a.removeListener("connect",f),a.reconnecting=!1,delete a.reconnectionAttempts,delete a.reconnectionDelay,delete a.reconnectionTimer,delete a.redoTransports,a.options["try multiple transports"]=c}function f(){if(!a.reconnecting)return;if(a.connected)return e();if(a.connecting&&a.reconnecting)return a.reconnectionTimer=setTimeout(f,1e3);a.reconnectionAttempts++>=b?a.redoTransports?(a.publish("reconnect_failed"),e()):(a.on("connect_failed",f),a.options["try multiple transports"]=!0,a.transports=a.origTransports,a.transport=a.getTransport(),a.redoTransports=!0,a.connect()):(a.reconnectionDelay<d&&(a.reconnectionDelay*=2),a.connect(),a.publish("reconnecting",a.reconnectionDelay,a.reconnectionAttempts),a.reconnectionTimer=setTimeout(f,a.reconnectionDelay))}this.reconnecting=!0,this.reconnectionAttempts=0,this.reconnectionDelay=this.options["reconnection delay"];var a=this,b=this.options["max reconnection attempts"],c=this.options["try multiple transports"],d=this.options["reconnection limit"];this.options["try multiple transports"]=!1,this.reconnectionTimer=setTimeout(f,this.reconnectionDelay),this.on("connect",f)}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),function(a,b){function c(a,b){this.socket=a,this.name=b||"",this.flags={},this.json=new d(this,"json"),this.ackPackets=0,this.acks={}}function d(a,b){this.namespace=a,this.name=b}a.SocketNamespace=c,b.util.mixin(c,b.EventEmitter),c.prototype.$emit=b.EventEmitter.prototype.emit,c.prototype.of=function(){return this.socket.of.apply(this.socket,arguments)},c.prototype.packet=function(a){return a.endpoint=this.name,this.socket.packet(a),this.flags={},this},c.prototype.send=function(a,b){var c={type:this.flags.json?"json":"message",data:a};return"function"==typeof b&&(c.id=++this.ackPackets,c.ack=!0,this.acks[c.id]=b),this.packet(c)},c.prototype.emit=function(a){var b=Array.prototype.slice.call(arguments,1),c=b[b.length-1],d={type:"event",name:a};return"function"==typeof c&&(d.id=++this.ackPackets,d.ack="data",this.acks[d.id]=c,b=b.slice(0,b.length-1)),d.args=b,this.packet(d)},c.prototype.disconnect=function(){return this.name===""?this.socket.disconnect():(this.packet({type:"disconnect"}),this.$emit("disconnect")),this},c.prototype.onPacket=function(a){function d(){c.packet({type:"ack",args:b.util.toArray(arguments),ackId:a.id})}var c=this;switch(a.type){case"connect":this.$emit("connect");break;case"disconnect":this.name===""?this.socket.onDisconnect(a.reason||"booted"):this.$emit("disconnect",a.reason);break;case"message":case"json":var e=["message",a.data];a.ack=="data"?e.push(d):a.ack&&this.packet({type:"ack",ackId:a.id}),this.$emit.apply(this,e);break;case"event":var e=[a.name].concat(a.args);a.ack=="data"&&e.push(d),this.$emit.apply(this,e);break;case"ack":this.acks[a.ackId]&&(this.acks[a.ackId].apply(this,a.args),delete this.acks[a.ackId]);break;case"error":a.advice?this.socket.onError(a):a.reason=="unauthorized"?this.$emit("connect_failed",a.reason):this.$emit("error",a.reason)}},d.prototype.send=function(){this.namespace.flags[this.name]=!0,this.namespace.send.apply(this.namespace,arguments)},d.prototype.emit=function(){this.namespace.flags[this.name]=!0,this.namespace.emit.apply(this.namespace,arguments)}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(a,b,c){function d(a){b.Transport.apply(this,arguments)}a.websocket=d,b.util.inherit(d,b.Transport),d.prototype.name="websocket",d.prototype.open=function(){var a=b.util.query(this.socket.options.query),d=this,e;return e||(e=c.MozWebSocket||c.WebSocket),this.websocket=new e(this.prepareUrl()+a),this.websocket.onopen=function(){d.onOpen(),d.socket.setBuffer(!1)},this.websocket.onmessage=function(a){d.onData(a.data)},this.websocket.onclose=function(){d.onClose(),d.socket.setBuffer(!0)},this.websocket.onerror=function(a){d.onError(a)},this},b.util.ua.iDevice?d.prototype.send=function(a){var b=this;return setTimeout(function(){b.websocket.send(a)},0),this}:d.prototype.send=function(a){return this.websocket.send(a),this},d.prototype.payload=function(a){for(var b=0,c=a.length;b<c;b++)this.packet(a[b]);return this},d.prototype.close=function(){return this.websocket.close(),this},d.prototype.onError=function(a){this.socket.onError(a)},d.prototype.scheme=function(){return this.socket.options.secure?"wss":"ws"},d.check=function(){return"WebSocket"in c&&!("__addTask"in WebSocket)||"MozWebSocket"in c},d.xdomainCheck=function(){return!0},b.transports.push("websocket")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),function(a,b){function c(){b.Transport.websocket.apply(this,arguments)}a.flashsocket=c,b.util.inherit(c,b.Transport.websocket),c.prototype.name="flashsocket",c.prototype.open=function(){var a=this,c=arguments;return WebSocket.__addTask(function(){b.Transport.websocket.prototype.open.apply(a,c)}),this},c.prototype.send=function(){var a=this,c=arguments;return WebSocket.__addTask(function(){b.Transport.websocket.prototype.send.apply(a,c)}),this},c.prototype.close=function(){return WebSocket.__tasks.length=0,b.Transport.websocket.prototype.close.call(this),this},c.prototype.ready=function(a,d){function e(){var b=a.options,e=b["flash policy port"],g=["http"+(b.secure?"s":"")+":/",b.host+":"+b.port,b.resource,"static/flashsocket","WebSocketMain"+(a.isXDomain()?"Insecure":"")+".swf"];c.loaded||(typeof WEB_SOCKET_SWF_LOCATION=="undefined"&&(WEB_SOCKET_SWF_LOCATION=g.join("/")),e!==843&&WebSocket.loadFlashPolicyFile("xmlsocket://"+b.host+":"+e),WebSocket.__initialize(),c.loaded=!0),d.call(f)}var f=this;if(document.body)return e();b.util.load(e)},c.check=function(){return typeof WebSocket!="undefined"&&"__initialize"in WebSocket&&!!swfobject?swfobject.getFlashPlayerVersion().major>=10:!1},c.xdomainCheck=function(){return!0},typeof window!="undefined"&&(WEB_SOCKET_DISABLE_AUTO_INITIALIZATION=!0),b.transports.push("flashsocket")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports);if("undefined"!=typeof window)var swfobject=function(){function A(){if(t)return;try{var a=i.getElementsByTagName("body")[0].appendChild(Q("span"));a.parentNode.removeChild(a)}catch(b){return}t=!0;var c=l.length;for(var d=0;d<c;d++)l[d]()}function B(a){t?a():l[l.length]=a}function C(b){if(typeof h.addEventListener!=a)h.addEventListener("load",b,!1);else if(typeof i.addEventListener!=a)i.addEventListener("load",b,!1);else if(typeof h.attachEvent!=a)R(h,"onload",b);else if(typeof h.onload=="function"){var c=h.onload;h.onload=function(){c(),b()}}else h.onload=b}function D(){k?E():F()}function E(){var c=i.getElementsByTagName("body")[0],d=Q(b);d.setAttribute("type",e);var f=c.appendChild(d);if(f){var g=0;(function(){if(typeof f.GetVariable!=a){var b=f.GetVariable("$version");b&&(b=b.split(" ")[1].split(","),y.pv=[parseInt(b[0],10),parseInt(b[1],10),parseInt(b[2],10)])}else if(g<10){g++,setTimeout(arguments.callee,10);return}c.removeChild(d),f=null,F()})()}else F()}function F(){var b=m.length;if(b>0)for(var c=0;c<b;c++){var d=m[c].id,e=m[c].callbackFn,f={success:!1,id:d};if(y.pv[0]>0){var g=P(d);if(g)if(S(m[c].swfVersion)&&!(y.wk&&y.wk<312))U(d,!0),e&&(f.success=!0,f.ref=G(d),e(f));else if(m[c].expressInstall&&H()){var h={};h.data=m[c].expressInstall,h.width=g.getAttribute("width")||"0",h.height=g.getAttribute("height")||"0",g.getAttribute("class")&&(h.styleclass=g.getAttribute("class")),g.getAttribute("align")&&(h.align=g.getAttribute("align"));var i={},j=g.getElementsByTagName("param"),k=j.length;for(var l=0;l<k;l++)j[l].getAttribute("name").toLowerCase()!="movie"&&(i[j[l].getAttribute("name")]=j[l].getAttribute("value"));I(h,i,d,e)}else J(g),e&&e(f)}else{U(d,!0);if(e){var n=G(d);n&&typeof n.SetVariable!=a&&(f.success=!0,f.ref=n),e(f)}}}}function G(c){var d=null,e=P(c);if(e&&e.nodeName=="OBJECT")if(typeof e.SetVariable!=a)d=e;else{var f=e.getElementsByTagName(b)[0];f&&(d=f)}return d}function H(){return!u&&S("6.0.65")&&(y.win||y.mac)&&!(y.wk&&y.wk<312)}function I(b,c,d,e){u=!0,r=e||null,s={success:!1,id:d};var g=P(d);if(g){g.nodeName=="OBJECT"?(p=K(g),q=null):(p=g,q=d),b.id=f;if(typeof b.width==a||!/%$/.test(b.width)&&parseInt(b.width,10)<310)b.width="310";if(typeof b.height==a||!/%$/.test(b.height)&&parseInt(b.height,10)<137)b.height="137";i.title=i.title.slice(0,47)+" - Flash Player Installation";var j=y.ie&&y.win?["Active"].concat("").join("X"):"PlugIn",k="MMredirectURL="+h.location.toString().replace(/&/g,"%26")+"&MMplayerType="+j+"&MMdoctitle="+i.title;typeof c.flashvars!=a?c.flashvars+="&"+k:c.flashvars=k;if(y.ie&&y.win&&g.readyState!=4){var l=Q("div");d+="SWFObjectNew",l.setAttribute("id",d),g.parentNode.insertBefore(l,g),g.style.display="none",function(){g.readyState==4?g.parentNode.removeChild(g):setTimeout(arguments.callee,10)}()}L(b,c,d)}}function J(a){if(y.ie&&y.win&&a.readyState!=4){var b=Q("div");a.parentNode.insertBefore(b,a),b.parentNode.replaceChild(K(a),b),a.style.display="none",function(){a.readyState==4?a.parentNode.removeChild(a):setTimeout(arguments.callee,10)}()}else a.parentNode.replaceChild(K(a),a)}function K(a){var c=Q("div");if(y.win&&y.ie)c.innerHTML=a.innerHTML;else{var d=a.getElementsByTagName(b)[0];if(d){var e=d.childNodes;if(e){var f=e.length;for(var g=0;g<f;g++)(e[g].nodeType!=1||e[g].nodeName!="PARAM")&&e[g].nodeType!=8&&c.appendChild(e[g].cloneNode(!0))}}}return c}function L(c,d,f){var g,h=P(f);if(y.wk&&y.wk<312)return g;if(h){typeof c.id==a&&(c.id=f);if(y.ie&&y.win){var i="";for(var j in c)c[j]!=Object.prototype[j]&&(j.toLowerCase()=="data"?d.movie=c[j]:j.toLowerCase()=="styleclass"?i+=' class="'+c[j]+'"':j.toLowerCase()!="classid"&&(i+=" "+j+'="'+c[j]+'"'));var k="";for(var l in d)d[l]!=Object.prototype[l]&&(k+='<param name="'+l+'" value="'+d[l]+'" />');h.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+i+">"+k+"</object>",n[n.length]=c.id,g=P(c.id)}else{var m=Q(b);m.setAttribute("type",e);for(var o in c)c[o]!=Object.prototype[o]&&(o.toLowerCase()=="styleclass"?m.setAttribute("class",c[o]):o.toLowerCase()!="classid"&&m.setAttribute(o,c[o]));for(var p in d)d[p]!=Object.prototype[p]&&p.toLowerCase()!="movie"&&M(m,p,d[p]);h.parentNode.replaceChild(m,h),g=m}}return g}function M(a,b,c){var d=Q("param");d.setAttribute("name",b),d.setAttribute("value",c),a.appendChild(d)}function N(a){var b=P(a);b&&b.nodeName=="OBJECT"&&(y.ie&&y.win?(b.style.display="none",function(){b.readyState==4?O(a):setTimeout(arguments.callee,10)}()):b.parentNode.removeChild(b))}function O(a){var b=P(a);if(b){for(var c in b)typeof b[c]=="function"&&(b[c]=null);b.parentNode.removeChild(b)}}function P(a){var b=null;try{b=i.getElementById(a)}catch(c){}return b}function Q(a){return i.createElement(a)}function R(a,b,c){a.attachEvent(b,c),o[o.length]=[a,b,c]}function S(a){var b=y.pv,c=a.split(".");return c[0]=parseInt(c[0],10),c[1]=parseInt(c[1],10)||0,c[2]=parseInt(c[2],10)||0,b[0]>c[0]||b[0]==c[0]&&b[1]>c[1]||b[0]==c[0]&&b[1]==c[1]&&b[2]>=c[2]?!0:!1}function T(c,d,e,f){if(y.ie&&y.mac)return;var g=i.getElementsByTagName("head")[0];if(!g)return;var h=e&&typeof e=="string"?e:"screen";f&&(v=null,w=null);if(!v||w!=h){var j=Q("style");j.setAttribute("type","text/css"),j.setAttribute("media",h),v=g.appendChild(j),y.ie&&y.win&&typeof i.styleSheets!=a&&i.styleSheets.length>0&&(v=i.styleSheets[i.styleSheets.length-1]),w=h}y.ie&&y.win?v&&typeof v.addRule==b&&v.addRule(c,d):v&&typeof i.createTextNode!=a&&v.appendChild(i.createTextNode(c+" {"+d+"}"))}function U(a,b){if(!x)return;var c=b?"visible":"hidden";t&&P(a)?P(a).style.visibility=c:T("#"+a,"visibility:"+c)}function V(b){var c=/[\\\"<>\.;]/,d=c.exec(b)!=null;return d&&typeof encodeURIComponent!=a?encodeURIComponent(b):b}var a="undefined",b="object",c="Shockwave Flash",d="ShockwaveFlash.ShockwaveFlash",e="application/x-shockwave-flash",f="SWFObjectExprInst",g="onreadystatechange",h=window,i=document,j=navigator,k=!1,l=[D],m=[],n=[],o=[],p,q,r,s,t=!1,u=!1,v,w,x=!0,y=function(){var f=typeof i.getElementById!=a&&typeof i.getElementsByTagName!=a&&typeof i.createElement!=a,g=j.userAgent.toLowerCase(),l=j.platform.toLowerCase(),m=l?/win/.test(l):/win/.test(g),n=l?/mac/.test(l):/mac/.test(g),o=/webkit/.test(g)?parseFloat(g.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):!1,p=!1,q=[0,0,0],r=null;if(typeof j.plugins!=a&&typeof j.plugins[c]==b)r=j.plugins[c].description,r&&(typeof j.mimeTypes==a||!j.mimeTypes[e]||!!j.mimeTypes[e].enabledPlugin)&&(k=!0,p=!1,r=r.replace(/^.*\s+(\S+\s+\S+$)/,"$1"),q[0]=parseInt(r.replace(/^(.*)\..*$/,"$1"),10),q[1]=parseInt(r.replace(/^.*\.(.*)\s.*$/,"$1"),10),q[2]=/[a-zA-Z]/.test(r)?parseInt(r.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0);else if(typeof h[["Active"].concat("Object").join("X")]!=a)try{var s=new(window[["Active"].concat("Object").join("X")])(d);s&&(r=s.GetVariable("$version"),r&&(p=!0,r=r.split(" ")[1].split(","),q=[parseInt(r[0],10),parseInt(r[1],10),parseInt(r[2],10)]))}catch(t){}return{w3:f,pv:q,wk:o,ie:p,win:m,mac:n}}(),z=function(){if(!y.w3)return;(typeof i.readyState!=a&&i.readyState=="complete"||typeof i.readyState==a&&(i.getElementsByTagName("body")[0]||i.body))&&A(),t||(typeof i.addEventListener!=a&&i.addEventListener("DOMContentLoaded",A,!1),y.ie&&y.win&&(i.attachEvent(g,function(){i.readyState=="complete"&&(i.detachEvent(g,arguments.callee),A())}),h==top&&function(){if(t)return;try{i.documentElement.doScroll("left")}catch(a){setTimeout(arguments.callee,0);return}A()}()),y.wk&&function(){if(t)return;if(!/loaded|complete/.test(i.readyState)){setTimeout(arguments.callee,0);return}A()}(),C(A))}(),W=function(){y.ie&&y.win&&window.attachEvent("onunload",function(){var a=o.length;for(var b=0;b<a;b++)o[b][0].detachEvent(o[b][1],o[b][2]);var c=n.length;for(var d=0;d<c;d++)N(n[d]);for(var e in y)y[e]=null;y=null;for(var f in swfobject)swfobject[f]=null;swfobject=null})}();return{registerObject:function(a,b,c,d){if(y.w3&&a&&b){var e={};e.id=a,e.swfVersion=b,e.expressInstall=c,e.callbackFn=d,m[m.length]=e,U(a,!1)}else d&&d({success:!1,id:a})},getObjectById:function(a){if(y.w3)return G(a)},embedSWF:function(c,d,e,f,g,h,i,j,k,l){var m={success:!1,id:d};y.w3&&!(y.wk&&y.wk<312)&&c&&d&&e&&f&&g?(U(d,!1),B(function(){e+="",f+="";var n={};if(k&&typeof k===b)for(var o in k)n[o]=k[o];n.data=c,n.width=e,n.height=f;var p={};if(j&&typeof j===b)for(var q in j)p[q]=j[q];if(i&&typeof i===b)for(var r in i)typeof p.flashvars!=a?p.flashvars+="&"+r+"="+i[r]:p.flashvars=r+"="+i[r];if(S(g)){var s=L(n,p,d);n.id==d&&U(d,!0),m.success=!0,m.ref=s}else{if(h&&H()){n.data=h,I(n,p,d,l);return}U(d,!0)}l&&l(m)})):l&&l(m)},switchOffAutoHideShow:function(){x=!1},ua:y,getFlashPlayerVersion:function(){return{major:y.pv[0],minor:y.pv[1],release:y.pv[2]}},hasFlashPlayerVersion:S,createSWF:function(a,b,c){return y.w3?L(a,b,c):undefined},showExpressInstall:function(a,b,c,d){y.w3&&H()&&I(a,b,c,d)},removeSWF:function(a){y.w3&&N(a)},createCSS:function(a,b,c,d){y.w3&&T(a,b,c,d)},addDomLoadEvent:B,addLoadEvent:C,getQueryParamValue:function(a){var b=i.location.search||i.location.hash;if(b){/\?/.test(b)&&(b=b.split("?")[1]);if(a==null)return V(b);var c=b.split("&");for(var d=0;d<c.length;d++)if(c[d].substring(0,c[d].indexOf("="))==a)return V(c[d].substring(c[d].indexOf("=")+1))}return""},expressInstallCallback:function(){if(u){var a=P(f);a&&p&&(a.parentNode.replaceChild(p,a),q&&(U(q,!0),y.ie&&y.win&&(p.style.display="block")),r&&r(s)),u=!1}}}}();(function(){if("undefined"==typeof window||window.WebSocket)return;var a=window.console;if(!a||!a.log||!a.error)a={log:function(){},error:function(){}};if(!swfobject.hasFlashPlayerVersion("10.0.0")){a.error("Flash Player >= 10.0.0 is required.");return}location.protocol=="file:"&&a.error("WARNING: web-socket-js doesn't work in file:///... URL unless you set Flash Security Settings properly. Open the page via Web server i.e. http://..."),WebSocket=function(a,b,c,d,e){var f=this;f.__id=WebSocket.__nextId++,WebSocket.__instances[f.__id]=f,f.readyState=WebSocket.CONNECTING,f.bufferedAmount=0,f.__events={},b?typeof b=="string"&&(b=[b]):b=[],setTimeout(function(){WebSocket.__addTask(function(){WebSocket.__flash.create(f.__id,a,b,c||null,d||0,e||null)})},0)},WebSocket.prototype.send=function(a){if(this.readyState==WebSocket.CONNECTING)throw"INVALID_STATE_ERR: Web Socket connection has not been established";var b=WebSocket.__flash.send(this.__id,encodeURIComponent(a));return b<0?!0:(this.bufferedAmount+=b,!1)},WebSocket.prototype.close=function(){if(this.readyState==WebSocket.CLOSED||this.readyState==WebSocket.CLOSING)return;this.readyState=WebSocket.CLOSING,WebSocket.__flash.close(this.__id)},WebSocket.prototype.addEventListener=function(a,b,c){a in this.__events||(this.__events[a]=[]),this.__events[a].push(b)},WebSocket.prototype.removeEventListener=function(a,b,c){if(!(a in this.__events))return;var d=this.__events[a];for(var e=d.length-1;e>=0;--e)if(d[e]===b){d.splice(e,1);break}},WebSocket.prototype.dispatchEvent=function(a){var b=this.__events[a.type]||[];for(var c=0;c<b.length;++c)b[c](a);var d=this["on"+a.type];d&&d(a)},WebSocket.prototype.__handleEvent=function(a){"readyState"in a&&(this.readyState=a.readyState),"protocol"in a&&(this.protocol=a.protocol);var b;if(a.type=="open"||a.type=="error")b=this.__createSimpleEvent(a.type);else if(a.type=="close")b=this.__createSimpleEvent("close");else{if(a.type!="message")throw"unknown event type: "+a.type;var c=decodeURIComponent(a.message);b=this.__createMessageEvent("message",c)}this.dispatchEvent(b)},WebSocket.prototype.__createSimpleEvent=function(a){if(document.createEvent&&window.Event){var b=document.createEvent("Event");return b.initEvent(a,!1,!1),b}return{type:a,bubbles:!1,cancelable:!1}},WebSocket.prototype.__createMessageEvent=function(a,b){if(document.createEvent&&window.MessageEvent&&!window.opera){var c=document.createEvent("MessageEvent");return c.initMessageEvent("message",!1,!1,b,null,null,window,null),c}return{type:a,data:b,bubbles:!1,cancelable:!1}},WebSocket.CONNECTING=0,WebSocket.OPEN=1,WebSocket.CLOSING=2,WebSocket.CLOSED=3,WebSocket.__flash=null,WebSocket.__instances={},WebSocket.__tasks=[],WebSocket.__nextId=0,WebSocket.loadFlashPolicyFile=function(a){WebSocket.__addTask(function(){WebSocket.__flash.loadManualPolicyFile(a)})},WebSocket.__initialize=function(){if(WebSocket.__flash)return;WebSocket.__swfLocation&&(window.WEB_SOCKET_SWF_LOCATION=WebSocket.__swfLocation);if(!window.WEB_SOCKET_SWF_LOCATION){a.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");return}var b=document.createElement("div");b.id="webSocketContainer",b.style.position="absolute",WebSocket.__isFlashLite()?(b.style.left="0px",b.style.top="0px"):(b.style.left="-100px",b.style.top="-100px");var c=document.createElement("div");c.id="webSocketFlash",b.appendChild(c),document.body.appendChild(b),swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION,"webSocketFlash","1","1","10.0.0",null,null,{hasPriority:!0,swliveconnect:!0,allowScriptAccess:"always"},null,function(b){b.success||a.error("[WebSocket] swfobject.embedSWF failed")})},WebSocket.__onFlashInitialized=function(){setTimeout(function(){WebSocket.__flash=document.getElementById("webSocketFlash"),WebSocket.__flash.setCallerUrl(location.href),WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);for(var a=0;a<WebSocket.__tasks.length;++a)WebSocket.__tasks[a]();WebSocket.__tasks=[]},0)},WebSocket.__onFlashEvent=function(){return setTimeout(function(){try{var b=WebSocket.__flash.receiveEvents();for(var c=0;c<b.length;++c)WebSocket.__instances[b[c].webSocketId].__handleEvent(b[c])}catch(d){a.error(d)}},0),!0},WebSocket.__log=function(b){a.log(decodeURIComponent(b))},WebSocket.__error=function(b){a.error(decodeURIComponent(b))},WebSocket.__addTask=function(a){WebSocket.__flash?a():WebSocket.__tasks.push(a)},WebSocket.__isFlashLite=function(){if(!window.navigator||!window.navigator.mimeTypes)return!1;var a=window.navigator.mimeTypes["application/x-shockwave-flash"];return!a||!a.enabledPlugin||!a.enabledPlugin.filename?!1:a.enabledPlugin.filename.match(/flashlite/i)?!0:!1},window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION||(window.addEventListener?window.addEventListener("load",function(){WebSocket.__initialize()},!1):window.attachEvent("onload",function(){WebSocket.__initialize()}))})(),function(a,b,c){function d(a){if(!a)return;b.Transport.apply(this,arguments),this.sendBuffer=[]}function e(){}a.XHR=d,b.util.inherit(d,b.Transport),d.prototype.open=function(){return this.socket.setBuffer(!1),this.onOpen(),this.get(),this.setCloseTimeout(),this},d.prototype.payload=function(a){var c=[];for(var d=0,e=a.length;d<e;d++)c.push(b.parser.encodePacket(a[d]));this.send(b.parser.encodePayload(c))},d.prototype.send=function(a){return this.post(a),this},d.prototype.post=function(a){function d(){this.readyState==4&&(this.onreadystatechange=e,b.posting=!1,this.status==200?b.socket.setBuffer(!1):b.onClose())}function f(){this.onload=e,b.socket.setBuffer(!1)}var b=this;this.socket.setBuffer(!0),this.sendXHR=this.request("POST"),c.XDomainRequest&&this.sendXHR instanceof XDomainRequest?this.sendXHR.onload=this.sendXHR.onerror=f:this.sendXHR.onreadystatechange=d,this.sendXHR.send(a)},d.prototype.close=function(){return this.onClose(),this},d.prototype.request=function(a){var c=b.util.request(this.socket.isXDomain()),d=b.util.query(this.socket.options.query,"t="+ +(new Date));c.open(a||"GET",this.prepareUrl()+d,!0);if(a=="POST")try{c.setRequestHeader?c.setRequestHeader("Content-type","text/plain;charset=UTF-8"):c.contentType="text/plain"}catch(e){}return c},d.prototype.scheme=function(){return this.socket.options.secure?"https":"http"},d.check=function(a,d){try{var e=b.util.request(d),f=c.XDomainRequest&&e instanceof XDomainRequest,g=a&&a.options&&a.options.secure?"https:":"http:",h=c.location&&g!=c.location.protocol;if(e&&(!f||!h))return!0}catch(i){}return!1},d.xdomainCheck=function(a){return d.check(a,!0)}}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),function(a,b){function c(a){b.Transport.XHR.apply(this,arguments)}a.htmlfile=c,b.util.inherit(c,b.Transport.XHR),c.prototype.name="htmlfile",c.prototype.get=function(){this.doc=new(window[["Active"].concat("Object").join("X")])("htmlfile"),this.doc.open(),this.doc.write("<html></html>"),this.doc.close(),this.doc.parentWindow.s=this;var a=this.doc.createElement("div");a.className="socketio",this.doc.body.appendChild(a),this.iframe=this.doc.createElement("iframe"),a.appendChild(this.iframe);var c=this,d=b.util.query(this.socket.options.query,"t="+ +(new Date));this.iframe.src=this.prepareUrl()+d,b.util.on(window,"unload",function(){c.destroy()})},c.prototype._=function(a,b){this.onData(a);try{var c=b.getElementsByTagName("script")[0];c.parentNode.removeChild(c)}catch(d){}},c.prototype.destroy=function(){if(this.iframe){try{this.iframe.src="about:blank"}catch(a){}this.doc=null,this.iframe.parentNode.removeChild(this.iframe),this.iframe=null,CollectGarbage()}},c.prototype.close=function(){return this.destroy(),b.Transport.XHR.prototype.close.call(this)},c.check=function(a){if(typeof window!="undefined"&&["Active"].concat("Object").join("X")in window)try{var c=new(window[["Active"].concat("Object").join("X")])("htmlfile");return c&&b.Transport.XHR.check(a)}catch(d){}return!1},c.xdomainCheck=function(){return!1},b.transports.push("htmlfile")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(a,b,c){function d(){b.Transport.XHR.apply(this,arguments)}function e(){}a["xhr-polling"]=d,b.util.inherit(d,b.Transport.XHR),b.util.merge(d,b.Transport.XHR),d.prototype.name="xhr-polling",d.prototype.heartbeats=function(){return!1},d.prototype.open=function(){var a=this;return b.Transport.XHR.prototype.open.call(a),!1},d.prototype.get=function(){function b(){this.readyState==4&&(this.onreadystatechange=e,this.status==200?(a.onData(this.responseText),a.get()):a.onClose())}function d(){this.onload=e,this.onerror=e,a.retryCounter=1,a.onData(this.responseText),a.get()}function f(){a.retryCounter++,!a.retryCounter||a.retryCounter>3?a.onClose():a.get()}if(!this.isOpen)return;var a=this;this.xhr=this.request(),c.XDomainRequest&&this.xhr instanceof XDomainRequest?(this.xhr.onload=d,this.xhr.onerror=f):this.xhr.onreadystatechange=b,this.xhr.send(null)},d.prototype.onClose=function(){b.Transport.XHR.prototype.onClose.call(this);if(this.xhr){this.xhr.onreadystatechange=this.xhr.onload=this.xhr.onerror=e;try{this.xhr.abort()}catch(a){}this.xhr=null}},d.prototype.ready=function(a,c){var d=this;b.util.defer(function(){c.call(d)})},b.transports.push("xhr-polling")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),function(a,b,c){function e(a){b.Transport["xhr-polling"].apply(this,arguments),this.index=b.j.length;var c=this;b.j.push(function(a){c._(a)})}var d=c.document&&"MozAppearance"in c.document.documentElement.style;a["jsonp-polling"]=e,b.util.inherit(e,b.Transport["xhr-polling"]),e.prototype.name="jsonp-polling",e.prototype.post=function(a){function i(){j(),c.socket.setBuffer(!1)}function j(){c.iframe&&c.form.removeChild(c.iframe);try{h=document.createElement('<iframe name="'+c.iframeId+'">')}catch(a){h=document.createElement("iframe"),h.name=c.iframeId}h.id=c.iframeId,c.form.appendChild(h),c.iframe=h}var c=this,d=b.util.query(this.socket.options.query,"t="+ +(new Date)+"&i="+this.index);if(!this.form){var e=document.createElement("form"),f=document.createElement("textarea"),g=this.iframeId="socketio_iframe_"+this.index,h;e.className="socketio",e.style.position="absolute",e.style.top="0px",e.style.left="0px",e.style.display="none",e.target=g,e.method="POST",e.setAttribute("accept-charset","utf-8"),f.name="d",e.appendChild(f),document.body.appendChild(e),this.form=e,this.area=f}this.form.action=this.prepareUrl()+d,j(),this.area.value=b.JSON.stringify(a);try{this.form.submit()}catch(k){}this.iframe.attachEvent?h.onreadystatechange=function(){c.iframe.readyState=="complete"&&i()}:this.iframe.onload=i,this.socket.setBuffer(!0)},e.prototype.get=function(){var a=this,c=document.createElement("script"),e=b.util.query(this.socket.options.query,"t="+ +(new Date)+"&i="+this.index);this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),c.async=!0,c.src=this.prepareUrl()+e,c.onerror=function(){a.onClose()};var f=document.getElementsByTagName("script")[0];f.parentNode.insertBefore(c,f),this.script=c,d&&setTimeout(function(){var a=document.createElement("iframe");document.body.appendChild(a),document.body.removeChild(a)},100)},e.prototype._=function(a){return this.onData(a),this.isOpen&&this.get(),this},e.prototype.ready=function(a,c){var e=this;if(!d)return c.call(this);b.util.load(function(){c.call(e)})},e.check=function(){return"document"in c},e.xdomainCheck=function(){return!0},b.transports.push("jsonp-polling")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),typeof define=="function"&&define.amd&&define([],function(){return io})})()
},{}],33:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeStreamComponent', function ($ige, $time, igeBase, IgeEventingClass) {
	/**
	 * Adds stream capabilities to the network system.
	 */
	var IgeStreamComponent = IgeEventingClass.extend({
		classId: 'IgeStreamComponent',
		componentId: 'stream',
		
		/**
		 * @constructor
		 * @param entity
		 * @param options
		 */
		init: function (entity, options) {
			this._network = entity;
			this._options = options;
			
			var self = this;
			
			// Set the stream data section designator character
			this._sectionDesignator = '';
			
			/* CEXCLUDE */
			if ($ige.isServer) {
				// Define the network stream command
				this._network.define('_igeStreamCreate');
				this._network.define('_igeStreamDestroy');
				this._network.define('_igeStreamData');
				this._network.define('_igeStreamTime');
				
				// Define the object that will hold the stream data queue
				this._queuedData = {};
				
				// Set some stream data containers
				this._streamClientData = {};
				this._streamClientCreated = {};
			}
			/* CEXCLUDE */
			
			if ($ige.isClient) {
				// Define the network stream command
				this._network.define('_igeStreamCreate', function () {
					self._onStreamCreate.apply(self, arguments);
				});
				this._network.define('_igeStreamDestroy', function () {
					self._onStreamDestroy.apply(self, arguments);
				});
				this._network.define('_igeStreamData', function () {
					self._onStreamData.apply(self, arguments);
				});
				this._network.define('_igeStreamTime', function () {
					self._onStreamTime.apply(self, arguments);
				});
			}
			
			// Set some defaults
			this._renderLatency = 100;
			this._streamInterval = 50;
		},
		
		/**
		 * Gets /Sets the amount of milliseconds in the past that the renderer will
		 * show updates from the stream. This allows us to interpolate from a previous
		 * position to the next position in the stream update. Updates come in and
		 * are already in the past when they are received so we need to set this
		 * latency value to something greater than the highest level of acceptable
		 * network latency. Usually this is a value between 100 and 200ms. If your
		 * game requires much tighter latency you will have to reduce the number of
		 * players / network updates / data size in order to compensate. A value of
		 * 100 in this call is the standard that most triple-A FPS games accept as
		 * normal render latency and should be OK for your game.
		 *
		 * @param latency
		 */
		renderLatency: function (latency) {
			if (latency !== undefined) {
				this._renderLatency = latency;
				return this._network;
			}
			
			return this._renderLatency;
		},
		
		/* CEXCLUDE */
		/**
		 * Gets / sets the interval by which updates to the game world are packaged
		 * and transmitted to connected clients. The greater the value, the less
		 * updates are sent per second.
		 * @param {Number=} ms The number of milliseconds between stream messages.
		 */
		sendInterval: function (ms) {
			if (ms !== undefined) {
				this.log('Setting delta stream interval to ' + (ms / $ige.engine._timeScale) + 'ms');
				this._streamInterval = ms / $ige.engine._timeScale;
				return this._network;
			}
			
			return this._streamInterval;
		},
		
		/**
		 * Starts the stream of world updates to connected clients.
		 */
		start: function () {
			var self = this;
			
			this.log('Starting delta stream...');
			this._streamTimer = setInterval(function () {
				self._sendQueue();
			}, this._streamInterval);
			
			return this._network;
		},
		
		/**
		 * Stops the stream of world updates to connected clients.
		 */
		stop: function () {
			this._stopTimeSync();
			
			this.log('Stopping delta stream...');
			clearInterval(this._streamTimer);
			
			return this._network;
		},
		
		/**
		 * Queues stream data to be sent during the next stream data interval.
		 * @param {String} id The id of the entity that this data belongs to.
		 * @param {String} data The data queued for delivery to the client.
		 * @param {String} clientId The client id this data is queued for.
		 * @return {*}
		 */
		queue: function (id, data, clientId) {
			this._queuedData[id] = [data, clientId];
			return this._network;
		},
		
		/**
		 * Asks the server to send the data packets for all the queued stream
		 * data to the specified clients.
		 * @private
		 */
		_sendQueue: function () {
			var st = new Date().getTime(),
				ct,
				dt,
				arr = this._queuedData,
				entityId,
				network = this._network,
				stream = network.stream,
				item, currentTime = $time._currentTime,
				clientSentTimeData = {};
			
			// Send the stream data
			for (entityId in arr) {
				if (arr.hasOwnProperty(entityId)) {
					item = arr[entityId];
					
					// Check if we've already sent this client the starting
					// time of the stream data
					if (!clientSentTimeData[item[1]]) {
						// Send the stream start time
						network.send('_igeStreamTime', currentTime, item[1]);
						clientSentTimeData[item[1]] = true;
					}
					
					network.send('_igeStreamData', item[0], item[1]);
					
					// Store the new data for later comparison
					stream._streamClientData[entityId][item[1]] = item[0];
					delete arr[entityId];
					
					if (stream._streamPropertyChange) { delete stream._streamPropertyChange[entityId]; }
					
					ct = new Date().getTime();
					dt = ct - st;
					
					if (dt > this._streamInterval) {
						console.log('WARNING, Stream send is taking too long: ' + dt + 'ms');
						break;
					}
				}
			}
		},
		/* CEXCLUDE */
		
		/**
		 * Handles receiving the start time of the stream data.
		 * @param data
		 * @private
		 */
		_onStreamTime: function (data) {
			this._streamDataTime = data;
		},
		
		_onStreamCreate: function (data) {
			var self = this,
				classId = data[0],
				entityId = data[1],
				parentId = data[2],
				transformData = data[3],
				createData = data[4],
				parent = $ige.engine.$(parentId),
				classConstructor,
				controller,
				entity;
			
			// Check the required class exists
			if (parent) {
				// Check that the entity doesn't already exist
				if (!$ige.engine.$(entityId)) {
					classConstructor = appCore.module(classId);
					
					if (classConstructor) {
						classConstructor.controller(undefined, function (err, controller) {
							if (err) {
								return;
							}
							
							// The entity does not currently exist so create it!
							entity = new controller(createData)
								.id(entityId)
								.mount(parent);
							
							entity.streamSectionData('transform', transformData, true, true);
							
							// Set the just created flag which will stop the renderer
							// from handling this entity until after the first stream
							// data has been received for it
							entity._streamJustCreated = true;
							
							if (entity._streamEmitCreated) {
								entity.emit('streamCreated');
							}
							
							// Since we just created an entity through receiving stream
							// data, inform any interested listeners
							self.emit('entityCreated', entity);
						});
					} else {
						$ige.engine.network.stop();
						$ige.engine.stop();
						
						this.log('Network stream cannot create entity with class ' + classId + ' because the class has not been defined! The engine will now stop.', 'error');
					}
				}
			} else {
				this.log('Cannot properly handle network streamed entity with id ' + entityId + ' because it\'s parent with id ' + parentId + ' does not exist on the scenegraph!', 'warning');
			}
		},
		
		_onStreamDestroy: function (data) {
			var entity = $ige.engine.$(data[1]),
				self = this;
			
			if (entity) {
				// Calculate how much time we have left before the entity
				// should be removed from the simulation given the render
				// latency setting and the current time
				var destroyDelta = $ige.engine.network.stream._renderLatency + ($time._currentTime - data[0]);
				
				if (destroyDelta > 0) {
					// Give the entity a lifespan to destroy it in x ms
					entity.lifeSpan(destroyDelta, function () {
						self.emit('entityDestroyed', entity);
					});
				} else {
					// Destroy immediately
					self.emit('entityDestroyed', entity);
					entity.destroy();
				}
			}
		},
		
		/**
		 * Called when the client receives data from the stream system.
		 * Handles decoding the data and calling the relevant entity
		 * _onStreamData() methods.
		 * @param data
		 * @private
		 */
		_onStreamData: function (data) {
			// Read the packet data into variables
			var entityId,
				entity,
				sectionArr,
				sectionDataArr = data.split($ige.engine.network.stream._sectionDesignator),
				sectionDataCount,
				sectionIndex,
				justCreated;
			
			// We know the first bit of data will always be the
			// target entity's ID
			entityId = sectionDataArr.shift();
			sectionDataCount = sectionDataArr.length;
			
			// Check if the entity with this ID currently exists
			entity = $ige.engine.$(entityId);
			
			if (entity) {
				// Hold the entity's just created flag
				justCreated = entity._streamJustCreated;
				
				// Get the entity stream section array
				sectionArr = entity._streamSections;
				
				// Now loop the data sections array and compile the rest of the
				// data string from the data section return data
				for (sectionIndex = 0; sectionIndex < sectionDataCount; sectionIndex++) {
					// Tell the entity to handle this section's data
					entity.streamSectionData(sectionArr[sectionIndex], sectionDataArr[sectionIndex], justCreated);
				}
				
				// Now that the entity has had it's first bit of data
				// reset the just created flag
				delete entity._streamJustCreated;
			} else {
				this.log('+++ Stream: Data received for unknown entity (' + entityId + ')');
			}
		}
	});
	
	return IgeStreamComponent;
});
},{"irrelon-appcore":125}],34:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeBox2dComponent', function ($ige, $time, Box2D, IgeEventingClass) {
	/**
	 * The engine's box2d component class.
	 */
	var IgeBox2dComponent = IgeEventingClass.extend({
		classId: 'IgeBox2dComponent',
		componentId: 'box2d',
		
		init: function (entity, options) {
			// Check that the engine has not already started
			// as this will mess everything up if it has
			if ($ige.engine._state !== 0) {
				this.log('Cannot add box2d component to the ige instance once the engine has started!', 'error');
			}
			
			this._entity = entity;
			this._options = options;
			this._mode = 0;
			
			this.b2Color = Box2D.Common.b2Color;
			this.b2Vec2 = Box2D.Common.Math.b2Vec2;
			this.b2Math = Box2D.Common.Math.b2Math;
			this.b2Shape = Box2D.Collision.Shapes.b2Shape;
			this.b2BodyDef = Box2D.Dynamics.b2BodyDef;
			this.b2Body = Box2D.Dynamics.b2Body;
			this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
			this.b2Fixture = Box2D.Dynamics.b2Fixture;
			this.b2World = Box2D.Dynamics.b2World;
			this.b2MassData = Box2D.Collision.Shapes.b2MassData;
			this.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
			this.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
			this.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
			this.b2ContactListener = Box2D.Dynamics.b2ContactListener;
			this.b2Distance = Box2D.Collision.b2Distance;
			this.b2Contact = Box2D.Dynamics.Contacts.b2Contact;
			this.b2FilterData = Box2D.Dynamics.b2FilterData;
			this.b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;
			
			// Extend the b2Contact class to allow the IGE entity accessor
			// and other helper methods
			this.b2Contact.prototype.igeEntityA = function () {
				var ent = this.m_fixtureA.m_body._entity;
				ent._box2dOurContactFixture = this.m_fixtureA;
				ent._box2dTheirContactFixture = this.m_fixtureB;
				return ent;
			};
			
			this.b2Contact.prototype.igeEntityB = function () {
				var ent = this.m_fixtureB.m_body._entity;
				ent._box2dOurContactFixture = this.m_fixtureB;
				ent._box2dTheirContactFixture = this.m_fixtureA;
				return ent;
			};
			
			this.b2Contact.prototype.igeEitherId = function (id1, id2) {
				if (!id2) {
					return this.m_fixtureA.m_body._entity._id === id1 || this.m_fixtureB.m_body._entity._id === id1;
				} else {
					return (this.m_fixtureA.m_body._entity._id === id1 || this.m_fixtureB.m_body._entity._id === id1) &&
						(this.m_fixtureA.m_body._entity._id === id2 || this.m_fixtureB.m_body._entity._id === id2);
				}
			};
			
			this.b2Contact.prototype.igeEitherCategory = function (category1, category2) {
				if (!category2) {
					return this.m_fixtureA.m_body._entity._category === category1 || this.m_fixtureB.m_body._entity._category === category1;
				} else {
					return (this.m_fixtureA.m_body._entity._category === category1 || this.m_fixtureB.m_body._entity._category === category1) &&
						(this.m_fixtureA.m_body._entity._category === category2 || this.m_fixtureB.m_body._entity._category === category2);
				}
			};
			
			this.b2Contact.prototype.igeBothCategories = function (category1) {
				return (this.m_fixtureA.m_body._entity._category === category1 && this.m_fixtureB.m_body._entity._category === category1);
			};
			
			this.b2Contact.prototype.igeEntityByCategory = function (category) {
				if (this.m_fixtureA.m_body._entity._category === category) {
					return this.igeEntityA();
				}
				
				if (this.m_fixtureB.m_body._entity._category === category) {
					return this.igeEntityB();
				}
			};
			
			this.b2Contact.prototype.igeEntityById = function (id) {
				if (this.m_fixtureA.m_body._entity._id === id) {
					return this.igeEntityA();
				}
				
				if (this.m_fixtureB.m_body._entity._id === id) {
					return this.igeEntityB();
				}
			};
			
			this.b2Contact.prototype.igeEntityByFixtureId = function (id) {
				if (this.m_fixtureA.igeId === id) {
					return this.igeEntityA();
				}
				
				if (this.m_fixtureB.igeId === id) {
					return this.igeEntityB();
				}
			};
			
			this.b2Contact.prototype.igeOtherEntity = function (entity) {
				if (this.m_fixtureA.m_body._entity === entity) {
					return this.igeEntityB();
				} else {
					return this.igeEntityA();
				}
			};
			
			this._sleep = true;
			this._scaleRatio = 30;
			this._gravity = new this.b2Vec2(0, 0);
			
			this._removeWhenReady = [];
			
			this.log('Physics component initiated!');
		},
		
		useWorker: function (val) {
			if (typeof(Worker) !== 'undefined') {
				if (val !== undefined) {
					this._useWorker = val;
					return this._entity;
				}
				
				return this._useWorker;
			} else {
				this.log('Web workers were not detected on this browser. Cannot access useWorker() method.', 'warning');
			}
		},
		
		/**
		 * Gets / sets the world interval mode. In mode 0 (zero) the
		 * box2d simulation is synced to the framerate of the engine's
		 * renderer. In mode 1 the box2d simulation is stepped at a constant
		 * speed regardless of the engine's renderer. This must be set *before*
		 * calling the start() method in order for the setting to take effect.
		 * @param {Integer} val The mode, either 0 or 1.
		 * @returns {*}
		 */
		mode: function (val) {
			if (val !== undefined) {
				this._mode = val;
				return this._entity;
			}
			
			return this._mode;
		},
		
		/**
		 * Gets / sets if the world should allow sleep or not.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		sleep: function (val) {
			if (val !== undefined) {
				this._sleep = val;
				return this._entity;
			}
			
			return this._sleep;
		},
		
		/**
		 * Gets / sets the current engine to box2d scaling ratio.
		 * @param val
		 * @return {*}
		 */
		scaleRatio: function (val) {
			if (val !== undefined) {
				this._scaleRatio = val;
				return this._entity;
			}
			
			return this._scaleRatio;
		},
		
		/**
		 * Gets / sets the gravity vector.
		 * @param x
		 * @param y
		 * @return {*}
		 */
		gravity: function (x, y) {
			if (x !== undefined && y !== undefined) {
				this._gravity = new this.b2Vec2(x, y);
				return this._entity;
			}
			
			return this._gravity;
		},
		
		/**
		 * Gets the current Box2d world object.
		 * @return {b2World}
		 */
		world: function () {
			return this._world;
		},
		
		/**
		 * Creates the Box2d world.
		 * @param {String=} id
		 * @param {Object=} options
		 * @return {*}
		 */
		createWorld: function (id, options) {
			this._world = new this.b2World(
				this._gravity,
				this._sleep
			);
			
			this.log('World created');
			
			return this._entity;
		},
		
		/**
		 * Creates a Box2d fixture and returns it.
		 * @param params
		 * @return {b2FixtureDef}
		 */
		createFixture: function (params) {
			var tempDef = new this.b2FixtureDef(),
				param;
			
			for (param in params) {
				if (params.hasOwnProperty(param)) {
					if (param !== 'shape' && param !== 'filter') {
						tempDef[param] = params[param];
					}
				}
			}
			
			return tempDef;
		},
		
		/**
		 * Creates a Box2d body and attaches it to an IGE entity
		 * based on the supplied body definition.
		 * @param {IgeEntity} entity
		 * @param {Object} body
		 * @return {b2Body}
		 */
		createBody: function (entity, body) {
			var tempDef = new this.b2BodyDef(),
				param,
				tempBod,
				fixtureDef,
				tempFixture,
				finalFixture,
				tempShape,
				tempFilterData,
				i,
				finalX, finalY,
				finalWidth, finalHeight;
			
			// Process body definition and create a box2d body for it
			switch (body.type) {
				case 'static':
					tempDef.type = this.b2Body.b2_staticBody;
					break;
				
				case 'dynamic':
					tempDef.type = this.b2Body.b2_dynamicBody;
					break;
				
				case 'kinematic':
					tempDef.type = this.b2Body.b2_kinematicBody;
					break;
			}
			
			// Add the parameters of the body to the new body instance
			for (param in body) {
				if (body.hasOwnProperty(param)) {
					switch (param) {
						case 'type':
						case 'gravitic':
						case 'fixedRotation':
						case 'fixtures':
							// Ignore these for now, we process them
							// below as post-creation attributes
							break;
						
						default:
							tempDef[param] = body[param];
							break;
					}
				}
			}
			
			// Set the position
			tempDef.position = new this.b2Vec2(entity._translate.x / this._scaleRatio, entity._translate.y / this._scaleRatio);
			
			// Create the new body
			tempBod = this._world.CreateBody(tempDef);
			
			// Now apply any post-creation attributes we need to
			for (param in body) {
				if (body.hasOwnProperty(param)) {
					switch (param) {
						case 'gravitic':
							if (!body.gravitic) {
								tempBod.m_nonGravitic = true;
							}
							break;
						
						case 'fixedRotation':
							if (body.fixedRotation) {
								tempBod.SetFixedRotation(true);
							}
							break;
						
						case 'fixtures':
							if (body.fixtures && body.fixtures.length) {
								for (i = 0; i < body.fixtures.length; i++) {
									// Grab the fixture definition
									fixtureDef = body.fixtures[i];
									
									// Create the fixture
									tempFixture = this.createFixture(fixtureDef);
									tempFixture.igeId = fixtureDef.igeId;
									
									// Check for a shape definition for the fixture
									if (fixtureDef.shape) {
										// Create based on the shape type
										switch (fixtureDef.shape.type) {
											case 'circle':
												tempShape = new this.b2CircleShape();
												if (fixtureDef.shape.data && typeof(fixtureDef.shape.data.radius) !== 'undefined') {
													tempShape.SetRadius(fixtureDef.shape.data.radius / this._scaleRatio);
												} else {
													tempShape.SetRadius((entity._bounds2d.x / this._scaleRatio) / 2);
												}
												
												if (fixtureDef.shape.data) {
													finalX = fixtureDef.shape.data.x !== undefined ? fixtureDef.shape.data.x : 0;
													finalY = fixtureDef.shape.data.y !== undefined ? fixtureDef.shape.data.y : 0;
													
													tempShape.SetLocalPosition(new this.b2Vec2(finalX / this._scaleRatio, finalY / this._scaleRatio));
												}
												break;
											
											case 'polygon':
												tempShape = new this.b2PolygonShape();
												tempShape.SetAsArray(fixtureDef.shape.data._poly, fixtureDef.shape.data.length());
												break;
											
											case 'rectangle':
												tempShape = new this.b2PolygonShape();
												
												if (fixtureDef.shape.data) {
													finalX = fixtureDef.shape.data.x !== undefined ? fixtureDef.shape.data.x : 0;
													finalY = fixtureDef.shape.data.y !== undefined ? fixtureDef.shape.data.y : 0;
													finalWidth = fixtureDef.shape.data.width !== undefined ? fixtureDef.shape.data.width : (entity._bounds2d.x / 2);
													finalHeight = fixtureDef.shape.data.height !== undefined ? fixtureDef.shape.data.height : (entity._bounds2d.y / 2);
												} else {
													finalX = 0;
													finalY = 0;
													finalWidth = (entity._bounds2d.x / 2);
													finalHeight = (entity._bounds2d.y / 2);
												}
												
												// Set the polygon as a box
												tempShape.SetAsOrientedBox(
													(finalWidth / this._scaleRatio),
													(finalHeight / this._scaleRatio),
													new this.b2Vec2(finalX / this._scaleRatio, finalY / this._scaleRatio),
													0
												);
												break;
										}
										
										if (tempShape) {
											tempFixture.shape = tempShape;
											finalFixture = tempBod.CreateFixture(tempFixture);
											finalFixture.igeId = tempFixture.igeId;
										}
									}
									
									if (fixtureDef.filter && finalFixture) {
										tempFilterData = new this._entity.box2d.b2FilterData();
										
										if (fixtureDef.filter.categoryBits !== undefined) {
											tempFilterData.categoryBits = fixtureDef.filter.categoryBits;
										}
										if (fixtureDef.filter.maskBits !== undefined) {
											tempFilterData.maskBits = fixtureDef.filter.maskBits;
										}
										if (fixtureDef.filter.categoryIndex !== undefined) {
											tempFilterData.categoryIndex = fixtureDef.filter.categoryIndex;
										}
										
										finalFixture.SetFilterData(tempFilterData);
									}
									
									if (fixtureDef.density !== undefined && finalFixture) {
										finalFixture.SetDensity(fixtureDef.density);
									}
								}
							} else {
								this.log('Box2D body has no fixtures, have you specified fixtures correctly? They are supposed to be an array of fixture objects.', 'warning');
							}
							break;
					}
				}
			}
			
			// Store the entity that is linked to this body
			tempBod._entity = entity;
			
			// Add the body to the world with the passed fixture
			return tempBod;
		},
		
		/**
		 * Produces static box2d bodies from passed map data.
		 * @param {IgeTileMap2d} mapLayer
		 * @param {Function=} callback Returns true or false depending
		 * on if the passed map data should be included as part of the
		 * box2d static object data. This allows you to control what
		 * parts of the map data are to be considered for box2d static
		 * objects and which parts are to be ignored. If not passed then
		 * any tile with any map data is considered part of the static
		 * object data.
		 */
		staticsFromMap: function (mapLayer, callback) {
			if (mapLayer.map) {
				var tileWidth = mapLayer.tileWidth(),
					tileHeight = mapLayer.tileHeight(),
					posX, posY,
					rectArray, rectCount, rect;
				
				// Get the array of rectangle bounds based on
				// the map's data
				rectArray = mapLayer.scanRects(callback);
				rectCount = rectArray.length;
				
				while (rectCount--) {
					rect = rectArray[rectCount];
					
					posX = (tileWidth * (rect.width / 2));
					posY = (tileHeight * (rect.height / 2));
					
					new IgeEntityBox2d()
						.translateTo(rect.x * tileWidth + posX, rect.y * tileHeight + posY, 0)
						.width(rect.width * tileWidth)
						.height(rect.height * tileHeight)
						.drawBounds(true)
						.drawBoundsData(false)
						.box2dBody({
							type: 'static',
							allowSleep: true,
							fixtures: [{
								shape: {
									type: 'rectangle'
								}
							}]
						});
				}
			} else {
				this.log('Cannot extract box2d static bodies from map data because passed map does not have a .map property!', 'error');
			}
		},
		
		/**
		 * Creates a contact listener with the specified callbacks. When
		 * contacts begin and end inside the box2d simulation the specified
		 * callbacks are fired.
		 * @param {Function} beginContactCallback The method to call when the contact listener detects contact has started.
		 * @param {Function} endContactCallback The method to call when the contact listener detects contact has ended.
		 * @param {Function} preSolve
		 * @param {Function} postSolve
		 */
		contactListener: function (beginContactCallback, endContactCallback, preSolve, postSolve) {
			var contactListener = new this.b2ContactListener();
			if (beginContactCallback !== undefined) {
				contactListener.BeginContact = beginContactCallback;
			}
			
			if (endContactCallback !== undefined) {
				contactListener.EndContact = endContactCallback;
			}
			
			if (preSolve !== undefined) {
				contactListener.PreSolve = preSolve;
			}
			
			if (postSolve !== undefined) {
				contactListener.PostSolve = postSolve;
			}
			this._world.SetContactListener(contactListener);
		},
		
		/**
		 * If enabled, sets the physics world into network debug mode which
		 * will stop the world from generating collisions but still allow us
		 * to see shape outlines as they are attached to bodies. Useful when
		 * your physics system is server-side but seeing client-side shape
		 * data is useful for debugging collisions.
		 * @param {Boolean} val
		 */
		networkDebugMode: function (val) {
			if (val !== undefined) {
				this._networkDebugMode = val;
				
				if (val === true) {
					// We are enabled so disable all physics contacts
					this.contactListener(
						// Begin contact
						function (contact) {
						},
						// End contact
						function (contact) {
						},
						// Pre-solve
						function (contact) {
							// Cancel the contact
							contact.SetEnabled(false);
						},
						// Post-solve
						function (contact) {
						}
					);
				} else {
					// Re-enable contacts
					this.contactListener();
				}
				
				return this._entity;
			}
			
			return this._networkDebugMode;
		},
		
		/**
		 * Creates a debug entity that outputs the bounds of each box2d
		 * body during standard engine ticks.
		 * @param {IgeEntity} mountScene
		 */
		enableDebug: function (mountScene) {
			if (mountScene) {
				// Define the debug drawing instance
				var debugDraw = new this.b2DebugDraw();
				this._box2dDebug = true;
				
				debugDraw.SetSprite($ige.engine._ctx);
				debugDraw.SetDrawScale(this._scaleRatio);
				debugDraw.SetFillAlpha(0.3);
				debugDraw.SetLineThickness(1.0);
				debugDraw.SetFlags(
					this.b2DebugDraw.e_controllerBit
					| this.b2DebugDraw.e_jointBit
					| this.b2DebugDraw.e_pairBit
					| this.b2DebugDraw.e_shapeBit
					//| this.b2DebugDraw.e_aabbBit
					//| this.b2DebugDraw.e_centerOfMassBit
				);
				
				// Set the debug draw for the world
				this._world.SetDebugDraw(debugDraw);
				
				// Create the debug painter entity and mount
				// it to the passed scene
				new igeClassStore.IgeBox2dDebugPainter(this._entity)
					.depth(40000) // Set a really high depth
					.drawBounds(false)
					.mount(mountScene);
			} else {
				this.log('Cannot enable box2d debug drawing because the passed argument is not an object on the scenegraph.', 'error');
			}
		},
		
		/**
		 * Queues a body for removal from the physics world.
		 * @param body
		 */
		destroyBody: function (body) {
			this._removeWhenReady.push(body);
		},
		
		/**
		 * Gets / sets the callback method that will be called after
		 * every physics world step.
		 * @param method
		 * @return {*}
		 */
		updateCallback: function (method) {
			if (method !== undefined) {
				this._updateCallback = method;
				return this._entity;
			}
			
			return this._updateCallback;
		},
		
		start: function () {
			if (!this._active) {
				this._active = true;
				
				if (!this._networkDebugMode) {
					if (this._mode === 0) {
						// Add the box2d behaviour to the ige
						this._entity.addBehaviour('box2dStep', this._behaviour);
					} else {
						this._intervalTimer = setInterval(this._behaviour, 1000 / 60);
					}
				}
			}
		},
		
		stop: function () {
			if (this._active) {
				this._active = false;
				
				if (this._mode === 0) {
					// Add the box2d behaviour to the ige
					this._entity.removeBehaviour('box2dStep');
				} else {
					clearInterval(this._intervalTimer);
				}
			}
		},
		
		/**
		 * Steps the physics simulation forward.
		 * @param ctx
		 * @private
		 */
		_behaviour: function (ctx) {
			var self = this.box2d,
				tempBod,
				entity,
				entityBox2dBody,
				removeWhenReady,
				count,
				destroyBody;
			
			if (self._active && self._world) {
				if (!self._world.IsLocked()) {
					// Remove any bodies that were queued for removal
					removeWhenReady = self._removeWhenReady;
					count = removeWhenReady.length;
					
					if (count) {
						destroyBody = self._world.DestroyBody;
						while (count--) {
							destroyBody.apply(self._world, [removeWhenReady[count]]);
						}
						self._removeWhenReady = [];
						removeWhenReady = null;
					}
				}
				
				// Call the world step; frame-rate, velocity iterations, position iterations
				if (self._mode === 0) {
					self._world.Step($time._tickDelta / 1000, 8, 3);
				} else {
					self._world.Step(1 / 60, 8, 3);
				}
				
				// Loop the physics objects and move the entities they are assigned to
				tempBod = self._world.GetBodyList();
				while (tempBod) {
					if (tempBod._entity) {
						// Body has an entity assigned to it
						entity = tempBod._entity; //self.$ige.engine.entities.read(tempBod.m_userData);
						entityBox2dBody = entity._box2dBody;
						
						// Check if the body is awake and is dynamic (we don't transform static bodies)
						if (tempBod.IsAwake() && tempBod.m_type !== 0) {
							// Update the entity data to match the body data
							entityBox2dBody.updating = true;
							entity.translateTo(tempBod.m_xf.position.x * self._scaleRatio, tempBod.m_xf.position.y * self._scaleRatio, entity._translate.z);
							entity.rotateTo(entity._rotate.x, entity._rotate.y, tempBod.GetAngle());
							entityBox2dBody.updating = false;
							
							if (entityBox2dBody.asleep) {
								// The body was asleep last frame, fire an awake event
								entityBox2dBody.asleep = false;
								self.emit('afterAwake', entity);
							}
						} else {
							if (!entityBox2dBody.asleep) {
								// The body was awake last frame, fire an asleep event
								entityBox2dBody.asleep = true;
								self.emit('afterAsleep', entity);
							}
						}
					}
					
					tempBod = tempBod.GetNext();
				}
				
				// Clear forces because we have ended our physics simulation frame
				self._world.ClearForces();
				
				tempBod = null;
				entity = null;
				
				if (typeof(self._updateCallback) === 'function') {
					self._updateCallback();
				}
			}
		},
		
		destroy: function () {
			// Stop processing box2d steps
			this._entity.removeBehaviour('box2dStep');
			
			// Destroy all box2d world bodies
			
		}
	});
	
	return IgeBox2dComponent;
});
},{"irrelon-appcore":125}],35:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeBox2dDebugPainter', function (IgeObject) {
	var IgeBox2dDebugPainter = IgeObject.extend({
		classId: 'IgeBox2dDebugPainter',
		
		init: function (entity, options) {
			IgeObject.prototype.init.call(this);
			
			this._entity = entity;
			this._options = options;
		},
		
		tick: function (ctx) {
			if (this._parent && this._parent.isometricMounts() === 1) {
				ctx.scale(1.414, 0.707); // This should be super-accurate now
				ctx.rotate(45 * Math.PI / 180);
			}
			
			this._entity.box2d._world.DrawDebugData();
			
			IgeObject.prototype.tick.call(this, ctx);
		}
	});
	
	return IgeBox2dDebugPainter;
});
},{"irrelon-appcore":125}],36:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeBox2dMultiWorldComponent', function (IgeEventingClass) {
	/**
	 * The engine's box2d multi-world component class.
	 */
	var IgeBox2dMultiWorldComponent = IgeEventingClass.extend({
		classId: 'IgeBox2dMultiWorldComponent',
		componentId: 'box2d',
		
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			this._worlds = {};
			
			this.b2Color = Box2D.Common.b2Color;
			this.b2Vec2 = Box2D.Common.Math.b2Vec2;
			this.b2Math = Box2D.Common.Math.b2Math;
			this.b2Shape = Box2D.Collision.Shapes.b2Shape;
			this.b2BodyDef = Box2D.Dynamics.b2BodyDef;
			this.b2Body = Box2D.Dynamics.b2Body;
			this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
			this.b2Fixture = Box2D.Dynamics.b2Fixture;
			this.b2World = Box2D.Dynamics.b2World;
			this.b2MassData = Box2D.Collision.Shapes.b2MassData;
			this.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
			this.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
			this.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
			this.b2ContactListener = Box2D.Dynamics.b2ContactListener;
			this.b2Distance = Box2D.Collision.b2Distance;
			this.b2Contact = Box2D.Dynamics.Contacts.b2Contact;
			this.b2FilterData = Box2D.Dynamics.b2FilterData;
			this.b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;
			
			// Extend the b2Contact class to allow the IGE entity accessor
			// and other helper methods
			this.b2Contact.prototype.igeEntityA = function () {
				var ent = this.m_fixtureA.m_body._entity;
				ent._box2dOurContactFixture = this.m_fixtureA;
				ent._box2dTheirContactFixture = this.m_fixtureB;
				return ent;
			};
			
			this.b2Contact.prototype.igeEntityB = function () {
				var ent = this.m_fixtureB.m_body._entity;
				ent._box2dOurContactFixture = this.m_fixtureB;
				ent._box2dTheirContactFixture = this.m_fixtureA;
				return ent;
			};
			
			this.b2Contact.prototype.igeEitherId = function (id1, id2) {
				if (!id2) {
					return this.m_fixtureA.m_body._entity._id === id1 || this.m_fixtureB.m_body._entity._id === id1;
				} else {
					return (this.m_fixtureA.m_body._entity._id === id1 || this.m_fixtureB.m_body._entity._id === id1) &&
						(this.m_fixtureA.m_body._entity._id === id2 || this.m_fixtureB.m_body._entity._id === id2);
				}
			};
			
			this.b2Contact.prototype.igeEitherCategory = function (category1, category2) {
				if (!category2) {
					return this.m_fixtureA.m_body._entity._category === category1 || this.m_fixtureB.m_body._entity._category === category1;
				} else {
					return (this.m_fixtureA.m_body._entity._category === category1 || this.m_fixtureB.m_body._entity._category === category1) &&
						(this.m_fixtureA.m_body._entity._category === category2 || this.m_fixtureB.m_body._entity._category === category2);
				}
			};
			
			this.b2Contact.prototype.igeBothCategories = function (category1) {
				return (this.m_fixtureA.m_body._entity._category === category1 && this.m_fixtureB.m_body._entity._category === category1);
			};
			
			this.b2Contact.prototype.igeEntityByCategory = function (category) {
				if (this.m_fixtureA.m_body._entity._category === category) {
					return this.igeEntityA();
				}
				
				if (this.m_fixtureB.m_body._entity._category === category) {
					return this.igeEntityB();
				}
			};
			
			this.b2Contact.prototype.igeEntityById = function (id) {
				if (this.m_fixtureA.m_body._entity._id === id) {
					return this.igeEntityA();
				}
				
				if (this.m_fixtureB.m_body._entity._id === id) {
					return this.igeEntityB();
				}
			};
			
			this.b2Contact.prototype.igeEntityByFixtureId = function (id) {
				if (this.m_fixtureA.igeId === id) {
					return this.igeEntityA();
				}
				
				if (this.m_fixtureB.igeId === id) {
					return this.igeEntityB();
				}
			};
			
			this.b2Contact.prototype.igeOtherEntity = function (entity) {
				if (this.m_fixtureA.m_body._entity === entity) {
					return this.igeEntityB();
				} else {
					return this.igeEntityA();
				}
			};
			
			this.log('Physics component initiated!');
		},
		
		/**
		 * Gets the Box2d world object by it's id.
		 * @return {b2World}
		 */
		world: function (id) {
			return this._worlds[id];
		},
		
		/**
		 * Creates the Box2d world.
		 * @param {String} id
		 * @param {Object=} options
		 * @return {*}
		 */
		createWorld: function (options) {
			var world;
			
			options = options || {};
			options.id = options.id || $ige.engine.newIdHex();
			options.gravity = options.gravity || new this.b2Vec2(0, 0);
			options.sleep = options.sleep !== undefined ? options.sleep : true;
			
			// Create world instance
			this._worlds[options.id] = world = new IgeBox2dWorld(this, options);
			
			return world;
		}
	});
	
	return IgeBox2dMultiWorldComponent;
});
},{"irrelon-appcore":125}],37:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeBox2dWorld', function ($time, IgeEventingClass) {
	var IgeBox2dWorld = IgeEventingClass.extend({
		classId: 'IgeBox2dWorld',
		
		init: function (entity, options) {
			this.b2Color = Box2D.Common.b2Color;
			this.b2Vec2 = Box2D.Common.Math.b2Vec2;
			this.b2Math = Box2D.Common.Math.b2Math;
			this.b2Shape = Box2D.Collision.Shapes.b2Shape;
			this.b2BodyDef = Box2D.Dynamics.b2BodyDef;
			this.b2Body = Box2D.Dynamics.b2Body;
			this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
			this.b2Fixture = Box2D.Dynamics.b2Fixture;
			this.b2World = Box2D.Dynamics.b2World;
			this.b2MassData = Box2D.Collision.Shapes.b2MassData;
			this.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
			this.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
			this.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
			this.b2ContactListener = Box2D.Dynamics.b2ContactListener;
			this.b2Distance = Box2D.Collision.b2Distance;
			this.b2Contact = Box2D.Dynamics.Contacts.b2Contact;
			this.b2FilterData = Box2D.Dynamics.b2FilterData;
			this.b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;
			
			this._entity = entity;
			
			options = options || {
					id: $ige.engine.newIdHex(),
					gravity: new this.b2Vec2(0, 0),
					sleep: true
				};
			
			this._id = options.id;
			this._sleep = options.sleep;
			this._scaleRatio = options.scaleRatio !== undefined ? options.scaleRatio : 30;
			this._gravity = options.gravity;
			this._mode = 0;
			
			this._removeWhenReady = [];
			
			this._world = new this.b2World(
				options.gravity,
				options.sleep
			);
		},
		
		/**
		 * Creates a Box2d fixture and returns it.
		 * @param params
		 * @return {b2FixtureDef}
		 */
		createFixture: function (params) {
			var tempDef = new this.b2FixtureDef(),
				param;
			
			for (param in params) {
				if (params.hasOwnProperty(param)) {
					if (param !== 'shape' && param !== 'filter') {
						tempDef[param] = params[param];
					}
				}
			}
			
			return tempDef;
		},
		
		/**
		 * Creates a Box2d body and attaches it to an IGE entity
		 * based on the supplied body definition.
		 * @param {IgeEntityBox2d} entity
		 * @param {Object} body
		 * @return {b2Body}
		 */
		createBody: function (entity, body) {
			var tempDef = new this.b2BodyDef(),
				param,
				tempBod,
				fixtureDef,
				tempFixture,
				finalFixture,
				tempShape,
				tempFilterData,
				i,
				finalX, finalY,
				finalWidth, finalHeight;
			
			// Process body definition and create a box2d body for it
			switch (body.type) {
				case 'static':
					tempDef.type = this.b2Body.b2_staticBody;
					break;
				
				case 'dynamic':
					tempDef.type = this.b2Body.b2_dynamicBody;
					break;
				
				case 'kinematic':
					tempDef.type = this.b2Body.b2_kinematicBody;
					break;
			}
			
			// Add the parameters of the body to the new body instance
			for (param in body) {
				if (body.hasOwnProperty(param)) {
					switch (param) {
						case 'type':
						case 'gravitic':
						case 'fixedRotation':
						case 'fixtures':
							// Ignore these for now, we process them
							// below as post-creation attributes
							break;
						
						default:
							tempDef[param] = body[param];
							break;
					}
				}
			}
			
			// Set the position
			tempDef.position = new this.b2Vec2(entity._translate.x / this._scaleRatio, entity._translate.y / this._scaleRatio);
			
			// Create the new body
			tempBod = this._world.CreateBody(tempDef);
			
			// Now apply any post-creation attributes we need to
			for (param in body) {
				if (body.hasOwnProperty(param)) {
					switch (param) {
						case 'gravitic':
							if (!body.gravitic) {
								tempBod.m_nonGravitic = true;
							}
							break;
						
						case 'fixedRotation':
							if (body.fixedRotation) {
								tempBod.SetFixedRotation(true);
							}
							break;
						
						case 'fixtures':
							if (body.fixtures && body.fixtures.length) {
								for (i = 0; i < body.fixtures.length; i++) {
									// Grab the fixture definition
									fixtureDef = body.fixtures[i];
									
									// Create the fixture
									tempFixture = this.createFixture(fixtureDef);
									tempFixture.igeId = fixtureDef.igeId;
									
									// Check for a shape definition for the fixture
									if (fixtureDef.shape) {
										// Create based on the shape type
										switch (fixtureDef.shape.type) {
											case 'circle':
												tempShape = new this.b2CircleShape();
												if (fixtureDef.shape.data && typeof(fixtureDef.shape.data.radius) !== 'undefined') {
													tempShape.SetRadius(fixtureDef.shape.data.radius / this._scaleRatio);
												} else {
													tempShape.SetRadius((entity._bounds2d.x / this._scaleRatio) / 2);
												}
												
												if (fixtureDef.shape.data) {
													finalX = fixtureDef.shape.data.x !== undefined ? fixtureDef.shape.data.x : 0;
													finalY = fixtureDef.shape.data.y !== undefined ? fixtureDef.shape.data.y : 0;
													
													tempShape.SetLocalPosition(new this.b2Vec2(finalX / this._scaleRatio, finalY / this._scaleRatio));
												}
												break;
											
											case 'polygon':
												tempShape = new this.b2PolygonShape();
												tempShape.SetAsArray(fixtureDef.shape.data._poly, fixtureDef.shape.data.length());
												break;
											
											case 'rectangle':
												tempShape = new this.b2PolygonShape();
												
												if (fixtureDef.shape.data) {
													finalX = fixtureDef.shape.data.x !== undefined ? fixtureDef.shape.data.x : 0;
													finalY = fixtureDef.shape.data.y !== undefined ? fixtureDef.shape.data.y : 0;
													finalWidth = fixtureDef.shape.data.width !== undefined ? fixtureDef.shape.data.width : (entity._bounds2d.x / 2);
													finalHeight = fixtureDef.shape.data.height !== undefined ? fixtureDef.shape.data.height : (entity._bounds2d.y / 2);
												} else {
													finalX = 0;
													finalY = 0;
													finalWidth = (entity._bounds2d.x / 2);
													finalHeight = (entity._bounds2d.y / 2);
												}
												
												// Set the polygon as a box
												tempShape.SetAsOrientedBox(
													(finalWidth / this._scaleRatio),
													(finalHeight / this._scaleRatio),
													new this.b2Vec2(finalX / this._scaleRatio, finalY / this._scaleRatio),
													0
												);
												break;
										}
										
										if (tempShape) {
											tempFixture.shape = tempShape;
											finalFixture = tempBod.CreateFixture(tempFixture);
											finalFixture.igeId = tempFixture.igeId;
										}
									}
									
									if (fixtureDef.filter && finalFixture) {
										tempFilterData = new this.b2FilterData();
										
										if (fixtureDef.filter.categoryBits !== undefined) {
											tempFilterData.categoryBits = fixtureDef.filter.categoryBits;
										}
										if (fixtureDef.filter.maskBits !== undefined) {
											tempFilterData.maskBits = fixtureDef.filter.maskBits;
										}
										if (fixtureDef.filter.categoryIndex !== undefined) {
											tempFilterData.categoryIndex = fixtureDef.filter.categoryIndex;
										}
										
										finalFixture.SetFilterData(tempFilterData);
									}
									
									if (fixtureDef.density !== undefined && finalFixture) {
										finalFixture.SetDensity(fixtureDef.density);
									}
								}
							} else {
								this.log('Box2D body has no fixtures, have you specified fixtures correctly? They are supposed to be an array of fixture objects.', 'warning');
							}
							break;
					}
				}
			}
			
			// Store the entity that is linked to this body
			tempBod._entity = entity;
			
			// Add the body to the world with the passed fixture
			return tempBod;
		},
		
		/**
		 * Produces static box2d bodies from passed map data.
		 * @param {IgeTileMap2d} mapLayer
		 * @param {Function=} callback Returns true or false depending
		 * on if the passed map data should be included as part of the
		 * box2d static object data. This allows you to control what
		 * parts of the map data are to be considered for box2d static
		 * objects and which parts are to be ignored. If not passed then
		 * any tile with any map data is considered part of the static
		 * object data.
		 */
		staticsFromMap: function (mapLayer, callback) {
			if (mapLayer.map) {
				var tileWidth = mapLayer.tileWidth(),
					tileHeight = mapLayer.tileHeight(),
					posX, posY,
					rectArray, rectCount, rect;
				
				// Get the array of rectangle bounds based on
				// the map's data
				rectArray = mapLayer.scanRects(callback);
				rectCount = rectArray.length;
				
				while (rectCount--) {
					rect = rectArray[rectCount];
					
					posX = (tileWidth * (rect.width / 2));
					posY = (tileHeight * (rect.height / 2));
					
					new IgeEntityBox2d()
						.translateTo(rect.x * tileWidth + posX, rect.y * tileHeight + posY, 0)
						.width(rect.width * tileWidth)
						.height(rect.height * tileHeight)
						.drawBounds(true)
						.drawBoundsData(false)
						.box2dBody({
							type: 'static',
							allowSleep: true,
							fixtures: [{
								shape: {
									type: 'rectangle'
								}
							}]
						});
				}
			} else {
				this.log('Cannot extract box2d static bodies from map data because passed map does not have a .map property!', 'error');
			}
		},
		
		/**
		 * Creates a contact listener with the specified callbacks. When
		 * contacts begin and end inside the box2d simulation the specified
		 * callbacks are fired.
		 * @param {Function} beginContactCallback The method to call when the contact listener detects contact has started.
		 * @param {Function} endContactCallback The method to call when the contact listener detects contact has ended.
		 * @param {Function} preSolve
		 * @param {Function} postSolve
		 */
		contactListener: function (beginContactCallback, endContactCallback, preSolve, postSolve) {
			var contactListener = new this.b2ContactListener();
			if (beginContactCallback !== undefined) {
				contactListener.BeginContact = beginContactCallback;
			}
			
			if (endContactCallback !== undefined) {
				contactListener.EndContact = endContactCallback;
			}
			
			if (preSolve !== undefined) {
				contactListener.PreSolve = preSolve;
			}
			
			if (postSolve !== undefined) {
				contactListener.PostSolve = postSolve;
			}
			this._world.SetContactListener(contactListener);
		},
		
		/**
		 * If enabled, sets the physics world into network debug mode which
		 * will stop the world from generating collisions but still allow us
		 * to see shape outlines as they are attached to bodies. Useful when
		 * your physics system is server-side but seeing client-side shape
		 * data is useful for debugging collisions.
		 * @param {Boolean} val
		 */
		networkDebugMode: function (val) {
			if (val !== undefined) {
				this._networkDebugMode = val;
				
				if (val === true) {
					// We are enabled so disable all physics contacts
					this.contactListener(
						// Begin contact
						function (contact) {
						},
						// End contact
						function (contact) {
						},
						// Pre-solve
						function (contact) {
							// Cancel the contact
							contact.SetEnabled(false);
						},
						// Post-solve
						function (contact) {
						}
					);
				} else {
					// Re-enable contacts
					this.contactListener();
				}
				
				return this;
			}
			
			return this._networkDebugMode;
		},
		
		/**
		 * Creates a debug entity that outputs the bounds of each box2d
		 * body during standard engine ticks.
		 * @param {IgeEntity} mountScene
		 */
		enableDebug: function (mountScene) {
			if (mountScene) {
				// Define the debug drawing instance
				var debugDraw = new this.b2DebugDraw();
				this._box2dDebug = true;
				
				debugDraw.SetSprite($ige.engine._ctx);
				debugDraw.SetDrawScale(this._scaleRatio);
				debugDraw.SetFillAlpha(0.3);
				debugDraw.SetLineThickness(1.0);
				debugDraw.SetFlags(
					this.b2DebugDraw.e_controllerBit
					| this.b2DebugDraw.e_jointBit
					| this.b2DebugDraw.e_pairBit
					| this.b2DebugDraw.e_shapeBit
					//| this.b2DebugDraw.e_aabbBit
					//| this.b2DebugDraw.e_centerOfMassBit
				);
				
				// Set the debug draw for the world
				this._world.SetDebugDraw(debugDraw);
				
				// Create the debug painter entity and mount
				// it to the passed scene
				new igeClassStore.IgeBox2dDebugPainter()
					.depth(40000) // Set a really high depth
					.drawBounds(false)
					.mount(mountScene);
			} else {
				this.log('Cannot enable box2d debug drawing because the passed argument is not an object on the scenegraph.', 'error');
			}
		},
		
		/**
		 * Queues a body for removal from the physics world.
		 * @param body
		 */
		destroyBody: function (body) {
			this._removeWhenReady.push(body);
		},
		
		/**
		 * Gets / sets the callback method that will be called after
		 * every physics world step.
		 * @param method
		 * @return {*}
		 */
		updateCallback: function (method) {
			if (method !== undefined) {
				this._updateCallback = method;
				return this;
			}
			
			return this._updateCallback;
		},
		
		start: function () {
			var self = this;
			if (!this._active) {
				this._active = true;
				
				if (!this._networkDebugMode) {
					if (this._mode === 0) {
						// Add the box2d behaviour to the ige
						$ige.engine.addBehaviour('box2dStep_' + self._id, function () {
							self._behaviour.apply(self, arguments);
						});
					} else {
						this._intervalTimer = setInterval(function () {
							self._behaviour.apply(self, arguments);
						}, 1000 / 60);
					}
				}
			}
		},
		
		stop: function () {
			if (this._active) {
				this._active = false;
				
				if (this._mode === 0) {
					// Add the box2d behaviour to the ige
					$ige.engine.removeBehaviour('box2dStep_' + this._id);
				} else {
					clearInterval(this._intervalTimer);
				}
			}
		},
		
		/**
		 * Steps the physics simulation forward.
		 * @param ctx
		 * @private
		 */
		_behaviour: function (ctx) {
			var self = this,
				tempBod,
				entity,
				entityBox2dBody,
				removeWhenReady,
				count,
				destroyBody;
			
			if (self._active && self._world) {
				if (!self._world.IsLocked()) {
					// Remove any bodies that were queued for removal
					removeWhenReady = self._removeWhenReady;
					count = removeWhenReady.length;
					
					if (count) {
						destroyBody = self._world.DestroyBody;
						while (count--) {
							destroyBody.apply(self._world, [removeWhenReady[count]]);
						}
						self._removeWhenReady = [];
						removeWhenReady = null;
					}
				}
				
				// Call the world step; frame-rate, velocity iterations, position iterations
				if (self._mode === 0) {
					self._world.Step($time._tickDelta / 1000, 8, 3);
				} else {
					self._world.Step(1 / 60, 8, 3);
				}
				
				// Loop the physics objects and move the entities they are assigned to
				tempBod = self._world.GetBodyList();
				while (tempBod) {
					if (tempBod._entity) {
						// Body has an entity assigned to it
						entity = tempBod._entity; //self.$ige.engine.entities.read(tempBod.m_userData);
						entityBox2dBody = entity._box2dBody;
						
						// Check if the body is awake and is dynamic (we don't transform static bodies)
						if (tempBod.IsAwake() && tempBod.m_type !== 0) {
							// Update the entity data to match the body data
							entityBox2dBody.updating = true;
							entity.translateTo(tempBod.m_xf.position.x * entity._b2dRef._scaleRatio, tempBod.m_xf.position.y * entity._b2dRef._scaleRatio, entity._translate.z);
							entity.rotateTo(entity._rotate.x, entity._rotate.y, tempBod.GetAngle());
							entityBox2dBody.updating = false;
							
							if (entityBox2dBody.asleep) {
								// The body was asleep last frame, fire an awake event
								entityBox2dBody.asleep = false;
								self.emit('afterAwake', entity);
							}
						} else {
							if (!entityBox2dBody.asleep) {
								// The body was awake last frame, fire an asleep event
								entityBox2dBody.asleep = true;
								self.emit('afterAsleep', entity);
							}
						}
					}
					
					tempBod = tempBod.GetNext();
				}
				
				// Clear forces because we have ended our physics simulation frame
				self._world.ClearForces();
				
				tempBod = null;
				entity = null;
				
				if (typeof(self._updateCallback) === 'function') {
					self._updateCallback();
				}
			}
		},
		
		destroy: function () {
			// Stop processing box2d steps
			this.removeBehaviour('box2dStep');
			
			// Destroy all box2d world bodies
			
		}
	});
	
	return IgeBox2dWorld;
});
},{"irrelon-appcore":125}],38:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEntityBox2d', function ($ige, IgeEntity) {
	/**
	 * Creates a new entity with box2d integration.
	 */
	var IgeEntityBox2d = IgeEntity.extend({
		classId: 'IgeEntityBox2d',
		
		init: function (world) {
			IgeEntity.prototype.init.call(this);
			
			if (world) {
				if (typeof(world) === 'string') {
					// Get world reference
					world = $ige.engine.box2d.world(world);
				}
				
				this._box2dWorld = world;
				this._b2dRef = world;
			} else {
				this._b2dRef = $ige.engine.box2d;
			}
			
			// Check if box2d is enabled in the engine
			if ($ige.engine.box2d) {
				if (!this._b2dRef._networkDebugMode) {
					// Store the existing transform methods
					this._translateToProto = this.translateTo;
					this._translateByProto = this.translateBy;
					
					this._rotateToProto = this.rotateTo;
					this._rotateByProto = this.rotateBy;
					
					// Take over the transform methods
					this.translateTo = this._translateTo;
					this.translateBy = this._translateBy;
					
					this.rotateTo = this._rotateTo;
					this.rotateBy = this._rotateBy;
				} else {
					this._translateToProto = function () {
					};
					this._translateByProto = function () {
					};
					
					this._rotateToProto = function () {
					};
					this._rotateByProto = function () {
					};
					
					this._updateProto = this.update;
					
					// Make sure box2d is kept up to date by the engine
					this.update = this._update;
				}
			}
		},
		
		/**
		 * Gets / sets the box2d body's active flag which determines
		 * if it will be included as part of the physics simulation
		 * or not.
		 * @param {Boolean=} val Set to true to include the body in
		 * the physics simulation or false for it to be ignored.
		 * @return {*}
		 */
		box2dActive: function (val) {
			if (this._box2dBody) {
				if (val !== undefined) {
					this._box2dBody.SetActive(val);
					return this;
				}
				
				return this._box2dBody.IsActive();
			}
			
			return this;
		},
		
		/**
		 * Gets / sets the physics body definition. When setting the
		 * definition the physics body will also be created automatically
		 * from the supplied definition.
		 * @param def
		 * @return {*}
		 */
		box2dBody: function (def) {
			if (def !== undefined) {
				this._box2dBodyDef = def;
				
				// Check that the box2d component exists
				if ($ige.engine.box2d) {
					// Ask the box2d component to create a new body for us
					this._box2dBody = this._b2dRef.createBody(this, def);
				} else {
					this.log('You are trying to create a box2d entity but you have not added the box2d component to the ige instance!', 'error');
				}
				
				return this;
			}
			
			return this._box2dBodyDef;
		},
		
		/**
		 * Gets / sets the box2d body's gravitic value. If set to false,
		 * this entity will not be affected by gravity. If set to true it
		 * will be affected by gravity.
		 * @param {Boolean=} val True to allow gravity to affect this entity.
		 * @returns {*}
		 */
		gravitic: function (val) {
			if (this._box2dBody) {
				if (val !== undefined) {
					this._box2dBody.m_nonGravitic = !val;
					this._box2dBodyDef.gravitic = val;
					
					// Wake up the body
					this._box2dBody.SetAwake(true);
					return this;
				}
				
				return !this._box2dBody.m_nonGravitic;
			}
		},
		
		on: function () {
			if (arguments.length === 3) {
				var evName = arguments[0],
					target = arguments[1],
					callback = arguments[2],
					type;
				
				switch (target.substr(0, 1)) {
					case '#':
						type = 0;
						break;
					
					case '.':
						type = 1;
						break;
				}
				
				target = target.substr(1, target.length - 1);
				
				switch (evName) {
					case 'collisionStart':
						this._collisionStartListeners = this._collisionStartListeners || [];
						this._collisionStartListeners.push({
							type: type,
							target: target,
							callback: callback
						});
						
						if (!this._contactListener) {
							// Setup contact listener
							this._contactListener = this._setupContactListeners();
						}
						break;
					
					case 'collisionEnd':
						this._collisionEndListeners = this._collisionEndListeners || [];
						this._collisionEndListeners.push({
							type: type,
							target: target,
							callback: callback
						});
						
						if (!this._contactListener) {
							// Setup contact listener
							this._contactListener = this._setupContactListeners();
						}
						break;
					
					default:
						this.log('Cannot add event listener, event type ' + evName + ' not recognised', 'error');
						break;
				}
			} else {
				IgeEntity.prototype.on.apply(this, arguments);
			}
		},
		
		off: function () {
			if (arguments.length === 3) {
				
			} else {
				IgeEntity.prototype.off.apply(this, arguments);
			}
		},
		
		_setupContactListeners: function () {
			var self = this;
			
			$ige.engine.box2d.contactListener(
				// Listen for when contact's begin
				function (contact) {
					//console.log('Contact begins between', contact.igeEntityA()._id, 'and', contact.igeEntityB()._id);
					
					// Loop the collision listeners and check for a match
					var arr = self._collisionStartListeners;
					
					if (arr) {
						self._checkContact(contact, arr);
					}
				},
				// Listen for when contact's end
				function (contact) {
					//console.log('Contact ends between', contact.igeEntityA()._id, 'and', contact.igeEntityB()._id);
					// Loop the collision listeners and check for a match
					var arr = self._collisionEndListeners;
					
					if (arr) {
						self._checkContact(contact, arr);
					}
				}/*,
				 // Handle pre-solver events
				 function (contact) {
				 // If player ship collides with lunar surface, crash!
				 if (contact.igeEitherCategory('orb') && contact.igeEitherCategory('ship')) {
				 // Cancel the contact
				 contact.SetEnabled(false);
				 }
				 
				 // You can also check an entity by it's category using igeEitherCategory('categoryName')
				 }*/
			);
		},
		
		_checkContact: function (contact, arr) {
			var self = this,
				arrCount = arr.length,
				otherEntity,
				listener,
				i;
			
			if (contact.igeEntityA()._id === self._id) {
				otherEntity = contact.igeEntityB();
			} else if (contact.igeEntityB()._id === self._id) {
				otherEntity = contact.igeEntityA();
			} else {
				// This contact has nothing to do with us
				return;
			}
			
			for (i = 0; i < arrCount; i++) {
				listener = arr[i];
				
				if (listener.type === 0) {
					// Listener target is an id
					if (otherEntity._id === listener.target) {
						// Contact with target established, fire callback
						listener.callback(contact);
					}
				}
				
				if (arr[i].type === 1) {
					// Listener target is a category
					if (otherEntity._category === listener.target) {
						// Contact with target established, fire callback
						listener.callback(contact);
					}
				}
			}
		},
		
		/**
		 * Takes over translateTo calls and processes box2d movement as well.
		 * @param x
		 * @param y
		 * @param z
		 * @return {*}
		 * @private
		 */
		_translateTo: function (x, y, z) {
			var entBox2d = this._box2dBody;
			
			// Call the original method
			this._translateToProto(x, y, z);
			
			// Check if the entity has a box2d body attached
			// and if so, is it updating or not
			if (entBox2d && !entBox2d.updating) {
				// We have an entity with a box2d definition that is
				// not currently updating so let's override the standard
				// transform op and take over
				
				// Translate the body
				entBox2d.SetPosition({x: x / this._b2dRef._scaleRatio, y: y / this._b2dRef._scaleRatio});
				entBox2d.SetAwake(true);
			}
			
			return this;
		},
		
		/**
		 * Takes over translateBy calls and processes box2d movement as well.
		 * @param x
		 * @param y
		 * @param z
		 * @private
		 */
		_translateBy: function (x, y, z) {
			this._translateTo(this._translate.x + x, this._translate.y + y, this._translate.z + z);
		},
		
		/**
		 * Takes over translateTo calls and processes box2d movement as well.
		 * @param x
		 * @param y
		 * @param z
		 * @return {*}
		 * @private
		 */
		_rotateTo: function (x, y, z) {
			var entBox2d = this._box2dBody;
			
			// Call the original method
			this._rotateToProto(x, y, z);
			
			// Check if the entity has a box2d body attached
			// and if so, is it updating or not
			if (entBox2d && !entBox2d.updating) {
				// We have an entity with a box2d definition that is
				// not currently updating so let's override the standard
				// transform op and take over
				
				// Translate the body
				entBox2d.SetAngle(z);
				entBox2d.SetAwake(true);
			}
			
			return this;
		},
		
		/**
		 * Takes over translateBy calls and processes box2d movement as well.
		 * @param x
		 * @param y
		 * @param z
		 * @private
		 */
		_rotateBy: function (x, y, z) {
			this._rotateTo(this._rotate.x + x, this._rotate.y + y, this._rotate.z + z);
		},
		
		/**
		 * Purely for networkDebugMode handling, ensures that an entity's transform is
		 * not taken over by the physics simulation and is instead handled by the engine.
		 * @param ctx
		 * @private
		 */
		_update: function (ctx) {
			// Call the original method
			this._updateProto(ctx);
			
			// Update the box2d body transform
			this._translateTo(this._translate.x, this._translate.y, this._translate.z);
			this._rotateTo(this._rotate.x, this._rotate.y, this._rotate.z);
			
			//IgeEntity.prototype.update.call(this, ctx);
		},
		
		/**
		 * If true, disabled box2d debug shape drawing for this entity.
		 * @param {Boolean} val
		 */
		box2dNoDebug: function (val) {
			if (val !== undefined) {
				this._box2dNoDebug = val;
				return this;
			}
			
			return this._box2dNoDebug;
		},
		
		/**
		 * Destroys the physics entity and the box2d body that
		 * is attached to it.
		 */
		destroy: function () {
			if (this._box2dBody) {
				this._b2dRef.destroyBody(this._box2dBody);
			}
			IgeEntity.prototype.destroy.call(this);
		}
	});
	
	return IgeEntityBox2d;
});
},{"irrelon-appcore":125}],39:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('Box2D', function () {
   /*
    * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
    *
    * This software is provided 'as-is', without any express or implied
    * warranty.  In no event will the authors be held liable for any damages
    * arising from the use of this software.
    * Permission is granted to anyone to use this software for any purpose,
    * including commercial applications, and to alter it and redistribute it
    * freely, subject to the following restrictions:
    * 1. The origin of this software must not be misrepresented; you must not
    * claim that you wrote the original software. If you use this software
    * in a product, an acknowledgment in the product documentation would be
    * appreciated but is not required.
    * 2. Altered source versions must be plainly marked as such, and must not be
    * misrepresented as being the original software.
    * 3. This notice may not be removed or altered from any source distribution.
    */
	var Box2D = {};
	
	(function (a2j, undefined) {
		if (!(Object.defineProperty instanceof Function)
			&& Object.__defineGetter__ instanceof Function
			&& Object.__defineSetter__ instanceof Function) {
			Object.defineProperty = function (obj, p, cfg) {
				if (cfg.get instanceof Function)
					obj.__defineGetter__(p, cfg.get);
				if (cfg.set instanceof Function)
					obj.__defineSetter__(p, cfg.set);
			}
		}
		
		function emptyFn () {
		};
		a2j.inherit = function (cls, base) {
			var tmpCtr = cls;
			emptyFn.prototype = base.prototype;
			cls.prototype = new emptyFn;
			cls.prototype.constructor = tmpCtr;
		};
		
		a2j.generateCallback = function generateCallback (context, cb) {
			return function () {
				cb.apply(context, arguments);
			};
		};
		
		a2j.NVector = function NVector (length) {
			if (length === undefined) length = 0;
			var tmp = new Array(length || 0);
			for (var i = 0; i < length; ++i)
				tmp[i] = 0;
			return tmp;
		};
		
		a2j.is = function is (o1, o2) {
			if (o1 === null) return false;
			if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
			if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
			return false;
		};
		
		a2j.parseUInt = function (v) {
			return Math.abs(parseInt(v));
		}
		
	})(Box2D);

//#TODO remove assignments from global namespace
	var Vector = Array;
	var Vector_a2j_Number = Box2D.NVector;
//package structure
	if (typeof(Box2D) === "undefined") Box2D = {};
	if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
	if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
	if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
	if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
	if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
	if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
	if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
	if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
	(function () {
		Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';
		
		function b2AABB () {
			b2AABB.b2AABB.apply(this, arguments);
		};
		Box2D.Collision.b2AABB = b2AABB;
		
		function b2Bound () {
			b2Bound.b2Bound.apply(this, arguments);
		};
		Box2D.Collision.b2Bound = b2Bound;
		
		function b2BoundValues () {
			b2BoundValues.b2BoundValues.apply(this, arguments);
			if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
		};
		Box2D.Collision.b2BoundValues = b2BoundValues;
		
		function b2Collision () {
			b2Collision.b2Collision.apply(this, arguments);
		};
		Box2D.Collision.b2Collision = b2Collision;
		
		function b2ContactID () {
			b2ContactID.b2ContactID.apply(this, arguments);
			if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
		};
		Box2D.Collision.b2ContactID = b2ContactID;
		
		function b2ContactPoint () {
			b2ContactPoint.b2ContactPoint.apply(this, arguments);
		};
		Box2D.Collision.b2ContactPoint = b2ContactPoint;
		
		function b2Distance () {
			b2Distance.b2Distance.apply(this, arguments);
		};
		Box2D.Collision.b2Distance = b2Distance;
		
		function b2DistanceInput () {
			b2DistanceInput.b2DistanceInput.apply(this, arguments);
		};
		Box2D.Collision.b2DistanceInput = b2DistanceInput;
		
		function b2DistanceOutput () {
			b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
		};
		Box2D.Collision.b2DistanceOutput = b2DistanceOutput;
		
		function b2DistanceProxy () {
			b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
		};
		Box2D.Collision.b2DistanceProxy = b2DistanceProxy;
		
		function b2DynamicTree () {
			b2DynamicTree.b2DynamicTree.apply(this, arguments);
			if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
		};
		Box2D.Collision.b2DynamicTree = b2DynamicTree;
		
		function b2DynamicTreeBroadPhase () {
			b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
		};
		Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;
		
		function b2DynamicTreeNode () {
			b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
		};
		Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;
		
		function b2DynamicTreePair () {
			b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
		};
		Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;
		
		function b2Manifold () {
			b2Manifold.b2Manifold.apply(this, arguments);
			if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
		};
		Box2D.Collision.b2Manifold = b2Manifold;
		
		function b2ManifoldPoint () {
			b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
			if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
		};
		Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;
		
		function b2Point () {
			b2Point.b2Point.apply(this, arguments);
		};
		Box2D.Collision.b2Point = b2Point;
		
		function b2RayCastInput () {
			b2RayCastInput.b2RayCastInput.apply(this, arguments);
			if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
		};
		Box2D.Collision.b2RayCastInput = b2RayCastInput;
		
		function b2RayCastOutput () {
			b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
		};
		Box2D.Collision.b2RayCastOutput = b2RayCastOutput;
		
		function b2Segment () {
			b2Segment.b2Segment.apply(this, arguments);
		};
		Box2D.Collision.b2Segment = b2Segment;
		
		function b2SeparationFunction () {
			b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
		};
		Box2D.Collision.b2SeparationFunction = b2SeparationFunction;
		
		function b2Simplex () {
			b2Simplex.b2Simplex.apply(this, arguments);
			if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
		};
		Box2D.Collision.b2Simplex = b2Simplex;
		
		function b2SimplexCache () {
			b2SimplexCache.b2SimplexCache.apply(this, arguments);
		};
		Box2D.Collision.b2SimplexCache = b2SimplexCache;
		
		function b2SimplexVertex () {
			b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
		};
		Box2D.Collision.b2SimplexVertex = b2SimplexVertex;
		
		function b2TimeOfImpact () {
			b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
		};
		Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;
		
		function b2TOIInput () {
			b2TOIInput.b2TOIInput.apply(this, arguments);
		};
		Box2D.Collision.b2TOIInput = b2TOIInput;
		
		function b2WorldManifold () {
			b2WorldManifold.b2WorldManifold.apply(this, arguments);
			if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
		};
		Box2D.Collision.b2WorldManifold = b2WorldManifold;
		
		function ClipVertex () {
			ClipVertex.ClipVertex.apply(this, arguments);
		};
		Box2D.Collision.ClipVertex = ClipVertex;
		
		function Features () {
			Features.Features.apply(this, arguments);
		};
		Box2D.Collision.Features = Features;
		
		function b2CircleShape () {
			b2CircleShape.b2CircleShape.apply(this, arguments);
			if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;
		
		function b2EdgeChainDef () {
			b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
			if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;
		
		function b2EdgeShape () {
			b2EdgeShape.b2EdgeShape.apply(this, arguments);
			if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;
		
		function b2MassData () {
			b2MassData.b2MassData.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2MassData = b2MassData;
		
		function b2PolygonShape () {
			b2PolygonShape.b2PolygonShape.apply(this, arguments);
			if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;
		
		function b2Shape () {
			b2Shape.b2Shape.apply(this, arguments);
			if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2Shape = b2Shape;
		Box2D.Common.b2internal = 'Box2D.Common.b2internal';
		
		function b2Color () {
			b2Color.b2Color.apply(this, arguments);
			if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
		};
		Box2D.Common.b2Color = b2Color;
		
		function b2Settings () {
			b2Settings.b2Settings.apply(this, arguments);
		};
		Box2D.Common.b2Settings = b2Settings;
		
		function b2Mat22 () {
			b2Mat22.b2Mat22.apply(this, arguments);
			if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
		};
		Box2D.Common.Math.b2Mat22 = b2Mat22;
		
		function b2Mat33 () {
			b2Mat33.b2Mat33.apply(this, arguments);
			if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
		};
		Box2D.Common.Math.b2Mat33 = b2Mat33;
		
		function b2Math () {
			b2Math.b2Math.apply(this, arguments);
		};
		Box2D.Common.Math.b2Math = b2Math;
		
		function b2Sweep () {
			b2Sweep.b2Sweep.apply(this, arguments);
		};
		Box2D.Common.Math.b2Sweep = b2Sweep;
		
		function b2Transform () {
			b2Transform.b2Transform.apply(this, arguments);
			if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
		};
		Box2D.Common.Math.b2Transform = b2Transform;
		
		function b2Vec2 () {
			b2Vec2.b2Vec2.apply(this, arguments);
			if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
		};
		Box2D.Common.Math.b2Vec2 = b2Vec2;
		
		function b2Vec3 () {
			b2Vec3.b2Vec3.apply(this, arguments);
			if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
		};
		Box2D.Common.Math.b2Vec3 = b2Vec3;
		
		function b2Body () {
			b2Body.b2Body.apply(this, arguments);
			if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
		};
		Box2D.Dynamics.b2Body = b2Body;
		
		function b2BodyDef () {
			b2BodyDef.b2BodyDef.apply(this, arguments);
			if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
		};
		Box2D.Dynamics.b2BodyDef = b2BodyDef;
		
		function b2ContactFilter () {
			b2ContactFilter.b2ContactFilter.apply(this, arguments);
		};
		Box2D.Dynamics.b2ContactFilter = b2ContactFilter;
		
		function b2ContactImpulse () {
			b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
		};
		Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;
		
		function b2ContactListener () {
			b2ContactListener.b2ContactListener.apply(this, arguments);
		};
		Box2D.Dynamics.b2ContactListener = b2ContactListener;
		
		function b2ContactManager () {
			b2ContactManager.b2ContactManager.apply(this, arguments);
			if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
		};
		Box2D.Dynamics.b2ContactManager = b2ContactManager;
		
		function b2DebugDraw () {
			b2DebugDraw.b2DebugDraw.apply(this, arguments);
			if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
		};
		Box2D.Dynamics.b2DebugDraw = b2DebugDraw;
		
		function b2DestructionListener () {
			b2DestructionListener.b2DestructionListener.apply(this, arguments);
		};
		Box2D.Dynamics.b2DestructionListener = b2DestructionListener;
		
		function b2FilterData () {
			b2FilterData.b2FilterData.apply(this, arguments);
		};
		Box2D.Dynamics.b2FilterData = b2FilterData;
		
		function b2Fixture () {
			b2Fixture.b2Fixture.apply(this, arguments);
			if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
		};
		Box2D.Dynamics.b2Fixture = b2Fixture;
		
		function b2FixtureDef () {
			b2FixtureDef.b2FixtureDef.apply(this, arguments);
			if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
		};
		Box2D.Dynamics.b2FixtureDef = b2FixtureDef;
		
		function b2Island () {
			b2Island.b2Island.apply(this, arguments);
			if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
		};
		Box2D.Dynamics.b2Island = b2Island;
		
		function b2TimeStep () {
			b2TimeStep.b2TimeStep.apply(this, arguments);
		};
		Box2D.Dynamics.b2TimeStep = b2TimeStep;
		
		function b2World () {
			b2World.b2World.apply(this, arguments);
			if (this.constructor === b2World) this.b2World.apply(this, arguments);
		};
		Box2D.Dynamics.b2World = b2World;
		
		function b2CircleContact () {
			b2CircleContact.b2CircleContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;
		
		function b2Contact () {
			b2Contact.b2Contact.apply(this, arguments);
			if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2Contact = b2Contact;
		
		function b2ContactConstraint () {
			b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
			if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;
		
		function b2ContactConstraintPoint () {
			b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;
		
		function b2ContactEdge () {
			b2ContactEdge.b2ContactEdge.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;
		
		function b2ContactFactory () {
			b2ContactFactory.b2ContactFactory.apply(this, arguments);
			if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;
		
		function b2ContactRegister () {
			b2ContactRegister.b2ContactRegister.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;
		
		function b2ContactResult () {
			b2ContactResult.b2ContactResult.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;
		
		function b2ContactSolver () {
			b2ContactSolver.b2ContactSolver.apply(this, arguments);
			if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;
		
		function b2EdgeAndCircleContact () {
			b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
		
		function b2NullContact () {
			b2NullContact.b2NullContact.apply(this, arguments);
			if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;
		
		function b2PolyAndCircleContact () {
			b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;
		
		function b2PolyAndEdgeContact () {
			b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;
		
		function b2PolygonContact () {
			b2PolygonContact.b2PolygonContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;
		
		function b2PositionSolverManifold () {
			b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
			if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;
		
		function b2BuoyancyController () {
			b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;
		
		function b2ConstantAccelController () {
			b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;
		
		function b2ConstantForceController () {
			b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;
		
		function b2Controller () {
			b2Controller.b2Controller.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2Controller = b2Controller;
		
		function b2ControllerEdge () {
			b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;
		
		function b2GravityController () {
			b2GravityController.b2GravityController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;
		
		function b2TensorDampingController () {
			b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;
		
		function b2DistanceJoint () {
			b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
			if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;
		
		function b2DistanceJointDef () {
			b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
			if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;
		
		function b2FrictionJoint () {
			b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
			if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;
		
		function b2FrictionJointDef () {
			b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
			if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;
		
		function b2GearJoint () {
			b2GearJoint.b2GearJoint.apply(this, arguments);
			if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;
		
		function b2GearJointDef () {
			b2GearJointDef.b2GearJointDef.apply(this, arguments);
			if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;
		
		function b2Jacobian () {
			b2Jacobian.b2Jacobian.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;
		
		function b2Joint () {
			b2Joint.b2Joint.apply(this, arguments);
			if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2Joint = b2Joint;
		
		function b2JointDef () {
			b2JointDef.b2JointDef.apply(this, arguments);
			if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2JointDef = b2JointDef;
		
		function b2JointEdge () {
			b2JointEdge.b2JointEdge.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;
		
		function b2LineJoint () {
			b2LineJoint.b2LineJoint.apply(this, arguments);
			if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;
		
		function b2LineJointDef () {
			b2LineJointDef.b2LineJointDef.apply(this, arguments);
			if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;
		
		function b2MouseJoint () {
			b2MouseJoint.b2MouseJoint.apply(this, arguments);
			if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;
		
		function b2MouseJointDef () {
			b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
			if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;
		
		function b2PrismaticJoint () {
			b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
			if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;
		
		function b2PrismaticJointDef () {
			b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
			if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;
		
		function b2PulleyJoint () {
			b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
			if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;
		
		function b2PulleyJointDef () {
			b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
			if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;
		
		function b2RevoluteJoint () {
			b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
			if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;
		
		function b2RevoluteJointDef () {
			b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
			if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;
		
		function b2WeldJoint () {
			b2WeldJoint.b2WeldJoint.apply(this, arguments);
			if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;
		
		function b2WeldJointDef () {
			b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
			if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
	})(); //definitions
	Box2D.postDefs = [];
	(function () {
		var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2AABB = Box2D.Collision.b2AABB,
			b2Bound = Box2D.Collision.b2Bound,
			b2BoundValues = Box2D.Collision.b2BoundValues,
			b2Collision = Box2D.Collision.b2Collision,
			b2ContactID = Box2D.Collision.b2ContactID,
			b2ContactPoint = Box2D.Collision.b2ContactPoint,
			b2Distance = Box2D.Collision.b2Distance,
			b2DistanceInput = Box2D.Collision.b2DistanceInput,
			b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
			b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
			b2DynamicTree = Box2D.Collision.b2DynamicTree,
			b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
			b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
			b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
			b2Manifold = Box2D.Collision.b2Manifold,
			b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
			b2Point = Box2D.Collision.b2Point,
			b2RayCastInput = Box2D.Collision.b2RayCastInput,
			b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
			b2Segment = Box2D.Collision.b2Segment,
			b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
			b2Simplex = Box2D.Collision.b2Simplex,
			b2SimplexCache = Box2D.Collision.b2SimplexCache,
			b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
			b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
			b2TOIInput = Box2D.Collision.b2TOIInput,
			b2WorldManifold = Box2D.Collision.b2WorldManifold,
			ClipVertex = Box2D.Collision.ClipVertex,
			Features = Box2D.Collision.Features,
			IBroadPhase = Box2D.Collision.IBroadPhase;
		
		b2AABB.b2AABB = function () {
			this.lowerBound = new b2Vec2();
			this.upperBound = new b2Vec2();
		};
		b2AABB.prototype.IsValid = function () {
			var dX = this.upperBound.x - this.lowerBound.x;
			var dY = this.upperBound.y - this.lowerBound.y;
			var valid = dX >= 0.0 && dY >= 0.0;
			valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
			return valid;
		}
		b2AABB.prototype.GetCenter = function () {
			return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
		}
		b2AABB.prototype.GetExtents = function () {
			return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
		}
		b2AABB.prototype.Contains = function (aabb) {
			var result = true;
			result = result && this.lowerBound.x <= aabb.lowerBound.x;
			result = result && this.lowerBound.y <= aabb.lowerBound.y;
			result = result && aabb.upperBound.x <= this.upperBound.x;
			result = result && aabb.upperBound.y <= this.upperBound.y;
			return result;
		}
		b2AABB.prototype.RayCast = function (output, input) {
			var tmin = (-Number.MAX_VALUE);
			var tmax = Number.MAX_VALUE;
			var pX = input.p1.x;
			var pY = input.p1.y;
			var dX = input.p2.x - input.p1.x;
			var dY = input.p2.y - input.p1.y;
			var absDX = Math.abs(dX);
			var absDY = Math.abs(dY);
			var normal = output.normal;
			var inv_d = 0;
			var t1 = 0;
			var t2 = 0;
			var t3 = 0;
			var s = 0;
			{
				if (absDX < Number.MIN_VALUE) {
					if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
				}
				else {
					inv_d = 1.0 / dX;
					t1 = (this.lowerBound.x - pX) * inv_d;
					t2 = (this.upperBound.x - pX) * inv_d;
					s = (-1.0);
					if (t1 > t2) {
						t3 = t1;
						t1 = t2;
						t2 = t3;
						s = 1.0;
					}
					if (t1 > tmin) {
						normal.x = s;
						normal.y = 0;
						tmin = t1;
					}
					tmax = Math.min(tmax, t2);
					if (tmin > tmax) return false;
				}
			}
			{
				if (absDY < Number.MIN_VALUE) {
					if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
				}
				else {
					inv_d = 1.0 / dY;
					t1 = (this.lowerBound.y - pY) * inv_d;
					t2 = (this.upperBound.y - pY) * inv_d;
					s = (-1.0);
					if (t1 > t2) {
						t3 = t1;
						t1 = t2;
						t2 = t3;
						s = 1.0;
					}
					if (t1 > tmin) {
						normal.y = s;
						normal.x = 0;
						tmin = t1;
					}
					tmax = Math.min(tmax, t2);
					if (tmin > tmax) return false;
				}
			}
			output.fraction = tmin;
			return true;
		}
		b2AABB.prototype.TestOverlap = function (other) {
			var d1X = other.lowerBound.x - this.upperBound.x;
			var d1Y = other.lowerBound.y - this.upperBound.y;
			var d2X = this.lowerBound.x - other.upperBound.x;
			var d2Y = this.lowerBound.y - other.upperBound.y;
			if (d1X > 0.0 || d1Y > 0.0) return false;
			if (d2X > 0.0 || d2Y > 0.0) return false;
			return true;
		}
		b2AABB.Combine = function (aabb1, aabb2) {
			var aabb = new b2AABB();
			aabb.Combine(aabb1, aabb2);
			return aabb;
		}
		b2AABB.prototype.Combine = function (aabb1, aabb2) {
			this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
			this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
			this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
			this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
		}
		b2Bound.b2Bound = function () {
		};
		b2Bound.prototype.IsLower = function () {
			return (this.value & 1) == 0;
		}
		b2Bound.prototype.IsUpper = function () {
			return (this.value & 1) == 1;
		}
		b2Bound.prototype.Swap = function (b) {
			var tempValue = this.value;
			var tempProxy = this.proxy;
			var tempStabbingCount = this.stabbingCount;
			this.value = b.value;
			this.proxy = b.proxy;
			this.stabbingCount = b.stabbingCount;
			b.value = tempValue;
			b.proxy = tempProxy;
			b.stabbingCount = tempStabbingCount;
		}
		b2BoundValues.b2BoundValues = function () {
		};
		b2BoundValues.prototype.b2BoundValues = function () {
			this.lowerValues = new Vector_a2j_Number();
			this.lowerValues[0] = 0.0;
			this.lowerValues[1] = 0.0;
			this.upperValues = new Vector_a2j_Number();
			this.upperValues[0] = 0.0;
			this.upperValues[1] = 0.0;
		}
		b2Collision.b2Collision = function () {
		};
		b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
			if (offset === undefined) offset = 0;
			var cv;
			var numOut = 0;
			cv = vIn[0];
			var vIn0 = cv.v;
			cv = vIn[1];
			var vIn1 = cv.v;
			var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
			var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
			if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
			if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
			if (distance0 * distance1 < 0.0) {
				var interp = distance0 / (distance0 - distance1);
				cv = vOut[numOut];
				var tVec = cv.v;
				tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
				tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
				cv = vOut[numOut];
				var cv2;
				if (distance0 > 0.0) {
					cv2 = vIn[0];
					cv.id = cv2.id;
				}
				else {
					cv2 = vIn[1];
					cv.id = cv2.id;
				}
				++numOut;
			}
			return numOut;
		}
		b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
			if (edge1 === undefined) edge1 = 0;
			var count1 = parseInt(poly1.m_vertexCount);
			var vertices1 = poly1.m_vertices;
			var normals1 = poly1.m_normals;
			var count2 = parseInt(poly2.m_vertexCount);
			var vertices2 = poly2.m_vertices;
			var tMat;
			var tVec;
			tMat = xf1.R;
			tVec = normals1[edge1];
			var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tMat = xf2.R;
			var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
			var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
			var index = 0;
			var minDot = Number.MAX_VALUE;
			for (var i = 0; i < count2; ++i) {
				tVec = vertices2[i];
				var dot = tVec.x * normal1X + tVec.y * normal1Y;
				if (dot < minDot) {
					minDot = dot;
					index = i;
				}
			}
			tVec = vertices1[edge1];
			tMat = xf1.R;
			var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tVec = vertices2[index];
			tMat = xf2.R;
			var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			v2X -= v1X;
			v2Y -= v1Y;
			var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
			return separation;
		}
		b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
			var count1 = parseInt(poly1.m_vertexCount);
			var normals1 = poly1.m_normals;
			var tVec;
			var tMat;
			tMat = xf2.R;
			tVec = poly2.m_centroid;
			var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tMat = xf1.R;
			tVec = poly1.m_centroid;
			dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
			var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
			var edge = 0;
			var maxDot = (-Number.MAX_VALUE);
			for (var i = 0; i < count1; ++i) {
				tVec = normals1[i];
				var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
				if (dot > maxDot) {
					maxDot = dot;
					edge = i;
				}
			}
			var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
			var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
			var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
			var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
			var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
			var bestEdge = 0;
			var bestSeparation = 0;
			var increment = 0;
			if (sPrev > s && sPrev > sNext) {
				increment = (-1);
				bestEdge = prevEdge;
				bestSeparation = sPrev;
			}
			else if (sNext > s) {
				increment = 1;
				bestEdge = nextEdge;
				bestSeparation = sNext;
			}
			else {
				edgeIndex[0] = edge;
				return s;
			}
			while (true) {
				if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
				else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;
				s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
				if (s > bestSeparation) {
					bestEdge = edge;
					bestSeparation = s;
				}
				else {
					break;
				}
			}
			edgeIndex[0] = bestEdge;
			return bestSeparation;
		}
		b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
			if (edge1 === undefined) edge1 = 0;
			var count1 = parseInt(poly1.m_vertexCount);
			var normals1 = poly1.m_normals;
			var count2 = parseInt(poly2.m_vertexCount);
			var vertices2 = poly2.m_vertices;
			var normals2 = poly2.m_normals;
			var tMat;
			var tVec;
			tMat = xf1.R;
			tVec = normals1[edge1];
			var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tMat = xf2.R;
			var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
			normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
			normal1X = tX;
			var index = 0;
			var minDot = Number.MAX_VALUE;
			for (var i = 0; i < count2; ++i) {
				tVec = normals2[i];
				var dot = (normal1X * tVec.x + normal1Y * tVec.y);
				if (dot < minDot) {
					minDot = dot;
					index = i;
				}
			}
			var tClip;
			var i1 = parseInt(index);
			var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
			tClip = c[0];
			tVec = vertices2[i1];
			tMat = xf2.R;
			tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tClip.id.features.referenceEdge = edge1;
			tClip.id.features.incidentEdge = i1;
			tClip.id.features.incidentVertex = 0;
			tClip = c[1];
			tVec = vertices2[i2];
			tMat = xf2.R;
			tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tClip.id.features.referenceEdge = edge1;
			tClip.id.features.incidentEdge = i2;
			tClip.id.features.incidentVertex = 1;
		}
		b2Collision.MakeClipPointVector = function () {
			var r = new Vector(2);
			r[0] = new ClipVertex();
			r[1] = new ClipVertex();
			return r;
		}
		b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
			var cv;
			manifold.m_pointCount = 0;
			var totalRadius = polyA.m_radius + polyB.m_radius;
			var edgeA = 0;
			b2Collision.s_edgeAO[0] = edgeA;
			var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
			edgeA = b2Collision.s_edgeAO[0];
			if (separationA > totalRadius) return;
			var edgeB = 0;
			b2Collision.s_edgeBO[0] = edgeB;
			var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
			edgeB = b2Collision.s_edgeBO[0];
			if (separationB > totalRadius) return;
			var poly1;
			var poly2;
			var xf1;
			var xf2;
			var edge1 = 0;
			var flip = 0;
			var k_relativeTol = 0.98;
			var k_absoluteTol = 0.001;
			var tMat;
			if (separationB > k_relativeTol * separationA + k_absoluteTol) {
				poly1 = polyB;
				poly2 = polyA;
				xf1 = xfB;
				xf2 = xfA;
				edge1 = edgeB;
				manifold.m_type = b2Manifold.e_faceB;
				flip = 1;
			}
			else {
				poly1 = polyA;
				poly2 = polyB;
				xf1 = xfA;
				xf2 = xfB;
				edge1 = edgeA;
				manifold.m_type = b2Manifold.e_faceA;
				flip = 0;
			}
			var incidentEdge = b2Collision.s_incidentEdge;
			b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
			var count1 = parseInt(poly1.m_vertexCount);
			var vertices1 = poly1.m_vertices;
			var local_v11 = vertices1[edge1];
			var local_v12;
			if (edge1 + 1 < count1) {
				local_v12 = vertices1[parseInt(edge1 + 1)];
			}
			else {
				local_v12 = vertices1[0];
			}
			var localTangent = b2Collision.s_localTangent;
			localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
			localTangent.Normalize();
			var localNormal = b2Collision.s_localNormal;
			localNormal.x = localTangent.y;
			localNormal.y = (-localTangent.x);
			var planePoint = b2Collision.s_planePoint;
			planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
			var tangent = b2Collision.s_tangent;
			tMat = xf1.R;
			tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
			tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
			var tangent2 = b2Collision.s_tangent2;
			tangent2.x = (-tangent.x);
			tangent2.y = (-tangent.y);
			var normal = b2Collision.s_normal;
			normal.x = tangent.y;
			normal.y = (-tangent.x);
			var v11 = b2Collision.s_v11;
			var v12 = b2Collision.s_v12;
			v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
			v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
			v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
			v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
			var frontOffset = normal.x * v11.x + normal.y * v11.y;
			var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
			var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
			var clipPoints1 = b2Collision.s_clipPoints1;
			var clipPoints2 = b2Collision.s_clipPoints2;
			var np = 0;
			np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
			if (np < 2) return;
			np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
			if (np < 2) return;
			manifold.m_localPlaneNormal.SetV(localNormal);
			manifold.m_localPoint.SetV(planePoint);
			var pointCount = 0;
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
				cv = clipPoints2[i];
				var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
				if (separation <= totalRadius) {
					var cp = manifold.m_points[pointCount];
					tMat = xf2.R;
					var tX = cv.v.x - xf2.position.x;
					var tY = cv.v.y - xf2.position.y;
					cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
					cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
					cp.m_id.Set(cv.id);
					cp.m_id.features.flip = flip;
					++pointCount;
				}
			}
			manifold.m_pointCount = pointCount;
		}
		b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
			manifold.m_pointCount = 0;
			var tMat;
			var tVec;
			tMat = xf1.R;
			tVec = circle1.m_p;
			var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tMat = xf2.R;
			tVec = circle2.m_p;
			var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			var dX = p2X - p1X;
			var dY = p2Y - p1Y;
			var distSqr = dX * dX + dY * dY;
			var radius = circle1.m_radius + circle2.m_radius;
			if (distSqr > radius * radius) {
				return;
			}
			manifold.m_type = b2Manifold.e_circles;
			manifold.m_localPoint.SetV(circle1.m_p);
			manifold.m_localPlaneNormal.SetZero();
			manifold.m_pointCount = 1;
			manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
			manifold.m_points[0].m_id.key = 0;
		}
		b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
			manifold.m_pointCount = 0;
			var tPoint;
			var dX = 0;
			var dY = 0;
			var positionX = 0;
			var positionY = 0;
			var tVec;
			var tMat;
			tMat = xf2.R;
			tVec = circle.m_p;
			var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			dX = cX - xf1.position.x;
			dY = cY - xf1.position.y;
			tMat = xf1.R;
			var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
			var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
			var dist = 0;
			var normalIndex = 0;
			var separation = (-Number.MAX_VALUE);
			var radius = polygon.m_radius + circle.m_radius;
			var vertexCount = parseInt(polygon.m_vertexCount);
			var vertices = polygon.m_vertices;
			var normals = polygon.m_normals;
			for (var i = 0; i < vertexCount; ++i) {
				tVec = vertices[i];
				dX = cLocalX - tVec.x;
				dY = cLocalY - tVec.y;
				tVec = normals[i];
				var s = tVec.x * dX + tVec.y * dY;
				if (s > radius) {
					return;
				}
				if (s > separation) {
					separation = s;
					normalIndex = i;
				}
			}
			var vertIndex1 = parseInt(normalIndex);
			var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
			var v1 = vertices[vertIndex1];
			var v2 = vertices[vertIndex2];
			if (separation < Number.MIN_VALUE) {
				manifold.m_pointCount = 1;
				manifold.m_type = b2Manifold.e_faceA;
				manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
				manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
				manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
				manifold.m_points[0].m_localPoint.SetV(circle.m_p);
				manifold.m_points[0].m_id.key = 0;
				return;
			}
			var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
			var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
			if (u1 <= 0.0) {
				if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
				manifold.m_pointCount = 1;
				manifold.m_type = b2Manifold.e_faceA;
				manifold.m_localPlaneNormal.x = cLocalX - v1.x;
				manifold.m_localPlaneNormal.y = cLocalY - v1.y;
				manifold.m_localPlaneNormal.Normalize();
				manifold.m_localPoint.SetV(v1);
				manifold.m_points[0].m_localPoint.SetV(circle.m_p);
				manifold.m_points[0].m_id.key = 0;
			}
			else if (u2 <= 0) {
				if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
				manifold.m_pointCount = 1;
				manifold.m_type = b2Manifold.e_faceA;
				manifold.m_localPlaneNormal.x = cLocalX - v2.x;
				manifold.m_localPlaneNormal.y = cLocalY - v2.y;
				manifold.m_localPlaneNormal.Normalize();
				manifold.m_localPoint.SetV(v2);
				manifold.m_points[0].m_localPoint.SetV(circle.m_p);
				manifold.m_points[0].m_id.key = 0;
			}
			else {
				var faceCenterX = 0.5 * (v1.x + v2.x);
				var faceCenterY = 0.5 * (v1.y + v2.y);
				separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
				if (separation > radius) return;
				manifold.m_pointCount = 1;
				manifold.m_type = b2Manifold.e_faceA;
				manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
				manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
				manifold.m_localPlaneNormal.Normalize();
				manifold.m_localPoint.Set(faceCenterX, faceCenterY);
				manifold.m_points[0].m_localPoint.SetV(circle.m_p);
				manifold.m_points[0].m_id.key = 0;
			}
		}
		b2Collision.TestOverlap = function (a, b) {
			var t1 = b.lowerBound;
			var t2 = a.upperBound;
			var d1X = t1.x - t2.x;
			var d1Y = t1.y - t2.y;
			t1 = a.lowerBound;
			t2 = b.upperBound;
			var d2X = t1.x - t2.x;
			var d2Y = t1.y - t2.y;
			if (d1X > 0.0 || d1Y > 0.0) return false;
			if (d2X > 0.0 || d2Y > 0.0) return false;
			return true;
		}
		Box2D.postDefs.push(function () {
			Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
			Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
			Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
			Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
			Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
			Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
			Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
			Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
			Box2D.Collision.b2Collision.s_normal = new b2Vec2();
			Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
			Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
			Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
			Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
			Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
			Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
		});
		b2ContactID.b2ContactID = function () {
			this.features = new Features();
		};
		b2ContactID.prototype.b2ContactID = function () {
			this.features._m_id = this;
		}
		b2ContactID.prototype.Set = function (id) {
			this.key = id._key;
		}
		b2ContactID.prototype.Copy = function () {
			var id = new b2ContactID();
			id.key = this.key;
			return id;
		}
		Object.defineProperty(b2ContactID.prototype, 'key', {
			enumerable: false,
			configurable: true,
			get: function () {
				return this._key;
			}
		});
		Object.defineProperty(b2ContactID.prototype, 'key', {
			enumerable: false,
			configurable: true,
			set: function (value) {
				if (value === undefined) value = 0;
				this._key = value;
				this.features._referenceEdge = this._key & 0x000000ff;
				this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
				this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
				this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
			}
		});
		b2ContactPoint.b2ContactPoint = function () {
			this.position = new b2Vec2();
			this.velocity = new b2Vec2();
			this.normal = new b2Vec2();
			this.id = new b2ContactID();
		};
		b2Distance.b2Distance = function () {
		};
		b2Distance.Distance = function (output, cache, input) {
			++b2Distance.b2_gjkCalls;
			var proxyA = input.proxyA;
			var proxyB = input.proxyB;
			var transformA = input.transformA;
			var transformB = input.transformB;
			var simplex = b2Distance.s_simplex;
			simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
			var vertices = simplex.m_vertices;
			var k_maxIters = 20;
			var saveA = b2Distance.s_saveA;
			var saveB = b2Distance.s_saveB;
			var saveCount = 0;
			var closestPoint = simplex.GetClosestPoint();
			var distanceSqr1 = closestPoint.LengthSquared();
			var distanceSqr2 = distanceSqr1;
			var i = 0;
			var p;
			var iter = 0;
			while (iter < k_maxIters) {
				saveCount = simplex.m_count;
				for (i = 0;
					 i < saveCount; i++) {
					saveA[i] = vertices[i].indexA;
					saveB[i] = vertices[i].indexB;
				}
				switch (simplex.m_count) {
					case 1:
						break;
					case 2:
						simplex.Solve2();
						break;
					case 3:
						simplex.Solve3();
						break;
					default:
						b2Settings.b2Assert(false);
				}
				if (simplex.m_count == 3) {
					break;
				}
				p = simplex.GetClosestPoint();
				distanceSqr2 = p.LengthSquared();
				if (distanceSqr2 > distanceSqr1) {
				}
				distanceSqr1 = distanceSqr2;
				var d = simplex.GetSearchDirection();
				if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
					break;
				}
				var vertex = vertices[simplex.m_count];
				vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
				vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
				vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
				vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
				vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
				++iter;
				++b2Distance.b2_gjkIters;
				var duplicate = false;
				for (i = 0;
					 i < saveCount; i++) {
					if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
						duplicate = true;
						break;
					}
				}
				if (duplicate) {
					break;
				}
				++simplex.m_count;
			}
			b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
			simplex.GetWitnessPoints(output.pointA, output.pointB);
			output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
			output.iterations = iter;
			simplex.WriteCache(cache);
			if (input.useRadii) {
				var rA = proxyA.m_radius;
				var rB = proxyB.m_radius;
				if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
					output.distance -= rA + rB;
					var normal = b2Math.SubtractVV(output.pointB, output.pointA);
					normal.Normalize();
					output.pointA.x += rA * normal.x;
					output.pointA.y += rA * normal.y;
					output.pointB.x -= rB * normal.x;
					output.pointB.y -= rB * normal.y;
				}
				else {
					p = new b2Vec2();
					p.x = .5 * (output.pointA.x + output.pointB.x);
					p.y = .5 * (output.pointA.y + output.pointB.y);
					output.pointA.x = output.pointB.x = p.x;
					output.pointA.y = output.pointB.y = p.y;
					output.distance = 0.0;
				}
			}
		}
		Box2D.postDefs.push(function () {
			Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
			Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
			Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
		});
		b2DistanceInput.b2DistanceInput = function () {
		};
		b2DistanceOutput.b2DistanceOutput = function () {
			this.pointA = new b2Vec2();
			this.pointB = new b2Vec2();
		};
		b2DistanceProxy.b2DistanceProxy = function () {
		};
		b2DistanceProxy.prototype.Set = function (shape) {
			switch (shape.GetType()) {
				case b2Shape.e_circleShape: {
					var circle = (shape instanceof b2CircleShape ? shape : null);
					this.m_vertices = new Vector(1, true);
					this.m_vertices[0] = circle.m_p;
					this.m_count = 1;
					this.m_radius = circle.m_radius;
				}
					break;
				case b2Shape.e_polygonShape: {
					var polygon = (shape instanceof b2PolygonShape ? shape : null);
					this.m_vertices = polygon.m_vertices;
					this.m_count = polygon.m_vertexCount;
					this.m_radius = polygon.m_radius;
				}
					break;
				default:
					b2Settings.b2Assert(false);
			}
		}
		b2DistanceProxy.prototype.GetSupport = function (d) {
			var bestIndex = 0;
			var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
			for (var i = 1; i < this.m_count; ++i) {
				var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
				if (value > bestValue) {
					bestIndex = i;
					bestValue = value;
				}
			}
			return bestIndex;
		}
		b2DistanceProxy.prototype.GetSupportVertex = function (d) {
			var bestIndex = 0;
			var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
			for (var i = 1; i < this.m_count; ++i) {
				var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
				if (value > bestValue) {
					bestIndex = i;
					bestValue = value;
				}
			}
			return this.m_vertices[bestIndex];
		}
		b2DistanceProxy.prototype.GetVertexCount = function () {
			return this.m_count;
		}
		b2DistanceProxy.prototype.GetVertex = function (index) {
			if (index === undefined) index = 0;
			b2Settings.b2Assert(0 <= index && index < this.m_count);
			return this.m_vertices[index];
		}
		b2DynamicTree.b2DynamicTree = function () {
		};
		b2DynamicTree.prototype.b2DynamicTree = function () {
			this.m_root = null;
			this.m_freeList = null;
			this.m_path = 0;
			this.m_insertionCount = 0;
		}
		b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
			var node = this.AllocateNode();
			var extendX = b2Settings.b2_aabbExtension;
			var extendY = b2Settings.b2_aabbExtension;
			node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
			node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
			node.aabb.upperBound.x = aabb.upperBound.x + extendX;
			node.aabb.upperBound.y = aabb.upperBound.y + extendY;
			node.userData = userData;
			this.InsertLeaf(node);
			return node;
		}
		b2DynamicTree.prototype.DestroyProxy = function (proxy) {
			this.RemoveLeaf(proxy);
			this.FreeNode(proxy);
		}
		b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
			b2Settings.b2Assert(proxy.IsLeaf());
			if (proxy.aabb.Contains(aabb)) {
				return false;
			}
			this.RemoveLeaf(proxy);
			var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
			var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
			proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
			proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
			proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
			proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
			this.InsertLeaf(proxy);
			return true;
		}
		b2DynamicTree.prototype.Rebalance = function (iterations) {
			if (iterations === undefined) iterations = 0;
			if (this.m_root == null) return;
			for (var i = 0; i < iterations; i++) {
				var node = this.m_root;
				var bit = 0;
				while (node.IsLeaf() == false) {
					node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
					bit = (bit + 1) & 31;
				}
				++this.m_path;
				this.RemoveLeaf(node);
				this.InsertLeaf(node);
			}
		}
		b2DynamicTree.prototype.GetFatAABB = function (proxy) {
			return proxy.aabb;
		}
		b2DynamicTree.prototype.GetUserData = function (proxy) {
			return proxy.userData;
		}
		b2DynamicTree.prototype.Query = function (callback, aabb) {
			if (this.m_root == null) return;
			var stack = new Vector();
			var count = 0;
			stack[count++] = this.m_root;
			while (count > 0) {
				var node = stack[--count];
				if (node.aabb.TestOverlap(aabb)) {
					if (node.IsLeaf()) {
						var proceed = callback(node);
						if (!proceed) return;
					}
					else {
						stack[count++] = node.child1;
						stack[count++] = node.child2;
					}
				}
			}
		}
		b2DynamicTree.prototype.RayCast = function (callback, input) {
			if (this.m_root == null) return;
			var p1 = input.p1;
			var p2 = input.p2;
			var r = b2Math.SubtractVV(p1, p2);
			r.Normalize();
			var v = b2Math.CrossFV(1.0, r);
			var abs_v = b2Math.AbsV(v);
			var maxFraction = input.maxFraction;
			var segmentAABB = new b2AABB();
			var tX = 0;
			var tY = 0;
			{
				tX = p1.x + maxFraction * (p2.x - p1.x);
				tY = p1.y + maxFraction * (p2.y - p1.y);
				segmentAABB.lowerBound.x = Math.min(p1.x, tX);
				segmentAABB.lowerBound.y = Math.min(p1.y, tY);
				segmentAABB.upperBound.x = Math.max(p1.x, tX);
				segmentAABB.upperBound.y = Math.max(p1.y, tY);
			}
			var stack = new Vector();
			var count = 0;
			stack[count++] = this.m_root;
			while (count > 0) {
				var node = stack[--count];
				if (node.aabb.TestOverlap(segmentAABB) == false) {
					continue;
				}
				var c = node.aabb.GetCenter();
				var h = node.aabb.GetExtents();
				var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
				if (separation > 0.0) continue;
				if (node.IsLeaf()) {
					var subInput = new b2RayCastInput();
					subInput.p1 = input.p1;
					subInput.p2 = input.p2;
					subInput.maxFraction = input.maxFraction;
					maxFraction = callback(subInput, node);
					if (maxFraction == 0.0) return;
					if (maxFraction > 0.0) {
						tX = p1.x + maxFraction * (p2.x - p1.x);
						tY = p1.y + maxFraction * (p2.y - p1.y);
						segmentAABB.lowerBound.x = Math.min(p1.x, tX);
						segmentAABB.lowerBound.y = Math.min(p1.y, tY);
						segmentAABB.upperBound.x = Math.max(p1.x, tX);
						segmentAABB.upperBound.y = Math.max(p1.y, tY);
					}
				}
				else {
					stack[count++] = node.child1;
					stack[count++] = node.child2;
				}
			}
		}
		b2DynamicTree.prototype.AllocateNode = function () {
			if (this.m_freeList) {
				var node = this.m_freeList;
				this.m_freeList = node.parent;
				node.parent = null;
				node.child1 = null;
				node.child2 = null;
				return node;
			}
			return new b2DynamicTreeNode();
		}
		b2DynamicTree.prototype.FreeNode = function (node) {
			node.parent = this.m_freeList;
			this.m_freeList = node;
		}
		b2DynamicTree.prototype.InsertLeaf = function (leaf) {
			++this.m_insertionCount;
			if (this.m_root == null) {
				this.m_root = leaf;
				this.m_root.parent = null;
				return;
			}
			var center = leaf.aabb.GetCenter();
			var sibling = this.m_root;
			if (sibling.IsLeaf() == false) {
				do {
					var child1 = sibling.child1;
					var child2 = sibling.child2;
					var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
					var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
					if (norm1 < norm2) {
						sibling = child1;
					}
					else {
						sibling = child2;
					}
				}
				while (sibling.IsLeaf() == false)
			}
			var node1 = sibling.parent;
			var node2 = this.AllocateNode();
			node2.parent = node1;
			node2.userData = null;
			node2.aabb.Combine(leaf.aabb, sibling.aabb);
			if (node1) {
				if (sibling.parent.child1 == sibling) {
					node1.child1 = node2;
				}
				else {
					node1.child2 = node2;
				}
				node2.child1 = sibling;
				node2.child2 = leaf;
				sibling.parent = node2;
				leaf.parent = node2;
				do {
					if (node1.aabb.Contains(node2.aabb)) break;
					node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
					node2 = node1;
					node1 = node1.parent;
				}
				while (node1)
			}
			else {
				node2.child1 = sibling;
				node2.child2 = leaf;
				sibling.parent = node2;
				leaf.parent = node2;
				this.m_root = node2;
			}
		}
		b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
			if (leaf == this.m_root) {
				this.m_root = null;
				return;
			}
			var node2 = leaf.parent;
			var node1 = node2.parent;
			var sibling;
			if (node2.child1 == leaf) {
				sibling = node2.child2;
			}
			else {
				sibling = node2.child1;
			}
			if (node1) {
				if (node1.child1 == node2) {
					node1.child1 = sibling;
				}
				else {
					node1.child2 = sibling;
				}
				sibling.parent = node1;
				this.FreeNode(node2);
				while (node1) {
					var oldAABB = node1.aabb;
					node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
					if (oldAABB.Contains(node1.aabb)) break;
					node1 = node1.parent;
				}
			}
			else {
				this.m_root = sibling;
				sibling.parent = null;
				this.FreeNode(node2);
			}
		}
		b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
			this.m_tree = new b2DynamicTree();
			this.m_moveBuffer = new Vector();
			this.m_pairBuffer = new Vector();
			this.m_pairCount = 0;
		};
		b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
			var proxy = this.m_tree.CreateProxy(aabb, userData);
			++this.m_proxyCount;
			this.BufferMove(proxy);
			return proxy;
		}
		b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
			this.UnBufferMove(proxy);
			--this.m_proxyCount;
			this.m_tree.DestroyProxy(proxy);
		}
		b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
			var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
			if (buffer) {
				this.BufferMove(proxy);
			}
		}
		b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
			var aabbA = this.m_tree.GetFatAABB(proxyA);
			var aabbB = this.m_tree.GetFatAABB(proxyB);
			return aabbA.TestOverlap(aabbB);
		}
		b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
			return this.m_tree.GetUserData(proxy);
		}
		b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
			return this.m_tree.GetFatAABB(proxy);
		}
		b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
			return this.m_proxyCount;
		}
		b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
			var __this = this;
			__this.m_pairCount = 0;
			var i = 0,
				queryProxy;
			for (i = 0;
				 i < __this.m_moveBuffer.length; ++i) {
				queryProxy = __this.m_moveBuffer[i];
				
				function QueryCallback (proxy) {
					if (proxy == queryProxy) return true;
					if (__this.m_pairCount == __this.m_pairBuffer.length) {
						__this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
					}
					var pair = __this.m_pairBuffer[__this.m_pairCount];
					pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
					pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
					++__this.m_pairCount;
					return true;
				};
				var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
				__this.m_tree.Query(QueryCallback, fatAABB);
			}
			__this.m_moveBuffer.length = 0;
			for (var i = 0; i < __this.m_pairCount;) {
				var primaryPair = __this.m_pairBuffer[i];
				var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
				var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
				callback(userDataA, userDataB);
				++i;
				while (i < __this.m_pairCount) {
					var pair = __this.m_pairBuffer[i];
					if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
						break;
					}
					++i;
				}
			}
		}
		b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
			this.m_tree.Query(callback, aabb);
		}
		b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
			this.m_tree.RayCast(callback, input);
		}
		b2DynamicTreeBroadPhase.prototype.Validate = function () {
		}
		b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
			if (iterations === undefined) iterations = 0;
			this.m_tree.Rebalance(iterations);
		}
		b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
			this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
		}
		b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
			var i = parseInt(this.m_moveBuffer.indexOf(proxy));
			this.m_moveBuffer.splice(i, 1);
		}
		b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
			return 0;
		}
		b2DynamicTreeBroadPhase.__implements = {};
		b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
		b2DynamicTreeNode.b2DynamicTreeNode = function () {
			this.aabb = new b2AABB();
		};
		b2DynamicTreeNode.prototype.IsLeaf = function () {
			return this.child1 == null;
		}
		b2DynamicTreePair.b2DynamicTreePair = function () {
		};
		b2Manifold.b2Manifold = function () {
			this.m_pointCount = 0;
		};
		b2Manifold.prototype.b2Manifold = function () {
			this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
				this.m_points[i] = new b2ManifoldPoint();
			}
			this.m_localPlaneNormal = new b2Vec2();
			this.m_localPoint = new b2Vec2();
		}
		b2Manifold.prototype.Reset = function () {
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
				((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
			}
			this.m_localPlaneNormal.SetZero();
			this.m_localPoint.SetZero();
			this.m_type = 0;
			this.m_pointCount = 0;
		}
		b2Manifold.prototype.Set = function (m) {
			this.m_pointCount = m.m_pointCount;
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
				((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
			}
			this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
			this.m_localPoint.SetV(m.m_localPoint);
			this.m_type = m.m_type;
		}
		b2Manifold.prototype.Copy = function () {
			var copy = new b2Manifold();
			copy.Set(this);
			return copy;
		}
		Box2D.postDefs.push(function () {
			Box2D.Collision.b2Manifold.e_circles = 0x0001;
			Box2D.Collision.b2Manifold.e_faceA = 0x0002;
			Box2D.Collision.b2Manifold.e_faceB = 0x0004;
		});
		b2ManifoldPoint.b2ManifoldPoint = function () {
			this.m_localPoint = new b2Vec2();
			this.m_id = new b2ContactID();
		};
		b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
			this.Reset();
		}
		b2ManifoldPoint.prototype.Reset = function () {
			this.m_localPoint.SetZero();
			this.m_normalImpulse = 0.0;
			this.m_tangentImpulse = 0.0;
			this.m_id.key = 0;
		}
		b2ManifoldPoint.prototype.Set = function (m) {
			this.m_localPoint.SetV(m.m_localPoint);
			this.m_normalImpulse = m.m_normalImpulse;
			this.m_tangentImpulse = m.m_tangentImpulse;
			this.m_id.Set(m.m_id);
		}
		b2Point.b2Point = function () {
			this.p = new b2Vec2();
		};
		b2Point.prototype.Support = function (xf, vX, vY) {
			if (vX === undefined) vX = 0;
			if (vY === undefined) vY = 0;
			return this.p;
		}
		b2Point.prototype.GetFirstVertex = function (xf) {
			return this.p;
		}
		b2RayCastInput.b2RayCastInput = function () {
			this.p1 = new b2Vec2();
			this.p2 = new b2Vec2();
		};
		b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
			if (p1 === undefined) p1 = null;
			if (p2 === undefined) p2 = null;
			if (maxFraction === undefined) maxFraction = 1;
			if (p1) this.p1.SetV(p1);
			if (p2) this.p2.SetV(p2);
			this.maxFraction = maxFraction;
		}
		b2RayCastOutput.b2RayCastOutput = function () {
			this.normal = new b2Vec2();
		};
		b2Segment.b2Segment = function () {
			this.p1 = new b2Vec2();
			this.p2 = new b2Vec2();
		};
		b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
			if (maxLambda === undefined) maxLambda = 0;
			var s = segment.p1;
			var rX = segment.p2.x - s.x;
			var rY = segment.p2.y - s.y;
			var dX = this.p2.x - this.p1.x;
			var dY = this.p2.y - this.p1.y;
			var nX = dY;
			var nY = (-dX);
			var k_slop = 100.0 * Number.MIN_VALUE;
			var denom = (-(rX * nX + rY * nY));
			if (denom > k_slop) {
				var bX = s.x - this.p1.x;
				var bY = s.y - this.p1.y;
				var a = (bX * nX + bY * nY);
				if (0.0 <= a && a <= maxLambda * denom) {
					var mu2 = (-rX * bY) + rY * bX;
					if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
						a /= denom;
						var nLen = Math.sqrt(nX * nX + nY * nY);
						nX /= nLen;
						nY /= nLen;
						lambda[0] = a;
						normal.Set(nX, nY);
						return true;
					}
				}
			}
			return false;
		}
		b2Segment.prototype.Extend = function (aabb) {
			this.ExtendForward(aabb);
			this.ExtendBackward(aabb);
		}
		b2Segment.prototype.ExtendForward = function (aabb) {
			var dX = this.p2.x - this.p1.x;
			var dY = this.p2.y - this.p1.y;
			var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
				dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
			this.p2.x = this.p1.x + dX * lambda;
			this.p2.y = this.p1.y + dY * lambda;
		}
		b2Segment.prototype.ExtendBackward = function (aabb) {
			var dX = (-this.p2.x) + this.p1.x;
			var dY = (-this.p2.y) + this.p1.y;
			var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
				dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
			this.p1.x = this.p2.x + dX * lambda;
			this.p1.y = this.p2.y + dY * lambda;
		}
		b2SeparationFunction.b2SeparationFunction = function () {
			this.m_localPoint = new b2Vec2();
			this.m_axis = new b2Vec2();
		};
		b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
			this.m_proxyA = proxyA;
			this.m_proxyB = proxyB;
			var count = parseInt(cache.count);
			b2Settings.b2Assert(0 < count && count < 3);
			var localPointA;
			var localPointA1;
			var localPointA2;
			var localPointB;
			var localPointB1;
			var localPointB2;
			var pointAX = 0;
			var pointAY = 0;
			var pointBX = 0;
			var pointBY = 0;
			var normalX = 0;
			var normalY = 0;
			var tMat;
			var tVec;
			var s = 0;
			var sgn = 0;
			if (count == 1) {
				this.m_type = b2SeparationFunction.e_points;
				localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
				localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
				tVec = localPointA;
				tMat = transformA.R;
				pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				tVec = localPointB;
				tMat = transformB.R;
				pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				this.m_axis.x = pointBX - pointAX;
				this.m_axis.y = pointBY - pointAY;
				this.m_axis.Normalize();
			}
			else if (cache.indexB[0] == cache.indexB[1]) {
				this.m_type = b2SeparationFunction.e_faceA;
				localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
				localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
				localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
				this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
				this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
				this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
				this.m_axis.Normalize();
				tVec = this.m_axis;
				tMat = transformA.R;
				normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
				normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
				tVec = this.m_localPoint;
				tMat = transformA.R;
				pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				tVec = localPointB;
				tMat = transformB.R;
				pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
				if (s < 0.0) {
					this.m_axis.NegativeSelf();
				}
			}
			else if (cache.indexA[0] == cache.indexA[0]) {
				this.m_type = b2SeparationFunction.e_faceB;
				localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
				localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
				localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
				this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
				this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
				this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
				this.m_axis.Normalize();
				tVec = this.m_axis;
				tMat = transformB.R;
				normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
				normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
				tVec = this.m_localPoint;
				tMat = transformB.R;
				pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				tVec = localPointA;
				tMat = transformA.R;
				pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
				if (s < 0.0) {
					this.m_axis.NegativeSelf();
				}
			}
			else {
				localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
				localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
				localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
				localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
				var pA = b2Math.MulX(transformA, localPointA);
				var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
				var pB = b2Math.MulX(transformB, localPointB);
				var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
				var a = dA.x * dA.x + dA.y * dA.y;
				var e = dB.x * dB.x + dB.y * dB.y;
				var r = b2Math.SubtractVV(dB, dA);
				var c = dA.x * r.x + dA.y * r.y;
				var f = dB.x * r.x + dB.y * r.y;
				var b = dA.x * dB.x + dA.y * dB.y;
				var denom = a * e - b * b;
				s = 0.0;
				if (denom != 0.0) {
					s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
				}
				var t = (b * s + f) / e;
				if (t < 0.0) {
					t = 0.0;
					s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
				}
				localPointA = new b2Vec2();
				localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
				localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
				localPointB = new b2Vec2();
				localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
				localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
				if (s == 0.0 || s == 1.0) {
					this.m_type = b2SeparationFunction.e_faceB;
					this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
					this.m_axis.Normalize();
					this.m_localPoint = localPointB;
					tVec = this.m_axis;
					tMat = transformB.R;
					normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tVec = this.m_localPoint;
					tMat = transformB.R;
					pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tVec = localPointA;
					tMat = transformA.R;
					pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
					if (s < 0.0) {
						this.m_axis.NegativeSelf();
					}
				}
				else {
					this.m_type = b2SeparationFunction.e_faceA;
					this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
					this.m_localPoint = localPointA;
					tVec = this.m_axis;
					tMat = transformA.R;
					normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tVec = this.m_localPoint;
					tMat = transformA.R;
					pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tVec = localPointB;
					tMat = transformB.R;
					pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
					if (s < 0.0) {
						this.m_axis.NegativeSelf();
					}
				}
			}
		}
		b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
			var axisA;
			var axisB;
			var localPointA;
			var localPointB;
			var pointA;
			var pointB;
			var seperation = 0;
			var normal;
			switch (this.m_type) {
				case b2SeparationFunction.e_points: {
					axisA = b2Math.MulTMV(transformA.R, this.m_axis);
					axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
					localPointA = this.m_proxyA.GetSupportVertex(axisA);
					localPointB = this.m_proxyB.GetSupportVertex(axisB);
					pointA = b2Math.MulX(transformA, localPointA);
					pointB = b2Math.MulX(transformB, localPointB);
					seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
					return seperation;
				}
				case b2SeparationFunction.e_faceA: {
					normal = b2Math.MulMV(transformA.R, this.m_axis);
					pointA = b2Math.MulX(transformA, this.m_localPoint);
					axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
					localPointB = this.m_proxyB.GetSupportVertex(axisB);
					pointB = b2Math.MulX(transformB, localPointB);
					seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
					return seperation;
				}
				case b2SeparationFunction.e_faceB: {
					normal = b2Math.MulMV(transformB.R, this.m_axis);
					pointB = b2Math.MulX(transformB, this.m_localPoint);
					axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
					localPointA = this.m_proxyA.GetSupportVertex(axisA);
					pointA = b2Math.MulX(transformA, localPointA);
					seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
					return seperation;
				}
				default:
					b2Settings.b2Assert(false);
					return 0.0;
			}
		}
		Box2D.postDefs.push(function () {
			Box2D.Collision.b2SeparationFunction.e_points = 0x01;
			Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
			Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
		});
		b2Simplex.b2Simplex = function () {
			this.m_v1 = new b2SimplexVertex();
			this.m_v2 = new b2SimplexVertex();
			this.m_v3 = new b2SimplexVertex();
			this.m_vertices = new Vector(3);
		};
		b2Simplex.prototype.b2Simplex = function () {
			this.m_vertices[0] = this.m_v1;
			this.m_vertices[1] = this.m_v2;
			this.m_vertices[2] = this.m_v3;
		}
		b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
			b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
			var wALocal;
			var wBLocal;
			this.m_count = cache.count;
			var vertices = this.m_vertices;
			for (var i = 0; i < this.m_count; i++) {
				var v = vertices[i];
				v.indexA = cache.indexA[i];
				v.indexB = cache.indexB[i];
				wALocal = proxyA.GetVertex(v.indexA);
				wBLocal = proxyB.GetVertex(v.indexB);
				v.wA = b2Math.MulX(transformA, wALocal);
				v.wB = b2Math.MulX(transformB, wBLocal);
				v.w = b2Math.SubtractVV(v.wB, v.wA);
				v.a = 0;
			}
			if (this.m_count > 1) {
				var metric1 = cache.metric;
				var metric2 = this.GetMetric();
				if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
					this.m_count = 0;
				}
			}
			if (this.m_count == 0) {
				v = vertices[0];
				v.indexA = 0;
				v.indexB = 0;
				wALocal = proxyA.GetVertex(0);
				wBLocal = proxyB.GetVertex(0);
				v.wA = b2Math.MulX(transformA, wALocal);
				v.wB = b2Math.MulX(transformB, wBLocal);
				v.w = b2Math.SubtractVV(v.wB, v.wA);
				this.m_count = 1;
			}
		}
		b2Simplex.prototype.WriteCache = function (cache) {
			cache.metric = this.GetMetric();
			cache.count = Box2D.parseUInt(this.m_count);
			var vertices = this.m_vertices;
			for (var i = 0; i < this.m_count; i++) {
				cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
				cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
			}
		}
		b2Simplex.prototype.GetSearchDirection = function () {
			switch (this.m_count) {
				case 1:
					return this.m_v1.w.GetNegative();
				case 2: {
					var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
					var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
					if (sgn > 0.0) {
						return b2Math.CrossFV(1.0, e12);
					}
					else {
						return b2Math.CrossVF(e12, 1.0);
					}
				}
				default:
					b2Settings.b2Assert(false);
					return new b2Vec2();
			}
		}
		b2Simplex.prototype.GetClosestPoint = function () {
			switch (this.m_count) {
				case 0:
					b2Settings.b2Assert(false);
					return new b2Vec2();
				case 1:
					return this.m_v1.w;
				case 2:
					return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
				default:
					b2Settings.b2Assert(false);
					return new b2Vec2();
			}
		}
		b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
			switch (this.m_count) {
				case 0:
					b2Settings.b2Assert(false);
					break;
				case 1:
					pA.SetV(this.m_v1.wA);
					pB.SetV(this.m_v1.wB);
					break;
				case 2:
					pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
					pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
					pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
					pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
					break;
				case 3:
					pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
					pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
					break;
				default:
					b2Settings.b2Assert(false);
					break;
			}
		}
		b2Simplex.prototype.GetMetric = function () {
			switch (this.m_count) {
				case 0:
					b2Settings.b2Assert(false);
					return 0.0;
				case 1:
					return 0.0;
				case 2:
					return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
				case 3:
					return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
				default:
					b2Settings.b2Assert(false);
					return 0.0;
			}
		}
		b2Simplex.prototype.Solve2 = function () {
			var w1 = this.m_v1.w;
			var w2 = this.m_v2.w;
			var e12 = b2Math.SubtractVV(w2, w1);
			var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
			if (d12_2 <= 0.0) {
				this.m_v1.a = 1.0;
				this.m_count = 1;
				return;
			}
			var d12_1 = (w2.x * e12.x + w2.y * e12.y);
			if (d12_1 <= 0.0) {
				this.m_v2.a = 1.0;
				this.m_count = 1;
				this.m_v1.Set(this.m_v2);
				return;
			}
			var inv_d12 = 1.0 / (d12_1 + d12_2);
			this.m_v1.a = d12_1 * inv_d12;
			this.m_v2.a = d12_2 * inv_d12;
			this.m_count = 2;
		}
		b2Simplex.prototype.Solve3 = function () {
			var w1 = this.m_v1.w;
			var w2 = this.m_v2.w;
			var w3 = this.m_v3.w;
			var e12 = b2Math.SubtractVV(w2, w1);
			var w1e12 = b2Math.Dot(w1, e12);
			var w2e12 = b2Math.Dot(w2, e12);
			var d12_1 = w2e12;
			var d12_2 = (-w1e12);
			var e13 = b2Math.SubtractVV(w3, w1);
			var w1e13 = b2Math.Dot(w1, e13);
			var w3e13 = b2Math.Dot(w3, e13);
			var d13_1 = w3e13;
			var d13_2 = (-w1e13);
			var e23 = b2Math.SubtractVV(w3, w2);
			var w2e23 = b2Math.Dot(w2, e23);
			var w3e23 = b2Math.Dot(w3, e23);
			var d23_1 = w3e23;
			var d23_2 = (-w2e23);
			var n123 = b2Math.CrossVV(e12, e13);
			var d123_1 = n123 * b2Math.CrossVV(w2, w3);
			var d123_2 = n123 * b2Math.CrossVV(w3, w1);
			var d123_3 = n123 * b2Math.CrossVV(w1, w2);
			if (d12_2 <= 0.0 && d13_2 <= 0.0) {
				this.m_v1.a = 1.0;
				this.m_count = 1;
				return;
			}
			if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
				var inv_d12 = 1.0 / (d12_1 + d12_2);
				this.m_v1.a = d12_1 * inv_d12;
				this.m_v2.a = d12_2 * inv_d12;
				this.m_count = 2;
				return;
			}
			if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
				var inv_d13 = 1.0 / (d13_1 + d13_2);
				this.m_v1.a = d13_1 * inv_d13;
				this.m_v3.a = d13_2 * inv_d13;
				this.m_count = 2;
				this.m_v2.Set(this.m_v3);
				return;
			}
			if (d12_1 <= 0.0 && d23_2 <= 0.0) {
				this.m_v2.a = 1.0;
				this.m_count = 1;
				this.m_v1.Set(this.m_v2);
				return;
			}
			if (d13_1 <= 0.0 && d23_1 <= 0.0) {
				this.m_v3.a = 1.0;
				this.m_count = 1;
				this.m_v1.Set(this.m_v3);
				return;
			}
			if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
				var inv_d23 = 1.0 / (d23_1 + d23_2);
				this.m_v2.a = d23_1 * inv_d23;
				this.m_v3.a = d23_2 * inv_d23;
				this.m_count = 2;
				this.m_v1.Set(this.m_v3);
				return;
			}
			var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
			this.m_v1.a = d123_1 * inv_d123;
			this.m_v2.a = d123_2 * inv_d123;
			this.m_v3.a = d123_3 * inv_d123;
			this.m_count = 3;
		}
		b2SimplexCache.b2SimplexCache = function () {
			this.indexA = new Vector_a2j_Number(3);
			this.indexB = new Vector_a2j_Number(3);
		};
		b2SimplexVertex.b2SimplexVertex = function () {
		};
		b2SimplexVertex.prototype.Set = function (other) {
			this.wA.SetV(other.wA);
			this.wB.SetV(other.wB);
			this.w.SetV(other.w);
			this.a = other.a;
			this.indexA = other.indexA;
			this.indexB = other.indexB;
		}
		b2TimeOfImpact.b2TimeOfImpact = function () {
		};
		b2TimeOfImpact.TimeOfImpact = function (input) {
			++b2TimeOfImpact.b2_toiCalls;
			var proxyA = input.proxyA;
			var proxyB = input.proxyB;
			var sweepA = input.sweepA;
			var sweepB = input.sweepB;
			b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
			b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
			var radius = proxyA.m_radius + proxyB.m_radius;
			var tolerance = input.tolerance;
			var alpha = 0.0;
			var k_maxIterations = 1000;
			var iter = 0;
			var target = 0.0;
			b2TimeOfImpact.s_cache.count = 0;
			b2TimeOfImpact.s_distanceInput.useRadii = false;
			for (; ;) {
				sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
				sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
				b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
				b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
				b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
				b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
				b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
				if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
					alpha = 1.0;
					break;
				}
				b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
				var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
				if (separation <= 0.0) {
					alpha = 1.0;
					break;
				}
				if (iter == 0) {
					if (separation > radius) {
						target = b2Math.Max(radius - tolerance, 0.75 * radius);
					}
					else {
						target = b2Math.Max(separation - tolerance, 0.02 * radius);
					}
				}
				if (separation - target < 0.5 * tolerance) {
					if (iter == 0) {
						alpha = 1.0;
						break;
					}
					break;
				}
				var newAlpha = alpha;
				{
					var x1 = alpha;
					var x2 = 1.0;
					var f1 = separation;
					sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
					sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
					var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
					if (f2 >= target) {
						alpha = 1.0;
						break;
					}
					var rootIterCount = 0;
					for (; ;) {
						var x = 0;
						if (rootIterCount & 1) {
							x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
						}
						else {
							x = 0.5 * (x1 + x2);
						}
						sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
						sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
						var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
						if (b2Math.Abs(f - target) < 0.025 * tolerance) {
							newAlpha = x;
							break;
						}
						if (f > target) {
							x1 = x;
							f1 = f;
						}
						else {
							x2 = x;
							f2 = f;
						}
						++rootIterCount;
						++b2TimeOfImpact.b2_toiRootIters;
						if (rootIterCount == 50) {
							break;
						}
					}
					b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
				}
				if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
					break;
				}
				alpha = newAlpha;
				iter++;
				++b2TimeOfImpact.b2_toiIters;
				if (iter == k_maxIterations) {
					break;
				}
			}
			b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
			return alpha;
		}
		Box2D.postDefs.push(function () {
			Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
			Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
			Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
			Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
			Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
			Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
			Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
			Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
			Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
			Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
			Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
		});
		b2TOIInput.b2TOIInput = function () {
			this.proxyA = new b2DistanceProxy();
			this.proxyB = new b2DistanceProxy();
			this.sweepA = new b2Sweep();
			this.sweepB = new b2Sweep();
		};
		b2WorldManifold.b2WorldManifold = function () {
			this.m_normal = new b2Vec2();
		};
		b2WorldManifold.prototype.b2WorldManifold = function () {
			this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
				this.m_points[i] = new b2Vec2();
			}
		}
		b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
			if (radiusA === undefined) radiusA = 0;
			if (radiusB === undefined) radiusB = 0;
			if (manifold.m_pointCount == 0) {
				return;
			}
			var i = 0;
			var tVec;
			var tMat;
			var normalX = 0;
			var normalY = 0;
			var planePointX = 0;
			var planePointY = 0;
			var clipPointX = 0;
			var clipPointY = 0;
			switch (manifold.m_type) {
				case b2Manifold.e_circles: {
					tMat = xfA.R;
					tVec = manifold.m_localPoint;
					var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = xfB.R;
					tVec = manifold.m_points[0].m_localPoint;
					var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					var dX = pointBX - pointAX;
					var dY = pointBY - pointAY;
					var d2 = dX * dX + dY * dY;
					if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
						var d = Math.sqrt(d2);
						this.m_normal.x = dX / d;
						this.m_normal.y = dY / d;
					}
					else {
						this.m_normal.x = 1;
						this.m_normal.y = 0;
					}
					var cAX = pointAX + radiusA * this.m_normal.x;
					var cAY = pointAY + radiusA * this.m_normal.y;
					var cBX = pointBX - radiusB * this.m_normal.x;
					var cBY = pointBY - radiusB * this.m_normal.y;
					this.m_points[0].x = 0.5 * (cAX + cBX);
					this.m_points[0].y = 0.5 * (cAY + cBY);
				}
					break;
				case b2Manifold.e_faceA: {
					tMat = xfA.R;
					tVec = manifold.m_localPlaneNormal;
					normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = xfA.R;
					tVec = manifold.m_localPoint;
					planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					this.m_normal.x = normalX;
					this.m_normal.y = normalY;
					for (i = 0;
						 i < manifold.m_pointCount; i++) {
						tMat = xfB.R;
						tVec = manifold.m_points[i].m_localPoint;
						clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
						clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
						this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
						this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
					}
				}
					break;
				case b2Manifold.e_faceB: {
					tMat = xfB.R;
					tVec = manifold.m_localPlaneNormal;
					normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = xfB.R;
					tVec = manifold.m_localPoint;
					planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					this.m_normal.x = (-normalX);
					this.m_normal.y = (-normalY);
					for (i = 0;
						 i < manifold.m_pointCount; i++) {
						tMat = xfA.R;
						tVec = manifold.m_points[i].m_localPoint;
						clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
						clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
						this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
						this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
					}
				}
					break;
			}
		}
		ClipVertex.ClipVertex = function () {
			this.v = new b2Vec2();
			this.id = new b2ContactID();
		};
		ClipVertex.prototype.Set = function (other) {
			this.v.SetV(other.v);
			this.id.Set(other.id);
		}
		Features.Features = function () {
		};
		Object.defineProperty(Features.prototype, 'referenceEdge', {
			enumerable: false,
			configurable: true,
			get: function () {
				return this._referenceEdge;
			}
		});
		Object.defineProperty(Features.prototype, 'referenceEdge', {
			enumerable: false,
			configurable: true,
			set: function (value) {
				if (value === undefined) value = 0;
				this._referenceEdge = value;
				this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
			}
		});
		Object.defineProperty(Features.prototype, 'incidentEdge', {
			enumerable: false,
			configurable: true,
			get: function () {
				return this._incidentEdge;
			}
		});
		Object.defineProperty(Features.prototype, 'incidentEdge', {
			enumerable: false,
			configurable: true,
			set: function (value) {
				if (value === undefined) value = 0;
				this._incidentEdge = value;
				this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
			}
		});
		Object.defineProperty(Features.prototype, 'incidentVertex', {
			enumerable: false,
			configurable: true,
			get: function () {
				return this._incidentVertex;
			}
		});
		Object.defineProperty(Features.prototype, 'incidentVertex', {
			enumerable: false,
			configurable: true,
			set: function (value) {
				if (value === undefined) value = 0;
				this._incidentVertex = value;
				this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
			}
		});
		Object.defineProperty(Features.prototype, 'flip', {
			enumerable: false,
			configurable: true,
			get: function () {
				return this._flip;
			}
		});
		Object.defineProperty(Features.prototype, 'flip', {
			enumerable: false,
			configurable: true,
			set: function (value) {
				if (value === undefined) value = 0;
				this._flip = value;
				this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
			}
		});
	})();
	(function () {
		var b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World,
			b2AABB = Box2D.Collision.b2AABB,
			b2Bound = Box2D.Collision.b2Bound,
			b2BoundValues = Box2D.Collision.b2BoundValues,
			b2Collision = Box2D.Collision.b2Collision,
			b2ContactID = Box2D.Collision.b2ContactID,
			b2ContactPoint = Box2D.Collision.b2ContactPoint,
			b2Distance = Box2D.Collision.b2Distance,
			b2DistanceInput = Box2D.Collision.b2DistanceInput,
			b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
			b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
			b2DynamicTree = Box2D.Collision.b2DynamicTree,
			b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
			b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
			b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
			b2Manifold = Box2D.Collision.b2Manifold,
			b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
			b2Point = Box2D.Collision.b2Point,
			b2RayCastInput = Box2D.Collision.b2RayCastInput,
			b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
			b2Segment = Box2D.Collision.b2Segment,
			b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
			b2Simplex = Box2D.Collision.b2Simplex,
			b2SimplexCache = Box2D.Collision.b2SimplexCache,
			b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
			b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
			b2TOIInput = Box2D.Collision.b2TOIInput,
			b2WorldManifold = Box2D.Collision.b2WorldManifold,
			ClipVertex = Box2D.Collision.ClipVertex,
			Features = Box2D.Collision.Features,
			IBroadPhase = Box2D.Collision.IBroadPhase;
		
		Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
		b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
		b2CircleShape.b2CircleShape = function () {
			Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
			this.m_p = new b2Vec2();
		};
		b2CircleShape.prototype.Copy = function () {
			var s = new b2CircleShape();
			s.Set(this);
			return s;
		}
		b2CircleShape.prototype.Set = function (other) {
			this.__super.Set.call(this, other);
			if (Box2D.is(other, b2CircleShape)) {
				var other2 = (other instanceof b2CircleShape ? other : null);
				this.m_p.SetV(other2.m_p);
			}
		}
		b2CircleShape.prototype.TestPoint = function (transform, p) {
			var tMat = transform.R;
			var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
			var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
			dX = p.x - dX;
			dY = p.y - dY;
			return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
		}
		b2CircleShape.prototype.RayCast = function (output, input, transform) {
			var tMat = transform.R;
			var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
			var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
			var sX = input.p1.x - positionX;
			var sY = input.p1.y - positionY;
			var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
			var rX = input.p2.x - input.p1.x;
			var rY = input.p2.y - input.p1.y;
			var c = (sX * rX + sY * rY);
			var rr = (rX * rX + rY * rY);
			var sigma = c * c - rr * b;
			if (sigma < 0.0 || rr < Number.MIN_VALUE) {
				return false;
			}
			var a = (-(c + Math.sqrt(sigma)));
			if (0.0 <= a && a <= input.maxFraction * rr) {
				a /= rr;
				output.fraction = a;
				output.normal.x = sX + a * rX;
				output.normal.y = sY + a * rY;
				output.normal.Normalize();
				return true;
			}
			return false;
		}
		b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
			var tMat = transform.R;
			var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
			var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
			aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
			aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
		}
		b2CircleShape.prototype.ComputeMass = function (massData, density) {
			if (density === undefined) density = 0;
			massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
			massData.center.SetV(this.m_p);
			massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
		}
		b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
			if (offset === undefined) offset = 0;
			var p = b2Math.MulX(xf, this.m_p);
			var l = (-(b2Math.Dot(normal, p) - offset));
			if (l < (-this.m_radius) + Number.MIN_VALUE) {
				return 0;
			}
			if (l > this.m_radius) {
				c.SetV(p);
				return Math.PI * this.m_radius * this.m_radius;
			}
			var r2 = this.m_radius * this.m_radius;
			var l2 = l * l;
			var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
			var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
			c.x = p.x + normal.x * com;
			c.y = p.y + normal.y * com;
			return area;
		}
		b2CircleShape.prototype.GetLocalPosition = function () {
			return this.m_p;
		}
		b2CircleShape.prototype.SetLocalPosition = function (position) {
			this.m_p.SetV(position);
		}
		b2CircleShape.prototype.GetRadius = function () {
			return this.m_radius;
		}
		b2CircleShape.prototype.SetRadius = function (radius) {
			if (radius === undefined) radius = 0;
			this.m_radius = radius;
		}
		b2CircleShape.prototype.b2CircleShape = function (radius) {
			if (radius === undefined) radius = 0;
			this.__super.b2Shape.call(this);
			this.m_type = b2Shape.e_circleShape;
			this.m_radius = radius;
		}
		b2EdgeChainDef.b2EdgeChainDef = function () {
		};
		b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
			this.vertexCount = 0;
			this.isALoop = true;
			this.vertices = [];
		}
		Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
		b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
		b2EdgeShape.b2EdgeShape = function () {
			Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
			this.s_supportVec = new b2Vec2();
			this.m_v1 = new b2Vec2();
			this.m_v2 = new b2Vec2();
			this.m_coreV1 = new b2Vec2();
			this.m_coreV2 = new b2Vec2();
			this.m_normal = new b2Vec2();
			this.m_direction = new b2Vec2();
			this.m_cornerDir1 = new b2Vec2();
			this.m_cornerDir2 = new b2Vec2();
		};
		b2EdgeShape.prototype.TestPoint = function (transform, p) {
			return false;
		}
		b2EdgeShape.prototype.RayCast = function (output, input, transform) {
			var tMat;
			var rX = input.p2.x - input.p1.x;
			var rY = input.p2.y - input.p1.y;
			tMat = transform.R;
			var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
			var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
			var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
			var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
			var k_slop = 100.0 * Number.MIN_VALUE;
			var denom = (-(rX * nX + rY * nY));
			if (denom > k_slop) {
				var bX = input.p1.x - v1X;
				var bY = input.p1.y - v1Y;
				var a = (bX * nX + bY * nY);
				if (0.0 <= a && a <= input.maxFraction * denom) {
					var mu2 = (-rX * bY) + rY * bX;
					if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
						a /= denom;
						output.fraction = a;
						var nLen = Math.sqrt(nX * nX + nY * nY);
						output.normal.x = nX / nLen;
						output.normal.y = nY / nLen;
						return true;
					}
				}
			}
			return false;
		}
		b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
			var tMat = transform.R;
			var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
			var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
			var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
			var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
			if (v1X < v2X) {
				aabb.lowerBound.x = v1X;
				aabb.upperBound.x = v2X;
			}
			else {
				aabb.lowerBound.x = v2X;
				aabb.upperBound.x = v1X;
			}
			if (v1Y < v2Y) {
				aabb.lowerBound.y = v1Y;
				aabb.upperBound.y = v2Y;
			}
			else {
				aabb.lowerBound.y = v2Y;
				aabb.upperBound.y = v1Y;
			}
		}
		b2EdgeShape.prototype.ComputeMass = function (massData, density) {
			if (density === undefined) density = 0;
			massData.mass = 0;
			massData.center.SetV(this.m_v1);
			massData.I = 0;
		}
		b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
			if (offset === undefined) offset = 0;
			var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
			var v1 = b2Math.MulX(xf, this.m_v1);
			var v2 = b2Math.MulX(xf, this.m_v2);
			var d1 = b2Math.Dot(normal, v1) - offset;
			var d2 = b2Math.Dot(normal, v2) - offset;
			if (d1 > 0) {
				if (d2 > 0) {
					return 0;
				}
				else {
					v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
					v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
				}
			}
			else {
				if (d2 > 0) {
					v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
					v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
				}
				else {
				}
			}
			c.x = (v0.x + v1.x + v2.x) / 3;
			c.y = (v0.y + v1.y + v2.y) / 3;
			return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
		}
		b2EdgeShape.prototype.GetLength = function () {
			return this.m_length;
		}
		b2EdgeShape.prototype.GetVertex1 = function () {
			return this.m_v1;
		}
		b2EdgeShape.prototype.GetVertex2 = function () {
			return this.m_v2;
		}
		b2EdgeShape.prototype.GetCoreVertex1 = function () {
			return this.m_coreV1;
		}
		b2EdgeShape.prototype.GetCoreVertex2 = function () {
			return this.m_coreV2;
		}
		b2EdgeShape.prototype.GetNormalVector = function () {
			return this.m_normal;
		}
		b2EdgeShape.prototype.GetDirectionVector = function () {
			return this.m_direction;
		}
		b2EdgeShape.prototype.GetCorner1Vector = function () {
			return this.m_cornerDir1;
		}
		b2EdgeShape.prototype.GetCorner2Vector = function () {
			return this.m_cornerDir2;
		}
		b2EdgeShape.prototype.Corner1IsConvex = function () {
			return this.m_cornerConvex1;
		}
		b2EdgeShape.prototype.Corner2IsConvex = function () {
			return this.m_cornerConvex2;
		}
		b2EdgeShape.prototype.GetFirstVertex = function (xf) {
			var tMat = xf.R;
			return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
		}
		b2EdgeShape.prototype.GetNextEdge = function () {
			return this.m_nextEdge;
		}
		b2EdgeShape.prototype.GetPrevEdge = function () {
			return this.m_prevEdge;
		}
		b2EdgeShape.prototype.Support = function (xf, dX, dY) {
			if (dX === undefined) dX = 0;
			if (dY === undefined) dY = 0;
			var tMat = xf.R;
			var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
			var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
			var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
			var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
			if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
				this.s_supportVec.x = v1X;
				this.s_supportVec.y = v1Y;
			}
			else {
				this.s_supportVec.x = v2X;
				this.s_supportVec.y = v2Y;
			}
			return this.s_supportVec;
		}
		b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
			this.__super.b2Shape.call(this);
			this.m_type = b2Shape.e_edgeShape;
			this.m_prevEdge = null;
			this.m_nextEdge = null;
			this.m_v1 = v1;
			this.m_v2 = v2;
			this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
			this.m_length = this.m_direction.Normalize();
			this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
			this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
			this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
			this.m_cornerDir1 = this.m_normal;
			this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
		}
		b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
			this.m_prevEdge = edge;
			this.m_coreV1 = core;
			this.m_cornerDir1 = cornerDir;
			this.m_cornerConvex1 = convex;
		}
		b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
			this.m_nextEdge = edge;
			this.m_coreV2 = core;
			this.m_cornerDir2 = cornerDir;
			this.m_cornerConvex2 = convex;
		}
		b2MassData.b2MassData = function () {
			this.mass = 0.0;
			this.center = new b2Vec2(0, 0);
			this.I = 0.0;
		};
		Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
		b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
		b2PolygonShape.b2PolygonShape = function () {
			Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
		};
		b2PolygonShape.prototype.Copy = function () {
			var s = new b2PolygonShape();
			s.Set(this);
			return s;
		}
		b2PolygonShape.prototype.Set = function (other) {
			this.__super.Set.call(this, other);
			if (Box2D.is(other, b2PolygonShape)) {
				var other2 = (other instanceof b2PolygonShape ? other : null);
				this.m_centroid.SetV(other2.m_centroid);
				this.m_vertexCount = other2.m_vertexCount;
				this.Reserve(this.m_vertexCount);
				for (var i = 0; i < this.m_vertexCount; i++) {
					this.m_vertices[i].SetV(other2.m_vertices[i]);
					this.m_normals[i].SetV(other2.m_normals[i]);
				}
			}
		}
		b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
			if (vertexCount === undefined) vertexCount = 0;
			var v = new Vector();
			var i = 0,
				tVec;
			for (i = 0;
				 i < vertices.length; ++i) {
				tVec = vertices[i];
				v.push(tVec);
			}
			this.SetAsVector(v, vertexCount);
		}
		b2PolygonShape.AsArray = function (vertices, vertexCount) {
			if (vertexCount === undefined) vertexCount = 0;
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsArray(vertices, vertexCount);
			return polygonShape;
		}
		b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
			if (vertexCount === undefined) vertexCount = 0;
			if (vertexCount == 0) vertexCount = vertices.length;
			b2Settings.b2Assert(2 <= vertexCount);
			this.m_vertexCount = vertexCount;
			this.Reserve(vertexCount);
			var i = 0;
			for (i = 0;
				 i < this.m_vertexCount; i++) {
				this.m_vertices[i].SetV(vertices[i]);
			}
			for (i = 0;
				 i < this.m_vertexCount; ++i) {
				var i1 = parseInt(i);
				var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
				var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
				b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
				this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
				this.m_normals[i].Normalize();
			}
			this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
		}
		b2PolygonShape.AsVector = function (vertices, vertexCount) {
			if (vertexCount === undefined) vertexCount = 0;
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsVector(vertices, vertexCount);
			return polygonShape;
		}
		b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
			if (hx === undefined) hx = 0;
			if (hy === undefined) hy = 0;
			this.m_vertexCount = 4;
			this.Reserve(4);
			this.m_vertices[0].Set((-hx), (-hy));
			this.m_vertices[1].Set(hx, (-hy));
			this.m_vertices[2].Set(hx, hy);
			this.m_vertices[3].Set((-hx), hy);
			this.m_normals[0].Set(0.0, (-1.0));
			this.m_normals[1].Set(1.0, 0.0);
			this.m_normals[2].Set(0.0, 1.0);
			this.m_normals[3].Set((-1.0), 0.0);
			this.m_centroid.SetZero();
		}
		b2PolygonShape.AsBox = function (hx, hy) {
			if (hx === undefined) hx = 0;
			if (hy === undefined) hy = 0;
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsBox(hx, hy);
			return polygonShape;
		}
		b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
			if (hx === undefined) hx = 0;
			if (hy === undefined) hy = 0;
			if (center === undefined) center = null;
			if (angle === undefined) angle = 0.0;
			this.m_vertexCount = 4;
			this.Reserve(4);
			this.m_vertices[0].Set((-hx), (-hy));
			this.m_vertices[1].Set(hx, (-hy));
			this.m_vertices[2].Set(hx, hy);
			this.m_vertices[3].Set((-hx), hy);
			this.m_normals[0].Set(0.0, (-1.0));
			this.m_normals[1].Set(1.0, 0.0);
			this.m_normals[2].Set(0.0, 1.0);
			this.m_normals[3].Set((-1.0), 0.0);
			this.m_centroid = center;
			var xf = new b2Transform();
			xf.position = center;
			xf.R.Set(angle);
			for (var i = 0; i < this.m_vertexCount; ++i) {
				this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
				this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
			}
		}
		b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
			if (hx === undefined) hx = 0;
			if (hy === undefined) hy = 0;
			if (center === undefined) center = null;
			if (angle === undefined) angle = 0.0;
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsOrientedBox(hx, hy, center, angle);
			return polygonShape;
		}
		b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
			this.m_vertexCount = 2;
			this.Reserve(2);
			this.m_vertices[0].SetV(v1);
			this.m_vertices[1].SetV(v2);
			this.m_centroid.x = 0.5 * (v1.x + v2.x);
			this.m_centroid.y = 0.5 * (v1.y + v2.y);
			this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
			this.m_normals[0].Normalize();
			this.m_normals[1].x = (-this.m_normals[0].x);
			this.m_normals[1].y = (-this.m_normals[0].y);
		}
		b2PolygonShape.AsEdge = function (v1, v2) {
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsEdge(v1, v2);
			return polygonShape;
		}
		b2PolygonShape.prototype.TestPoint = function (xf, p) {
			var tVec;
			var tMat = xf.R;
			var tX = p.x - xf.position.x;
			var tY = p.y - xf.position.y;
			var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
			var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
			for (var i = 0; i < this.m_vertexCount; ++i) {
				tVec = this.m_vertices[i];
				tX = pLocalX - tVec.x;
				tY = pLocalY - tVec.y;
				tVec = this.m_normals[i];
				var dot = (tVec.x * tX + tVec.y * tY);
				if (dot > 0.0) {
					return false;
				}
			}
			return true;
		}
		b2PolygonShape.prototype.RayCast = function (output, input, transform) {
			var lower = 0.0;
			var upper = input.maxFraction;
			var tX = 0;
			var tY = 0;
			var tMat;
			var tVec;
			tX = input.p1.x - transform.position.x;
			tY = input.p1.y - transform.position.y;
			tMat = transform.R;
			var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
			var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
			tX = input.p2.x - transform.position.x;
			tY = input.p2.y - transform.position.y;
			tMat = transform.R;
			var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
			var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
			var dX = p2X - p1X;
			var dY = p2Y - p1Y;
			var index = parseInt((-1));
			for (var i = 0; i < this.m_vertexCount; ++i) {
				tVec = this.m_vertices[i];
				tX = tVec.x - p1X;
				tY = tVec.y - p1Y;
				tVec = this.m_normals[i];
				var numerator = (tVec.x * tX + tVec.y * tY);
				var denominator = (tVec.x * dX + tVec.y * dY);
				if (denominator == 0.0) {
					if (numerator < 0.0) {
						return false;
					}
				}
				else {
					if (denominator < 0.0 && numerator < lower * denominator) {
						lower = numerator / denominator;
						index = i;
					}
					else if (denominator > 0.0 && numerator < upper * denominator) {
						upper = numerator / denominator;
					}
				}
				if (upper < lower - Number.MIN_VALUE) {
					return false;
				}
			}
			if (index >= 0) {
				output.fraction = lower;
				tMat = transform.R;
				tVec = this.m_normals[index];
				output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				return true;
			}
			return false;
		}
		b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
			var tMat = xf.R;
			var tVec = this.m_vertices[0];
			var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			var upperX = lowerX;
			var upperY = lowerY;
			for (var i = 1; i < this.m_vertexCount; ++i) {
				tVec = this.m_vertices[i];
				var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				lowerX = lowerX < vX ? lowerX : vX;
				lowerY = lowerY < vY ? lowerY : vY;
				upperX = upperX > vX ? upperX : vX;
				upperY = upperY > vY ? upperY : vY;
			}
			aabb.lowerBound.x = lowerX - this.m_radius;
			aabb.lowerBound.y = lowerY - this.m_radius;
			aabb.upperBound.x = upperX + this.m_radius;
			aabb.upperBound.y = upperY + this.m_radius;
		}
		b2PolygonShape.prototype.ComputeMass = function (massData, density) {
			if (density === undefined) density = 0;
			if (this.m_vertexCount == 2) {
				massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
				massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
				massData.mass = 0.0;
				massData.I = 0.0;
				return;
			}
			var centerX = 0.0;
			var centerY = 0.0;
			var area = 0.0;
			var I = 0.0;
			var p1X = 0.0;
			var p1Y = 0.0;
			var k_inv3 = 1.0 / 3.0;
			for (var i = 0; i < this.m_vertexCount; ++i) {
				var p2 = this.m_vertices[i];
				var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
				var e1X = p2.x - p1X;
				var e1Y = p2.y - p1Y;
				var e2X = p3.x - p1X;
				var e2Y = p3.y - p1Y;
				var D = e1X * e2Y - e1Y * e2X;
				var triangleArea = 0.5 * D;
				area += triangleArea;
				centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
				centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
				var px = p1X;
				var py = p1Y;
				var ex1 = e1X;
				var ey1 = e1Y;
				var ex2 = e2X;
				var ey2 = e2Y;
				var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
				var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
				I += D * (intx2 + inty2);
			}
			massData.mass = density * area;
			centerX *= 1.0 / area;
			centerY *= 1.0 / area;
			massData.center.Set(centerX, centerY);
			massData.I = density * I;
		}
		b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
			if (offset === undefined) offset = 0;
			var normalL = b2Math.MulTMV(xf.R, normal);
			var offsetL = offset - b2Math.Dot(normal, xf.position);
			var depths = new Vector_a2j_Number();
			var diveCount = 0;
			var intoIndex = parseInt((-1));
			var outoIndex = parseInt((-1));
			var lastSubmerged = false;
			var i = 0;
			for (i = 0;
				 i < this.m_vertexCount; ++i) {
				depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
				var isSubmerged = depths[i] < (-Number.MIN_VALUE);
				if (i > 0) {
					if (isSubmerged) {
						if (!lastSubmerged) {
							intoIndex = i - 1;
							diveCount++;
						}
					}
					else {
						if (lastSubmerged) {
							outoIndex = i - 1;
							diveCount++;
						}
					}
				}
				lastSubmerged = isSubmerged;
			}
			switch (diveCount) {
				case 0:
					if (lastSubmerged) {
						var md = new b2MassData();
						this.ComputeMass(md, 1);
						c.SetV(b2Math.MulX(xf, md.center));
						return md.mass;
					}
					else {
						return 0;
					}
					break;
				case 1:
					if (intoIndex == (-1)) {
						intoIndex = this.m_vertexCount - 1;
					}
					else {
						outoIndex = this.m_vertexCount - 1;
					}
					break;
			}
			var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
			var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
			var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
			var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
			var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
			var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
			var area = 0;
			var center = new b2Vec2();
			var p2 = this.m_vertices[intoIndex2];
			var p3;
			i = intoIndex2;
			while (i != outoIndex2) {
				i = (i + 1) % this.m_vertexCount;
				if (i == outoIndex2) p3 = outoVec;
				else p3 = this.m_vertices[i];
				var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
				area += triangleArea;
				center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
				center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
				p2 = p3;
			}
			center.Multiply(1 / area);
			c.SetV(b2Math.MulX(xf, center));
			return area;
		}
		b2PolygonShape.prototype.GetVertexCount = function () {
			return this.m_vertexCount;
		}
		b2PolygonShape.prototype.GetVertices = function () {
			return this.m_vertices;
		}
		b2PolygonShape.prototype.GetNormals = function () {
			return this.m_normals;
		}
		b2PolygonShape.prototype.GetSupport = function (d) {
			var bestIndex = 0;
			var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
			for (var i = 1; i < this.m_vertexCount; ++i) {
				var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
				if (value > bestValue) {
					bestIndex = i;
					bestValue = value;
				}
			}
			return bestIndex;
		}
		b2PolygonShape.prototype.GetSupportVertex = function (d) {
			var bestIndex = 0;
			var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
			for (var i = 1; i < this.m_vertexCount; ++i) {
				var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
				if (value > bestValue) {
					bestIndex = i;
					bestValue = value;
				}
			}
			return this.m_vertices[bestIndex];
		}
		b2PolygonShape.prototype.Validate = function () {
			return false;
		}
		b2PolygonShape.prototype.b2PolygonShape = function () {
			this.__super.b2Shape.call(this);
			this.m_type = b2Shape.e_polygonShape;
			this.m_centroid = new b2Vec2();
			this.m_vertices = new Vector();
			this.m_normals = new Vector();
		}
		b2PolygonShape.prototype.Reserve = function (count) {
			if (count === undefined) count = 0;
			for (var i = parseInt(this.m_vertices.length); i < count; i++) {
				this.m_vertices[i] = new b2Vec2();
				this.m_normals[i] = new b2Vec2();
			}
		}
		b2PolygonShape.ComputeCentroid = function (vs, count) {
			if (count === undefined) count = 0;
			var c = new b2Vec2();
			var area = 0.0;
			var p1X = 0.0;
			var p1Y = 0.0;
			var inv3 = 1.0 / 3.0;
			for (var i = 0; i < count; ++i) {
				var p2 = vs[i];
				var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
				var e1X = p2.x - p1X;
				var e1Y = p2.y - p1Y;
				var e2X = p3.x - p1X;
				var e2Y = p3.y - p1Y;
				var D = (e1X * e2Y - e1Y * e2X);
				var triangleArea = 0.5 * D;
				area += triangleArea;
				c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
				c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
			}
			c.x *= 1.0 / area;
			c.y *= 1.0 / area;
			return c;
		}
		b2PolygonShape.ComputeOBB = function (obb, vs, count) {
			if (count === undefined) count = 0;
			var i = 0;
			var p = new Vector(count + 1);
			for (i = 0;
				 i < count; ++i) {
				p[i] = vs[i];
			}
			p[count] = p[0];
			var minArea = Number.MAX_VALUE;
			for (i = 1;
				 i <= count; ++i) {
				var root = p[parseInt(i - 1)];
				var uxX = p[i].x - root.x;
				var uxY = p[i].y - root.y;
				var length = Math.sqrt(uxX * uxX + uxY * uxY);
				uxX /= length;
				uxY /= length;
				var uyX = (-uxY);
				var uyY = uxX;
				var lowerX = Number.MAX_VALUE;
				var lowerY = Number.MAX_VALUE;
				var upperX = (-Number.MAX_VALUE);
				var upperY = (-Number.MAX_VALUE);
				for (var j = 0; j < count; ++j) {
					var dX = p[j].x - root.x;
					var dY = p[j].y - root.y;
					var rX = (uxX * dX + uxY * dY);
					var rY = (uyX * dX + uyY * dY);
					if (rX < lowerX) lowerX = rX;
					if (rY < lowerY) lowerY = rY;
					if (rX > upperX) upperX = rX;
					if (rY > upperY) upperY = rY;
				}
				var area = (upperX - lowerX) * (upperY - lowerY);
				if (area < 0.95 * minArea) {
					minArea = area;
					obb.R.col1.x = uxX;
					obb.R.col1.y = uxY;
					obb.R.col2.x = uyX;
					obb.R.col2.y = uyY;
					var centerX = 0.5 * (lowerX + upperX);
					var centerY = 0.5 * (lowerY + upperY);
					var tMat = obb.R;
					obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
					obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
					obb.extents.x = 0.5 * (upperX - lowerX);
					obb.extents.y = 0.5 * (upperY - lowerY);
				}
			}
		}
		Box2D.postDefs.push(function () {
			Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
		});
		b2Shape.b2Shape = function () {
		};
		b2Shape.prototype.Copy = function () {
			return null;
		}
		b2Shape.prototype.Set = function (other) {
			this.m_radius = other.m_radius;
		}
		b2Shape.prototype.GetType = function () {
			return this.m_type;
		}
		b2Shape.prototype.TestPoint = function (xf, p) {
			return false;
		}
		b2Shape.prototype.RayCast = function (output, input, transform) {
			return false;
		}
		b2Shape.prototype.ComputeAABB = function (aabb, xf) {
		}
		b2Shape.prototype.ComputeMass = function (massData, density) {
			if (density === undefined) density = 0;
		}
		b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
			if (offset === undefined) offset = 0;
			return 0;
		}
		b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
			var input = new b2DistanceInput();
			input.proxyA = new b2DistanceProxy();
			input.proxyA.Set(shape1);
			input.proxyB = new b2DistanceProxy();
			input.proxyB.Set(shape2);
			input.transformA = transform1;
			input.transformB = transform2;
			input.useRadii = true;
			var simplexCache = new b2SimplexCache();
			simplexCache.count = 0;
			var output = new b2DistanceOutput();
			b2Distance.Distance(output, simplexCache, input);
			return output.distance < 10.0 * Number.MIN_VALUE;
		}
		b2Shape.prototype.b2Shape = function () {
			this.m_type = b2Shape.e_unknownShape;
			this.m_radius = b2Settings.b2_linearSlop;
		}
		Box2D.postDefs.push(function () {
			Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
			Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
			Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
			Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
			Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
			Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
			Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
			Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
		});
	})();
	(function () {
		var b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3;
		
		b2Color.b2Color = function () {
			this._r = 0;
			this._g = 0;
			this._b = 0;
		};
		b2Color.prototype.b2Color = function (rr, gg, bb) {
			if (rr === undefined) rr = 0;
			if (gg === undefined) gg = 0;
			if (bb === undefined) bb = 0;
			this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
			this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
			this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
		}
		b2Color.prototype.Set = function (rr, gg, bb) {
			if (rr === undefined) rr = 0;
			if (gg === undefined) gg = 0;
			if (bb === undefined) bb = 0;
			this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
			this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
			this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
		}
		Object.defineProperty(b2Color.prototype, 'r', {
			enumerable: false,
			configurable: true,
			set: function (rr) {
				if (rr === undefined) rr = 0;
				this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
			}
		});
		Object.defineProperty(b2Color.prototype, 'g', {
			enumerable: false,
			configurable: true,
			set: function (gg) {
				if (gg === undefined) gg = 0;
				this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
			}
		});
		Object.defineProperty(b2Color.prototype, 'b', {
			enumerable: false,
			configurable: true,
			set: function (bb) {
				if (bb === undefined) bb = 0;
				this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
			}
		});
		Object.defineProperty(b2Color.prototype, 'color', {
			enumerable: false,
			configurable: true,
			get: function () {
				return (this._r << 16) | (this._g << 8) | (this._b);
			}
		});
		b2Settings.b2Settings = function () {
		};
		b2Settings.b2MixFriction = function (friction1, friction2) {
			if (friction1 === undefined) friction1 = 0;
			if (friction2 === undefined) friction2 = 0;
			return Math.sqrt(friction1 * friction2);
		}
		b2Settings.b2MixRestitution = function (restitution1, restitution2) {
			if (restitution1 === undefined) restitution1 = 0;
			if (restitution2 === undefined) restitution2 = 0;
			return restitution1 > restitution2 ? restitution1 : restitution2;
		}
		b2Settings.b2Assert = function (a) {
			if (!a) {
				throw "Assertion Failed";
			}
		}
		Box2D.postDefs.push(function () {
			Box2D.Common.b2Settings.VERSION = "2.1alpha";
			Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
			Box2D.Common.b2Settings.b2_pi = Math.PI;
			Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
			Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
			Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
			Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
			Box2D.Common.b2Settings.b2_linearSlop = 0.005;
			Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
			Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
			Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
			Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
			Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
			Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
			Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
			Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
			Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
			Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
			Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
			Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
			Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
			Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
			Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
		});
	})();
	(function () {
		var b2AABB = Box2D.Collision.b2AABB,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3;
		
		b2Mat22.b2Mat22 = function () {
			this.col1 = new b2Vec2();
			this.col2 = new b2Vec2();
		};
		b2Mat22.prototype.b2Mat22 = function () {
			this.SetIdentity();
		}
		b2Mat22.FromAngle = function (angle) {
			if (angle === undefined) angle = 0;
			var mat = new b2Mat22();
			mat.Set(angle);
			return mat;
		}
		b2Mat22.FromVV = function (c1, c2) {
			var mat = new b2Mat22();
			mat.SetVV(c1, c2);
			return mat;
		}
		b2Mat22.prototype.Set = function (angle) {
			if (angle === undefined) angle = 0;
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			this.col1.x = c;
			this.col2.x = (-s);
			this.col1.y = s;
			this.col2.y = c;
		}
		b2Mat22.prototype.SetVV = function (c1, c2) {
			this.col1.SetV(c1);
			this.col2.SetV(c2);
		}
		b2Mat22.prototype.Copy = function () {
			var mat = new b2Mat22();
			mat.SetM(this);
			return mat;
		}
		b2Mat22.prototype.SetM = function (m) {
			this.col1.SetV(m.col1);
			this.col2.SetV(m.col2);
		}
		b2Mat22.prototype.AddM = function (m) {
			this.col1.x += m.col1.x;
			this.col1.y += m.col1.y;
			this.col2.x += m.col2.x;
			this.col2.y += m.col2.y;
		}
		b2Mat22.prototype.SetIdentity = function () {
			this.col1.x = 1.0;
			this.col2.x = 0.0;
			this.col1.y = 0.0;
			this.col2.y = 1.0;
		}
		b2Mat22.prototype.SetZero = function () {
			this.col1.x = 0.0;
			this.col2.x = 0.0;
			this.col1.y = 0.0;
			this.col2.y = 0.0;
		}
		b2Mat22.prototype.GetAngle = function () {
			return Math.atan2(this.col1.y, this.col1.x);
		}
		b2Mat22.prototype.GetInverse = function (out) {
			var a = this.col1.x;
			var b = this.col2.x;
			var c = this.col1.y;
			var d = this.col2.y;
			var det = a * d - b * c;
			if (det != 0.0) {
				det = 1.0 / det;
			}
			out.col1.x = det * d;
			out.col2.x = (-det * b);
			out.col1.y = (-det * c);
			out.col2.y = det * a;
			return out;
		}
		b2Mat22.prototype.Solve = function (out, bX, bY) {
			if (bX === undefined) bX = 0;
			if (bY === undefined) bY = 0;
			var a11 = this.col1.x;
			var a12 = this.col2.x;
			var a21 = this.col1.y;
			var a22 = this.col2.y;
			var det = a11 * a22 - a12 * a21;
			if (det != 0.0) {
				det = 1.0 / det;
			}
			out.x = det * (a22 * bX - a12 * bY);
			out.y = det * (a11 * bY - a21 * bX);
			return out;
		}
		b2Mat22.prototype.Abs = function () {
			this.col1.Abs();
			this.col2.Abs();
		}
		b2Mat33.b2Mat33 = function () {
			this.col1 = new b2Vec3();
			this.col2 = new b2Vec3();
			this.col3 = new b2Vec3();
		};
		b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
			if (c1 === undefined) c1 = null;
			if (c2 === undefined) c2 = null;
			if (c3 === undefined) c3 = null;
			if (!c1 && !c2 && !c3) {
				this.col1.SetZero();
				this.col2.SetZero();
				this.col3.SetZero();
			}
			else {
				this.col1.SetV(c1);
				this.col2.SetV(c2);
				this.col3.SetV(c3);
			}
		}
		b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
			this.col1.SetV(c1);
			this.col2.SetV(c2);
			this.col3.SetV(c3);
		}
		b2Mat33.prototype.Copy = function () {
			return new b2Mat33(this.col1, this.col2, this.col3);
		}
		b2Mat33.prototype.SetM = function (m) {
			this.col1.SetV(m.col1);
			this.col2.SetV(m.col2);
			this.col3.SetV(m.col3);
		}
		b2Mat33.prototype.AddM = function (m) {
			this.col1.x += m.col1.x;
			this.col1.y += m.col1.y;
			this.col1.z += m.col1.z;
			this.col2.x += m.col2.x;
			this.col2.y += m.col2.y;
			this.col2.z += m.col2.z;
			this.col3.x += m.col3.x;
			this.col3.y += m.col3.y;
			this.col3.z += m.col3.z;
		}
		b2Mat33.prototype.SetIdentity = function () {
			this.col1.x = 1.0;
			this.col2.x = 0.0;
			this.col3.x = 0.0;
			this.col1.y = 0.0;
			this.col2.y = 1.0;
			this.col3.y = 0.0;
			this.col1.z = 0.0;
			this.col2.z = 0.0;
			this.col3.z = 1.0;
		}
		b2Mat33.prototype.SetZero = function () {
			this.col1.x = 0.0;
			this.col2.x = 0.0;
			this.col3.x = 0.0;
			this.col1.y = 0.0;
			this.col2.y = 0.0;
			this.col3.y = 0.0;
			this.col1.z = 0.0;
			this.col2.z = 0.0;
			this.col3.z = 0.0;
		}
		b2Mat33.prototype.Solve22 = function (out, bX, bY) {
			if (bX === undefined) bX = 0;
			if (bY === undefined) bY = 0;
			var a11 = this.col1.x;
			var a12 = this.col2.x;
			var a21 = this.col1.y;
			var a22 = this.col2.y;
			var det = a11 * a22 - a12 * a21;
			if (det != 0.0) {
				det = 1.0 / det;
			}
			out.x = det * (a22 * bX - a12 * bY);
			out.y = det * (a11 * bY - a21 * bX);
			return out;
		}
		b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
			if (bX === undefined) bX = 0;
			if (bY === undefined) bY = 0;
			if (bZ === undefined) bZ = 0;
			var a11 = this.col1.x;
			var a21 = this.col1.y;
			var a31 = this.col1.z;
			var a12 = this.col2.x;
			var a22 = this.col2.y;
			var a32 = this.col2.z;
			var a13 = this.col3.x;
			var a23 = this.col3.y;
			var a33 = this.col3.z;
			var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
			if (det != 0.0) {
				det = 1.0 / det;
			}
			out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
			out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
			out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
			return out;
		}
		b2Math.b2Math = function () {
		};
		b2Math.IsValid = function (x) {
			if (x === undefined) x = 0;
			return isFinite(x);
		}
		b2Math.Dot = function (a, b) {
			return a.x * b.x + a.y * b.y;
		}
		b2Math.CrossVV = function (a, b) {
			return a.x * b.y - a.y * b.x;
		}
		b2Math.CrossVF = function (a, s) {
			if (s === undefined) s = 0;
			var v = new b2Vec2(s * a.y, (-s * a.x));
			return v;
		}
		b2Math.CrossFV = function (s, a) {
			if (s === undefined) s = 0;
			var v = new b2Vec2((-s * a.y), s * a.x);
			return v;
		}
		b2Math.MulMV = function (A, v) {
			var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
			return u;
		}
		b2Math.MulTMV = function (A, v) {
			var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
			return u;
		}
		b2Math.MulX = function (T, v) {
			var a = b2Math.MulMV(T.R, v);
			a.x += T.position.x;
			a.y += T.position.y;
			return a;
		}
		b2Math.MulXT = function (T, v) {
			var a = b2Math.SubtractVV(v, T.position);
			var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
			a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
			a.x = tX;
			return a;
		}
		b2Math.AddVV = function (a, b) {
			var v = new b2Vec2(a.x + b.x, a.y + b.y);
			return v;
		}
		b2Math.SubtractVV = function (a, b) {
			var v = new b2Vec2(a.x - b.x, a.y - b.y);
			return v;
		}
		b2Math.Distance = function (a, b) {
			var cX = a.x - b.x;
			var cY = a.y - b.y;
			return Math.sqrt(cX * cX + cY * cY);
		}
		b2Math.DistanceSquared = function (a, b) {
			var cX = a.x - b.x;
			var cY = a.y - b.y;
			return (cX * cX + cY * cY);
		}
		b2Math.MulFV = function (s, a) {
			if (s === undefined) s = 0;
			var v = new b2Vec2(s * a.x, s * a.y);
			return v;
		}
		b2Math.AddMM = function (A, B) {
			var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
			return C;
		}
		b2Math.MulMM = function (A, B) {
			var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
			return C;
		}
		b2Math.MulTMM = function (A, B) {
			var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
			var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
			var C = b2Mat22.FromVV(c1, c2);
			return C;
		}
		b2Math.Abs = function (a) {
			if (a === undefined) a = 0;
			return a > 0.0 ? a : (-a);
		}
		b2Math.AbsV = function (a) {
			var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
			return b;
		}
		b2Math.AbsM = function (A) {
			var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
			return B;
		}
		b2Math.Min = function (a, b) {
			if (a === undefined) a = 0;
			if (b === undefined) b = 0;
			return a < b ? a : b;
		}
		b2Math.MinV = function (a, b) {
			var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
			return c;
		}
		b2Math.Max = function (a, b) {
			if (a === undefined) a = 0;
			if (b === undefined) b = 0;
			return a > b ? a : b;
		}
		b2Math.MaxV = function (a, b) {
			var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
			return c;
		}
		b2Math.Clamp = function (a, low, high) {
			if (a === undefined) a = 0;
			if (low === undefined) low = 0;
			if (high === undefined) high = 0;
			return a < low ? low : a > high ? high : a;
		}
		b2Math.ClampV = function (a, low, high) {
			return b2Math.MaxV(low, b2Math.MinV(a, high));
		}
		b2Math.Swap = function (a, b) {
			var tmp = a[0];
			a[0] = b[0];
			b[0] = tmp;
		}
		b2Math.Random = function () {
			return Math.random() * 2 - 1;
		}
		b2Math.RandomRange = function (lo, hi) {
			if (lo === undefined) lo = 0;
			if (hi === undefined) hi = 0;
			var r = Math.random();
			r = (hi - lo) * r + lo;
			return r;
		}
		b2Math.NextPowerOfTwo = function (x) {
			if (x === undefined) x = 0;
			x |= (x >> 1) & 0x7FFFFFFF;
			x |= (x >> 2) & 0x3FFFFFFF;
			x |= (x >> 4) & 0x0FFFFFFF;
			x |= (x >> 8) & 0x00FFFFFF;
			x |= (x >> 16) & 0x0000FFFF;
			return x + 1;
		}
		b2Math.IsPowerOfTwo = function (x) {
			if (x === undefined) x = 0;
			var result = x > 0 && (x & (x - 1)) == 0;
			return result;
		}
		Box2D.postDefs.push(function () {
			Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
			Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
			Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
		});
		b2Sweep.b2Sweep = function () {
			this.localCenter = new b2Vec2();
			this.c0 = new b2Vec2;
			this.c = new b2Vec2();
		};
		b2Sweep.prototype.Set = function (other) {
			this.localCenter.SetV(other.localCenter);
			this.c0.SetV(other.c0);
			this.c.SetV(other.c);
			this.a0 = other.a0;
			this.a = other.a;
			this.t0 = other.t0;
		}
		b2Sweep.prototype.Copy = function () {
			var copy = new b2Sweep();
			copy.localCenter.SetV(this.localCenter);
			copy.c0.SetV(this.c0);
			copy.c.SetV(this.c);
			copy.a0 = this.a0;
			copy.a = this.a;
			copy.t0 = this.t0;
			return copy;
		}
		b2Sweep.prototype.GetTransform = function (xf, alpha) {
			if (alpha === undefined) alpha = 0;
			xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
			xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
			var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
			xf.R.Set(angle);
			var tMat = xf.R;
			xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
			xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
		}
		b2Sweep.prototype.Advance = function (t) {
			if (t === undefined) t = 0;
			if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
				var alpha = (t - this.t0) / (1.0 - this.t0);
				this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
				this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
				this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
				this.t0 = t;
			}
		}
		b2Transform.b2Transform = function () {
			this.position = new b2Vec2;
			this.R = new b2Mat22();
		};
		b2Transform.prototype.b2Transform = function (pos, r) {
			if (pos === undefined) pos = null;
			if (r === undefined) r = null;
			if (pos) {
				this.position.SetV(pos);
				this.R.SetM(r);
			}
		}
		b2Transform.prototype.Initialize = function (pos, r) {
			this.position.SetV(pos);
			this.R.SetM(r);
		}
		b2Transform.prototype.SetIdentity = function () {
			this.position.SetZero();
			this.R.SetIdentity();
		}
		b2Transform.prototype.Set = function (x) {
			this.position.SetV(x.position);
			this.R.SetM(x.R);
		}
		b2Transform.prototype.GetAngle = function () {
			return Math.atan2(this.R.col1.y, this.R.col1.x);
		}
		b2Vec2.b2Vec2 = function () {
		};
		b2Vec2.prototype.b2Vec2 = function (x_, y_) {
			if (x_ === undefined) x_ = 0;
			if (y_ === undefined) y_ = 0;
			this.x = x_;
			this.y = y_;
		}
		b2Vec2.prototype.SetZero = function () {
			this.x = 0.0;
			this.y = 0.0;
		}
		b2Vec2.prototype.Set = function (x_, y_) {
			if (x_ === undefined) x_ = 0;
			if (y_ === undefined) y_ = 0;
			this.x = x_;
			this.y = y_;
		}
		b2Vec2.prototype.SetV = function (v) {
			this.x = v.x;
			this.y = v.y;
		}
		b2Vec2.prototype.GetNegative = function () {
			return new b2Vec2((-this.x), (-this.y));
		}
		b2Vec2.prototype.NegativeSelf = function () {
			this.x = (-this.x);
			this.y = (-this.y);
		}
		b2Vec2.Make = function (x_, y_) {
			if (x_ === undefined) x_ = 0;
			if (y_ === undefined) y_ = 0;
			return new b2Vec2(x_, y_);
		}
		b2Vec2.prototype.Copy = function () {
			return new b2Vec2(this.x, this.y);
		}
		b2Vec2.prototype.Add = function (v) {
			this.x += v.x;
			this.y += v.y;
		}
		b2Vec2.prototype.Subtract = function (v) {
			this.x -= v.x;
			this.y -= v.y;
		}
		b2Vec2.prototype.Multiply = function (a) {
			if (a === undefined) a = 0;
			this.x *= a;
			this.y *= a;
		}
		b2Vec2.prototype.MulM = function (A) {
			var tX = this.x;
			this.x = A.col1.x * tX + A.col2.x * this.y;
			this.y = A.col1.y * tX + A.col2.y * this.y;
		}
		b2Vec2.prototype.MulTM = function (A) {
			var tX = b2Math.Dot(this, A.col1);
			this.y = b2Math.Dot(this, A.col2);
			this.x = tX;
		}
		b2Vec2.prototype.CrossVF = function (s) {
			if (s === undefined) s = 0;
			var tX = this.x;
			this.x = s * this.y;
			this.y = (-s * tX);
		}
		b2Vec2.prototype.CrossFV = function (s) {
			if (s === undefined) s = 0;
			var tX = this.x;
			this.x = (-s * this.y);
			this.y = s * tX;
		}
		b2Vec2.prototype.MinV = function (b) {
			this.x = this.x < b.x ? this.x : b.x;
			this.y = this.y < b.y ? this.y : b.y;
		}
		b2Vec2.prototype.MaxV = function (b) {
			this.x = this.x > b.x ? this.x : b.x;
			this.y = this.y > b.y ? this.y : b.y;
		}
		b2Vec2.prototype.Abs = function () {
			if (this.x < 0) this.x = (-this.x);
			if (this.y < 0) this.y = (-this.y);
		}
		b2Vec2.prototype.Length = function () {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		b2Vec2.prototype.LengthSquared = function () {
			return (this.x * this.x + this.y * this.y);
		}
		b2Vec2.prototype.Normalize = function () {
			var length = Math.sqrt(this.x * this.x + this.y * this.y);
			if (length < Number.MIN_VALUE) {
				return 0.0;
			}
			var invLength = 1.0 / length;
			this.x *= invLength;
			this.y *= invLength;
			return length;
		}
		b2Vec2.prototype.IsValid = function () {
			return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
		}
		b2Vec3.b2Vec3 = function () {
		};
		b2Vec3.prototype.b2Vec3 = function (x, y, z) {
			if (x === undefined) x = 0;
			if (y === undefined) y = 0;
			if (z === undefined) z = 0;
			this.x = x;
			this.y = y;
			this.z = z;
		}
		b2Vec3.prototype.SetZero = function () {
			this.x = this.y = this.z = 0.0;
		}
		b2Vec3.prototype.Set = function (x, y, z) {
			if (x === undefined) x = 0;
			if (y === undefined) y = 0;
			if (z === undefined) z = 0;
			this.x = x;
			this.y = y;
			this.z = z;
		}
		b2Vec3.prototype.SetV = function (v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
		}
		b2Vec3.prototype.GetNegative = function () {
			return new b2Vec3((-this.x), (-this.y), (-this.z));
		}
		b2Vec3.prototype.NegativeSelf = function () {
			this.x = (-this.x);
			this.y = (-this.y);
			this.z = (-this.z);
		}
		b2Vec3.prototype.Copy = function () {
			return new b2Vec3(this.x, this.y, this.z);
		}
		b2Vec3.prototype.Add = function (v) {
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
		}
		b2Vec3.prototype.Subtract = function (v) {
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
		}
		b2Vec3.prototype.Multiply = function (a) {
			if (a === undefined) a = 0;
			this.x *= a;
			this.y *= a;
			this.z *= a;
		}
	})();
	(function () {
		var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2AABB = Box2D.Collision.b2AABB,
			b2Bound = Box2D.Collision.b2Bound,
			b2BoundValues = Box2D.Collision.b2BoundValues,
			b2Collision = Box2D.Collision.b2Collision,
			b2ContactID = Box2D.Collision.b2ContactID,
			b2ContactPoint = Box2D.Collision.b2ContactPoint,
			b2Distance = Box2D.Collision.b2Distance,
			b2DistanceInput = Box2D.Collision.b2DistanceInput,
			b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
			b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
			b2DynamicTree = Box2D.Collision.b2DynamicTree,
			b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
			b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
			b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
			b2Manifold = Box2D.Collision.b2Manifold,
			b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
			b2Point = Box2D.Collision.b2Point,
			b2RayCastInput = Box2D.Collision.b2RayCastInput,
			b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
			b2Segment = Box2D.Collision.b2Segment,
			b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
			b2Simplex = Box2D.Collision.b2Simplex,
			b2SimplexCache = Box2D.Collision.b2SimplexCache,
			b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
			b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
			b2TOIInput = Box2D.Collision.b2TOIInput,
			b2WorldManifold = Box2D.Collision.b2WorldManifold,
			ClipVertex = Box2D.Collision.ClipVertex,
			Features = Box2D.Collision.Features,
			IBroadPhase = Box2D.Collision.IBroadPhase,
			b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World,
			b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
			b2Contact = Box2D.Dynamics.Contacts.b2Contact,
			b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
			b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
			b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
			b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
			b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
			b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
			b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
			b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
			b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
			b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
			b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
			b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
			b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
			b2Controller = Box2D.Dynamics.Controllers.b2Controller,
			b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
			b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
			b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
			b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
			b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
			b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
			b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
			b2Joint = Box2D.Dynamics.Joints.b2Joint,
			b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
			b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
			b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
			b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
			b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
			b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
			b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
			b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
			b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
			b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
			b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
			b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
			b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
			b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;
		
		b2Body.b2Body = function () {
			this.m_xf = new b2Transform();
			this.m_sweep = new b2Sweep();
			this.m_linearVelocity = new b2Vec2();
			this.m_force = new b2Vec2();
		};
		b2Body.prototype.connectEdges = function (s1, s2, angle1) {
			if (angle1 === undefined) angle1 = 0;
			var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
			var coreOffset = Math.tan((angle2 - angle1) * 0.5);
			var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
			core = b2Math.SubtractVV(core, s2.GetNormalVector());
			core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
			core = b2Math.AddVV(core, s2.GetVertex1());
			var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
			cornerDir.Normalize();
			var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
			s1.SetNextEdge(s2, core, cornerDir, convex);
			s2.SetPrevEdge(s1, core, cornerDir, convex);
			return angle2;
		}
		b2Body.prototype.CreateFixture = function (def) {
			if (this.m_world.IsLocked() == true) {
				return null;
			}
			var fixture = new b2Fixture();
			fixture.Create(this, this.m_xf, def);
			if (this.m_flags & b2Body.e_activeFlag) {
				var broadPhase = this.m_world.m_contactManager.m_broadPhase;
				fixture.CreateProxy(broadPhase, this.m_xf);
			}
			fixture.m_next = this.m_fixtureList;
			this.m_fixtureList = fixture;
			++this.m_fixtureCount;
			fixture.m_body = this;
			if (fixture.m_density > 0.0) {
				this.ResetMassData();
			}
			this.m_world.m_flags |= b2World.e_newFixture;
			return fixture;
		}
		b2Body.prototype.CreateFixture2 = function (shape, density) {
			if (density === undefined) density = 0.0;
			var def = new b2FixtureDef();
			def.shape = shape;
			def.density = density;
			return this.CreateFixture(def);
		}
		b2Body.prototype.DestroyFixture = function (fixture) {
			if (this.m_world.IsLocked() == true) {
				return;
			}
			var node = this.m_fixtureList;
			var ppF = null;
			var found = false;
			while (node != null) {
				if (node == fixture) {
					if (ppF) ppF.m_next = fixture.m_next;
					else this.m_fixtureList = fixture.m_next;
					found = true;
					break;
				}
				ppF = node;
				node = node.m_next;
			}
			var edge = this.m_contactList;
			while (edge) {
				var c = edge.contact;
				edge = edge.next;
				var fixtureA = c.GetFixtureA();
				var fixtureB = c.GetFixtureB();
				if (fixture == fixtureA || fixture == fixtureB) {
					this.m_world.m_contactManager.Destroy(c);
				}
			}
			if (this.m_flags & b2Body.e_activeFlag) {
				var broadPhase = this.m_world.m_contactManager.m_broadPhase;
				fixture.DestroyProxy(broadPhase);
			}
			else {
			}
			fixture.Destroy();
			fixture.m_body = null;
			fixture.m_next = null;
			--this.m_fixtureCount;
			this.ResetMassData();
		}
		b2Body.prototype.SetPositionAndAngle = function (position, angle) {
			if (angle === undefined) angle = 0;
			var f;
			if (this.m_world.IsLocked() == true) {
				return;
			}
			this.m_xf.R.Set(angle);
			this.m_xf.position.SetV(position);
			var tMat = this.m_xf.R;
			var tVec = this.m_sweep.localCenter;
			this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			this.m_sweep.c.x += this.m_xf.position.x;
			this.m_sweep.c.y += this.m_xf.position.y;
			this.m_sweep.c0.SetV(this.m_sweep.c);
			this.m_sweep.a0 = this.m_sweep.a = angle;
			var broadPhase = this.m_world.m_contactManager.m_broadPhase;
			for (f = this.m_fixtureList;
				 f; f = f.m_next) {
				f.Synchronize(broadPhase, this.m_xf, this.m_xf);
			}
			this.m_world.m_contactManager.FindNewContacts();
		}
		b2Body.prototype.SetTransform = function (xf) {
			this.SetPositionAndAngle(xf.position, xf.GetAngle());
		}
		b2Body.prototype.GetTransform = function () {
			return this.m_xf;
		}
		b2Body.prototype.GetPosition = function () {
			return this.m_xf.position;
		}
		b2Body.prototype.SetPosition = function (position) {
			this.SetPositionAndAngle(position, this.GetAngle());
		}
		b2Body.prototype.GetAngle = function () {
			return this.m_sweep.a;
		}
		b2Body.prototype.SetAngle = function (angle) {
			if (angle === undefined) angle = 0;
			this.SetPositionAndAngle(this.GetPosition(), angle);
		}
		b2Body.prototype.GetWorldCenter = function () {
			return this.m_sweep.c;
		}
		b2Body.prototype.GetLocalCenter = function () {
			return this.m_sweep.localCenter;
		}
		b2Body.prototype.SetLinearVelocity = function (v) {
			if (this.m_type == b2Body.b2_staticBody) {
				return;
			}
			this.m_linearVelocity.SetV(v);
		}
		b2Body.prototype.GetLinearVelocity = function () {
			return this.m_linearVelocity;
		}
		b2Body.prototype.SetAngularVelocity = function (omega) {
			if (omega === undefined) omega = 0;
			if (this.m_type == b2Body.b2_staticBody) {
				return;
			}
			this.m_angularVelocity = omega;
		}
		b2Body.prototype.GetAngularVelocity = function () {
			return this.m_angularVelocity;
		}
		b2Body.prototype.GetDefinition = function () {
			var bd = new b2BodyDef();
			bd.type = this.GetType();
			bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
			bd.angle = this.GetAngle();
			bd.angularDamping = this.m_angularDamping;
			bd.angularVelocity = this.m_angularVelocity;
			bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
			bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
			bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
			bd.linearDamping = this.m_linearDamping;
			bd.linearVelocity.SetV(this.GetLinearVelocity());
			bd.position = this.GetPosition();
			bd.userData = this.GetUserData();
			return bd;
		}
		b2Body.prototype.ApplyForce = function (force, point) {
			if (this.m_type != b2Body.b2_dynamicBody) {
				return;
			}
			if (this.IsAwake() == false) {
				this.SetAwake(true);
			}
			this.m_force.x += force.x;
			this.m_force.y += force.y;
			this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
		}
		b2Body.prototype.ApplyTorque = function (torque) {
			if (torque === undefined) torque = 0;
			if (this.m_type != b2Body.b2_dynamicBody) {
				return;
			}
			if (this.IsAwake() == false) {
				this.SetAwake(true);
			}
			this.m_torque += torque;
		}
		b2Body.prototype.ApplyImpulse = function (impulse, point) {
			if (this.m_type != b2Body.b2_dynamicBody) {
				return;
			}
			if (this.IsAwake() == false) {
				this.SetAwake(true);
			}
			this.m_linearVelocity.x += this.m_invMass * impulse.x;
			this.m_linearVelocity.y += this.m_invMass * impulse.y;
			this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
		}
		b2Body.prototype.Split = function (callback) {
			var linearVelocity = this.GetLinearVelocity().Copy();
			var angularVelocity = this.GetAngularVelocity();
			var center = this.GetWorldCenter();
			var body1 = this;
			var body2 = this.m_world.CreateBody(this.GetDefinition());
			var prev;
			for (var f = body1.m_fixtureList; f;) {
				if (callback(f)) {
					var next = f.m_next;
					if (prev) {
						prev.m_next = next;
					}
					else {
						body1.m_fixtureList = next;
					}
					body1.m_fixtureCount--;
					f.m_next = body2.m_fixtureList;
					body2.m_fixtureList = f;
					body2.m_fixtureCount++;
					f.m_body = body2;
					f = next;
				}
				else {
					prev = f;
					f = f.m_next;
				}
			}
			body1.ResetMassData();
			body2.ResetMassData();
			var center1 = body1.GetWorldCenter();
			var center2 = body2.GetWorldCenter();
			var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
			var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
			body1.SetLinearVelocity(velocity1);
			body2.SetLinearVelocity(velocity2);
			body1.SetAngularVelocity(angularVelocity);
			body2.SetAngularVelocity(angularVelocity);
			body1.SynchronizeFixtures();
			body2.SynchronizeFixtures();
			return body2;
		}
		b2Body.prototype.Merge = function (other) {
			var f;
			for (f = other.m_fixtureList;
				 f;) {
				var next = f.m_next;
				other.m_fixtureCount--;
				f.m_next = this.m_fixtureList;
				this.m_fixtureList = f;
				this.m_fixtureCount++;
				f.m_body = body2;
				f = next;
			}
			body1.m_fixtureCount = 0;
			var body1 = this;
			var body2 = other;
			var center1 = body1.GetWorldCenter();
			var center2 = body2.GetWorldCenter();
			var velocity1 = body1.GetLinearVelocity().Copy();
			var velocity2 = body2.GetLinearVelocity().Copy();
			var angular1 = body1.GetAngularVelocity();
			var angular = body2.GetAngularVelocity();
			body1.ResetMassData();
			this.SynchronizeFixtures();
		}
		b2Body.prototype.GetMass = function () {
			return this.m_mass;
		}
		b2Body.prototype.GetInertia = function () {
			return this.m_I;
		}
		b2Body.prototype.GetMassData = function (data) {
			data.mass = this.m_mass;
			data.I = this.m_I;
			data.center.SetV(this.m_sweep.localCenter);
		}
		b2Body.prototype.SetMassData = function (massData) {
			b2Settings.b2Assert(this.m_world.IsLocked() == false);
			if (this.m_world.IsLocked() == true) {
				return;
			}
			if (this.m_type != b2Body.b2_dynamicBody) {
				return;
			}
			this.m_invMass = 0.0;
			this.m_I = 0.0;
			this.m_invI = 0.0;
			this.m_mass = massData.mass;
			if (this.m_mass <= 0.0) {
				this.m_mass = 1.0;
			}
			this.m_invMass = 1.0 / this.m_mass;
			if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
				this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
				this.m_invI = 1.0 / this.m_I;
			}
			var oldCenter = this.m_sweep.c.Copy();
			this.m_sweep.localCenter.SetV(massData.center);
			this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
			this.m_sweep.c.SetV(this.m_sweep.c0);
			this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
			this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
		}
		b2Body.prototype.ResetMassData = function () {
			this.m_mass = 0.0;
			this.m_invMass = 0.0;
			this.m_I = 0.0;
			this.m_invI = 0.0;
			this.m_sweep.localCenter.SetZero();
			if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
				return;
			}
			var center = b2Vec2.Make(0, 0);
			for (var f = this.m_fixtureList; f; f = f.m_next) {
				if (f.m_density == 0.0) {
					continue;
				}
				var massData = f.GetMassData();
				this.m_mass += massData.mass;
				center.x += massData.center.x * massData.mass;
				center.y += massData.center.y * massData.mass;
				this.m_I += massData.I;
			}
			if (this.m_mass > 0.0) {
				this.m_invMass = 1.0 / this.m_mass;
				center.x *= this.m_invMass;
				center.y *= this.m_invMass;
			}
			else {
				this.m_mass = 1.0;
				this.m_invMass = 1.0;
			}
			if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
				this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
				this.m_I *= this.m_inertiaScale;
				b2Settings.b2Assert(this.m_I > 0);
				this.m_invI = 1.0 / this.m_I;
			}
			else {
				this.m_I = 0.0;
				this.m_invI = 0.0;
			}
			var oldCenter = this.m_sweep.c.Copy();
			this.m_sweep.localCenter.SetV(center);
			this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
			this.m_sweep.c.SetV(this.m_sweep.c0);
			this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
			this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
		}
		b2Body.prototype.GetWorldPoint = function (localPoint) {
			var A = this.m_xf.R;
			var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
			u.x += this.m_xf.position.x;
			u.y += this.m_xf.position.y;
			return u;
		}
		b2Body.prototype.GetWorldVector = function (localVector) {
			return b2Math.MulMV(this.m_xf.R, localVector);
		}
		b2Body.prototype.GetLocalPoint = function (worldPoint) {
			return b2Math.MulXT(this.m_xf, worldPoint);
		}
		b2Body.prototype.GetLocalVector = function (worldVector) {
			return b2Math.MulTMV(this.m_xf.R, worldVector);
		}
		b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
			return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
		}
		b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
			var A = this.m_xf.R;
			var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
			worldPoint.x += this.m_xf.position.x;
			worldPoint.y += this.m_xf.position.y;
			return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
		}
		b2Body.prototype.GetLinearDamping = function () {
			return this.m_linearDamping;
		}
		b2Body.prototype.SetLinearDamping = function (linearDamping) {
			if (linearDamping === undefined) linearDamping = 0;
			this.m_linearDamping = linearDamping;
		}
		b2Body.prototype.GetAngularDamping = function () {
			return this.m_angularDamping;
		}
		b2Body.prototype.SetAngularDamping = function (angularDamping) {
			if (angularDamping === undefined) angularDamping = 0;
			this.m_angularDamping = angularDamping;
		}
		b2Body.prototype.SetType = function (type) {
			if (type === undefined) type = 0;
			if (this.m_type == type) {
				return;
			}
			this.m_type = type;
			this.ResetMassData();
			if (this.m_type == b2Body.b2_staticBody) {
				this.m_linearVelocity.SetZero();
				this.m_angularVelocity = 0.0;
			}
			this.SetAwake(true);
			this.m_force.SetZero();
			this.m_torque = 0.0;
			for (var ce = this.m_contactList; ce; ce = ce.next) {
				ce.contact.FlagForFiltering();
			}
		}
		b2Body.prototype.GetType = function () {
			return this.m_type;
		}
		b2Body.prototype.SetBullet = function (flag) {
			if (flag) {
				this.m_flags |= b2Body.e_bulletFlag;
			}
			else {
				this.m_flags &= ~b2Body.e_bulletFlag;
			}
		}
		b2Body.prototype.IsBullet = function () {
			return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
		}
		b2Body.prototype.SetSleepingAllowed = function (flag) {
			if (flag) {
				this.m_flags |= b2Body.e_allowSleepFlag;
			}
			else {
				this.m_flags &= ~b2Body.e_allowSleepFlag;
				this.SetAwake(true);
			}
		}
		b2Body.prototype.SetAwake = function (flag) {
			if (flag) {
				this.m_flags |= b2Body.e_awakeFlag;
				this.m_sleepTime = 0.0;
			}
			else {
				this.m_flags &= ~b2Body.e_awakeFlag;
				this.m_sleepTime = 0.0;
				this.m_linearVelocity.SetZero();
				this.m_angularVelocity = 0.0;
				this.m_force.SetZero();
				this.m_torque = 0.0;
			}
		}
		b2Body.prototype.IsAwake = function () {
			return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
		}
		b2Body.prototype.SetFixedRotation = function (fixed) {
			if (fixed) {
				this.m_flags |= b2Body.e_fixedRotationFlag;
			}
			else {
				this.m_flags &= ~b2Body.e_fixedRotationFlag;
			}
			this.ResetMassData();
		}
		b2Body.prototype.IsFixedRotation = function () {
			return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
		}
		b2Body.prototype.SetActive = function (flag) {
			if (flag == this.IsActive()) {
				return;
			}
			var broadPhase;
			var f;
			if (flag) {
				this.m_flags |= b2Body.e_activeFlag;
				broadPhase = this.m_world.m_contactManager.m_broadPhase;
				for (f = this.m_fixtureList;
					 f; f = f.m_next) {
					f.CreateProxy(broadPhase, this.m_xf);
				}
			}
			else {
				this.m_flags &= ~b2Body.e_activeFlag;
				broadPhase = this.m_world.m_contactManager.m_broadPhase;
				for (f = this.m_fixtureList;
					 f; f = f.m_next) {
					f.DestroyProxy(broadPhase);
				}
				var ce = this.m_contactList;
				while (ce) {
					var ce0 = ce;
					ce = ce.next;
					this.m_world.m_contactManager.Destroy(ce0.contact);
				}
				this.m_contactList = null;
			}
		}
		b2Body.prototype.IsActive = function () {
			return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
		}
		b2Body.prototype.IsSleepingAllowed = function () {
			return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
		}
		b2Body.prototype.GetFixtureList = function () {
			return this.m_fixtureList;
		}
		b2Body.prototype.GetJointList = function () {
			return this.m_jointList;
		}
		b2Body.prototype.GetControllerList = function () {
			return this.m_controllerList;
		}
		b2Body.prototype.GetContactList = function () {
			return this.m_contactList;
		}
		b2Body.prototype.GetNext = function () {
			return this.m_next;
		}
		b2Body.prototype.GetUserData = function () {
			return this.m_userData;
		}
		b2Body.prototype.SetUserData = function (data) {
			this.m_userData = data;
		}
		b2Body.prototype.GetWorld = function () {
			return this.m_world;
		}
		b2Body.prototype.b2Body = function (bd, world) {
			this.m_flags = 0;
			if (bd.bullet) {
				this.m_flags |= b2Body.e_bulletFlag;
			}
			if (bd.fixedRotation) {
				this.m_flags |= b2Body.e_fixedRotationFlag;
			}
			if (bd.allowSleep) {
				this.m_flags |= b2Body.e_allowSleepFlag;
			}
			if (bd.awake) {
				this.m_flags |= b2Body.e_awakeFlag;
			}
			if (bd.active) {
				this.m_flags |= b2Body.e_activeFlag;
			}
			this.m_world = world;
			this.m_xf.position.SetV(bd.position);
			this.m_xf.R.Set(bd.angle);
			this.m_sweep.localCenter.SetZero();
			this.m_sweep.t0 = 1.0;
			this.m_sweep.a0 = this.m_sweep.a = bd.angle;
			var tMat = this.m_xf.R;
			var tVec = this.m_sweep.localCenter;
			this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			this.m_sweep.c.x += this.m_xf.position.x;
			this.m_sweep.c.y += this.m_xf.position.y;
			this.m_sweep.c0.SetV(this.m_sweep.c);
			this.m_jointList = null;
			this.m_controllerList = null;
			this.m_contactList = null;
			this.m_controllerCount = 0;
			this.m_prev = null;
			this.m_next = null;
			this.m_linearVelocity.SetV(bd.linearVelocity);
			this.m_angularVelocity = bd.angularVelocity;
			this.m_linearDamping = bd.linearDamping;
			this.m_angularDamping = bd.angularDamping;
			this.m_force.Set(0.0, 0.0);
			this.m_torque = 0.0;
			this.m_sleepTime = 0.0;
			this.m_type = bd.type;
			if (this.m_type == b2Body.b2_dynamicBody) {
				this.m_mass = 1.0;
				this.m_invMass = 1.0;
			}
			else {
				this.m_mass = 0.0;
				this.m_invMass = 0.0;
			}
			this.m_I = 0.0;
			this.m_invI = 0.0;
			this.m_inertiaScale = bd.inertiaScale;
			this.m_userData = bd.userData;
			this.m_fixtureList = null;
			this.m_fixtureCount = 0;
		}
		b2Body.prototype.SynchronizeFixtures = function () {
			var xf1 = b2Body.s_xf1;
			xf1.R.Set(this.m_sweep.a0);
			var tMat = xf1.R;
			var tVec = this.m_sweep.localCenter;
			xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			var f;
			var broadPhase = this.m_world.m_contactManager.m_broadPhase;
			for (f = this.m_fixtureList;
				 f; f = f.m_next) {
				f.Synchronize(broadPhase, xf1, this.m_xf);
			}
		}
		b2Body.prototype.SynchronizeTransform = function () {
			this.m_xf.R.Set(this.m_sweep.a);
			var tMat = this.m_xf.R;
			var tVec = this.m_sweep.localCenter;
			this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
		}
		b2Body.prototype.ShouldCollide = function (other) {
			if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
				return false;
			}
			for (var jn = this.m_jointList; jn; jn = jn.next) {
				if (jn.other == other) if (jn.joint.m_collideConnected == false) {
					return false;
				}
			}
			return true;
		}
		b2Body.prototype.Advance = function (t) {
			if (t === undefined) t = 0;
			this.m_sweep.Advance(t);
			this.m_sweep.c.SetV(this.m_sweep.c0);
			this.m_sweep.a = this.m_sweep.a0;
			this.SynchronizeTransform();
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
			Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
			Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
			Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
			Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
			Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
			Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
			Box2D.Dynamics.b2Body.b2_staticBody = 0;
			Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
			Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
		});
		b2BodyDef.b2BodyDef = function () {
			this.position = new b2Vec2();
			this.linearVelocity = new b2Vec2();
		};
		b2BodyDef.prototype.b2BodyDef = function () {
			this.userData = null;
			this.position.Set(0.0, 0.0);
			this.angle = 0.0;
			this.linearVelocity.Set(0, 0);
			this.angularVelocity = 0.0;
			this.linearDamping = 0.0;
			this.angularDamping = 0.0;
			this.allowSleep = true;
			this.awake = true;
			this.fixedRotation = false;
			this.bullet = false;
			this.type = b2Body.b2_staticBody;
			this.active = true;
			this.inertiaScale = 1.0;
		}
		b2ContactFilter.b2ContactFilter = function () {
		};
		b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
			var filter1 = fixtureA.GetFilterData();
			var filter2 = fixtureB.GetFilterData();
			if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
				return filter1.groupIndex > 0;
			}
			var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
			return collide;
		}
		b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
			if (!userData) return true;
			return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
		});
		b2ContactImpulse.b2ContactImpulse = function () {
			this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
			this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
		};
		b2ContactListener.b2ContactListener = function () {
		};
		b2ContactListener.prototype.BeginContact = function (contact) {
		}
		b2ContactListener.prototype.EndContact = function (contact) {
		}
		b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {
		}
		b2ContactListener.prototype.PostSolve = function (contact, impulse) {
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
		});
		b2ContactManager.b2ContactManager = function () {
		};
		b2ContactManager.prototype.b2ContactManager = function () {
			this.m_world = null;
			this.m_contactCount = 0;
			this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
			this.m_contactListener = b2ContactListener.b2_defaultListener;
			this.m_contactFactory = new b2ContactFactory(this.m_allocator);
			this.m_broadPhase = new b2DynamicTreeBroadPhase();
		}
		b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
			var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
			var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
			var bodyA = fixtureA.GetBody();
			var bodyB = fixtureB.GetBody();
			if (bodyA == bodyB) return;
			var edge = bodyB.GetContactList();
			while (edge) {
				if (edge.other == bodyA) {
					var fA = edge.contact.GetFixtureA();
					var fB = edge.contact.GetFixtureB();
					if (fA == fixtureA && fB == fixtureB) return;
					if (fA == fixtureB && fB == fixtureA) return;
				}
				edge = edge.next;
			}
			if (bodyB.ShouldCollide(bodyA) == false) {
				return;
			}
			if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
				return;
			}
			var c = this.m_contactFactory.Create(fixtureA, fixtureB);
			fixtureA = c.GetFixtureA();
			fixtureB = c.GetFixtureB();
			bodyA = fixtureA.m_body;
			bodyB = fixtureB.m_body;
			c.m_prev = null;
			c.m_next = this.m_world.m_contactList;
			if (this.m_world.m_contactList != null) {
				this.m_world.m_contactList.m_prev = c;
			}
			this.m_world.m_contactList = c;
			c.m_nodeA.contact = c;
			c.m_nodeA.other = bodyB;
			c.m_nodeA.prev = null;
			c.m_nodeA.next = bodyA.m_contactList;
			if (bodyA.m_contactList != null) {
				bodyA.m_contactList.prev = c.m_nodeA;
			}
			bodyA.m_contactList = c.m_nodeA;
			c.m_nodeB.contact = c;
			c.m_nodeB.other = bodyA;
			c.m_nodeB.prev = null;
			c.m_nodeB.next = bodyB.m_contactList;
			if (bodyB.m_contactList != null) {
				bodyB.m_contactList.prev = c.m_nodeB;
			}
			bodyB.m_contactList = c.m_nodeB;
			++this.m_world.m_contactCount;
			return;
		}
		b2ContactManager.prototype.FindNewContacts = function () {
			this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
		}
		b2ContactManager.prototype.Destroy = function (c) {
			var fixtureA = c.GetFixtureA();
			var fixtureB = c.GetFixtureB();
			var bodyA = fixtureA.GetBody();
			var bodyB = fixtureB.GetBody();
			if (c.IsTouching()) {
				this.m_contactListener.EndContact(c);
			}
			if (c.m_prev) {
				c.m_prev.m_next = c.m_next;
			}
			if (c.m_next) {
				c.m_next.m_prev = c.m_prev;
			}
			if (c == this.m_world.m_contactList) {
				this.m_world.m_contactList = c.m_next;
			}
			if (c.m_nodeA.prev) {
				c.m_nodeA.prev.next = c.m_nodeA.next;
			}
			if (c.m_nodeA.next) {
				c.m_nodeA.next.prev = c.m_nodeA.prev;
			}
			if (c.m_nodeA == bodyA.m_contactList) {
				bodyA.m_contactList = c.m_nodeA.next;
			}
			if (c.m_nodeB.prev) {
				c.m_nodeB.prev.next = c.m_nodeB.next;
			}
			if (c.m_nodeB.next) {
				c.m_nodeB.next.prev = c.m_nodeB.prev;
			}
			if (c.m_nodeB == bodyB.m_contactList) {
				bodyB.m_contactList = c.m_nodeB.next;
			}
			this.m_contactFactory.Destroy(c);
			--this.m_contactCount;
		}
		b2ContactManager.prototype.Collide = function () {
			var c = this.m_world.m_contactList;
			while (c) {
				var fixtureA = c.GetFixtureA();
				var fixtureB = c.GetFixtureB();
				var bodyA = fixtureA.GetBody();
				var bodyB = fixtureB.GetBody();
				if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
					c = c.GetNext();
					continue;
				}
				if (c.m_flags & b2Contact.e_filterFlag) {
					if (bodyB.ShouldCollide(bodyA) == false) {
						var cNuke = c;
						c = cNuke.GetNext();
						this.Destroy(cNuke);
						continue;
					}
					if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
						cNuke = c;
						c = cNuke.GetNext();
						this.Destroy(cNuke);
						continue;
					}
					c.m_flags &= ~b2Contact.e_filterFlag;
				}
				var proxyA = fixtureA.m_proxy;
				var proxyB = fixtureB.m_proxy;
				if (proxyA && proxyB) {
					var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
					if (overlap == false) {
						cNuke = c;
						c = cNuke.GetNext();
						this.Destroy(cNuke);
						continue;
					}
				}
				c.Update(this.m_contactListener);
				c = c.GetNext();
			}
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
		});
		b2DebugDraw.b2DebugDraw = function () {
		};
		b2DebugDraw.prototype.b2DebugDraw = function () {
		}
		b2DebugDraw.prototype.SetFlags = function (flags) {
			if (flags === undefined) flags = 0;
		}
		b2DebugDraw.prototype.GetFlags = function () {
		}
		b2DebugDraw.prototype.AppendFlags = function (flags) {
			if (flags === undefined) flags = 0;
		}
		b2DebugDraw.prototype.ClearFlags = function (flags) {
			if (flags === undefined) flags = 0;
		}
		b2DebugDraw.prototype.SetSprite = function (sprite) {
		}
		b2DebugDraw.prototype.GetSprite = function () {
		}
		b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
			if (drawScale === undefined) drawScale = 0;
		}
		b2DebugDraw.prototype.GetDrawScale = function () {
		}
		b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
			if (lineThickness === undefined) lineThickness = 0;
		}
		b2DebugDraw.prototype.GetLineThickness = function () {
		}
		b2DebugDraw.prototype.SetAlpha = function (alpha) {
			if (alpha === undefined) alpha = 0;
		}
		b2DebugDraw.prototype.GetAlpha = function () {
		}
		b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
			if (alpha === undefined) alpha = 0;
		}
		b2DebugDraw.prototype.GetFillAlpha = function () {
		}
		b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
			if (xformScale === undefined) xformScale = 0;
		}
		b2DebugDraw.prototype.GetXFormScale = function () {
		}
		b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
			if (vertexCount === undefined) vertexCount = 0;
		}
		b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
			if (vertexCount === undefined) vertexCount = 0;
		}
		b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
			if (radius === undefined) radius = 0;
		}
		b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
			if (radius === undefined) radius = 0;
		}
		b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
		}
		b2DebugDraw.prototype.DrawTransform = function (xf) {
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
			Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
			Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
			Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
			Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
			Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
		});
		b2DestructionListener.b2DestructionListener = function () {
		};
		b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {
		}
		b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {
		}
		b2FilterData.b2FilterData = function () {
			this.categoryBits = 0x0001;
			this.maskBits = 0xFFFF;
			this.groupIndex = 0;
		};
		b2FilterData.prototype.Copy = function () {
			var copy = new b2FilterData();
			copy.categoryBits = this.categoryBits;
			copy.maskBits = this.maskBits;
			copy.groupIndex = this.groupIndex;
			return copy;
		}
		b2Fixture.b2Fixture = function () {
			this.m_filter = new b2FilterData();
		};
		b2Fixture.prototype.GetType = function () {
			return this.m_shape.GetType();
		}
		b2Fixture.prototype.GetShape = function () {
			return this.m_shape;
		}
		b2Fixture.prototype.SetSensor = function (sensor) {
			if (this.m_isSensor == sensor) return;
			this.m_isSensor = sensor;
			if (this.m_body == null) return;
			var edge = this.m_body.GetContactList();
			while (edge) {
				var contact = edge.contact;
				var fixtureA = contact.GetFixtureA();
				var fixtureB = contact.GetFixtureB();
				if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
				edge = edge.next;
			}
		}
		b2Fixture.prototype.IsSensor = function () {
			return this.m_isSensor;
		}
		b2Fixture.prototype.SetFilterData = function (filter) {
			this.m_filter = filter.Copy();
			if (this.m_body) return;
			var edge = this.m_body.GetContactList();
			while (edge) {
				var contact = edge.contact;
				var fixtureA = contact.GetFixtureA();
				var fixtureB = contact.GetFixtureB();
				if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
				edge = edge.next;
			}
		}
		b2Fixture.prototype.GetFilterData = function () {
			return this.m_filter.Copy();
		}
		b2Fixture.prototype.GetBody = function () {
			return this.m_body;
		}
		b2Fixture.prototype.GetNext = function () {
			return this.m_next;
		}
		b2Fixture.prototype.GetUserData = function () {
			return this.m_userData;
		}
		b2Fixture.prototype.SetUserData = function (data) {
			this.m_userData = data;
		}
		b2Fixture.prototype.TestPoint = function (p) {
			return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
		}
		b2Fixture.prototype.RayCast = function (output, input) {
			return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
		}
		b2Fixture.prototype.GetMassData = function (massData) {
			if (massData === undefined) massData = null;
			if (massData == null) {
				massData = new b2MassData();
			}
			this.m_shape.ComputeMass(massData, this.m_density);
			return massData;
		}
		b2Fixture.prototype.SetDensity = function (density) {
			if (density === undefined) density = 0;
			this.m_density = density;
		}
		b2Fixture.prototype.GetDensity = function () {
			return this.m_density;
		}
		b2Fixture.prototype.GetFriction = function () {
			return this.m_friction;
		}
		b2Fixture.prototype.SetFriction = function (friction) {
			if (friction === undefined) friction = 0;
			this.m_friction = friction;
		}
		b2Fixture.prototype.GetRestitution = function () {
			return this.m_restitution;
		}
		b2Fixture.prototype.SetRestitution = function (restitution) {
			if (restitution === undefined) restitution = 0;
			this.m_restitution = restitution;
		}
		b2Fixture.prototype.GetAABB = function () {
			return this.m_aabb;
		}
		b2Fixture.prototype.b2Fixture = function () {
			this.m_aabb = new b2AABB();
			this.m_userData = null;
			this.m_body = null;
			this.m_next = null;
			this.m_shape = null;
			this.m_density = 0.0;
			this.m_friction = 0.0;
			this.m_restitution = 0.0;
		}
		b2Fixture.prototype.Create = function (body, xf, def) {
			this.m_userData = def.userData;
			this.m_friction = def.friction;
			this.m_restitution = def.restitution;
			this.m_body = body;
			this.m_next = null;
			this.m_filter = def.filter.Copy();
			this.m_isSensor = def.isSensor;
			this.m_shape = def.shape.Copy();
			this.m_density = def.density;
		}
		b2Fixture.prototype.Destroy = function () {
			this.m_shape = null;
		}
		b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
			this.m_shape.ComputeAABB(this.m_aabb, xf);
			this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
		}
		b2Fixture.prototype.DestroyProxy = function (broadPhase) {
			if (this.m_proxy == null) {
				return;
			}
			broadPhase.DestroyProxy(this.m_proxy);
			this.m_proxy = null;
		}
		b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
			if (!this.m_proxy) return;
			var aabb1 = new b2AABB();
			var aabb2 = new b2AABB();
			this.m_shape.ComputeAABB(aabb1, transform1);
			this.m_shape.ComputeAABB(aabb2, transform2);
			this.m_aabb.Combine(aabb1, aabb2);
			var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
			broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
		}
		b2FixtureDef.b2FixtureDef = function () {
			this.filter = new b2FilterData();
		};
		b2FixtureDef.prototype.b2FixtureDef = function () {
			this.shape = null;
			this.userData = null;
			this.friction = 0.2;
			this.restitution = 0.0;
			this.density = 0.0;
			this.filter.categoryBits = 0x0001;
			this.filter.maskBits = 0xFFFF;
			this.filter.groupIndex = 0;
			this.isSensor = false;
		}
		b2Island.b2Island = function () {
		};
		b2Island.prototype.b2Island = function () {
			this.m_bodies = new Vector();
			this.m_contacts = new Vector();
			this.m_joints = new Vector();
		}
		b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
			if (bodyCapacity === undefined) bodyCapacity = 0;
			if (contactCapacity === undefined) contactCapacity = 0;
			if (jointCapacity === undefined) jointCapacity = 0;
			var i = 0;
			this.m_bodyCapacity = bodyCapacity;
			this.m_contactCapacity = contactCapacity;
			this.m_jointCapacity = jointCapacity;
			this.m_bodyCount = 0;
			this.m_contactCount = 0;
			this.m_jointCount = 0;
			this.m_allocator = allocator;
			this.m_listener = listener;
			this.m_contactSolver = contactSolver;
			for (i = this.m_bodies.length;
				 i < bodyCapacity; i++)
				this.m_bodies[i] = null;
			for (i = this.m_contacts.length;
				 i < contactCapacity; i++)
				this.m_contacts[i] = null;
			for (i = this.m_joints.length;
				 i < jointCapacity; i++)
				this.m_joints[i] = null;
		}
		b2Island.prototype.Clear = function () {
			this.m_bodyCount = 0;
			this.m_contactCount = 0;
			this.m_jointCount = 0;
		}
		b2Island.prototype.Solve = function (step, gravity, allowSleep) {
			var i = 0;
			var j = 0;
			var b;
			var joint;
			var gravityX = gravity.x;
			var gravityY = gravity.y;
			
			for (i = 0;
				 i < this.m_bodyCount; ++i) {
				b = this.m_bodies[i];
				if (b.GetType() != b2Body.b2_dynamicBody) continue;
				if (b.m_nonGravitic) {
					// Don't apply gravity to this body
					b.m_linearVelocity.x += step.dt * (b.m_invMass * b.m_force.x);
					b.m_linearVelocity.y += step.dt * (b.m_invMass * b.m_force.y);
				} else {
					// Apply gravity to this body
					b.m_linearVelocity.x += step.dt * (gravityX + b.m_invMass * b.m_force.x);
					b.m_linearVelocity.y += step.dt * (gravityY + b.m_invMass * b.m_force.y);
				}
				b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
				b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
				b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
			}
			this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
			var contactSolver = this.m_contactSolver;
			contactSolver.InitVelocityConstraints(step);
			for (i = 0;
				 i < this.m_jointCount; ++i) {
				joint = this.m_joints[i];
				joint.InitVelocityConstraints(step);
			}
			for (i = 0;
				 i < step.velocityIterations; ++i) {
				for (j = 0;
					 j < this.m_jointCount; ++j) {
					joint = this.m_joints[j];
					joint.SolveVelocityConstraints(step);
				}
				contactSolver.SolveVelocityConstraints();
			}
			for (i = 0;
				 i < this.m_jointCount; ++i) {
				joint = this.m_joints[i];
				joint.FinalizeVelocityConstraints();
			}
			contactSolver.FinalizeVelocityConstraints();
			for (i = 0;
				 i < this.m_bodyCount; ++i) {
				b = this.m_bodies[i];
				if (b.GetType() == b2Body.b2_staticBody) continue;
				var translationX = step.dt * b.m_linearVelocity.x;
				var translationY = step.dt * b.m_linearVelocity.y;
				if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
					b.m_linearVelocity.Normalize();
					b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
					b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
				}
				var rotation = step.dt * b.m_angularVelocity;
				if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
					if (b.m_angularVelocity < 0.0) {
						b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
					}
					else {
						b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
					}
				}
				b.m_sweep.c0.SetV(b.m_sweep.c);
				b.m_sweep.a0 = b.m_sweep.a;
				b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
				b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
				b.m_sweep.a += step.dt * b.m_angularVelocity;
				b.SynchronizeTransform();
			}
			for (i = 0;
				 i < step.positionIterations; ++i) {
				var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
				var jointsOkay = true;
				for (j = 0;
					 j < this.m_jointCount; ++j) {
					joint = this.m_joints[j];
					var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
					jointsOkay = jointsOkay && jointOkay;
				}
				if (contactsOkay && jointsOkay) {
					break;
				}
			}
			this.Report(contactSolver.m_constraints);
			if (allowSleep) {
				var minSleepTime = Number.MAX_VALUE;
				var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
				var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
				for (i = 0;
					 i < this.m_bodyCount; ++i) {
					b = this.m_bodies[i];
					if (b.GetType() == b2Body.b2_staticBody) {
						continue;
					}
					if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
						b.m_sleepTime = 0.0;
						minSleepTime = 0.0;
					}
					if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
						b.m_sleepTime = 0.0;
						minSleepTime = 0.0;
					}
					else {
						b.m_sleepTime += step.dt;
						minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
					}
				}
				if (minSleepTime >= b2Settings.b2_timeToSleep) {
					for (i = 0;
						 i < this.m_bodyCount; ++i) {
						b = this.m_bodies[i];
						b.SetAwake(false);
					}
				}
			}
		}
		b2Island.prototype.SolveTOI = function (subStep) {
			var i = 0;
			var j = 0;
			this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
			var contactSolver = this.m_contactSolver;
			for (i = 0;
				 i < this.m_jointCount; ++i) {
				this.m_joints[i].InitVelocityConstraints(subStep);
			}
			for (i = 0;
				 i < subStep.velocityIterations; ++i) {
				contactSolver.SolveVelocityConstraints();
				for (j = 0;
					 j < this.m_jointCount; ++j) {
					this.m_joints[j].SolveVelocityConstraints(subStep);
				}
			}
			for (i = 0;
				 i < this.m_bodyCount; ++i) {
				var b = this.m_bodies[i];
				if (b.GetType() == b2Body.b2_staticBody) continue;
				var translationX = subStep.dt * b.m_linearVelocity.x;
				var translationY = subStep.dt * b.m_linearVelocity.y;
				if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
					b.m_linearVelocity.Normalize();
					b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
					b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
				}
				var rotation = subStep.dt * b.m_angularVelocity;
				if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
					if (b.m_angularVelocity < 0.0) {
						b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
					}
					else {
						b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
					}
				}
				b.m_sweep.c0.SetV(b.m_sweep.c);
				b.m_sweep.a0 = b.m_sweep.a;
				b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
				b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
				b.m_sweep.a += subStep.dt * b.m_angularVelocity;
				b.SynchronizeTransform();
			}
			var k_toiBaumgarte = 0.75;
			for (i = 0;
				 i < subStep.positionIterations; ++i) {
				var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
				var jointsOkay = true;
				for (j = 0;
					 j < this.m_jointCount; ++j) {
					var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
					jointsOkay = jointsOkay && jointOkay;
				}
				if (contactsOkay && jointsOkay) {
					break;
				}
			}
			this.Report(contactSolver.m_constraints);
		}
		b2Island.prototype.Report = function (constraints) {
			if (this.m_listener == null) {
				return;
			}
			for (var i = 0; i < this.m_contactCount; ++i) {
				var c = this.m_contacts[i];
				var cc = constraints[i];
				for (var j = 0; j < cc.pointCount; ++j) {
					b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
					b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
				}
				this.m_listener.PostSolve(c, b2Island.s_impulse);
			}
		}
		b2Island.prototype.AddBody = function (body) {
			body.m_islandIndex = this.m_bodyCount;
			this.m_bodies[this.m_bodyCount++] = body;
		}
		b2Island.prototype.AddContact = function (contact) {
			this.m_contacts[this.m_contactCount++] = contact;
		}
		b2Island.prototype.AddJoint = function (joint) {
			this.m_joints[this.m_jointCount++] = joint;
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
		});
		b2TimeStep.b2TimeStep = function () {
		};
		b2TimeStep.prototype.Set = function (step) {
			this.dt = step.dt;
			this.inv_dt = step.inv_dt;
			this.positionIterations = step.positionIterations;
			this.velocityIterations = step.velocityIterations;
			this.warmStarting = step.warmStarting;
		}
		b2World.b2World = function () {
			this.s_stack = new Vector();
			this.m_contactManager = new b2ContactManager();
			this.m_contactSolver = new b2ContactSolver();
			this.m_island = new b2Island();
		};
		b2World.prototype.b2World = function (gravity, doSleep) {
			this.m_destructionListener = null;
			this.m_debugDraw = null;
			this.m_bodyList = null;
			this.m_contactList = null;
			this.m_jointList = null;
			this.m_controllerList = null;
			this.m_bodyCount = 0;
			this.m_contactCount = 0;
			this.m_jointCount = 0;
			this.m_controllerCount = 0;
			b2World.m_warmStarting = true;
			b2World.m_continuousPhysics = true;
			this.m_allowSleep = doSleep;
			this.m_gravity = gravity;
			this.m_inv_dt0 = 0.0;
			this.m_contactManager.m_world = this;
			var bd = new b2BodyDef();
			this.m_groundBody = this.CreateBody(bd);
		}
		b2World.prototype.SetDestructionListener = function (listener) {
			this.m_destructionListener = listener;
		}
		b2World.prototype.SetContactFilter = function (filter) {
			this.m_contactManager.m_contactFilter = filter;
		}
		b2World.prototype.SetContactListener = function (listener) {
			this.m_contactManager.m_contactListener = listener;
		}
		b2World.prototype.SetDebugDraw = function (debugDraw) {
			this.m_debugDraw = debugDraw;
		}
		b2World.prototype.SetBroadPhase = function (broadPhase) {
			var oldBroadPhase = this.m_contactManager.m_broadPhase;
			this.m_contactManager.m_broadPhase = broadPhase;
			for (var b = this.m_bodyList; b; b = b.m_next) {
				for (var f = b.m_fixtureList; f; f = f.m_next) {
					f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
				}
			}
		}
		b2World.prototype.Validate = function () {
			this.m_contactManager.m_broadPhase.Validate();
		}
		b2World.prototype.GetProxyCount = function () {
			return this.m_contactManager.m_broadPhase.GetProxyCount();
		}
		b2World.prototype.CreateBody = function (def) {
			if (this.IsLocked() == true) {
				return null;
			}
			var b = new b2Body(def, this);
			b.m_prev = null;
			b.m_next = this.m_bodyList;
			if (this.m_bodyList) {
				this.m_bodyList.m_prev = b;
			}
			this.m_bodyList = b;
			++this.m_bodyCount;
			return b;
		}
		b2World.prototype.DestroyBody = function (b) {
			if (this.IsLocked() == true) {
				return;
			}
			var jn = b.m_jointList;
			while (jn) {
				var jn0 = jn;
				jn = jn.next;
				if (this.m_destructionListener) {
					this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
				}
				this.DestroyJoint(jn0.joint);
			}
			var coe = b.m_controllerList;
			while (coe) {
				var coe0 = coe;
				coe = coe.nextController;
				coe0.controller.RemoveBody(b);
			}
			var ce = b.m_contactList;
			while (ce) {
				var ce0 = ce;
				ce = ce.next;
				this.m_contactManager.Destroy(ce0.contact);
			}
			b.m_contactList = null;
			var f = b.m_fixtureList;
			while (f) {
				var f0 = f;
				f = f.m_next;
				if (this.m_destructionListener) {
					this.m_destructionListener.SayGoodbyeFixture(f0);
				}
				f0.DestroyProxy(this.m_contactManager.m_broadPhase);
				f0.Destroy();
			}
			b.m_fixtureList = null;
			b.m_fixtureCount = 0;
			if (b.m_prev) {
				b.m_prev.m_next = b.m_next;
			}
			if (b.m_next) {
				b.m_next.m_prev = b.m_prev;
			}
			if (b == this.m_bodyList) {
				this.m_bodyList = b.m_next;
			}
			--this.m_bodyCount;
		}
		b2World.prototype.CreateJoint = function (def) {
			var j = b2Joint.Create(def, null);
			j.m_prev = null;
			j.m_next = this.m_jointList;
			if (this.m_jointList) {
				this.m_jointList.m_prev = j;
			}
			this.m_jointList = j;
			++this.m_jointCount;
			j.m_edgeA.joint = j;
			j.m_edgeA.other = j.m_bodyB;
			j.m_edgeA.prev = null;
			j.m_edgeA.next = j.m_bodyA.m_jointList;
			if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
			j.m_bodyA.m_jointList = j.m_edgeA;
			j.m_edgeB.joint = j;
			j.m_edgeB.other = j.m_bodyA;
			j.m_edgeB.prev = null;
			j.m_edgeB.next = j.m_bodyB.m_jointList;
			if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
			j.m_bodyB.m_jointList = j.m_edgeB;
			var bodyA = def.bodyA;
			var bodyB = def.bodyB;
			if (def.collideConnected == false) {
				var edge = bodyB.GetContactList();
				while (edge) {
					if (edge.other == bodyA) {
						edge.contact.FlagForFiltering();
					}
					edge = edge.next;
				}
			}
			return j;
		}
		b2World.prototype.DestroyJoint = function (j) {
			var collideConnected = j.m_collideConnected;
			if (j.m_prev) {
				j.m_prev.m_next = j.m_next;
			}
			if (j.m_next) {
				j.m_next.m_prev = j.m_prev;
			}
			if (j == this.m_jointList) {
				this.m_jointList = j.m_next;
			}
			var bodyA = j.m_bodyA;
			var bodyB = j.m_bodyB;
			bodyA.SetAwake(true);
			bodyB.SetAwake(true);
			if (j.m_edgeA.prev) {
				j.m_edgeA.prev.next = j.m_edgeA.next;
			}
			if (j.m_edgeA.next) {
				j.m_edgeA.next.prev = j.m_edgeA.prev;
			}
			if (j.m_edgeA == bodyA.m_jointList) {
				bodyA.m_jointList = j.m_edgeA.next;
			}
			j.m_edgeA.prev = null;
			j.m_edgeA.next = null;
			if (j.m_edgeB.prev) {
				j.m_edgeB.prev.next = j.m_edgeB.next;
			}
			if (j.m_edgeB.next) {
				j.m_edgeB.next.prev = j.m_edgeB.prev;
			}
			if (j.m_edgeB == bodyB.m_jointList) {
				bodyB.m_jointList = j.m_edgeB.next;
			}
			j.m_edgeB.prev = null;
			j.m_edgeB.next = null;
			b2Joint.Destroy(j, null);
			--this.m_jointCount;
			if (collideConnected == false) {
				var edge = bodyB.GetContactList();
				while (edge) {
					if (edge.other == bodyA) {
						edge.contact.FlagForFiltering();
					}
					edge = edge.next;
				}
			}
		}
		b2World.prototype.AddController = function (c) {
			c.m_next = this.m_controllerList;
			c.m_prev = null;
			this.m_controllerList = c;
			c.m_world = this;
			this.m_controllerCount++;
			return c;
		}
		b2World.prototype.RemoveController = function (c) {
			if (c.m_prev) c.m_prev.m_next = c.m_next;
			if (c.m_next) c.m_next.m_prev = c.m_prev;
			if (this.m_controllerList == c) this.m_controllerList = c.m_next;
			this.m_controllerCount--;
		}
		b2World.prototype.CreateController = function (controller) {
			if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
			controller.m_next = this.m_controllerList;
			controller.m_prev = null;
			if (this.m_controllerList) this.m_controllerList.m_prev = controller;
			this.m_controllerList = controller;
			++this.m_controllerCount;
			controller.m_world = this;
			return controller;
		}
		b2World.prototype.DestroyController = function (controller) {
			controller.Clear();
			if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
			if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
			if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
			--this.m_controllerCount;
		}
		b2World.prototype.SetWarmStarting = function (flag) {
			b2World.m_warmStarting = flag;
		}
		b2World.prototype.SetContinuousPhysics = function (flag) {
			b2World.m_continuousPhysics = flag;
		}
		b2World.prototype.GetBodyCount = function () {
			return this.m_bodyCount;
		}
		b2World.prototype.GetJointCount = function () {
			return this.m_jointCount;
		}
		b2World.prototype.GetContactCount = function () {
			return this.m_contactCount;
		}
		b2World.prototype.SetGravity = function (gravity) {
			this.m_gravity = gravity;
		}
		b2World.prototype.GetGravity = function () {
			return this.m_gravity;
		}
		b2World.prototype.GetGroundBody = function () {
			return this.m_groundBody;
		}
		b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
			if (dt === undefined) dt = 0;
			if (velocityIterations === undefined) velocityIterations = 0;
			if (positionIterations === undefined) positionIterations = 0;
			if (this.m_flags & b2World.e_newFixture) {
				this.m_contactManager.FindNewContacts();
				this.m_flags &= ~b2World.e_newFixture;
			}
			this.m_flags |= b2World.e_locked;
			var step = b2World.s_timestep2;
			step.dt = dt;
			step.velocityIterations = velocityIterations;
			step.positionIterations = positionIterations;
			if (dt > 0.0) {
				step.inv_dt = 1.0 / dt;
			}
			else {
				step.inv_dt = 0.0;
			}
			step.dtRatio = this.m_inv_dt0 * dt;
			step.warmStarting = b2World.m_warmStarting;
			this.m_contactManager.Collide();
			if (step.dt > 0.0) {
				this.Solve(step);
			}
			if (b2World.m_continuousPhysics && step.dt > 0.0) {
				this.SolveTOI(step);
			}
			if (step.dt > 0.0) {
				this.m_inv_dt0 = step.inv_dt;
			}
			this.m_flags &= ~b2World.e_locked;
		}
		b2World.prototype.ClearForces = function () {
			for (var body = this.m_bodyList; body; body = body.m_next) {
				body.m_force.SetZero();
				body.m_torque = 0.0;
			}
		}
		b2World.prototype.DrawDebugData = function () {
			if (this.m_debugDraw == null) {
				return;
			}
			this.m_debugDraw.m_sprite.graphics.clear();
			var flags = this.m_debugDraw.GetFlags();
			var i = 0;
			var b;
			var f;
			var s;
			var j;
			var bp;
			var invQ = new b2Vec2;
			var x1 = new b2Vec2;
			var x2 = new b2Vec2;
			var xf;
			var b1 = new b2AABB();
			var b2 = new b2AABB();
			var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
			var color = new b2Color(0, 0, 0);
			if (flags & b2DebugDraw.e_shapeBit) {
				for (b = this.m_bodyList;
					 b; b = b.m_next) {
					// This is different from the original in that we check
					// if the box2dNoDebug has been set first before drawing
					// a debug shape for this body
					if (!b._entity || !b._entity._box2dNoDebug) {
						xf = b.m_xf;
						for (f = b.GetFixtureList();
							 f; f = f.m_next) {
							s = f.GetShape();
							if (b.IsActive() == false) {
								color.Set(0.5, 0.5, 0.3);
								this.DrawShape(s, xf, color);
							}
							else if (b.GetType() == b2Body.b2_staticBody) {
								color.Set(0.5, 0.9, 0.5);
								this.DrawShape(s, xf, color);
							}
							else if (b.GetType() == b2Body.b2_kinematicBody) {
								color.Set(0.5, 0.5, 0.9);
								this.DrawShape(s, xf, color);
							}
							else if (b.IsAwake() == false) {
								color.Set(0.6, 0.6, 0.6);
								this.DrawShape(s, xf, color);
							}
							else {
								color.Set(0.9, 0.7, 0.7);
								this.DrawShape(s, xf, color);
							}
						}
					}
				}
			}
			if (flags & b2DebugDraw.e_jointBit) {
				for (j = this.m_jointList;
					 j; j = j.m_next) {
					this.DrawJoint(j);
				}
			}
			if (flags & b2DebugDraw.e_controllerBit) {
				for (var c = this.m_controllerList; c; c = c.m_next) {
					c.Draw(this.m_debugDraw);
				}
			}
			if (flags & b2DebugDraw.e_pairBit) {
				color.Set(0.3, 0.9, 0.9);
				for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
					var fixtureA = contact.GetFixtureA();
					var fixtureB = contact.GetFixtureB();
					var cA = fixtureA.GetAABB().GetCenter();
					var cB = fixtureB.GetAABB().GetCenter();
					this.m_debugDraw.DrawSegment(cA, cB, color);
				}
			}
			if (flags & b2DebugDraw.e_aabbBit) {
				bp = this.m_contactManager.m_broadPhase;
				vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
				for (b = this.m_bodyList;
					 b; b = b.GetNext()) {
					if (b.IsActive() == false) {
						continue;
					}
					for (f = b.GetFixtureList();
						 f; f = f.GetNext()) {
						var aabb = bp.GetFatAABB(f.m_proxy);
						vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
						vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
						vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
						vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
						this.m_debugDraw.DrawPolygon(vs, 4, color);
					}
				}
			}
			if (flags & b2DebugDraw.e_centerOfMassBit) {
				for (b = this.m_bodyList;
					 b; b = b.m_next) {
					xf = b2World.s_xf;
					xf.R = b.m_xf.R;
					xf.position = b.GetWorldCenter();
					this.m_debugDraw.DrawTransform(xf);
				}
			}
		}
		b2World.prototype.QueryAABB = function (callback, aabb) {
			var __this = this;
			var broadPhase = __this.m_contactManager.m_broadPhase;
			
			function WorldQueryWrapper (proxy) {
				return callback(broadPhase.GetUserData(proxy));
			};
			broadPhase.Query(WorldQueryWrapper, aabb);
		}
		b2World.prototype.QueryShape = function (callback, shape, transform) {
			var __this = this;
			if (transform === undefined) transform = null;
			if (transform == null) {
				transform = new b2Transform();
				transform.SetIdentity();
			}
			var broadPhase = __this.m_contactManager.m_broadPhase;
			
			function WorldQueryWrapper (proxy) {
				var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
				if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
				return true;
			};
			var aabb = new b2AABB();
			shape.ComputeAABB(aabb, transform);
			broadPhase.Query(WorldQueryWrapper, aabb);
		}
		b2World.prototype.QueryPoint = function (callback, p) {
			var __this = this;
			var broadPhase = __this.m_contactManager.m_broadPhase;
			
			function WorldQueryWrapper (proxy) {
				var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
				if (fixture.TestPoint(p)) return callback(fixture);
				return true;
			};
			var aabb = new b2AABB();
			aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
			aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
			broadPhase.Query(WorldQueryWrapper, aabb);
		}
		b2World.prototype.RayCast = function (callback, point1, point2) {
			var __this = this;
			var broadPhase = __this.m_contactManager.m_broadPhase;
			var output = new b2RayCastOutput;
			
			function RayCastWrapper (input, proxy) {
				var userData = broadPhase.GetUserData(proxy);
				var fixture = (userData instanceof b2Fixture ? userData : null);
				var hit = fixture.RayCast(output, input);
				if (hit) {
					var fraction = output.fraction;
					var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
					return callback(fixture, point, output.normal, fraction);
				}
				return input.maxFraction;
			};
			var input = new b2RayCastInput(point1, point2);
			broadPhase.RayCast(RayCastWrapper, input);
		}
		b2World.prototype.RayCastOne = function (point1, point2) {
			var __this = this;
			var result;
			
			function RayCastOneWrapper (fixture, point, normal, fraction) {
				if (fraction === undefined) fraction = 0;
				result = fixture;
				return fraction;
			};
			__this.RayCast(RayCastOneWrapper, point1, point2);
			return result;
		}
		b2World.prototype.RayCastAll = function (point1, point2) {
			var __this = this;
			var result = new Vector();
			
			function RayCastAllWrapper (fixture, point, normal, fraction) {
				if (fraction === undefined) fraction = 0;
				result[result.length] = fixture;
				return 1;
			};
			__this.RayCast(RayCastAllWrapper, point1, point2);
			return result;
		}
		b2World.prototype.GetBodyList = function () {
			return this.m_bodyList;
		}
		b2World.prototype.GetJointList = function () {
			return this.m_jointList;
		}
		b2World.prototype.GetContactList = function () {
			return this.m_contactList;
		}
		b2World.prototype.IsLocked = function () {
			return (this.m_flags & b2World.e_locked) > 0;
		}
		b2World.prototype.Solve = function (step) {
			var b;
			for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
				controller.Step(step);
			}
			var island = this.m_island;
			island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
			for (b = this.m_bodyList;
				 b; b = b.m_next) {
				b.m_flags &= ~b2Body.e_islandFlag;
			}
			for (var c = this.m_contactList; c; c = c.m_next) {
				c.m_flags &= ~b2Contact.e_islandFlag;
			}
			for (var j = this.m_jointList; j; j = j.m_next) {
				j.m_islandFlag = false;
			}
			var stackSize = parseInt(this.m_bodyCount);
			var stack = this.s_stack;
			for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
				if (seed.m_flags & b2Body.e_islandFlag) {
					continue;
				}
				if (seed.IsAwake() == false || seed.IsActive() == false) {
					continue;
				}
				if (seed.GetType() == b2Body.b2_staticBody) {
					continue;
				}
				island.Clear();
				var stackCount = 0;
				stack[stackCount++] = seed;
				seed.m_flags |= b2Body.e_islandFlag;
				while (stackCount > 0) {
					b = stack[--stackCount];
					island.AddBody(b);
					if (b.IsAwake() == false) {
						b.SetAwake(true);
					}
					if (b.GetType() == b2Body.b2_staticBody) {
						continue;
					}
					var other;
					for (var ce = b.m_contactList; ce; ce = ce.next) {
						if (ce.contact.m_flags & b2Contact.e_islandFlag) {
							continue;
						}
						if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
							continue;
						}
						island.AddContact(ce.contact);
						ce.contact.m_flags |= b2Contact.e_islandFlag;
						other = ce.other;
						if (other.m_flags & b2Body.e_islandFlag) {
							continue;
						}
						stack[stackCount++] = other;
						other.m_flags |= b2Body.e_islandFlag;
					}
					for (var jn = b.m_jointList; jn; jn = jn.next) {
						if (jn.joint.m_islandFlag == true) {
							continue;
						}
						other = jn.other;
						if (other.IsActive() == false) {
							continue;
						}
						island.AddJoint(jn.joint);
						jn.joint.m_islandFlag = true;
						if (other.m_flags & b2Body.e_islandFlag) {
							continue;
						}
						stack[stackCount++] = other;
						other.m_flags |= b2Body.e_islandFlag;
					}
				}
				island.Solve(step, this.m_gravity, this.m_allowSleep);
				for (var i = 0; i < island.m_bodyCount; ++i) {
					b = island.m_bodies[i];
					if (b.GetType() == b2Body.b2_staticBody) {
						b.m_flags &= ~b2Body.e_islandFlag;
					}
				}
			}
			for (i = 0;
				 i < stack.length; ++i) {
				if (!stack[i]) break;
				stack[i] = null;
			}
			for (b = this.m_bodyList;
				 b; b = b.m_next) {
				if (b.IsAwake() == false || b.IsActive() == false) {
					continue;
				}
				if (b.GetType() == b2Body.b2_staticBody) {
					continue;
				}
				b.SynchronizeFixtures();
			}
			this.m_contactManager.FindNewContacts();
		}
		b2World.prototype.SolveTOI = function (step) {
			var b;
			var fA;
			var fB;
			var bA;
			var bB;
			var cEdge;
			var j;
			var island = this.m_island;
			island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
			var queue = b2World.s_queue;
			for (b = this.m_bodyList;
				 b; b = b.m_next) {
				b.m_flags &= ~b2Body.e_islandFlag;
				b.m_sweep.t0 = 0.0;
			}
			var c;
			for (c = this.m_contactList;
				 c; c = c.m_next) {
				c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
			}
			for (j = this.m_jointList;
				 j; j = j.m_next) {
				j.m_islandFlag = false;
			}
			for (; ;) {
				var minContact = null;
				var minTOI = 1.0;
				for (c = this.m_contactList;
					 c; c = c.m_next) {
					if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
						continue;
					}
					var toi = 1.0;
					if (c.m_flags & b2Contact.e_toiFlag) {
						toi = c.m_toi;
					}
					else {
						fA = c.m_fixtureA;
						fB = c.m_fixtureB;
						bA = fA.m_body;
						bB = fB.m_body;
						if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
							continue;
						}
						var t0 = bA.m_sweep.t0;
						if (bA.m_sweep.t0 < bB.m_sweep.t0) {
							t0 = bB.m_sweep.t0;
							bA.m_sweep.Advance(t0);
						}
						else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
							t0 = bA.m_sweep.t0;
							bB.m_sweep.Advance(t0);
						}
						toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
						b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
						if (toi > 0.0 && toi < 1.0) {
							toi = (1.0 - toi) * t0 + toi;
							if (toi > 1) toi = 1;
						}
						c.m_toi = toi;
						c.m_flags |= b2Contact.e_toiFlag;
					}
					if (Number.MIN_VALUE < toi && toi < minTOI) {
						minContact = c;
						minTOI = toi;
					}
				}
				if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
					break;
				}
				fA = minContact.m_fixtureA;
				fB = minContact.m_fixtureB;
				bA = fA.m_body;
				bB = fB.m_body;
				b2World.s_backupA.Set(bA.m_sweep);
				b2World.s_backupB.Set(bB.m_sweep);
				bA.Advance(minTOI);
				bB.Advance(minTOI);
				minContact.Update(this.m_contactManager.m_contactListener);
				minContact.m_flags &= ~b2Contact.e_toiFlag;
				if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
					bA.m_sweep.Set(b2World.s_backupA);
					bB.m_sweep.Set(b2World.s_backupB);
					bA.SynchronizeTransform();
					bB.SynchronizeTransform();
					continue;
				}
				if (minContact.IsTouching() == false) {
					continue;
				}
				var seed = bA;
				if (seed.GetType() != b2Body.b2_dynamicBody) {
					seed = bB;
				}
				island.Clear();
				var queueStart = 0;
				var queueSize = 0;
				queue[queueStart + queueSize++] = seed;
				seed.m_flags |= b2Body.e_islandFlag;
				while (queueSize > 0) {
					b = queue[queueStart++];
					--queueSize;
					island.AddBody(b);
					if (b.IsAwake() == false) {
						b.SetAwake(true);
					}
					if (b.GetType() != b2Body.b2_dynamicBody) {
						continue;
					}
					for (cEdge = b.m_contactList;
						 cEdge; cEdge = cEdge.next) {
						if (island.m_contactCount == island.m_contactCapacity) {
							break;
						}
						if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
							continue;
						}
						if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
							continue;
						}
						island.AddContact(cEdge.contact);
						cEdge.contact.m_flags |= b2Contact.e_islandFlag;
						var other = cEdge.other;
						if (other.m_flags & b2Body.e_islandFlag) {
							continue;
						}
						if (other.GetType() != b2Body.b2_staticBody) {
							other.Advance(minTOI);
							other.SetAwake(true);
						}
						queue[queueStart + queueSize] = other;
						++queueSize;
						other.m_flags |= b2Body.e_islandFlag;
					}
					for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
						if (island.m_jointCount == island.m_jointCapacity) continue;
						if (jEdge.joint.m_islandFlag == true) continue;
						other = jEdge.other;
						if (other.IsActive() == false) {
							continue;
						}
						island.AddJoint(jEdge.joint);
						jEdge.joint.m_islandFlag = true;
						if (other.m_flags & b2Body.e_islandFlag) continue;
						if (other.GetType() != b2Body.b2_staticBody) {
							other.Advance(minTOI);
							other.SetAwake(true);
						}
						queue[queueStart + queueSize] = other;
						++queueSize;
						other.m_flags |= b2Body.e_islandFlag;
					}
				}
				var subStep = b2World.s_timestep;
				subStep.warmStarting = false;
				subStep.dt = (1.0 - minTOI) * step.dt;
				subStep.inv_dt = 1.0 / subStep.dt;
				subStep.dtRatio = 0.0;
				subStep.velocityIterations = step.velocityIterations;
				subStep.positionIterations = step.positionIterations;
				island.SolveTOI(subStep);
				var i = 0;
				for (i = 0;
					 i < island.m_bodyCount; ++i) {
					b = island.m_bodies[i];
					b.m_flags &= ~b2Body.e_islandFlag;
					if (b.IsAwake() == false) {
						continue;
					}
					if (b.GetType() != b2Body.b2_dynamicBody) {
						continue;
					}
					b.SynchronizeFixtures();
					for (cEdge = b.m_contactList;
						 cEdge; cEdge = cEdge.next) {
						cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
					}
				}
				for (i = 0;
					 i < island.m_contactCount; ++i) {
					c = island.m_contacts[i];
					c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
				}
				for (i = 0;
					 i < island.m_jointCount; ++i) {
					j = island.m_joints[i];
					j.m_islandFlag = false;
				}
				this.m_contactManager.FindNewContacts();
			}
		}
		b2World.prototype.DrawJoint = function (joint) {
			var b1 = joint.GetBodyA();
			var b2 = joint.GetBodyB();
			var xf1 = b1.m_xf;
			var xf2 = b2.m_xf;
			var x1 = xf1.position;
			var x2 = xf2.position;
			var p1 = joint.GetAnchorA();
			var p2 = joint.GetAnchorB();
			var color = b2World.s_jointColor;
			switch (joint.m_type) {
				case b2Joint.e_distanceJoint:
					this.m_debugDraw.DrawSegment(p1, p2, color);
					break;
				case b2Joint.e_pulleyJoint: {
					var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
					var s1 = pulley.GetGroundAnchorA();
					var s2 = pulley.GetGroundAnchorB();
					this.m_debugDraw.DrawSegment(s1, p1, color);
					this.m_debugDraw.DrawSegment(s2, p2, color);
					this.m_debugDraw.DrawSegment(s1, s2, color);
				}
					break;
				case b2Joint.e_mouseJoint:
					this.m_debugDraw.DrawSegment(p1, p2, color);
					break;
				default:
					if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
					this.m_debugDraw.DrawSegment(p1, p2, color);
					if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
			}
		}
		b2World.prototype.DrawShape = function (shape, xf, color) {
			switch (shape.m_type) {
				case b2Shape.e_circleShape: {
					var circle = ((shape instanceof b2CircleShape ? shape : null));
					var center = b2Math.MulX(xf, circle.m_p);
					var radius = circle.m_radius;
					var axis = xf.R.col1;
					this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
				}
					break;
				case b2Shape.e_polygonShape: {
					var i = 0;
					var poly = ((shape instanceof b2PolygonShape ? shape : null));
					var vertexCount = parseInt(poly.GetVertexCount());
					var localVertices = poly.GetVertices();
					var vertices = new Vector(vertexCount);
					for (i = 0;
						 i < vertexCount; ++i) {
						vertices[i] = b2Math.MulX(xf, localVertices[i]);
					}
					this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
				}
					break;
				case b2Shape.e_edgeShape: {
					var edge = (shape instanceof b2EdgeShape ? shape : null);
					this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
				}
					break;
			}
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
			Box2D.Dynamics.b2World.s_xf = new b2Transform();
			Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
			Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
			Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
			Box2D.Dynamics.b2World.s_queue = new Vector();
			Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
			Box2D.Dynamics.b2World.e_newFixture = 0x0001;
			Box2D.Dynamics.b2World.e_locked = 0x0002;
		});
	})();
	(function () {
		var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
			b2Contact = Box2D.Dynamics.Contacts.b2Contact,
			b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
			b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
			b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
			b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
			b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
			b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
			b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
			b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
			b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
			b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
			b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
			b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
			b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
			b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2AABB = Box2D.Collision.b2AABB,
			b2Bound = Box2D.Collision.b2Bound,
			b2BoundValues = Box2D.Collision.b2BoundValues,
			b2Collision = Box2D.Collision.b2Collision,
			b2ContactID = Box2D.Collision.b2ContactID,
			b2ContactPoint = Box2D.Collision.b2ContactPoint,
			b2Distance = Box2D.Collision.b2Distance,
			b2DistanceInput = Box2D.Collision.b2DistanceInput,
			b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
			b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
			b2DynamicTree = Box2D.Collision.b2DynamicTree,
			b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
			b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
			b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
			b2Manifold = Box2D.Collision.b2Manifold,
			b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
			b2Point = Box2D.Collision.b2Point,
			b2RayCastInput = Box2D.Collision.b2RayCastInput,
			b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
			b2Segment = Box2D.Collision.b2Segment,
			b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
			b2Simplex = Box2D.Collision.b2Simplex,
			b2SimplexCache = Box2D.Collision.b2SimplexCache,
			b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
			b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
			b2TOIInput = Box2D.Collision.b2TOIInput,
			b2WorldManifold = Box2D.Collision.b2WorldManifold,
			ClipVertex = Box2D.Collision.ClipVertex,
			Features = Box2D.Collision.Features,
			IBroadPhase = Box2D.Collision.IBroadPhase;
		
		Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
		b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2CircleContact.b2CircleContact = function () {
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2CircleContact.Create = function (allocator) {
			return new b2CircleContact();
		}
		b2CircleContact.Destroy = function (contact, allocator) {
		}
		b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
			this.__super.Reset.call(this, fixtureA, fixtureB);
		}
		b2CircleContact.prototype.Evaluate = function () {
			var bA = this.m_fixtureA.GetBody();
			var bB = this.m_fixtureB.GetBody();
			b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		b2Contact.b2Contact = function () {
			this.m_nodeA = new b2ContactEdge();
			this.m_nodeB = new b2ContactEdge();
			this.m_manifold = new b2Manifold();
			this.m_oldManifold = new b2Manifold();
		};
		b2Contact.prototype.GetManifold = function () {
			return this.m_manifold;
		}
		b2Contact.prototype.GetWorldManifold = function (worldManifold) {
			var bodyA = this.m_fixtureA.GetBody();
			var bodyB = this.m_fixtureB.GetBody();
			var shapeA = this.m_fixtureA.GetShape();
			var shapeB = this.m_fixtureB.GetShape();
			worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
		}
		b2Contact.prototype.IsTouching = function () {
			return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
		}
		b2Contact.prototype.IsContinuous = function () {
			return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
		}
		b2Contact.prototype.SetSensor = function (sensor) {
			if (sensor) {
				this.m_flags |= b2Contact.e_sensorFlag;
			}
			else {
				this.m_flags &= ~b2Contact.e_sensorFlag;
			}
		}
		b2Contact.prototype.IsSensor = function () {
			return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
		}
		b2Contact.prototype.SetEnabled = function (flag) {
			if (flag) {
				this.m_flags |= b2Contact.e_enabledFlag;
			}
			else {
				this.m_flags &= ~b2Contact.e_enabledFlag;
			}
		}
		b2Contact.prototype.IsEnabled = function () {
			return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
		}
		b2Contact.prototype.GetNext = function () {
			return this.m_next;
		}
		b2Contact.prototype.GetFixtureA = function () {
			return this.m_fixtureA;
		}
		b2Contact.prototype.GetFixtureB = function () {
			return this.m_fixtureB;
		}
		b2Contact.prototype.FlagForFiltering = function () {
			this.m_flags |= b2Contact.e_filterFlag;
		}
		b2Contact.prototype.b2Contact = function () {
		}
		b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
			if (fixtureA === undefined) fixtureA = null;
			if (fixtureB === undefined) fixtureB = null;
			this.m_flags = b2Contact.e_enabledFlag;
			if (!fixtureA || !fixtureB) {
				this.m_fixtureA = null;
				this.m_fixtureB = null;
				return;
			}
			if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
				this.m_flags |= b2Contact.e_sensorFlag;
			}
			var bodyA = fixtureA.GetBody();
			var bodyB = fixtureB.GetBody();
			if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
				this.m_flags |= b2Contact.e_continuousFlag;
			}
			this.m_fixtureA = fixtureA;
			this.m_fixtureB = fixtureB;
			this.m_manifold.m_pointCount = 0;
			this.m_prev = null;
			this.m_next = null;
			this.m_nodeA.contact = null;
			this.m_nodeA.prev = null;
			this.m_nodeA.next = null;
			this.m_nodeA.other = null;
			this.m_nodeB.contact = null;
			this.m_nodeB.prev = null;
			this.m_nodeB.next = null;
			this.m_nodeB.other = null;
		}
		b2Contact.prototype.Update = function (listener) {
			var tManifold = this.m_oldManifold;
			this.m_oldManifold = this.m_manifold;
			this.m_manifold = tManifold;
			this.m_flags |= b2Contact.e_enabledFlag;
			var touching = false;
			var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
			var bodyA = this.m_fixtureA.m_body;
			var bodyB = this.m_fixtureB.m_body;
			var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
			if (this.m_flags & b2Contact.e_sensorFlag) {
				if (aabbOverlap) {
					var shapeA = this.m_fixtureA.GetShape();
					var shapeB = this.m_fixtureB.GetShape();
					var xfA = bodyA.GetTransform();
					var xfB = bodyB.GetTransform();
					touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
				}
				this.m_manifold.m_pointCount = 0;
			}
			else {
				if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
					this.m_flags |= b2Contact.e_continuousFlag;
				}
				else {
					this.m_flags &= ~b2Contact.e_continuousFlag;
				}
				if (aabbOverlap) {
					this.Evaluate();
					touching = this.m_manifold.m_pointCount > 0;
					for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
						var mp2 = this.m_manifold.m_points[i];
						mp2.m_normalImpulse = 0.0;
						mp2.m_tangentImpulse = 0.0;
						var id2 = mp2.m_id;
						for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
							var mp1 = this.m_oldManifold.m_points[j];
							if (mp1.m_id.key == id2.key) {
								mp2.m_normalImpulse = mp1.m_normalImpulse;
								mp2.m_tangentImpulse = mp1.m_tangentImpulse;
								break;
							}
						}
					}
				}
				else {
					this.m_manifold.m_pointCount = 0;
				}
				if (touching != wasTouching) {
					bodyA.SetAwake(true);
					bodyB.SetAwake(true);
				}
			}
			if (touching) {
				this.m_flags |= b2Contact.e_touchingFlag;
			}
			else {
				this.m_flags &= ~b2Contact.e_touchingFlag;
			}
			if (wasTouching == false && touching == true) {
				listener.BeginContact(this);
			}
			if (wasTouching == true && touching == false) {
				listener.EndContact(this);
			}
			if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
				listener.PreSolve(this, this.m_oldManifold);
			}
		}
		b2Contact.prototype.Evaluate = function () {
		}
		b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
			b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
			b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
			b2Contact.s_input.sweepA = sweepA;
			b2Contact.s_input.sweepB = sweepB;
			b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
			return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
			Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
			Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
			Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
			Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
			Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
			Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
			Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
		});
		b2ContactConstraint.b2ContactConstraint = function () {
			this.localPlaneNormal = new b2Vec2();
			this.localPoint = new b2Vec2();
			this.normal = new b2Vec2();
			this.normalMass = new b2Mat22();
			this.K = new b2Mat22();
		};
		b2ContactConstraint.prototype.b2ContactConstraint = function () {
			this.points = new Vector(b2Settings.b2_maxManifoldPoints);
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
				this.points[i] = new b2ContactConstraintPoint();
			}
		}
		b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
			this.localPoint = new b2Vec2();
			this.rA = new b2Vec2();
			this.rB = new b2Vec2();
		};
		b2ContactEdge.b2ContactEdge = function () {
		};
		b2ContactFactory.b2ContactFactory = function () {
		};
		b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
			this.m_allocator = allocator;
			this.InitializeRegisters();
		}
		b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
			if (type1 === undefined) type1 = 0;
			if (type2 === undefined) type2 = 0;
			this.m_registers[type1][type2].createFcn = createFcn;
			this.m_registers[type1][type2].destroyFcn = destroyFcn;
			this.m_registers[type1][type2].primary = true;
			if (type1 != type2) {
				this.m_registers[type2][type1].createFcn = createFcn;
				this.m_registers[type2][type1].destroyFcn = destroyFcn;
				this.m_registers[type2][type1].primary = false;
			}
		}
		b2ContactFactory.prototype.InitializeRegisters = function () {
			this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
			for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
				this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
				for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
					this.m_registers[i][j] = new b2ContactRegister();
				}
			}
			this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
			this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
			this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
			this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
			this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
		}
		b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
			var type1 = parseInt(fixtureA.GetType());
			var type2 = parseInt(fixtureB.GetType());
			var reg = this.m_registers[type1][type2];
			var c;
			if (reg.pool) {
				c = reg.pool;
				reg.pool = c.m_next;
				reg.poolCount--;
				c.Reset(fixtureA, fixtureB);
				return c;
			}
			var createFcn = reg.createFcn;
			if (createFcn != null) {
				if (reg.primary) {
					c = createFcn(this.m_allocator);
					c.Reset(fixtureA, fixtureB);
					return c;
				}
				else {
					c = createFcn(this.m_allocator);
					c.Reset(fixtureB, fixtureA);
					return c;
				}
			}
			else {
				return null;
			}
		}
		b2ContactFactory.prototype.Destroy = function (contact) {
			if (contact.m_manifold.m_pointCount > 0) {
				contact.m_fixtureA.m_body.SetAwake(true);
				contact.m_fixtureB.m_body.SetAwake(true);
			}
			var type1 = parseInt(contact.m_fixtureA.GetType());
			var type2 = parseInt(contact.m_fixtureB.GetType());
			var reg = this.m_registers[type1][type2];
			if (true) {
				reg.poolCount++;
				contact.m_next = reg.pool;
				reg.pool = contact;
			}
			var destroyFcn = reg.destroyFcn;
			destroyFcn(contact, this.m_allocator);
		}
		b2ContactRegister.b2ContactRegister = function () {
		};
		b2ContactResult.b2ContactResult = function () {
			this.position = new b2Vec2();
			this.normal = new b2Vec2();
			this.id = new b2ContactID();
		};
		b2ContactSolver.b2ContactSolver = function () {
			this.m_step = new b2TimeStep();
			this.m_constraints = new Vector();
		};
		b2ContactSolver.prototype.b2ContactSolver = function () {
		}
		b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
			if (contactCount === undefined) contactCount = 0;
			var contact;
			this.m_step.Set(step);
			this.m_allocator = allocator;
			var i = 0;
			var tVec;
			var tMat;
			this.m_constraintCount = contactCount;
			while (this.m_constraints.length < this.m_constraintCount) {
				this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
			}
			for (i = 0;
				 i < contactCount; ++i) {
				contact = contacts[i];
				var fixtureA = contact.m_fixtureA;
				var fixtureB = contact.m_fixtureB;
				var shapeA = fixtureA.m_shape;
				var shapeB = fixtureB.m_shape;
				var radiusA = shapeA.m_radius;
				var radiusB = shapeB.m_radius;
				var bodyA = fixtureA.m_body;
				var bodyB = fixtureB.m_body;
				var manifold = contact.GetManifold();
				var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
				var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
				var vAX = bodyA.m_linearVelocity.x;
				var vAY = bodyA.m_linearVelocity.y;
				var vBX = bodyB.m_linearVelocity.x;
				var vBY = bodyB.m_linearVelocity.y;
				var wA = bodyA.m_angularVelocity;
				var wB = bodyB.m_angularVelocity;
				b2Settings.b2Assert(manifold.m_pointCount > 0);
				b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
				var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
				var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
				var cc = this.m_constraints[i];
				cc.bodyA = bodyA;
				cc.bodyB = bodyB;
				cc.manifold = manifold;
				cc.normal.x = normalX;
				cc.normal.y = normalY;
				cc.pointCount = manifold.m_pointCount;
				cc.friction = friction;
				cc.restitution = restitution;
				cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
				cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
				cc.localPoint.x = manifold.m_localPoint.x;
				cc.localPoint.y = manifold.m_localPoint.y;
				cc.radius = radiusA + radiusB;
				cc.type = manifold.m_type;
				for (var k = 0; k < cc.pointCount; ++k) {
					var cp = manifold.m_points[k];
					var ccp = cc.points[k];
					ccp.normalImpulse = cp.m_normalImpulse;
					ccp.tangentImpulse = cp.m_tangentImpulse;
					ccp.localPoint.SetV(cp.m_localPoint);
					var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
					var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
					var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
					var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
					var rnA = rAX * normalY - rAY * normalX;
					var rnB = rBX * normalY - rBY * normalX;
					rnA *= rnA;
					rnB *= rnB;
					var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
					ccp.normalMass = 1.0 / kNormal;
					var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
					kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
					ccp.equalizedMass = 1.0 / kEqualized;
					var tangentX = normalY;
					var tangentY = (-normalX);
					var rtA = rAX * tangentY - rAY * tangentX;
					var rtB = rBX * tangentY - rBY * tangentX;
					rtA *= rtA;
					rtB *= rtB;
					var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
					ccp.tangentMass = 1.0 / kTangent;
					ccp.velocityBias = 0.0;
					var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
					var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
					var vRel = cc.normal.x * tX + cc.normal.y * tY;
					if (vRel < (-b2Settings.b2_velocityThreshold)) {
						ccp.velocityBias += (-cc.restitution * vRel);
					}
				}
				if (cc.pointCount == 2) {
					var ccp1 = cc.points[0];
					var ccp2 = cc.points[1];
					var invMassA = bodyA.m_invMass;
					var invIA = bodyA.m_invI;
					var invMassB = bodyB.m_invMass;
					var invIB = bodyB.m_invI;
					var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
					var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
					var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
					var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
					var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
					var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
					var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
					var k_maxConditionNumber = 100.0;
					if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
						cc.K.col1.Set(k11, k12);
						cc.K.col2.Set(k12, k22);
						cc.K.GetInverse(cc.normalMass);
					}
					else {
						cc.pointCount = 1;
					}
				}
			}
		}
		b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
			var tVec;
			var tVec2;
			var tMat;
			for (var i = 0; i < this.m_constraintCount; ++i) {
				var c = this.m_constraints[i];
				var bodyA = c.bodyA;
				var bodyB = c.bodyB;
				var invMassA = bodyA.m_invMass;
				var invIA = bodyA.m_invI;
				var invMassB = bodyB.m_invMass;
				var invIB = bodyB.m_invI;
				var normalX = c.normal.x;
				var normalY = c.normal.y;
				var tangentX = normalY;
				var tangentY = (-normalX);
				var tX = 0;
				var j = 0;
				var tCount = 0;
				if (step.warmStarting) {
					tCount = c.pointCount;
					for (j = 0;
						 j < tCount; ++j) {
						var ccp = c.points[j];
						ccp.normalImpulse *= step.dtRatio;
						ccp.tangentImpulse *= step.dtRatio;
						var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
						var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
						bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
						bodyA.m_linearVelocity.x -= invMassA * PX;
						bodyA.m_linearVelocity.y -= invMassA * PY;
						bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
						bodyB.m_linearVelocity.x += invMassB * PX;
						bodyB.m_linearVelocity.y += invMassB * PY;
					}
				}
				else {
					tCount = c.pointCount;
					for (j = 0;
						 j < tCount; ++j) {
						var ccp2 = c.points[j];
						ccp2.normalImpulse = 0.0;
						ccp2.tangentImpulse = 0.0;
					}
				}
			}
		}
		b2ContactSolver.prototype.SolveVelocityConstraints = function () {
			var j = 0;
			var ccp;
			var rAX = 0;
			var rAY = 0;
			var rBX = 0;
			var rBY = 0;
			var dvX = 0;
			var dvY = 0;
			var vn = 0;
			var vt = 0;
			var lambda = 0;
			var maxFriction = 0;
			var newImpulse = 0;
			var PX = 0;
			var PY = 0;
			var dX = 0;
			var dY = 0;
			var P1X = 0;
			var P1Y = 0;
			var P2X = 0;
			var P2Y = 0;
			var tMat;
			var tVec;
			for (var i = 0; i < this.m_constraintCount; ++i) {
				var c = this.m_constraints[i];
				var bodyA = c.bodyA;
				var bodyB = c.bodyB;
				var wA = bodyA.m_angularVelocity;
				var wB = bodyB.m_angularVelocity;
				var vA = bodyA.m_linearVelocity;
				var vB = bodyB.m_linearVelocity;
				var invMassA = bodyA.m_invMass;
				var invIA = bodyA.m_invI;
				var invMassB = bodyB.m_invMass;
				var invIB = bodyB.m_invI;
				var normalX = c.normal.x;
				var normalY = c.normal.y;
				var tangentX = normalY;
				var tangentY = (-normalX);
				var friction = c.friction;
				var tX = 0;
				for (j = 0;
					 j < c.pointCount; j++) {
					ccp = c.points[j];
					dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
					dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
					vt = dvX * tangentX + dvY * tangentY;
					lambda = ccp.tangentMass * (-vt);
					maxFriction = friction * ccp.normalImpulse;
					newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
					lambda = newImpulse - ccp.tangentImpulse;
					PX = lambda * tangentX;
					PY = lambda * tangentY;
					vA.x -= invMassA * PX;
					vA.y -= invMassA * PY;
					wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
					vB.x += invMassB * PX;
					vB.y += invMassB * PY;
					wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
					ccp.tangentImpulse = newImpulse;
				}
				var tCount = parseInt(c.pointCount);
				if (c.pointCount == 1) {
					ccp = c.points[0];
					dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
					dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
					vn = dvX * normalX + dvY * normalY;
					lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
					newImpulse = ccp.normalImpulse + lambda;
					newImpulse = newImpulse > 0 ? newImpulse : 0.0;
					lambda = newImpulse - ccp.normalImpulse;
					PX = lambda * normalX;
					PY = lambda * normalY;
					vA.x -= invMassA * PX;
					vA.y -= invMassA * PY;
					wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
					vB.x += invMassB * PX;
					vB.y += invMassB * PY;
					wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
					ccp.normalImpulse = newImpulse;
				}
				else {
					var cp1 = c.points[0];
					var cp2 = c.points[1];
					var aX = cp1.normalImpulse;
					var aY = cp2.normalImpulse;
					var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
					var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
					var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
					var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
					var vn1 = dv1X * normalX + dv1Y * normalY;
					var vn2 = dv2X * normalX + dv2Y * normalY;
					var bX = vn1 - cp1.velocityBias;
					var bY = vn2 - cp2.velocityBias;
					tMat = c.K;
					bX -= tMat.col1.x * aX + tMat.col2.x * aY;
					bY -= tMat.col1.y * aX + tMat.col2.y * aY;
					var k_errorTol = 0.001;
					for (; ;) {
						tMat = c.normalMass;
						var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
						var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
						if (xX >= 0.0 && xY >= 0.0) {
							dX = xX - aX;
							dY = xY - aY;
							P1X = dX * normalX;
							P1Y = dX * normalY;
							P2X = dY * normalX;
							P2Y = dY * normalY;
							vA.x -= invMassA * (P1X + P2X);
							vA.y -= invMassA * (P1Y + P2Y);
							wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
							vB.x += invMassB * (P1X + P2X);
							vB.y += invMassB * (P1Y + P2Y);
							wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
							cp1.normalImpulse = xX;
							cp2.normalImpulse = xY;
							break;
						}
						xX = (-cp1.normalMass * bX);
						xY = 0.0;
						vn1 = 0.0;
						vn2 = c.K.col1.y * xX + bY;
						if (xX >= 0.0 && vn2 >= 0.0) {
							dX = xX - aX;
							dY = xY - aY;
							P1X = dX * normalX;
							P1Y = dX * normalY;
							P2X = dY * normalX;
							P2Y = dY * normalY;
							vA.x -= invMassA * (P1X + P2X);
							vA.y -= invMassA * (P1Y + P2Y);
							wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
							vB.x += invMassB * (P1X + P2X);
							vB.y += invMassB * (P1Y + P2Y);
							wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
							cp1.normalImpulse = xX;
							cp2.normalImpulse = xY;
							break;
						}
						xX = 0.0;
						xY = (-cp2.normalMass * bY);
						vn1 = c.K.col2.x * xY + bX;
						vn2 = 0.0;
						if (xY >= 0.0 && vn1 >= 0.0) {
							dX = xX - aX;
							dY = xY - aY;
							P1X = dX * normalX;
							P1Y = dX * normalY;
							P2X = dY * normalX;
							P2Y = dY * normalY;
							vA.x -= invMassA * (P1X + P2X);
							vA.y -= invMassA * (P1Y + P2Y);
							wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
							vB.x += invMassB * (P1X + P2X);
							vB.y += invMassB * (P1Y + P2Y);
							wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
							cp1.normalImpulse = xX;
							cp2.normalImpulse = xY;
							break;
						}
						xX = 0.0;
						xY = 0.0;
						vn1 = bX;
						vn2 = bY;
						if (vn1 >= 0.0 && vn2 >= 0.0) {
							dX = xX - aX;
							dY = xY - aY;
							P1X = dX * normalX;
							P1Y = dX * normalY;
							P2X = dY * normalX;
							P2Y = dY * normalY;
							vA.x -= invMassA * (P1X + P2X);
							vA.y -= invMassA * (P1Y + P2Y);
							wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
							vB.x += invMassB * (P1X + P2X);
							vB.y += invMassB * (P1Y + P2Y);
							wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
							cp1.normalImpulse = xX;
							cp2.normalImpulse = xY;
							break;
						}
						break;
					}
				}
				bodyA.m_angularVelocity = wA;
				bodyB.m_angularVelocity = wB;
			}
		}
		b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
			for (var i = 0; i < this.m_constraintCount; ++i) {
				var c = this.m_constraints[i];
				var m = c.manifold;
				for (var j = 0; j < c.pointCount; ++j) {
					var point1 = m.m_points[j];
					var point2 = c.points[j];
					point1.m_normalImpulse = point2.normalImpulse;
					point1.m_tangentImpulse = point2.tangentImpulse;
				}
			}
		}
		b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			var minSeparation = 0.0;
			for (var i = 0; i < this.m_constraintCount; i++) {
				var c = this.m_constraints[i];
				var bodyA = c.bodyA;
				var bodyB = c.bodyB;
				var invMassA = bodyA.m_mass * bodyA.m_invMass;
				var invIA = bodyA.m_mass * bodyA.m_invI;
				var invMassB = bodyB.m_mass * bodyB.m_invMass;
				var invIB = bodyB.m_mass * bodyB.m_invI;
				b2ContactSolver.s_psm.Initialize(c);
				var normal = b2ContactSolver.s_psm.m_normal;
				for (var j = 0; j < c.pointCount; j++) {
					var ccp = c.points[j];
					var point = b2ContactSolver.s_psm.m_points[j];
					var separation = b2ContactSolver.s_psm.m_separations[j];
					var rAX = point.x - bodyA.m_sweep.c.x;
					var rAY = point.y - bodyA.m_sweep.c.y;
					var rBX = point.x - bodyB.m_sweep.c.x;
					var rBY = point.y - bodyB.m_sweep.c.y;
					minSeparation = minSeparation < separation ? minSeparation : separation;
					var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
					var impulse = (-ccp.equalizedMass * C);
					var PX = impulse * normal.x;
					var PY = impulse * normal.y;
					bodyA.m_sweep.c.x -= invMassA * PX;
					bodyA.m_sweep.c.y -= invMassA * PY;
					bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
					bodyA.SynchronizeTransform();
					bodyB.m_sweep.c.x += invMassB * PX;
					bodyB.m_sweep.c.y += invMassB * PY;
					bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
					bodyB.SynchronizeTransform();
				}
			}
			return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
			Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
		});
		Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
		b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2EdgeAndCircleContact.Create = function (allocator) {
			return new b2EdgeAndCircleContact();
		}
		b2EdgeAndCircleContact.Destroy = function (contact, allocator) {
		}
		b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
			this.__super.Reset.call(this, fixtureA, fixtureB);
		}
		b2EdgeAndCircleContact.prototype.Evaluate = function () {
			var bA = this.m_fixtureA.GetBody();
			var bB = this.m_fixtureB.GetBody();
			this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {
		}
		Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
		b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2NullContact.b2NullContact = function () {
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2NullContact.prototype.b2NullContact = function () {
			this.__super.b2Contact.call(this);
		}
		b2NullContact.prototype.Evaluate = function () {
		}
		Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
		b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2PolyAndCircleContact.Create = function (allocator) {
			return new b2PolyAndCircleContact();
		}
		b2PolyAndCircleContact.Destroy = function (contact, allocator) {
		}
		b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
			this.__super.Reset.call(this, fixtureA, fixtureB);
			b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
			b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
		}
		b2PolyAndCircleContact.prototype.Evaluate = function () {
			var bA = this.m_fixtureA.m_body;
			var bB = this.m_fixtureB.m_body;
			b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
		b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2PolyAndEdgeContact.Create = function (allocator) {
			return new b2PolyAndEdgeContact();
		}
		b2PolyAndEdgeContact.Destroy = function (contact, allocator) {
		}
		b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
			this.__super.Reset.call(this, fixtureA, fixtureB);
			b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
			b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
		}
		b2PolyAndEdgeContact.prototype.Evaluate = function () {
			var bA = this.m_fixtureA.GetBody();
			var bB = this.m_fixtureB.GetBody();
			this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {
		}
		Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
		b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2PolygonContact.b2PolygonContact = function () {
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2PolygonContact.Create = function (allocator) {
			return new b2PolygonContact();
		}
		b2PolygonContact.Destroy = function (contact, allocator) {
		}
		b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
			this.__super.Reset.call(this, fixtureA, fixtureB);
		}
		b2PolygonContact.prototype.Evaluate = function () {
			var bA = this.m_fixtureA.GetBody();
			var bB = this.m_fixtureB.GetBody();
			b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		b2PositionSolverManifold.b2PositionSolverManifold = function () {
		};
		b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
			this.m_normal = new b2Vec2();
			this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
			this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
				this.m_points[i] = new b2Vec2();
			}
		}
		b2PositionSolverManifold.prototype.Initialize = function (cc) {
			b2Settings.b2Assert(cc.pointCount > 0);
			var i = 0;
			var clipPointX = 0;
			var clipPointY = 0;
			var tMat;
			var tVec;
			var planePointX = 0;
			var planePointY = 0;
			switch (cc.type) {
				case b2Manifold.e_circles: {
					tMat = cc.bodyA.m_xf.R;
					tVec = cc.localPoint;
					var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tMat = cc.bodyB.m_xf.R;
					tVec = cc.points[0].localPoint;
					var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					var dX = pointBX - pointAX;
					var dY = pointBY - pointAY;
					var d2 = dX * dX + dY * dY;
					if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
						var d = Math.sqrt(d2);
						this.m_normal.x = dX / d;
						this.m_normal.y = dY / d;
					}
					else {
						this.m_normal.x = 1.0;
						this.m_normal.y = 0.0;
					}
					this.m_points[0].x = 0.5 * (pointAX + pointBX);
					this.m_points[0].y = 0.5 * (pointAY + pointBY);
					this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
				}
					break;
				case b2Manifold.e_faceA: {
					tMat = cc.bodyA.m_xf.R;
					tVec = cc.localPlaneNormal;
					this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = cc.bodyA.m_xf.R;
					tVec = cc.localPoint;
					planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tMat = cc.bodyB.m_xf.R;
					for (i = 0;
						 i < cc.pointCount; ++i) {
						tVec = cc.points[i].localPoint;
						clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
						clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
						this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
						this.m_points[i].x = clipPointX;
						this.m_points[i].y = clipPointY;
					}
				}
					break;
				case b2Manifold.e_faceB: {
					tMat = cc.bodyB.m_xf.R;
					tVec = cc.localPlaneNormal;
					this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = cc.bodyB.m_xf.R;
					tVec = cc.localPoint;
					planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tMat = cc.bodyA.m_xf.R;
					for (i = 0;
						 i < cc.pointCount; ++i) {
						tVec = cc.points[i].localPoint;
						clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
						clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
						this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
						this.m_points[i].Set(clipPointX, clipPointY);
					}
					this.m_normal.x *= (-1);
					this.m_normal.y *= (-1);
				}
					break;
			}
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
			Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
		});
	})();
	(function () {
		var b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
			b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
			b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
			b2Controller = Box2D.Dynamics.Controllers.b2Controller,
			b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
			b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
			b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;
		
		Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
		b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2BuoyancyController.b2BuoyancyController = function () {
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.normal = new b2Vec2(0, (-1));
			this.offset = 0;
			this.density = 0;
			this.velocity = new b2Vec2(0, 0);
			this.linearDrag = 2;
			this.angularDrag = 1;
			this.useDensity = false;
			this.useWorldGravity = true;
			this.gravity = null;
		};
		b2BuoyancyController.prototype.Step = function (step) {
			if (!this.m_bodyList) return;
			if (this.useWorldGravity) {
				this.gravity = this.GetWorld().GetGravity().Copy();
			}
			for (var i = this.m_bodyList; i; i = i.nextBody) {
				var body = i.body;
				if (body.IsAwake() == false) {
					continue;
				}
				var areac = new b2Vec2();
				var massc = new b2Vec2();
				var area = 0.0;
				var mass = 0.0;
				for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
					var sc = new b2Vec2();
					var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
					area += sarea;
					areac.x += sarea * sc.x;
					areac.y += sarea * sc.y;
					var shapeDensity = 0;
					if (this.useDensity) {
						shapeDensity = 1;
					}
					else {
						shapeDensity = 1;
					}
					mass += sarea * shapeDensity;
					massc.x += sarea * sc.x * shapeDensity;
					massc.y += sarea * sc.y * shapeDensity;
				}
				areac.x /= area;
				areac.y /= area;
				massc.x /= mass;
				massc.y /= mass;
				if (area < Number.MIN_VALUE) continue;
				var buoyancyForce = this.gravity.GetNegative();
				buoyancyForce.Multiply(this.density * area);
				body.ApplyForce(buoyancyForce, massc);
				var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
				dragForce.Subtract(this.velocity);
				dragForce.Multiply((-this.linearDrag * area));
				body.ApplyForce(dragForce, areac);
				body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
			}
		}
		b2BuoyancyController.prototype.Draw = function (debugDraw) {
			var r = 1000;
			var p1 = new b2Vec2();
			var p2 = new b2Vec2();
			p1.x = this.normal.x * this.offset + this.normal.y * r;
			p1.y = this.normal.y * this.offset - this.normal.x * r;
			p2.x = this.normal.x * this.offset - this.normal.y * r;
			p2.y = this.normal.y * this.offset + this.normal.x * r;
			var color = new b2Color(0, 0, 1);
			debugDraw.DrawSegment(p1, p2, color);
		}
		Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
		b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2ConstantAccelController.b2ConstantAccelController = function () {
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.A = new b2Vec2(0, 0);
		};
		b2ConstantAccelController.prototype.Step = function (step) {
			var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
			for (var i = this.m_bodyList; i; i = i.nextBody) {
				var body = i.body;
				if (!body.IsAwake()) continue;
				body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
			}
		}
		Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
		b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2ConstantForceController.b2ConstantForceController = function () {
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.F = new b2Vec2(0, 0);
		};
		b2ConstantForceController.prototype.Step = function (step) {
			for (var i = this.m_bodyList; i; i = i.nextBody) {
				var body = i.body;
				if (!body.IsAwake()) continue;
				body.ApplyForce(this.F, body.GetWorldCenter());
			}
		}
		b2Controller.b2Controller = function () {
		};
		b2Controller.prototype.Step = function (step) {
		}
		b2Controller.prototype.Draw = function (debugDraw) {
		}
		b2Controller.prototype.AddBody = function (body) {
			var edge = new b2ControllerEdge();
			edge.controller = this;
			edge.body = body;
			edge.nextBody = this.m_bodyList;
			edge.prevBody = null;
			this.m_bodyList = edge;
			if (edge.nextBody) edge.nextBody.prevBody = edge;
			this.m_bodyCount++;
			edge.nextController = body.m_controllerList;
			edge.prevController = null;
			body.m_controllerList = edge;
			if (edge.nextController) edge.nextController.prevController = edge;
			body.m_controllerCount++;
		}
		b2Controller.prototype.RemoveBody = function (body) {
			var edge = body.m_controllerList;
			while (edge && edge.controller != this)
				edge = edge.nextController;
			if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
			if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
			if (edge.nextController) edge.nextController.prevController = edge.prevController;
			if (edge.prevController) edge.prevController.nextController = edge.nextController;
			if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
			if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
			body.m_controllerCount--;
			this.m_bodyCount--;
		}
		b2Controller.prototype.Clear = function () {
			while (this.m_bodyList)
				this.RemoveBody(this.m_bodyList.body);
		}
		b2Controller.prototype.GetNext = function () {
			return this.m_next;
		}
		b2Controller.prototype.GetWorld = function () {
			return this.m_world;
		}
		b2Controller.prototype.GetBodyList = function () {
			return this.m_bodyList;
		}
		b2ControllerEdge.b2ControllerEdge = function () {
		};
		Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
		b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2GravityController.b2GravityController = function () {
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.G = 1;
			this.invSqr = true;
		};
		b2GravityController.prototype.Step = function (step) {
			var i = null;
			var body1 = null;
			var p1 = null;
			var mass1 = 0;
			var j = null;
			var body2 = null;
			var p2 = null;
			var dx = 0;
			var dy = 0;
			var r2 = 0;
			var f = null;
			if (this.invSqr) {
				for (i = this.m_bodyList;
					 i; i = i.nextBody) {
					body1 = i.body;
					p1 = body1.GetWorldCenter();
					mass1 = body1.GetMass();
					for (j = this.m_bodyList;
						 j != i; j = j.nextBody) {
						body2 = j.body;
						p2 = body2.GetWorldCenter();
						dx = p2.x - p1.x;
						dy = p2.y - p1.y;
						r2 = dx * dx + dy * dy;
						if (r2 < Number.MIN_VALUE) continue;
						f = new b2Vec2(dx, dy);
						f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
						if (body1.IsAwake()) body1.ApplyForce(f, p1);
						f.Multiply((-1));
						if (body2.IsAwake()) body2.ApplyForce(f, p2);
					}
				}
			}
			else {
				for (i = this.m_bodyList;
					 i; i = i.nextBody) {
					body1 = i.body;
					p1 = body1.GetWorldCenter();
					mass1 = body1.GetMass();
					for (j = this.m_bodyList;
						 j != i; j = j.nextBody) {
						body2 = j.body;
						p2 = body2.GetWorldCenter();
						dx = p2.x - p1.x;
						dy = p2.y - p1.y;
						r2 = dx * dx + dy * dy;
						if (r2 < Number.MIN_VALUE) continue;
						f = new b2Vec2(dx, dy);
						f.Multiply(this.G / r2 * mass1 * body2.GetMass());
						if (body1.IsAwake()) body1.ApplyForce(f, p1);
						f.Multiply((-1));
						if (body2.IsAwake()) body2.ApplyForce(f, p2);
					}
				}
			}
		}
		Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
		b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2TensorDampingController.b2TensorDampingController = function () {
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.T = new b2Mat22();
			this.maxTimestep = 0;
		};
		b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
			if (xDamping === undefined) xDamping = 0;
			if (yDamping === undefined) yDamping = 0;
			this.T.col1.x = (-xDamping);
			this.T.col1.y = 0;
			this.T.col2.x = 0;
			this.T.col2.y = (-yDamping);
			if (xDamping > 0 || yDamping > 0) {
				this.maxTimestep = 1 / Math.max(xDamping, yDamping);
			}
			else {
				this.maxTimestep = 0;
			}
		}
		b2TensorDampingController.prototype.Step = function (step) {
			var timestep = step.dt;
			if (timestep <= Number.MIN_VALUE) return;
			if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
			for (var i = this.m_bodyList; i; i = i.nextBody) {
				var body = i.body;
				if (!body.IsAwake()) {
					continue;
				}
				var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
				body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
			}
		}
	})();
	(function () {
		var b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
			b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
			b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
			b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
			b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
			b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
			b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
			b2Joint = Box2D.Dynamics.Joints.b2Joint,
			b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
			b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
			b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
			b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
			b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
			b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
			b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
			b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
			b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
			b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
			b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
			b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
			b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
			b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
			b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World;
		
		Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
		b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2DistanceJoint.b2DistanceJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_u = new b2Vec2();
		};
		b2DistanceJoint.prototype.GetAnchorA = function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2DistanceJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
		}
		b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return 0.0;
		}
		b2DistanceJoint.prototype.GetLength = function () {
			return this.m_length;
		}
		b2DistanceJoint.prototype.SetLength = function (length) {
			if (length === undefined) length = 0;
			this.m_length = length;
		}
		b2DistanceJoint.prototype.GetFrequency = function () {
			return this.m_frequencyHz;
		}
		b2DistanceJoint.prototype.SetFrequency = function (hz) {
			if (hz === undefined) hz = 0;
			this.m_frequencyHz = hz;
		}
		b2DistanceJoint.prototype.GetDampingRatio = function () {
			return this.m_dampingRatio;
		}
		b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
			if (ratio === undefined) ratio = 0;
			this.m_dampingRatio = ratio;
		}
		b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			var tMat;
			var tX = 0;
			var tY = 0;
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_length = def.length;
			this.m_frequencyHz = def.frequencyHz;
			this.m_dampingRatio = def.dampingRatio;
			this.m_impulse = 0.0;
			this.m_gamma = 0.0;
			this.m_bias = 0.0;
		}
		b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
			this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
			var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
			if (length > b2Settings.b2_linearSlop) {
				this.m_u.Multiply(1.0 / length);
			}
			else {
				this.m_u.SetZero();
			}
			var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
			var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
			var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
			this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
			if (this.m_frequencyHz > 0.0) {
				var C = length - this.m_length;
				var omega = 2.0 * Math.PI * this.m_frequencyHz;
				var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
				var k = this.m_mass * omega * omega;
				this.m_gamma = step.dt * (d + step.dt * k);
				this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
				this.m_bias = C * step.dt * k * this.m_gamma;
				this.m_mass = invMass + this.m_gamma;
				this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
			}
			if (step.warmStarting) {
				this.m_impulse *= step.dtRatio;
				var PX = this.m_impulse * this.m_u.x;
				var PY = this.m_impulse * this.m_u.y;
				bA.m_linearVelocity.x -= bA.m_invMass * PX;
				bA.m_linearVelocity.y -= bA.m_invMass * PY;
				bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
				bB.m_linearVelocity.x += bB.m_invMass * PX;
				bB.m_linearVelocity.y += bB.m_invMass * PY;
				bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
			}
			else {
				this.m_impulse = 0.0;
			}
		}
		b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
			var tMat;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
			var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
			var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
			var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
			var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
			var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
			this.m_impulse += impulse;
			var PX = impulse * this.m_u.x;
			var PY = impulse * this.m_u.y;
			bA.m_linearVelocity.x -= bA.m_invMass * PX;
			bA.m_linearVelocity.y -= bA.m_invMass * PY;
			bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
			bB.m_linearVelocity.x += bB.m_invMass * PX;
			bB.m_linearVelocity.y += bB.m_invMass * PY;
			bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
		}
		b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			var tMat;
			if (this.m_frequencyHz > 0.0) {
				return true;
			}
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
			var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
			var length = Math.sqrt(dX * dX + dY * dY);
			dX /= length;
			dY /= length;
			var C = length - this.m_length;
			C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
			var impulse = (-this.m_mass * C);
			this.m_u.Set(dX, dY);
			var PX = impulse * this.m_u.x;
			var PY = impulse * this.m_u.y;
			bA.m_sweep.c.x -= bA.m_invMass * PX;
			bA.m_sweep.c.y -= bA.m_invMass * PY;
			bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
			bB.m_sweep.c.x += bB.m_invMass * PX;
			bB.m_sweep.c.y += bB.m_invMass * PY;
			bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return b2Math.Abs(C) < b2Settings.b2_linearSlop;
		}
		Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2DistanceJointDef.b2DistanceJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_distanceJoint;
			this.length = 1.0;
			this.frequencyHz = 0.0;
			this.dampingRatio = 0.0;
		}
		b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
			this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
			var dX = anchorB.x - anchorA.x;
			var dY = anchorB.y - anchorA.y;
			this.length = Math.sqrt(dX * dX + dY * dY);
			this.frequencyHz = 0.0;
			this.dampingRatio = 0.0;
		}
		Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
		b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2FrictionJoint.b2FrictionJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchorA = new b2Vec2();
			this.m_localAnchorB = new b2Vec2();
			this.m_linearMass = new b2Mat22();
			this.m_linearImpulse = new b2Vec2();
		};
		b2FrictionJoint.prototype.GetAnchorA = function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		}
		b2FrictionJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		}
		b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
		}
		b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_angularImpulse;
		}
		b2FrictionJoint.prototype.SetMaxForce = function (force) {
			if (force === undefined) force = 0;
			this.m_maxForce = force;
		}
		b2FrictionJoint.prototype.GetMaxForce = function () {
			return this.m_maxForce;
		}
		b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
			if (torque === undefined) torque = 0;
			this.m_maxTorque = torque;
		}
		b2FrictionJoint.prototype.GetMaxTorque = function () {
			return this.m_maxTorque;
		}
		b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			this.m_localAnchorA.SetV(def.localAnchorA);
			this.m_localAnchorB.SetV(def.localAnchorB);
			this.m_linearMass.SetZero();
			this.m_angularMass = 0.0;
			this.m_linearImpulse.SetZero();
			this.m_angularImpulse = 0.0;
			this.m_maxForce = def.maxForce;
			this.m_maxTorque = def.maxTorque;
		}
		b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			var K = new b2Mat22();
			K.col1.x = mA + mB;
			K.col2.x = 0.0;
			K.col1.y = 0.0;
			K.col2.y = mA + mB;
			K.col1.x += iA * rAY * rAY;
			K.col2.x += (-iA * rAX * rAY);
			K.col1.y += (-iA * rAX * rAY);
			K.col2.y += iA * rAX * rAX;
			K.col1.x += iB * rBY * rBY;
			K.col2.x += (-iB * rBX * rBY);
			K.col1.y += (-iB * rBX * rBY);
			K.col2.y += iB * rBX * rBX;
			K.GetInverse(this.m_linearMass);
			this.m_angularMass = iA + iB;
			if (this.m_angularMass > 0.0) {
				this.m_angularMass = 1.0 / this.m_angularMass;
			}
			if (step.warmStarting) {
				this.m_linearImpulse.x *= step.dtRatio;
				this.m_linearImpulse.y *= step.dtRatio;
				this.m_angularImpulse *= step.dtRatio;
				var P = this.m_linearImpulse;
				bA.m_linearVelocity.x -= mA * P.x;
				bA.m_linearVelocity.y -= mA * P.y;
				bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
				bB.m_linearVelocity.x += mB * P.x;
				bB.m_linearVelocity.y += mB * P.y;
				bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
			}
			else {
				this.m_linearImpulse.SetZero();
				this.m_angularImpulse = 0.0;
			}
		}
		b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var vA = bA.m_linearVelocity;
			var wA = bA.m_angularVelocity;
			var vB = bB.m_linearVelocity;
			var wB = bB.m_angularVelocity;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var maxImpulse = 0;
			{
				var Cdot = wB - wA;
				var impulse = (-this.m_angularMass * Cdot);
				var oldImpulse = this.m_angularImpulse;
				maxImpulse = step.dt * this.m_maxTorque;
				this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
				impulse = this.m_angularImpulse - oldImpulse;
				wA -= iA * impulse;
				wB += iB * impulse;
			}
			{
				var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
				var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
				var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
				var oldImpulseV = this.m_linearImpulse.Copy();
				this.m_linearImpulse.Add(impulseV);
				maxImpulse = step.dt * this.m_maxForce;
				if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
					this.m_linearImpulse.Normalize();
					this.m_linearImpulse.Multiply(maxImpulse);
				}
				impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
				vA.x -= mA * impulseV.x;
				vA.y -= mA * impulseV.y;
				wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
				vB.x += mB * impulseV.x;
				vB.y += mB * impulseV.y;
				wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
			}
			bA.m_angularVelocity = wA;
			bB.m_angularVelocity = wB;
		}
		b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			return true;
		}
		Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2FrictionJointDef.b2FrictionJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_frictionJoint;
			this.maxForce = 0.0;
			this.maxTorque = 0.0;
		}
		b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
			this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
		}
		Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
		b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2GearJoint.b2GearJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_groundAnchor1 = new b2Vec2();
			this.m_groundAnchor2 = new b2Vec2();
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_J = new b2Jacobian();
		};
		b2GearJoint.prototype.GetAnchorA = function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2GearJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
		}
		b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			var tMat = this.m_bodyB.m_xf.R;
			var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
			var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
			var tX = tMat.col1.x * rX + tMat.col2.x * rY;
			rY = tMat.col1.y * rX + tMat.col2.y * rY;
			rX = tX;
			var PX = this.m_impulse * this.m_J.linearB.x;
			var PY = this.m_impulse * this.m_J.linearB.y;
			return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
		}
		b2GearJoint.prototype.GetRatio = function () {
			return this.m_ratio;
		}
		b2GearJoint.prototype.SetRatio = function (ratio) {
			if (ratio === undefined) ratio = 0;
			this.m_ratio = ratio;
		}
		b2GearJoint.prototype.b2GearJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			var type1 = parseInt(def.joint1.m_type);
			var type2 = parseInt(def.joint2.m_type);
			this.m_revolute1 = null;
			this.m_prismatic1 = null;
			this.m_revolute2 = null;
			this.m_prismatic2 = null;
			var coordinate1 = 0;
			var coordinate2 = 0;
			this.m_ground1 = def.joint1.GetBodyA();
			this.m_bodyA = def.joint1.GetBodyB();
			if (type1 == b2Joint.e_revoluteJoint) {
				this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
				this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
				this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
				coordinate1 = this.m_revolute1.GetJointAngle();
			}
			else {
				this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
				this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
				this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
				coordinate1 = this.m_prismatic1.GetJointTranslation();
			}
			this.m_ground2 = def.joint2.GetBodyA();
			this.m_bodyB = def.joint2.GetBodyB();
			if (type2 == b2Joint.e_revoluteJoint) {
				this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
				this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
				this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
				coordinate2 = this.m_revolute2.GetJointAngle();
			}
			else {
				this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
				this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
				this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
				coordinate2 = this.m_prismatic2.GetJointTranslation();
			}
			this.m_ratio = def.ratio;
			this.m_constant = coordinate1 + this.m_ratio * coordinate2;
			this.m_impulse = 0.0;
		}
		b2GearJoint.prototype.InitVelocityConstraints = function (step) {
			var g1 = this.m_ground1;
			var g2 = this.m_ground2;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var ugX = 0;
			var ugY = 0;
			var rX = 0;
			var rY = 0;
			var tMat;
			var tVec;
			var crug = 0;
			var tX = 0;
			var K = 0.0;
			this.m_J.SetZero();
			if (this.m_revolute1) {
				this.m_J.angularA = (-1.0);
				K += bA.m_invI;
			}
			else {
				tMat = g1.m_xf.R;
				tVec = this.m_prismatic1.m_localXAxis1;
				ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
				ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
				tMat = bA.m_xf.R;
				rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = tMat.col1.x * rX + tMat.col2.x * rY;
				rY = tMat.col1.y * rX + tMat.col2.y * rY;
				rX = tX;
				crug = rX * ugY - rY * ugX;
				this.m_J.linearA.Set((-ugX), (-ugY));
				this.m_J.angularA = (-crug);
				K += bA.m_invMass + bA.m_invI * crug * crug;
			}
			if (this.m_revolute2) {
				this.m_J.angularB = (-this.m_ratio);
				K += this.m_ratio * this.m_ratio * bB.m_invI;
			}
			else {
				tMat = g2.m_xf.R;
				tVec = this.m_prismatic2.m_localXAxis1;
				ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
				ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
				tMat = bB.m_xf.R;
				rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = tMat.col1.x * rX + tMat.col2.x * rY;
				rY = tMat.col1.y * rX + tMat.col2.y * rY;
				rX = tX;
				crug = rX * ugY - rY * ugX;
				this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
				this.m_J.angularB = (-this.m_ratio * crug);
				K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
			}
			this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
			if (step.warmStarting) {
				bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
				bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
				bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
				bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
				bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
				bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
			}
			else {
				this.m_impulse = 0.0;
			}
		}
		b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
			var impulse = (-this.m_mass * Cdot);
			this.m_impulse += impulse;
			bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
			bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
			bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
			bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
			bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
			bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
		}
		b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			var linearError = 0.0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var coordinate1 = 0;
			var coordinate2 = 0;
			if (this.m_revolute1) {
				coordinate1 = this.m_revolute1.GetJointAngle();
			}
			else {
				coordinate1 = this.m_prismatic1.GetJointTranslation();
			}
			if (this.m_revolute2) {
				coordinate2 = this.m_revolute2.GetJointAngle();
			}
			else {
				coordinate2 = this.m_prismatic2.GetJointTranslation();
			}
			var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
			var impulse = (-this.m_mass * C);
			bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
			bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
			bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
			bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
			bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
			bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return linearError < b2Settings.b2_linearSlop;
		}
		Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2GearJointDef.b2GearJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
		};
		b2GearJointDef.prototype.b2GearJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_gearJoint;
			this.joint1 = null;
			this.joint2 = null;
			this.ratio = 1.0;
		}
		b2Jacobian.b2Jacobian = function () {
			this.linearA = new b2Vec2();
			this.linearB = new b2Vec2();
		};
		b2Jacobian.prototype.SetZero = function () {
			this.linearA.SetZero();
			this.angularA = 0.0;
			this.linearB.SetZero();
			this.angularB = 0.0;
		}
		b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
			if (a1 === undefined) a1 = 0;
			if (a2 === undefined) a2 = 0;
			this.linearA.SetV(x1);
			this.angularA = a1;
			this.linearB.SetV(x2);
			this.angularB = a2;
		}
		b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
			if (a1 === undefined) a1 = 0;
			if (a2 === undefined) a2 = 0;
			return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
		}
		b2Joint.b2Joint = function () {
			this.m_edgeA = new b2JointEdge();
			this.m_edgeB = new b2JointEdge();
			this.m_localCenterA = new b2Vec2();
			this.m_localCenterB = new b2Vec2();
		};
		b2Joint.prototype.GetType = function () {
			return this.m_type;
		}
		b2Joint.prototype.GetAnchorA = function () {
			return null;
		}
		b2Joint.prototype.GetAnchorB = function () {
			return null;
		}
		b2Joint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return null;
		}
		b2Joint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return 0.0;
		}
		b2Joint.prototype.GetBodyA = function () {
			return this.m_bodyA;
		}
		b2Joint.prototype.GetBodyB = function () {
			return this.m_bodyB;
		}
		b2Joint.prototype.GetNext = function () {
			return this.m_next;
		}
		b2Joint.prototype.GetUserData = function () {
			return this.m_userData;
		}
		b2Joint.prototype.SetUserData = function (data) {
			this.m_userData = data;
		}
		b2Joint.prototype.IsActive = function () {
			return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
		}
		b2Joint.Create = function (def, allocator) {
			var joint = null;
			switch (def.type) {
				case b2Joint.e_distanceJoint: {
					joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
				}
					break;
				case b2Joint.e_mouseJoint: {
					joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
				}
					break;
				case b2Joint.e_prismaticJoint: {
					joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
				}
					break;
				case b2Joint.e_revoluteJoint: {
					joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
				}
					break;
				case b2Joint.e_pulleyJoint: {
					joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
				}
					break;
				case b2Joint.e_gearJoint: {
					joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
				}
					break;
				case b2Joint.e_lineJoint: {
					joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
				}
					break;
				case b2Joint.e_weldJoint: {
					joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
				}
					break;
				case b2Joint.e_frictionJoint: {
					joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
				}
					break;
				default:
					break;
			}
			return joint;
		}
		b2Joint.Destroy = function (joint, allocator) {
		}
		b2Joint.prototype.b2Joint = function (def) {
			b2Settings.b2Assert(def.bodyA != def.bodyB);
			this.m_type = def.type;
			this.m_prev = null;
			this.m_next = null;
			this.m_bodyA = def.bodyA;
			this.m_bodyB = def.bodyB;
			this.m_collideConnected = def.collideConnected;
			this.m_islandFlag = false;
			this.m_userData = def.userData;
		}
		b2Joint.prototype.InitVelocityConstraints = function (step) {
		}
		b2Joint.prototype.SolveVelocityConstraints = function (step) {
		}
		b2Joint.prototype.FinalizeVelocityConstraints = function () {
		}
		b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			return false;
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
			Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
			Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
			Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
			Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
			Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
			Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
			Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
			Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
			Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
			Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
			Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
			Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
			Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
		});
		b2JointDef.b2JointDef = function () {
		};
		b2JointDef.prototype.b2JointDef = function () {
			this.type = b2Joint.e_unknownJoint;
			this.userData = null;
			this.bodyA = null;
			this.bodyB = null;
			this.collideConnected = false;
		}
		b2JointEdge.b2JointEdge = function () {
		};
		Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
		b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2LineJoint.b2LineJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_localXAxis1 = new b2Vec2();
			this.m_localYAxis1 = new b2Vec2();
			this.m_axis = new b2Vec2();
			this.m_perp = new b2Vec2();
			this.m_K = new b2Mat22();
			this.m_impulse = new b2Vec2();
		};
		b2LineJoint.prototype.GetAnchorA = function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2LineJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
		}
		b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_impulse.y;
		}
		b2LineJoint.prototype.GetJointTranslation = function () {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var p1 = bA.GetWorldPoint(this.m_localAnchor1);
			var p2 = bB.GetWorldPoint(this.m_localAnchor2);
			var dX = p2.x - p1.x;
			var dY = p2.y - p1.y;
			var axis = bA.GetWorldVector(this.m_localXAxis1);
			var translation = axis.x * dX + axis.y * dY;
			return translation;
		}
		b2LineJoint.prototype.GetJointSpeed = function () {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var p1X = bA.m_sweep.c.x + r1X;
			var p1Y = bA.m_sweep.c.y + r1Y;
			var p2X = bB.m_sweep.c.x + r2X;
			var p2Y = bB.m_sweep.c.y + r2Y;
			var dX = p2X - p1X;
			var dY = p2Y - p1Y;
			var axis = bA.GetWorldVector(this.m_localXAxis1);
			var v1 = bA.m_linearVelocity;
			var v2 = bB.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var w2 = bB.m_angularVelocity;
			var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
			return speed;
		}
		b2LineJoint.prototype.IsLimitEnabled = function () {
			return this.m_enableLimit;
		}
		b2LineJoint.prototype.EnableLimit = function (flag) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableLimit = flag;
		}
		b2LineJoint.prototype.GetLowerLimit = function () {
			return this.m_lowerTranslation;
		}
		b2LineJoint.prototype.GetUpperLimit = function () {
			return this.m_upperTranslation;
		}
		b2LineJoint.prototype.SetLimits = function (lower, upper) {
			if (lower === undefined) lower = 0;
			if (upper === undefined) upper = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_lowerTranslation = lower;
			this.m_upperTranslation = upper;
		}
		b2LineJoint.prototype.IsMotorEnabled = function () {
			return this.m_enableMotor;
		}
		b2LineJoint.prototype.EnableMotor = function (flag) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableMotor = flag;
		}
		b2LineJoint.prototype.SetMotorSpeed = function (speed) {
			if (speed === undefined) speed = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = speed;
		}
		b2LineJoint.prototype.GetMotorSpeed = function () {
			return this.m_motorSpeed;
		}
		b2LineJoint.prototype.SetMaxMotorForce = function (force) {
			if (force === undefined) force = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_maxMotorForce = force;
		}
		b2LineJoint.prototype.GetMaxMotorForce = function () {
			return this.m_maxMotorForce;
		}
		b2LineJoint.prototype.GetMotorForce = function () {
			return this.m_motorImpulse;
		}
		b2LineJoint.prototype.b2LineJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			var tMat;
			var tX = 0;
			var tY = 0;
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_localXAxis1.SetV(def.localAxisA);
			this.m_localYAxis1.x = (-this.m_localXAxis1.y);
			this.m_localYAxis1.y = this.m_localXAxis1.x;
			this.m_impulse.SetZero();
			this.m_motorMass = 0.0;
			this.m_motorImpulse = 0.0;
			this.m_lowerTranslation = def.lowerTranslation;
			this.m_upperTranslation = def.upperTranslation;
			this.m_maxMotorForce = def.maxMotorForce;
			this.m_motorSpeed = def.motorSpeed;
			this.m_enableLimit = def.enableLimit;
			this.m_enableMotor = def.enableMotor;
			this.m_limitState = b2Joint.e_inactiveLimit;
			this.m_axis.SetZero();
			this.m_perp.SetZero();
		}
		b2LineJoint.prototype.InitVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var tX = 0;
			this.m_localCenterA.SetV(bA.GetLocalCenter());
			this.m_localCenterB.SetV(bB.GetLocalCenter());
			var xf1 = bA.GetTransform();
			var xf2 = bB.GetTransform();
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
			var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
			var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
			var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
			this.m_invMassA = bA.m_invMass;
			this.m_invMassB = bB.m_invMass;
			this.m_invIA = bA.m_invI;
			this.m_invIB = bB.m_invI;
			{
				this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
				this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
				this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
				this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
				this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
			}
			{
				this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
				this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
				this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
				var m1 = this.m_invMassA;
				var m2 = this.m_invMassB;
				var i1 = this.m_invIA;
				var i2 = this.m_invIB;
				this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
				this.m_K.col2.x = this.m_K.col1.y;
				this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
			}
			if (this.m_enableLimit) {
				var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
				if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
					this.m_limitState = b2Joint.e_equalLimits;
				}
				else if (jointTransition <= this.m_lowerTranslation) {
					if (this.m_limitState != b2Joint.e_atLowerLimit) {
						this.m_limitState = b2Joint.e_atLowerLimit;
						this.m_impulse.y = 0.0;
					}
				}
				else if (jointTransition >= this.m_upperTranslation) {
					if (this.m_limitState != b2Joint.e_atUpperLimit) {
						this.m_limitState = b2Joint.e_atUpperLimit;
						this.m_impulse.y = 0.0;
					}
				}
				else {
					this.m_limitState = b2Joint.e_inactiveLimit;
					this.m_impulse.y = 0.0;
				}
			}
			else {
				this.m_limitState = b2Joint.e_inactiveLimit;
			}
			if (this.m_enableMotor == false) {
				this.m_motorImpulse = 0.0;
			}
			if (step.warmStarting) {
				this.m_impulse.x *= step.dtRatio;
				this.m_impulse.y *= step.dtRatio;
				this.m_motorImpulse *= step.dtRatio;
				var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
				var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
				var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
				var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
				bA.m_linearVelocity.x -= this.m_invMassA * PX;
				bA.m_linearVelocity.y -= this.m_invMassA * PY;
				bA.m_angularVelocity -= this.m_invIA * L1;
				bB.m_linearVelocity.x += this.m_invMassB * PX;
				bB.m_linearVelocity.y += this.m_invMassB * PY;
				bB.m_angularVelocity += this.m_invIB * L2;
			}
			else {
				this.m_impulse.SetZero();
				this.m_motorImpulse = 0.0;
			}
		}
		b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var v1 = bA.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var v2 = bB.m_linearVelocity;
			var w2 = bB.m_angularVelocity;
			var PX = 0;
			var PY = 0;
			var L1 = 0;
			var L2 = 0;
			if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
				var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
				var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
				var oldImpulse = this.m_motorImpulse;
				var maxImpulse = step.dt * this.m_maxMotorForce;
				this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
				impulse = this.m_motorImpulse - oldImpulse;
				PX = impulse * this.m_axis.x;
				PY = impulse * this.m_axis.y;
				L1 = impulse * this.m_a1;
				L2 = impulse * this.m_a2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
			if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
				var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
				var f1 = this.m_impulse.Copy();
				var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
				this.m_impulse.Add(df);
				if (this.m_limitState == b2Joint.e_atLowerLimit) {
					this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
				}
				else if (this.m_limitState == b2Joint.e_atUpperLimit) {
					this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
				}
				var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
				var f2r = 0;
				if (this.m_K.col1.x != 0.0) {
					f2r = b / this.m_K.col1.x + f1.x;
				}
				else {
					f2r = f1.x;
				}
				this.m_impulse.x = f2r;
				df.x = this.m_impulse.x - f1.x;
				df.y = this.m_impulse.y - f1.y;
				PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
				PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
				L1 = df.x * this.m_s1 + df.y * this.m_a1;
				L2 = df.x * this.m_s2 + df.y * this.m_a2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			else {
				var df2 = 0;
				if (this.m_K.col1.x != 0.0) {
					df2 = ((-Cdot1)) / this.m_K.col1.x;
				}
				else {
					df2 = 0.0;
				}
				this.m_impulse.x += df2;
				PX = df2 * this.m_perp.x;
				PY = df2 * this.m_perp.y;
				L1 = df2 * this.m_s1;
				L2 = df2 * this.m_s2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			bA.m_linearVelocity.SetV(v1);
			bA.m_angularVelocity = w1;
			bB.m_linearVelocity.SetV(v2);
			bB.m_angularVelocity = w2;
		}
		b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			var limitC = 0;
			var oldLimitImpulse = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var c1 = bA.m_sweep.c;
			var a1 = bA.m_sweep.a;
			var c2 = bB.m_sweep.c;
			var a2 = bB.m_sweep.a;
			var tMat;
			var tX = 0;
			var m1 = 0;
			var m2 = 0;
			var i1 = 0;
			var i2 = 0;
			var linearError = 0.0;
			var angularError = 0.0;
			var active = false;
			var C2 = 0.0;
			var R1 = b2Mat22.FromAngle(a1);
			var R2 = b2Mat22.FromAngle(a2);
			tMat = R1;
			var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
			var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = R2;
			var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
			var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = c2.x + r2X - c1.x - r1X;
			var dY = c2.y + r2Y - c1.y - r1Y;
			if (this.m_enableLimit) {
				this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
				this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
				this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
				var translation = this.m_axis.x * dX + this.m_axis.y * dY;
				if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
					C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
					linearError = b2Math.Abs(translation);
					active = true;
				}
				else if (translation <= this.m_lowerTranslation) {
					C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
					linearError = this.m_lowerTranslation - translation;
					active = true;
				}
				else if (translation >= this.m_upperTranslation) {
					C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
					linearError = translation - this.m_upperTranslation;
					active = true;
				}
			}
			this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
			this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
			this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
			var impulse = new b2Vec2();
			var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
			linearError = b2Math.Max(linearError, b2Math.Abs(C1));
			angularError = 0.0;
			if (active) {
				m1 = this.m_invMassA;
				m2 = this.m_invMassB;
				i1 = this.m_invIA;
				i2 = this.m_invIB;
				this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
				this.m_K.col2.x = this.m_K.col1.y;
				this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
				this.m_K.Solve(impulse, (-C1), (-C2));
			}
			else {
				m1 = this.m_invMassA;
				m2 = this.m_invMassB;
				i1 = this.m_invIA;
				i2 = this.m_invIB;
				var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				var impulse1 = 0;
				if (k11 != 0.0) {
					impulse1 = ((-C1)) / k11;
				}
				else {
					impulse1 = 0.0;
				}
				impulse.x = impulse1;
				impulse.y = 0.0;
			}
			var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
			var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
			var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
			var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
			c1.x -= this.m_invMassA * PX;
			c1.y -= this.m_invMassA * PY;
			a1 -= this.m_invIA * L1;
			c2.x += this.m_invMassB * PX;
			c2.y += this.m_invMassB * PY;
			a2 += this.m_invIB * L2;
			bA.m_sweep.a = a1;
			bB.m_sweep.a = a2;
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
		}
		Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2LineJointDef.b2LineJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
			this.localAxisA = new b2Vec2();
		};
		b2LineJointDef.prototype.b2LineJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_lineJoint;
			this.localAxisA.Set(1.0, 0.0);
			this.enableLimit = false;
			this.lowerTranslation = 0.0;
			this.upperTranslation = 0.0;
			this.enableMotor = false;
			this.maxMotorForce = 0.0;
			this.motorSpeed = 0.0;
		}
		b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
			this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
			this.localAxisA = this.bodyA.GetLocalVector(axis);
		}
		Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
		b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2MouseJoint.b2MouseJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.K = new b2Mat22();
			this.K1 = new b2Mat22();
			this.K2 = new b2Mat22();
			this.m_localAnchor = new b2Vec2();
			this.m_target = new b2Vec2();
			this.m_impulse = new b2Vec2();
			this.m_mass = new b2Mat22();
			this.m_C = new b2Vec2();
		};
		b2MouseJoint.prototype.GetAnchorA = function () {
			return this.m_target;
		}
		b2MouseJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
		}
		b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
		}
		b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return 0.0;
		}
		b2MouseJoint.prototype.GetTarget = function () {
			return this.m_target;
		}
		b2MouseJoint.prototype.SetTarget = function (target) {
			if (this.m_bodyB.IsAwake() == false) {
				this.m_bodyB.SetAwake(true);
			}
			this.m_target = target;
		}
		b2MouseJoint.prototype.GetMaxForce = function () {
			return this.m_maxForce;
		}
		b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
			if (maxForce === undefined) maxForce = 0;
			this.m_maxForce = maxForce;
		}
		b2MouseJoint.prototype.GetFrequency = function () {
			return this.m_frequencyHz;
		}
		b2MouseJoint.prototype.SetFrequency = function (hz) {
			if (hz === undefined) hz = 0;
			this.m_frequencyHz = hz;
		}
		b2MouseJoint.prototype.GetDampingRatio = function () {
			return this.m_dampingRatio;
		}
		b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
			if (ratio === undefined) ratio = 0;
			this.m_dampingRatio = ratio;
		}
		b2MouseJoint.prototype.b2MouseJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			this.m_target.SetV(def.target);
			var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
			var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
			var tMat = this.m_bodyB.m_xf.R;
			this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
			this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
			this.m_maxForce = def.maxForce;
			this.m_impulse.SetZero();
			this.m_frequencyHz = def.frequencyHz;
			this.m_dampingRatio = def.dampingRatio;
			this.m_beta = 0.0;
			this.m_gamma = 0.0;
		}
		b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
			var b = this.m_bodyB;
			var mass = b.GetMass();
			var omega = 2.0 * Math.PI * this.m_frequencyHz;
			var d = 2.0 * mass * this.m_dampingRatio * omega;
			var k = mass * omega * omega;
			this.m_gamma = step.dt * (d + step.dt * k);
			this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
			this.m_beta = step.dt * k * this.m_gamma;
			var tMat;
			tMat = b.m_xf.R;
			var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
			var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * rX + tMat.col2.x * rY);
			rY = (tMat.col1.y * rX + tMat.col2.y * rY);
			rX = tX;
			var invMass = b.m_invMass;
			var invI = b.m_invI;
			this.K1.col1.x = invMass;
			this.K1.col2.x = 0.0;
			this.K1.col1.y = 0.0;
			this.K1.col2.y = invMass;
			this.K2.col1.x = invI * rY * rY;
			this.K2.col2.x = (-invI * rX * rY);
			this.K2.col1.y = (-invI * rX * rY);
			this.K2.col2.y = invI * rX * rX;
			this.K.SetM(this.K1);
			this.K.AddM(this.K2);
			this.K.col1.x += this.m_gamma;
			this.K.col2.y += this.m_gamma;
			this.K.GetInverse(this.m_mass);
			this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
			this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
			b.m_angularVelocity *= 0.98;
			this.m_impulse.x *= step.dtRatio;
			this.m_impulse.y *= step.dtRatio;
			b.m_linearVelocity.x += invMass * this.m_impulse.x;
			b.m_linearVelocity.y += invMass * this.m_impulse.y;
			b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
		}
		b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
			var b = this.m_bodyB;
			var tMat;
			var tX = 0;
			var tY = 0;
			tMat = b.m_xf.R;
			var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
			var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rX + tMat.col2.x * rY);
			rY = (tMat.col1.y * rX + tMat.col2.y * rY);
			rX = tX;
			var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
			var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
			tMat = this.m_mass;
			tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
			tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
			var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
			var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
			var oldImpulseX = this.m_impulse.x;
			var oldImpulseY = this.m_impulse.y;
			this.m_impulse.x += impulseX;
			this.m_impulse.y += impulseY;
			var maxImpulse = step.dt * this.m_maxForce;
			if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
				this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
			}
			impulseX = this.m_impulse.x - oldImpulseX;
			impulseY = this.m_impulse.y - oldImpulseY;
			b.m_linearVelocity.x += b.m_invMass * impulseX;
			b.m_linearVelocity.y += b.m_invMass * impulseY;
			b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
		}
		b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			return true;
		}
		Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2MouseJointDef.b2MouseJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.target = new b2Vec2();
		};
		b2MouseJointDef.prototype.b2MouseJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_mouseJoint;
			this.maxForce = 0.0;
			this.frequencyHz = 5.0;
			this.dampingRatio = 0.7;
		}
		Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
		b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2PrismaticJoint.b2PrismaticJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_localXAxis1 = new b2Vec2();
			this.m_localYAxis1 = new b2Vec2();
			this.m_axis = new b2Vec2();
			this.m_perp = new b2Vec2();
			this.m_K = new b2Mat33();
			this.m_impulse = new b2Vec3();
		};
		b2PrismaticJoint.prototype.GetAnchorA = function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2PrismaticJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
		}
		b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_impulse.y;
		}
		b2PrismaticJoint.prototype.GetJointTranslation = function () {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var p1 = bA.GetWorldPoint(this.m_localAnchor1);
			var p2 = bB.GetWorldPoint(this.m_localAnchor2);
			var dX = p2.x - p1.x;
			var dY = p2.y - p1.y;
			var axis = bA.GetWorldVector(this.m_localXAxis1);
			var translation = axis.x * dX + axis.y * dY;
			return translation;
		}
		b2PrismaticJoint.prototype.GetJointSpeed = function () {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var p1X = bA.m_sweep.c.x + r1X;
			var p1Y = bA.m_sweep.c.y + r1Y;
			var p2X = bB.m_sweep.c.x + r2X;
			var p2Y = bB.m_sweep.c.y + r2Y;
			var dX = p2X - p1X;
			var dY = p2Y - p1Y;
			var axis = bA.GetWorldVector(this.m_localXAxis1);
			var v1 = bA.m_linearVelocity;
			var v2 = bB.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var w2 = bB.m_angularVelocity;
			var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
			return speed;
		}
		b2PrismaticJoint.prototype.IsLimitEnabled = function () {
			return this.m_enableLimit;
		}
		b2PrismaticJoint.prototype.EnableLimit = function (flag) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableLimit = flag;
		}
		b2PrismaticJoint.prototype.GetLowerLimit = function () {
			return this.m_lowerTranslation;
		}
		b2PrismaticJoint.prototype.GetUpperLimit = function () {
			return this.m_upperTranslation;
		}
		b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
			if (lower === undefined) lower = 0;
			if (upper === undefined) upper = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_lowerTranslation = lower;
			this.m_upperTranslation = upper;
		}
		b2PrismaticJoint.prototype.IsMotorEnabled = function () {
			return this.m_enableMotor;
		}
		b2PrismaticJoint.prototype.EnableMotor = function (flag) {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableMotor = flag;
		}
		b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
			if (speed === undefined) speed = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = speed;
		}
		b2PrismaticJoint.prototype.GetMotorSpeed = function () {
			return this.m_motorSpeed;
		}
		b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
			if (force === undefined) force = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_maxMotorForce = force;
		}
		b2PrismaticJoint.prototype.GetMotorForce = function () {
			return this.m_motorImpulse;
		}
		b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			var tMat;
			var tX = 0;
			var tY = 0;
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_localXAxis1.SetV(def.localAxisA);
			this.m_localYAxis1.x = (-this.m_localXAxis1.y);
			this.m_localYAxis1.y = this.m_localXAxis1.x;
			this.m_refAngle = def.referenceAngle;
			this.m_impulse.SetZero();
			this.m_motorMass = 0.0;
			this.m_motorImpulse = 0.0;
			this.m_lowerTranslation = def.lowerTranslation;
			this.m_upperTranslation = def.upperTranslation;
			this.m_maxMotorForce = def.maxMotorForce;
			this.m_motorSpeed = def.motorSpeed;
			this.m_enableLimit = def.enableLimit;
			this.m_enableMotor = def.enableMotor;
			this.m_limitState = b2Joint.e_inactiveLimit;
			this.m_axis.SetZero();
			this.m_perp.SetZero();
		}
		b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var tX = 0;
			this.m_localCenterA.SetV(bA.GetLocalCenter());
			this.m_localCenterB.SetV(bB.GetLocalCenter());
			var xf1 = bA.GetTransform();
			var xf2 = bB.GetTransform();
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
			var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
			var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
			var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
			this.m_invMassA = bA.m_invMass;
			this.m_invMassB = bB.m_invMass;
			this.m_invIA = bA.m_invI;
			this.m_invIB = bB.m_invI;
			{
				this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
				this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
				this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
				this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
				if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
			}
			{
				this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
				this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
				this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
				var m1 = this.m_invMassA;
				var m2 = this.m_invMassB;
				var i1 = this.m_invIA;
				var i2 = this.m_invIB;
				this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
				this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
				this.m_K.col2.x = this.m_K.col1.y;
				this.m_K.col2.y = i1 + i2;
				this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
				this.m_K.col3.x = this.m_K.col1.z;
				this.m_K.col3.y = this.m_K.col2.z;
				this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
			}
			if (this.m_enableLimit) {
				var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
				if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
					this.m_limitState = b2Joint.e_equalLimits;
				}
				else if (jointTransition <= this.m_lowerTranslation) {
					if (this.m_limitState != b2Joint.e_atLowerLimit) {
						this.m_limitState = b2Joint.e_atLowerLimit;
						this.m_impulse.z = 0.0;
					}
				}
				else if (jointTransition >= this.m_upperTranslation) {
					if (this.m_limitState != b2Joint.e_atUpperLimit) {
						this.m_limitState = b2Joint.e_atUpperLimit;
						this.m_impulse.z = 0.0;
					}
				}
				else {
					this.m_limitState = b2Joint.e_inactiveLimit;
					this.m_impulse.z = 0.0;
				}
			}
			else {
				this.m_limitState = b2Joint.e_inactiveLimit;
			}
			if (this.m_enableMotor == false) {
				this.m_motorImpulse = 0.0;
			}
			if (step.warmStarting) {
				this.m_impulse.x *= step.dtRatio;
				this.m_impulse.y *= step.dtRatio;
				this.m_motorImpulse *= step.dtRatio;
				var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
				var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
				var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
				var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
				bA.m_linearVelocity.x -= this.m_invMassA * PX;
				bA.m_linearVelocity.y -= this.m_invMassA * PY;
				bA.m_angularVelocity -= this.m_invIA * L1;
				bB.m_linearVelocity.x += this.m_invMassB * PX;
				bB.m_linearVelocity.y += this.m_invMassB * PY;
				bB.m_angularVelocity += this.m_invIB * L2;
			}
			else {
				this.m_impulse.SetZero();
				this.m_motorImpulse = 0.0;
			}
		}
		b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var v1 = bA.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var v2 = bB.m_linearVelocity;
			var w2 = bB.m_angularVelocity;
			var PX = 0;
			var PY = 0;
			var L1 = 0;
			var L2 = 0;
			if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
				var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
				var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
				var oldImpulse = this.m_motorImpulse;
				var maxImpulse = step.dt * this.m_maxMotorForce;
				this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
				impulse = this.m_motorImpulse - oldImpulse;
				PX = impulse * this.m_axis.x;
				PY = impulse * this.m_axis.y;
				L1 = impulse * this.m_a1;
				L2 = impulse * this.m_a2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
			var Cdot1Y = w2 - w1;
			if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
				var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
				var f1 = this.m_impulse.Copy();
				var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
				this.m_impulse.Add(df);
				if (this.m_limitState == b2Joint.e_atLowerLimit) {
					this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
				}
				else if (this.m_limitState == b2Joint.e_atUpperLimit) {
					this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
				}
				var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
				var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
				var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
				f2r.x += f1.x;
				f2r.y += f1.y;
				this.m_impulse.x = f2r.x;
				this.m_impulse.y = f2r.y;
				df.x = this.m_impulse.x - f1.x;
				df.y = this.m_impulse.y - f1.y;
				df.z = this.m_impulse.z - f1.z;
				PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
				PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
				L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
				L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			else {
				var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
				this.m_impulse.x += df2.x;
				this.m_impulse.y += df2.y;
				PX = df2.x * this.m_perp.x;
				PY = df2.x * this.m_perp.y;
				L1 = df2.x * this.m_s1 + df2.y;
				L2 = df2.x * this.m_s2 + df2.y;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			bA.m_linearVelocity.SetV(v1);
			bA.m_angularVelocity = w1;
			bB.m_linearVelocity.SetV(v2);
			bB.m_angularVelocity = w2;
		}
		b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			var limitC = 0;
			var oldLimitImpulse = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var c1 = bA.m_sweep.c;
			var a1 = bA.m_sweep.a;
			var c2 = bB.m_sweep.c;
			var a2 = bB.m_sweep.a;
			var tMat;
			var tX = 0;
			var m1 = 0;
			var m2 = 0;
			var i1 = 0;
			var i2 = 0;
			var linearError = 0.0;
			var angularError = 0.0;
			var active = false;
			var C2 = 0.0;
			var R1 = b2Mat22.FromAngle(a1);
			var R2 = b2Mat22.FromAngle(a2);
			tMat = R1;
			var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
			var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = R2;
			var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
			var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = c2.x + r2X - c1.x - r1X;
			var dY = c2.y + r2Y - c1.y - r1Y;
			if (this.m_enableLimit) {
				this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
				this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
				this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
				var translation = this.m_axis.x * dX + this.m_axis.y * dY;
				if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
					C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
					linearError = b2Math.Abs(translation);
					active = true;
				}
				else if (translation <= this.m_lowerTranslation) {
					C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
					linearError = this.m_lowerTranslation - translation;
					active = true;
				}
				else if (translation >= this.m_upperTranslation) {
					C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
					linearError = translation - this.m_upperTranslation;
					active = true;
				}
			}
			this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
			this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
			this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
			var impulse = new b2Vec3();
			var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
			var C1Y = a2 - a1 - this.m_refAngle;
			linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
			angularError = b2Math.Abs(C1Y);
			if (active) {
				m1 = this.m_invMassA;
				m2 = this.m_invMassB;
				i1 = this.m_invIA;
				i2 = this.m_invIB;
				this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
				this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
				this.m_K.col2.x = this.m_K.col1.y;
				this.m_K.col2.y = i1 + i2;
				this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
				this.m_K.col3.x = this.m_K.col1.z;
				this.m_K.col3.y = this.m_K.col2.z;
				this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
				this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
			}
			else {
				m1 = this.m_invMassA;
				m2 = this.m_invMassB;
				i1 = this.m_invIA;
				i2 = this.m_invIB;
				var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				var k12 = i1 * this.m_s1 + i2 * this.m_s2;
				var k22 = i1 + i2;
				this.m_K.col1.Set(k11, k12, 0.0);
				this.m_K.col2.Set(k12, k22, 0.0);
				var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
				impulse.x = impulse1.x;
				impulse.y = impulse1.y;
				impulse.z = 0.0;
			}
			var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
			var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
			var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
			var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
			c1.x -= this.m_invMassA * PX;
			c1.y -= this.m_invMassA * PY;
			a1 -= this.m_invIA * L1;
			c2.x += this.m_invMassB * PX;
			c2.y += this.m_invMassB * PY;
			a2 += this.m_invIB * L2;
			bA.m_sweep.a = a1;
			bB.m_sweep.a = a2;
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
		}
		Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2PrismaticJointDef.b2PrismaticJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
			this.localAxisA = new b2Vec2();
		};
		b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_prismaticJoint;
			this.localAxisA.Set(1.0, 0.0);
			this.referenceAngle = 0.0;
			this.enableLimit = false;
			this.lowerTranslation = 0.0;
			this.upperTranslation = 0.0;
			this.enableMotor = false;
			this.maxMotorForce = 0.0;
			this.motorSpeed = 0.0;
		}
		b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
			this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
			this.localAxisA = this.bodyA.GetLocalVector(axis);
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		}
		Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
		b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2PulleyJoint.b2PulleyJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_groundAnchor1 = new b2Vec2();
			this.m_groundAnchor2 = new b2Vec2();
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_u1 = new b2Vec2();
			this.m_u2 = new b2Vec2();
		};
		b2PulleyJoint.prototype.GetAnchorA = function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2PulleyJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
		}
		b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return 0.0;
		}
		b2PulleyJoint.prototype.GetGroundAnchorA = function () {
			var a = this.m_ground.m_xf.position.Copy();
			a.Add(this.m_groundAnchor1);
			return a;
		}
		b2PulleyJoint.prototype.GetGroundAnchorB = function () {
			var a = this.m_ground.m_xf.position.Copy();
			a.Add(this.m_groundAnchor2);
			return a;
		}
		b2PulleyJoint.prototype.GetLength1 = function () {
			var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
			var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
			var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
			var dX = p.x - sX;
			var dY = p.y - sY;
			return Math.sqrt(dX * dX + dY * dY);
		}
		b2PulleyJoint.prototype.GetLength2 = function () {
			var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
			var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
			var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
			var dX = p.x - sX;
			var dY = p.y - sY;
			return Math.sqrt(dX * dX + dY * dY);
		}
		b2PulleyJoint.prototype.GetRatio = function () {
			return this.m_ratio;
		}
		b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			var tMat;
			var tX = 0;
			var tY = 0;
			this.m_ground = this.m_bodyA.m_world.m_groundBody;
			this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
			this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
			this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
			this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_ratio = def.ratio;
			this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
			this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
			this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
			this.m_impulse = 0.0;
			this.m_limitImpulse1 = 0.0;
			this.m_limitImpulse2 = 0.0;
		}
		b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var p1X = bA.m_sweep.c.x + r1X;
			var p1Y = bA.m_sweep.c.y + r1Y;
			var p2X = bB.m_sweep.c.x + r2X;
			var p2Y = bB.m_sweep.c.y + r2Y;
			var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
			var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
			var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
			var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
			this.m_u1.Set(p1X - s1X, p1Y - s1Y);
			this.m_u2.Set(p2X - s2X, p2Y - s2Y);
			var length1 = this.m_u1.Length();
			var length2 = this.m_u2.Length();
			if (length1 > b2Settings.b2_linearSlop) {
				this.m_u1.Multiply(1.0 / length1);
			}
			else {
				this.m_u1.SetZero();
			}
			if (length2 > b2Settings.b2_linearSlop) {
				this.m_u2.Multiply(1.0 / length2);
			}
			else {
				this.m_u2.SetZero();
			}
			var C = this.m_constant - length1 - this.m_ratio * length2;
			if (C > 0.0) {
				this.m_state = b2Joint.e_inactiveLimit;
				this.m_impulse = 0.0;
			}
			else {
				this.m_state = b2Joint.e_atUpperLimit;
			}
			if (length1 < this.m_maxLength1) {
				this.m_limitState1 = b2Joint.e_inactiveLimit;
				this.m_limitImpulse1 = 0.0;
			}
			else {
				this.m_limitState1 = b2Joint.e_atUpperLimit;
			}
			if (length2 < this.m_maxLength2) {
				this.m_limitState2 = b2Joint.e_inactiveLimit;
				this.m_limitImpulse2 = 0.0;
			}
			else {
				this.m_limitState2 = b2Joint.e_atUpperLimit;
			}
			var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
			var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
			this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
			this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
			this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
			this.m_limitMass1 = 1.0 / this.m_limitMass1;
			this.m_limitMass2 = 1.0 / this.m_limitMass2;
			this.m_pulleyMass = 1.0 / this.m_pulleyMass;
			if (step.warmStarting) {
				this.m_impulse *= step.dtRatio;
				this.m_limitImpulse1 *= step.dtRatio;
				this.m_limitImpulse2 *= step.dtRatio;
				var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
				var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
				var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
				var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
				bA.m_linearVelocity.x += bA.m_invMass * P1X;
				bA.m_linearVelocity.y += bA.m_invMass * P1Y;
				bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
				bB.m_linearVelocity.x += bB.m_invMass * P2X;
				bB.m_linearVelocity.y += bB.m_invMass * P2Y;
				bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
			}
			else {
				this.m_impulse = 0.0;
				this.m_limitImpulse1 = 0.0;
				this.m_limitImpulse2 = 0.0;
			}
		}
		b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var v1X = 0;
			var v1Y = 0;
			var v2X = 0;
			var v2Y = 0;
			var P1X = 0;
			var P1Y = 0;
			var P2X = 0;
			var P2Y = 0;
			var Cdot = 0;
			var impulse = 0;
			var oldImpulse = 0;
			if (this.m_state == b2Joint.e_atUpperLimit) {
				v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
				v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
				v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
				v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
				Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
				impulse = this.m_pulleyMass * ((-Cdot));
				oldImpulse = this.m_impulse;
				this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
				impulse = this.m_impulse - oldImpulse;
				P1X = (-impulse * this.m_u1.x);
				P1Y = (-impulse * this.m_u1.y);
				P2X = (-this.m_ratio * impulse * this.m_u2.x);
				P2Y = (-this.m_ratio * impulse * this.m_u2.y);
				bA.m_linearVelocity.x += bA.m_invMass * P1X;
				bA.m_linearVelocity.y += bA.m_invMass * P1Y;
				bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
				bB.m_linearVelocity.x += bB.m_invMass * P2X;
				bB.m_linearVelocity.y += bB.m_invMass * P2Y;
				bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
			}
			if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
				v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
				v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
				Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
				impulse = (-this.m_limitMass1 * Cdot);
				oldImpulse = this.m_limitImpulse1;
				this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
				impulse = this.m_limitImpulse1 - oldImpulse;
				P1X = (-impulse * this.m_u1.x);
				P1Y = (-impulse * this.m_u1.y);
				bA.m_linearVelocity.x += bA.m_invMass * P1X;
				bA.m_linearVelocity.y += bA.m_invMass * P1Y;
				bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
			}
			if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
				v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
				v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
				Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
				impulse = (-this.m_limitMass2 * Cdot);
				oldImpulse = this.m_limitImpulse2;
				this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
				impulse = this.m_limitImpulse2 - oldImpulse;
				P2X = (-impulse * this.m_u2.x);
				P2Y = (-impulse * this.m_u2.y);
				bB.m_linearVelocity.x += bB.m_invMass * P2X;
				bB.m_linearVelocity.y += bB.m_invMass * P2Y;
				bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
			}
		}
		b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
			var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
			var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
			var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
			var r1X = 0;
			var r1Y = 0;
			var r2X = 0;
			var r2Y = 0;
			var p1X = 0;
			var p1Y = 0;
			var p2X = 0;
			var p2Y = 0;
			var length1 = 0;
			var length2 = 0;
			var C = 0;
			var impulse = 0;
			var oldImpulse = 0;
			var oldLimitPositionImpulse = 0;
			var tX = 0;
			var linearError = 0.0;
			if (this.m_state == b2Joint.e_atUpperLimit) {
				tMat = bA.m_xf.R;
				r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				tMat = bB.m_xf.R;
				r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				p1X = bA.m_sweep.c.x + r1X;
				p1Y = bA.m_sweep.c.y + r1Y;
				p2X = bB.m_sweep.c.x + r2X;
				p2Y = bB.m_sweep.c.y + r2Y;
				this.m_u1.Set(p1X - s1X, p1Y - s1Y);
				this.m_u2.Set(p2X - s2X, p2Y - s2Y);
				length1 = this.m_u1.Length();
				length2 = this.m_u2.Length();
				if (length1 > b2Settings.b2_linearSlop) {
					this.m_u1.Multiply(1.0 / length1);
				}
				else {
					this.m_u1.SetZero();
				}
				if (length2 > b2Settings.b2_linearSlop) {
					this.m_u2.Multiply(1.0 / length2);
				}
				else {
					this.m_u2.SetZero();
				}
				C = this.m_constant - length1 - this.m_ratio * length2;
				linearError = b2Math.Max(linearError, (-C));
				C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
				impulse = (-this.m_pulleyMass * C);
				p1X = (-impulse * this.m_u1.x);
				p1Y = (-impulse * this.m_u1.y);
				p2X = (-this.m_ratio * impulse * this.m_u2.x);
				p2Y = (-this.m_ratio * impulse * this.m_u2.y);
				bA.m_sweep.c.x += bA.m_invMass * p1X;
				bA.m_sweep.c.y += bA.m_invMass * p1Y;
				bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
				bB.m_sweep.c.x += bB.m_invMass * p2X;
				bB.m_sweep.c.y += bB.m_invMass * p2Y;
				bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
				bA.SynchronizeTransform();
				bB.SynchronizeTransform();
			}
			if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
				tMat = bA.m_xf.R;
				r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				p1X = bA.m_sweep.c.x + r1X;
				p1Y = bA.m_sweep.c.y + r1Y;
				this.m_u1.Set(p1X - s1X, p1Y - s1Y);
				length1 = this.m_u1.Length();
				if (length1 > b2Settings.b2_linearSlop) {
					this.m_u1.x *= 1.0 / length1;
					this.m_u1.y *= 1.0 / length1;
				}
				else {
					this.m_u1.SetZero();
				}
				C = this.m_maxLength1 - length1;
				linearError = b2Math.Max(linearError, (-C));
				C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
				impulse = (-this.m_limitMass1 * C);
				p1X = (-impulse * this.m_u1.x);
				p1Y = (-impulse * this.m_u1.y);
				bA.m_sweep.c.x += bA.m_invMass * p1X;
				bA.m_sweep.c.y += bA.m_invMass * p1Y;
				bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
				bA.SynchronizeTransform();
			}
			if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
				tMat = bB.m_xf.R;
				r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				p2X = bB.m_sweep.c.x + r2X;
				p2Y = bB.m_sweep.c.y + r2Y;
				this.m_u2.Set(p2X - s2X, p2Y - s2Y);
				length2 = this.m_u2.Length();
				if (length2 > b2Settings.b2_linearSlop) {
					this.m_u2.x *= 1.0 / length2;
					this.m_u2.y *= 1.0 / length2;
				}
				else {
					this.m_u2.SetZero();
				}
				C = this.m_maxLength2 - length2;
				linearError = b2Math.Max(linearError, (-C));
				C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
				impulse = (-this.m_limitMass2 * C);
				p2X = (-impulse * this.m_u2.x);
				p2Y = (-impulse * this.m_u2.y);
				bB.m_sweep.c.x += bB.m_invMass * p2X;
				bB.m_sweep.c.y += bB.m_invMass * p2Y;
				bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
				bB.SynchronizeTransform();
			}
			return linearError < b2Settings.b2_linearSlop;
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
		});
		Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2PulleyJointDef.b2PulleyJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.groundAnchorA = new b2Vec2();
			this.groundAnchorB = new b2Vec2();
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_pulleyJoint;
			this.groundAnchorA.Set((-1.0), 1.0);
			this.groundAnchorB.Set(1.0, 1.0);
			this.localAnchorA.Set((-1.0), 0.0);
			this.localAnchorB.Set(1.0, 0.0);
			this.lengthA = 0.0;
			this.maxLengthA = 0.0;
			this.lengthB = 0.0;
			this.maxLengthB = 0.0;
			this.ratio = 1.0;
			this.collideConnected = true;
		}
		b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
			if (r === undefined) r = 0;
			this.bodyA = bA;
			this.bodyB = bB;
			this.groundAnchorA.SetV(gaA);
			this.groundAnchorB.SetV(gaB);
			this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
			this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
			var d1X = anchorA.x - gaA.x;
			var d1Y = anchorA.y - gaA.y;
			this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
			var d2X = anchorB.x - gaB.x;
			var d2Y = anchorB.y - gaB.y;
			this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
			this.ratio = r;
			var C = this.lengthA + this.ratio * this.lengthB;
			this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
			this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
		}
		Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
		b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2RevoluteJoint.b2RevoluteJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.K = new b2Mat22();
			this.K1 = new b2Mat22();
			this.K2 = new b2Mat22();
			this.K3 = new b2Mat22();
			this.impulse3 = new b2Vec3();
			this.impulse2 = new b2Vec2();
			this.reduced = new b2Vec2();
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_impulse = new b2Vec3();
			this.m_mass = new b2Mat33();
		};
		b2RevoluteJoint.prototype.GetAnchorA = function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2RevoluteJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
		}
		b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_impulse.z;
		}
		b2RevoluteJoint.prototype.GetJointAngle = function () {
			return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
		}
		b2RevoluteJoint.prototype.GetJointSpeed = function () {
			return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
		}
		b2RevoluteJoint.prototype.IsLimitEnabled = function () {
			return this.m_enableLimit;
		}
		b2RevoluteJoint.prototype.EnableLimit = function (flag) {
			this.m_enableLimit = flag;
		}
		b2RevoluteJoint.prototype.GetLowerLimit = function () {
			return this.m_lowerAngle;
		}
		b2RevoluteJoint.prototype.GetUpperLimit = function () {
			return this.m_upperAngle;
		}
		b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
			if (lower === undefined) lower = 0;
			if (upper === undefined) upper = 0;
			this.m_lowerAngle = lower;
			this.m_upperAngle = upper;
		}
		b2RevoluteJoint.prototype.IsMotorEnabled = function () {
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			return this.m_enableMotor;
		}
		b2RevoluteJoint.prototype.EnableMotor = function (flag) {
			this.m_enableMotor = flag;
		}
		b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
			if (speed === undefined) speed = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = speed;
		}
		b2RevoluteJoint.prototype.GetMotorSpeed = function () {
			return this.m_motorSpeed;
		}
		b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
			if (torque === undefined) torque = 0;
			this.m_maxMotorTorque = torque;
		}
		b2RevoluteJoint.prototype.GetMotorTorque = function () {
			return this.m_maxMotorTorque;
		}
		b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_referenceAngle = def.referenceAngle;
			this.m_impulse.SetZero();
			this.m_motorImpulse = 0.0;
			this.m_lowerAngle = def.lowerAngle;
			this.m_upperAngle = def.upperAngle;
			this.m_maxMotorTorque = def.maxMotorTorque;
			this.m_motorSpeed = def.motorSpeed;
			this.m_enableLimit = def.enableLimit;
			this.m_enableMotor = def.enableMotor;
			this.m_limitState = b2Joint.e_inactiveLimit;
		}
		b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var tX = 0;
			if (this.m_enableMotor || this.m_enableLimit) {
			}
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var m1 = bA.m_invMass;
			var m2 = bB.m_invMass;
			var i1 = bA.m_invI;
			var i2 = bB.m_invI;
			this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
			this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
			this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
			this.m_mass.col1.y = this.m_mass.col2.x;
			this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
			this.m_mass.col3.y = r1X * i1 + r2X * i2;
			this.m_mass.col1.z = this.m_mass.col3.x;
			this.m_mass.col2.z = this.m_mass.col3.y;
			this.m_mass.col3.z = i1 + i2;
			this.m_motorMass = 1.0 / (i1 + i2);
			if (this.m_enableMotor == false) {
				this.m_motorImpulse = 0.0;
			}
			if (this.m_enableLimit) {
				var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
				if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
					this.m_limitState = b2Joint.e_equalLimits;
				}
				else if (jointAngle <= this.m_lowerAngle) {
					if (this.m_limitState != b2Joint.e_atLowerLimit) {
						this.m_impulse.z = 0.0;
					}
					this.m_limitState = b2Joint.e_atLowerLimit;
				}
				else if (jointAngle >= this.m_upperAngle) {
					if (this.m_limitState != b2Joint.e_atUpperLimit) {
						this.m_impulse.z = 0.0;
					}
					this.m_limitState = b2Joint.e_atUpperLimit;
				}
				else {
					this.m_limitState = b2Joint.e_inactiveLimit;
					this.m_impulse.z = 0.0;
				}
			}
			else {
				this.m_limitState = b2Joint.e_inactiveLimit;
			}
			if (step.warmStarting) {
				this.m_impulse.x *= step.dtRatio;
				this.m_impulse.y *= step.dtRatio;
				this.m_motorImpulse *= step.dtRatio;
				var PX = this.m_impulse.x;
				var PY = this.m_impulse.y;
				bA.m_linearVelocity.x -= m1 * PX;
				bA.m_linearVelocity.y -= m1 * PY;
				bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
				bB.m_linearVelocity.x += m2 * PX;
				bB.m_linearVelocity.y += m2 * PY;
				bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
			}
			else {
				this.m_impulse.SetZero();
				this.m_motorImpulse = 0.0;
			}
		}
		b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var tX = 0;
			var newImpulse = 0;
			var r1X = 0;
			var r1Y = 0;
			var r2X = 0;
			var r2Y = 0;
			var v1 = bA.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var v2 = bB.m_linearVelocity;
			var w2 = bB.m_angularVelocity;
			var m1 = bA.m_invMass;
			var m2 = bB.m_invMass;
			var i1 = bA.m_invI;
			var i2 = bB.m_invI;
			if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
				var Cdot = w2 - w1 - this.m_motorSpeed;
				var impulse = this.m_motorMass * ((-Cdot));
				var oldImpulse = this.m_motorImpulse;
				var maxImpulse = step.dt * this.m_maxMotorTorque;
				this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
				impulse = this.m_motorImpulse - oldImpulse;
				w1 -= i1 * impulse;
				w2 += i2 * impulse;
			}
			if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
				tMat = bA.m_xf.R;
				r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				tMat = bB.m_xf.R;
				r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
				var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
				var Cdot2 = w2 - w1;
				this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
				if (this.m_limitState == b2Joint.e_equalLimits) {
					this.m_impulse.Add(this.impulse3);
				}
				else if (this.m_limitState == b2Joint.e_atLowerLimit) {
					newImpulse = this.m_impulse.z + this.impulse3.z;
					if (newImpulse < 0.0) {
						this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
						this.impulse3.x = this.reduced.x;
						this.impulse3.y = this.reduced.y;
						this.impulse3.z = (-this.m_impulse.z);
						this.m_impulse.x += this.reduced.x;
						this.m_impulse.y += this.reduced.y;
						this.m_impulse.z = 0.0;
					}
				}
				else if (this.m_limitState == b2Joint.e_atUpperLimit) {
					newImpulse = this.m_impulse.z + this.impulse3.z;
					if (newImpulse > 0.0) {
						this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
						this.impulse3.x = this.reduced.x;
						this.impulse3.y = this.reduced.y;
						this.impulse3.z = (-this.m_impulse.z);
						this.m_impulse.x += this.reduced.x;
						this.m_impulse.y += this.reduced.y;
						this.m_impulse.z = 0.0;
					}
				}
				v1.x -= m1 * this.impulse3.x;
				v1.y -= m1 * this.impulse3.y;
				w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
				v2.x += m2 * this.impulse3.x;
				v2.y += m2 * this.impulse3.y;
				w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
			}
			else {
				tMat = bA.m_xf.R;
				r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				tMat = bB.m_xf.R;
				r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
				var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
				this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
				this.m_impulse.x += this.impulse2.x;
				this.m_impulse.y += this.impulse2.y;
				v1.x -= m1 * this.impulse2.x;
				v1.y -= m1 * this.impulse2.y;
				w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
				v2.x += m2 * this.impulse2.x;
				v2.y += m2 * this.impulse2.y;
				w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
			}
			bA.m_linearVelocity.SetV(v1);
			bA.m_angularVelocity = w1;
			bB.m_linearVelocity.SetV(v2);
			bB.m_angularVelocity = w2;
		}
		b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			var oldLimitImpulse = 0;
			var C = 0;
			var tMat;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var angularError = 0.0;
			var positionError = 0.0;
			var tX = 0;
			var impulseX = 0;
			var impulseY = 0;
			if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
				var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
				var limitImpulse = 0.0;
				if (this.m_limitState == b2Joint.e_equalLimits) {
					C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
					limitImpulse = (-this.m_motorMass * C);
					angularError = b2Math.Abs(C);
				}
				else if (this.m_limitState == b2Joint.e_atLowerLimit) {
					C = angle - this.m_lowerAngle;
					angularError = (-C);
					C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
					limitImpulse = (-this.m_motorMass * C);
				}
				else if (this.m_limitState == b2Joint.e_atUpperLimit) {
					C = angle - this.m_upperAngle;
					angularError = C;
					C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
					limitImpulse = (-this.m_motorMass * C);
				}
				bA.m_sweep.a -= bA.m_invI * limitImpulse;
				bB.m_sweep.a += bB.m_invI * limitImpulse;
				bA.SynchronizeTransform();
				bB.SynchronizeTransform();
			}
			{
				tMat = bA.m_xf.R;
				var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				tMat = bB.m_xf.R;
				var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
				var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
				var CLengthSquared = CX * CX + CY * CY;
				var CLength = Math.sqrt(CLengthSquared);
				positionError = CLength;
				var invMass1 = bA.m_invMass;
				var invMass2 = bB.m_invMass;
				var invI1 = bA.m_invI;
				var invI2 = bB.m_invI;
				var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
				if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
					var uX = CX / CLength;
					var uY = CY / CLength;
					var k = invMass1 + invMass2;
					var m = 1.0 / k;
					impulseX = m * ((-CX));
					impulseY = m * ((-CY));
					var k_beta = 0.5;
					bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
					bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
					bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
					bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
					CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
					CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
				}
				this.K1.col1.x = invMass1 + invMass2;
				this.K1.col2.x = 0.0;
				this.K1.col1.y = 0.0;
				this.K1.col2.y = invMass1 + invMass2;
				this.K2.col1.x = invI1 * r1Y * r1Y;
				this.K2.col2.x = (-invI1 * r1X * r1Y);
				this.K2.col1.y = (-invI1 * r1X * r1Y);
				this.K2.col2.y = invI1 * r1X * r1X;
				this.K3.col1.x = invI2 * r2Y * r2Y;
				this.K3.col2.x = (-invI2 * r2X * r2Y);
				this.K3.col1.y = (-invI2 * r2X * r2Y);
				this.K3.col2.y = invI2 * r2X * r2X;
				this.K.SetM(this.K1);
				this.K.AddM(this.K2);
				this.K.AddM(this.K3);
				this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
				impulseX = b2RevoluteJoint.tImpulse.x;
				impulseY = b2RevoluteJoint.tImpulse.y;
				bA.m_sweep.c.x -= bA.m_invMass * impulseX;
				bA.m_sweep.c.y -= bA.m_invMass * impulseY;
				bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
				bB.m_sweep.c.x += bB.m_invMass * impulseX;
				bB.m_sweep.c.y += bB.m_invMass * impulseY;
				bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
				bA.SynchronizeTransform();
				bB.SynchronizeTransform();
			}
			return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
		}
		Box2D.postDefs.push(function () {
			Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
		});
		Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2RevoluteJointDef.b2RevoluteJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_revoluteJoint;
			this.localAnchorA.Set(0.0, 0.0);
			this.localAnchorB.Set(0.0, 0.0);
			this.referenceAngle = 0.0;
			this.lowerAngle = 0.0;
			this.upperAngle = 0.0;
			this.maxMotorTorque = 0.0;
			this.motorSpeed = 0.0;
			this.enableLimit = false;
			this.enableMotor = false;
		}
		b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
			this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		}
		Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
		b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2WeldJoint.b2WeldJoint = function () {
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchorA = new b2Vec2();
			this.m_localAnchorB = new b2Vec2();
			this.m_impulse = new b2Vec3();
			this.m_mass = new b2Mat33();
		};
		b2WeldJoint.prototype.GetAnchorA = function () {
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		}
		b2WeldJoint.prototype.GetAnchorB = function () {
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		}
		b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
		}
		b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_impulse.z;
		}
		b2WeldJoint.prototype.b2WeldJoint = function (def) {
			this.__super.b2Joint.call(this, def);
			this.m_localAnchorA.SetV(def.localAnchorA);
			this.m_localAnchorB.SetV(def.localAnchorB);
			this.m_referenceAngle = def.referenceAngle;
			this.m_impulse.SetZero();
			this.m_mass = new b2Mat33();
		}
		b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
			this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
			this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
			this.m_mass.col1.y = this.m_mass.col2.x;
			this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
			this.m_mass.col3.y = rAX * iA + rBX * iB;
			this.m_mass.col1.z = this.m_mass.col3.x;
			this.m_mass.col2.z = this.m_mass.col3.y;
			this.m_mass.col3.z = iA + iB;
			if (step.warmStarting) {
				this.m_impulse.x *= step.dtRatio;
				this.m_impulse.y *= step.dtRatio;
				this.m_impulse.z *= step.dtRatio;
				bA.m_linearVelocity.x -= mA * this.m_impulse.x;
				bA.m_linearVelocity.y -= mA * this.m_impulse.y;
				bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
				bB.m_linearVelocity.x += mB * this.m_impulse.x;
				bB.m_linearVelocity.y += mB * this.m_impulse.y;
				bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
			}
			else {
				this.m_impulse.SetZero();
			}
		}
		b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var vA = bA.m_linearVelocity;
			var wA = bA.m_angularVelocity;
			var vB = bB.m_linearVelocity;
			var wB = bB.m_angularVelocity;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
			var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
			var Cdot2 = wB - wA;
			var impulse = new b2Vec3();
			this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
			this.m_impulse.Add(impulse);
			vA.x -= mA * impulse.x;
			vA.y -= mA * impulse.y;
			wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
			vB.x += mB * impulse.x;
			vB.y += mB * impulse.y;
			wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
			bA.m_angularVelocity = wA;
			bB.m_angularVelocity = wB;
		}
		b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
			if (baumgarte === undefined) baumgarte = 0;
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
			var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
			var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
			var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
			var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
			var angularError = b2Math.Abs(C2);
			if (positionError > k_allowedStretch) {
				iA *= 1.0;
				iB *= 1.0;
			}
			this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
			this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
			this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
			this.m_mass.col1.y = this.m_mass.col2.x;
			this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
			this.m_mass.col3.y = rAX * iA + rBX * iB;
			this.m_mass.col1.z = this.m_mass.col3.x;
			this.m_mass.col2.z = this.m_mass.col3.y;
			this.m_mass.col3.z = iA + iB;
			var impulse = new b2Vec3();
			this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
			bA.m_sweep.c.x -= mA * impulse.x;
			bA.m_sweep.c.y -= mA * impulse.y;
			bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
			bB.m_sweep.c.x += mB * impulse.x;
			bB.m_sweep.c.y += mB * impulse.y;
			bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
		}
		Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2WeldJointDef.b2WeldJointDef = function () {
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2WeldJointDef.prototype.b2WeldJointDef = function () {
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_weldJoint;
			this.referenceAngle = 0.0;
		}
		b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
			this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		}
	})();
	(function () {
		var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
		b2DebugDraw.b2DebugDraw = function () {
			this.m_drawScale = 1.0;
			this.m_lineThickness = 1.0;
			this.m_alpha = 1.0;
			this.m_fillAlpha = 1.0;
			this.m_xformScale = 1.0;
			var __this = this;
			//#WORKAROUND
			this.m_sprite = {
				graphics: {
					clear: function () {
						//__this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
					},
					setTranslation: function (x, y) {
						__this.m_ctx.translate(x, y);
					},
				}
			};
		};
		b2DebugDraw.prototype._color = function (color, alpha) {
			return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
		};
		b2DebugDraw.prototype.b2DebugDraw = function () {
			this.m_drawFlags = 0;
		};
		b2DebugDraw.prototype.SetFlags = function (flags) {
			if (flags === undefined) flags = 0;
			this.m_drawFlags = flags;
		};
		b2DebugDraw.prototype.GetFlags = function () {
			return this.m_drawFlags;
		};
		b2DebugDraw.prototype.AppendFlags = function (flags) {
			if (flags === undefined) flags = 0;
			this.m_drawFlags |= flags;
		};
		b2DebugDraw.prototype.ClearFlags = function (flags) {
			if (flags === undefined) flags = 0;
			this.m_drawFlags &= ~flags;
		};
		b2DebugDraw.prototype.SetSprite = function (sprite) {
			this.m_ctx = sprite;
		};
		b2DebugDraw.prototype.GetSprite = function () {
			return this.m_ctx;
		};
		b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
			if (drawScale === undefined) drawScale = 0;
			this.m_drawScale = drawScale;
		};
		b2DebugDraw.prototype.GetDrawScale = function () {
			return this.m_drawScale;
		};
		b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
			if (lineThickness === undefined) lineThickness = 0;
			this.m_lineThickness = lineThickness;
			this.m_ctx.strokeWidth = lineThickness;
		};
		b2DebugDraw.prototype.GetLineThickness = function () {
			return this.m_lineThickness;
		};
		b2DebugDraw.prototype.SetAlpha = function (alpha) {
			if (alpha === undefined) alpha = 0;
			this.m_alpha = alpha;
		};
		b2DebugDraw.prototype.GetAlpha = function () {
			return this.m_alpha;
		};
		b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
			if (alpha === undefined) alpha = 0;
			this.m_fillAlpha = alpha;
		};
		b2DebugDraw.prototype.GetFillAlpha = function () {
			return this.m_fillAlpha;
		};
		b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
			if (xformScale === undefined) xformScale = 0;
			this.m_xformScale = xformScale;
		};
		b2DebugDraw.prototype.GetXFormScale = function () {
			return this.m_xformScale;
		};
		b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
			if (!vertexCount) return;
			var s = this.m_ctx;
			var drawScale = this.m_drawScale;
			s.beginPath();
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
			for (var i = 1; i < vertexCount; i++) {
				s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
			}
			s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
			s.closePath();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
			if (!vertexCount) return;
			var s = this.m_ctx;
			var drawScale = this.m_drawScale;
			s.beginPath();
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.fillStyle = this._color(color.color, this.m_fillAlpha);
			s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
			for (var i = 1; i < vertexCount; i++) {
				s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
			}
			s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
			s.closePath();
			s.fill();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
			if (!radius) return;
			var s = this.m_ctx;
			var drawScale = this.m_drawScale;
			s.beginPath();
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
			s.closePath();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
			if (!radius) return;
			var s = this.m_ctx,
				drawScale = this.m_drawScale,
				cx = center.x * drawScale,
				cy = center.y * drawScale;
			s.moveTo(0, 0);
			s.beginPath();
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.fillStyle = this._color(color.color, this.m_fillAlpha);
			s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
			s.moveTo(cx, cy);
			s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
			s.closePath();
			s.fill();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
			var s = this.m_ctx,
				drawScale = this.m_drawScale;
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.beginPath();
			s.moveTo(p1.x * drawScale, p1.y * drawScale);
			s.lineTo(p2.x * drawScale, p2.y * drawScale);
			s.closePath();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawTransform = function (xf) {
			var s = this.m_ctx,
				drawScale = this.m_drawScale;
			s.beginPath();
			s.strokeStyle = this._color(0xff0000, this.m_alpha);
			s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
			s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);
			
			s.strokeStyle = this._color(0xff00, this.m_alpha);
			s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
			s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
			s.closePath();
			s.stroke();
		};
	})(); //post-definitions
	var i;
	for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
	delete Box2D.postDefs;
	
	return Box2D;
});
},{"irrelon-appcore":125}],40:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeCannonComponent', function (IgeEventingClass) {
	var IgeCannonComponent = IgeEventingClass.extend({
		classId: 'IgeCannonComponent',
		componentId: 'cannon',
		
		init: function (entity, options) {
			this._entity = entity;
			this._options = options;
			
			this._active = true;
			this._sleep = true;
			this._scaleRatio = 1;
			this._solverIterations = 10;
			this._gravity = new CANNON.Vec3(0, 0, -60);
			this._broadphase = new CANNON.NaiveBroadphase();
			
			this._removeWhenReady = [];
			
			// Materials
			this._normalMaterial = new CANNON.Material("normalMaterial");
			
			// Create a slippery material (friction coefficient = 0.0)
			this._slipperyMaterial = new CANNON.Material("slipperyMaterial");
			
			// The ContactMaterial defines what happens when two materials meet.
			// In this case we want friction coefficient = 0.0 when the slippery material touches ground.
			this._slipperyNormalCm = new CANNON.ContactMaterial(
				this._normalMaterial,
				this._slipperyMaterial,
				0.0, // friction coefficient
				0.3  // restitution
			);
			
			// Add the cannon behaviour to the ige
			$ige.engine.addBehaviour('cannonStep', this._behaviour);
		},
		
		/**
		 * Gets / sets if the world should allow sleep or not.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		sleep: function (val) {
			if (val !== undefined) {
				this._sleep = val;
				return this._entity;
			}
			
			return this._sleep;
		},
		
		/**
		 * Gets / sets the current engine to cannon scaling ratio.
		 * @param val
		 * @return {*}
		 */
		scaleRatio: function (val) {
			if (val !== undefined) {
				this._scaleRatio = val;
				return this._entity;
			}
			
			return this._scaleRatio;
		},
		
		/**
		 * Gets / sets the gravity vector.
		 * @return {*}
		 */
		gravity: function (x, y, z) {
			if (x !== undefined && y !== undefined) {
				this._gravity = new CANNON.Vec3(x, y, z);
				if (this._world) {
					this._world.gravity.set(this._gravity.x, this._gravity.y, this._gravity.z);
				}
				return this._entity;
			}
			
			return this._gravity;
		},
		
		solverIterations: function () {
			if (val !== undefined) {
				this._solverIterations = val;
				return this._entity;
			}
			
			return this._solverIterations;
		},
		
		createWorld: function () {
			this._world = new CANNON.World();
			this._world.gravity.set(this._gravity.x, this._gravity.y, this._gravity.z);
			this._world.broadphase = this._broadphase;
			this._world.solver.iterations = this._solverIterations;
			this._world.allowSleep = this._sleep;
			
			// We must add the contact materials to the world
			this._world.addContactMaterial(this._slipperyNormalCm);
			
			return this._entity;
		},
		
		createFloor: function (normalX, normalY, normalZ) {
			var groundShape = new CANNON.Plane(new CANNON.Vec3(normalX, normalY, normalZ)),
				groundBody = new CANNON.RigidBody(0, groundShape, this._slipperyMaterial);
			
			this._world.add(groundBody);
		},
		
		createBody: function (entity, body) {
			var param,
				type,
				fixtureDef,
				tempShape,
				tempBod,
				i;
			
			// Process body definition and create a cannon body for it
			switch (body.type) {
				case 'static':
					type = CANNON.Body.STATIC;
					break;
				
				case 'kinematic':
					type = CANNON.Body.KINEMATIC;
					break;
				
				case 'dynamic':
					type = CANNON.Body.DYNAMIC;
					break;
			}
			
			// Now apply any post-creation attributes we need to
			for (param in body) {
				if (body.hasOwnProperty(param)) {
					switch (param) {
						case 'fixtures':
							for (i = 0; i < body.fixtures.length; i++) {
								// Grab the fixture definition
								fixtureDef = body.fixtures[i];
								
								// Check for a shape definition for the fixture
								if (fixtureDef.shape) {
									// Create based on the shape type
									switch (fixtureDef.shape.type) {
										case 'box':
											if (fixtureDef.shape.data) {
												// Use defined data to create the shape
												if (fixtureDef.shape.data.sizeX !== undefined && fixtureDef.shape.data.sizeY !== undefined && fixtureDef.shape.data.sizeZ !== undefined) {
													tempShape = new CANNON.Box(new CANNON.Vec3(fixtureDef.shape.data.sizeX / this._scaleRatio, fixtureDef.shape.data.sizeY / this._scaleRatio, fixtureDef.shape.data.sizeZ / this._scaleRatio));
												} else {
													tempShape = new CANNON.Box(new CANNON.Vec3(entity._bounds3d.x2 + 1 / this._scaleRatio, entity._bounds3d.y2 / this._scaleRatio, entity._bounds3d.z2 / this._scaleRatio));
												}
											} else {
												tempShape = new CANNON.Box(new CANNON.Vec3(entity._bounds3d.x2 + 1 / this._scaleRatio, entity._bounds3d.y2 + 1 / this._scaleRatio, entity._bounds3d.z2 + 1 / this._scaleRatio));
											}
											break;
									}
								}
							}
							break;
					}
				}
			}
			
			tempBod = new CANNON.RigidBody(body.mass, tempShape, this._normalMaterial);
			tempBod.sleepSpeedLimit = 0.1;
			tempBod.sleepTimeLimit = 1000;
			
			if (body.allowSleep !== undefined) { tempBod.allowSleep = body.allowSleep; }
			if (body.sleepSpeedLimit !== undefined) { tempBod.sleepSpeedLimit = body.sleepSpeedLimit; }
			if (body.sleepTimeLimit !== undefined) { tempBod.sleepTimeLimit = body.sleepTimeLimit; }
			
			if (body.angularDamping !== undefined) { tempBod.angularDamping = body.angularDamping; }
			if (body.linearDamping !== undefined) { tempBod.linearDamping = body.linearDamping; }
			
			// Set the position
			tempBod.position.set(entity._translate.x / this._scaleRatio, entity._translate.y / this._scaleRatio, (entity._translate.z + entity._bounds3d.z2)  / this._scaleRatio);
			
			// Store the entity that is linked to this body
			tempBod._igeEntity = entity;
			
			// Add the body to the world
			this._world.add(tempBod);
			
			return tempBod;
		},
		
		enableDebug: function (canvasId) {
			// Define the debug drawing instance
			var debugDraw = new this.b2DebugDraw();
			this._cannonDebug = true;
			this._debugCanvas = document.getElementById(canvasId);
			this._debugCtx = this._debugCanvas.getContext('2d');
			
			debugDraw.SetSprite(this._debugCtx);
			debugDraw.SetDrawScale(this._scaleRatio);
			debugDraw.SetFillAlpha(0.3);
			debugDraw.SetLineThickness(1.0);
			debugDraw.SetFlags(
				this.b2DebugDraw.e_controllerBit
				| this.b2DebugDraw.e_jointBit
				| this.b2DebugDraw.e_pairBit
				| this.b2DebugDraw.e_shapeBit
				//| this.b2DebugDraw.e_aabbBit
				//| this.b2DebugDraw.e_centerOfMassBit
			);
			
			// Set the debug draw for the world
			this._world.SetDebugDraw(debugDraw);
		},
		
		/** step - Step the simulation forward. {
	 category:"method",
	 } **/
		_behaviour: function (ctx) {
			var self = $ige.engine.cannon,
				bodiesArr = self._world.bodies,
				bodyCount = bodiesArr.length,
				tempBod, entity;
			
			if (self._active) {
				// Call the world step
				self._world.step(1 / 60);
				
				while (bodyCount--) {
					tempBod = bodiesArr[bodyCount];
					
					// Check if the body has an IGE entity attached to it
					if (tempBod._igeEntity) {
						if (tempBod.isAwake()) {
							entity = tempBod._igeEntity;
							
							// Update the entity data to match the body data
							tempBod._igeUpdating = true;
							entity.translateTo(Math.ceil(tempBod.position.x * self._scaleRatio), Math.ceil(tempBod.position.y * self._scaleRatio), Math.ceil((tempBod.position.z * self._scaleRatio) - entity._bounds3d.z2));
							//entity.rotateTo(entity._rotate.x, entity._rotate.y, tempBod.GetAngle());
							tempBod._igeUpdating = false;
						}
					}
				}
				
				/*// Remove any bodies that were queued for removal
				 removeWhenReady = self._removeWhenReady;
				 count = removeWhenReady.length;
				 
				 if (count) {
				 destroyBody = self._world.DestroyBody;
				 while (count--) {
				 destroyBody.apply(self._world, [removeWhenReady[count]]);
				 }
				 self._removeWhenReady = [];
				 removeWhenReady = null;
				 }
				 
				 // Call the world step; frame-rate, velocity iterations, position iterations
				 self._world.Step(1 / 60, 8, 8);
				 
				 // Loop the physics objects and move the entities they are assigned to
				 tempBod = self._world.GetBodyList();
				 while (tempBod) {
				 if (tempBod._entity) {
				 // Body has an entity assigned to it
				 entity = tempBod._entity; //self.$ige.engine.entities.read(tempBod.m_userData);
				 entityCannonBody = entity._cannonBody;
				 
				 // Check if the body is awake and is dynamic (we don't transform static bodies)
				 if (tempBod.IsAwake()) {
				 // Update the entity data to match the body data
				 entityCannonBody.updating = true;
				 entity.translateTo(tempBod.m_xf.position.x * self._scaleRatio, tempBod.m_xf.position.y * self._scaleRatio, entity._translate.z);
				 entity.rotateTo(entity._rotate.x, entity._rotate.y, tempBod.GetAngle());
				 entityCannonBody.updating = false;
				 
				 if (entityCannonBody.asleep) {
				 // The body was asleep last frame, fire an awake event
				 entityCannonBody.asleep = false;
				 self.emit('afterAwake', entity);
				 }
				 } else {
				 if (!entityCannonBody.asleep) {
				 // The body was awake last frame, fire an asleep event
				 entityCannonBody.asleep = true;
				 self.emit('afterAsleep', entity);
				 }
				 }
				 }
				 
				 tempBod = tempBod.GetNext();
				 }
				 
				 if (self._cannonDebug && this._currentCamera) {
				 // Draw the debug data
				 self._debugCanvas.width = $ige.engine._bounds2d.x;
				 self._debugCanvas.height = $ige.engine._bounds2d.y;
				 
				 self._debugCtx.save();
				 this._currentCamera._transformContext(self._debugCtx);
				 self._debugCtx.translate($ige.engine._bounds2d.x2, $ige.engine._bounds2d.y2);
				 self._world.DrawDebugData();
				 self._debugCtx.restore();
				 }
				 
				 // Clear forces because we have ended our physics simulation frame
				 self._world.ClearForces();
				 
				 tempBod = null;
				 entity = null;*/
				
				if (typeof(self._updateCallback) === 'function') {
					self._updateCallback();
				}
			}
		}
	});
	
	return IgeCannonComponent;
});

},{"irrelon-appcore":125}],41:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEntityCannon', function (IgeEntity) {
	/**
	 * Creates a new entity with CANNON 3d physics integration.
	 */
	var IgeEntityCannon = IgeEntity.extend({
		classId: 'IgeEntityCannon',
		
		init: function () {
			IgeEntity.prototype.init.call(this);
			
			// Store the existing translate methods
			this._translateToProto = this.translateTo;
			this._translateByProto = this.translateBy;
			
			// Take over the translate methods
			this.translateTo = this._translateTo;
			this.translateBy = this._translateBy;
		},
		
		cannonBody: function (def) {
			if (def !== undefined) {
				this._cannonBodyDef = def;
				
				// Ask the cannon component to create a new body for us
				this._cannonBody = $ige.engine.cannon.createBody(this, def);
				
				return this;
			}
			
			return this._cannonBodyDef;
		},
		
		_translateTo: function (x, y, z) {
			var entCannon = this._cannonBody,
				scaleRatio = $ige.engine.cannon._scaleRatio;
			
			// Check if the entity has a cannon body attached
			// and if so, is it updating or not
			if (entCannon && !entCannon._igeUpdating) {
				// We have an entity with a cannon definition that is
				// not currently updating so let's override the standard
				// transform op and take over
				
				// Translate the body
				entCannon.position.x = x / scaleRatio;
				entCannon.position.y = y / scaleRatio;
				entCannon.position.z = (z + this._bounds3d.z2) / scaleRatio;
			}
			
			// Now call the original translate method
			this._translateToProto(x, y, z);
			
			return this;
		},
		
		_translateBy: function (x, y, z) {
			this._translateTo(this._translate.x + x, this._translate.y + y, this._translate.z + z);
		}
	});
	
	return IgeEntityCannon;
});
},{"irrelon-appcore":125}],42:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2012 cannon.js Authors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function () {
	/**
	 * @mainpage Cannon.js
	 * A lightweight 3D physics engine for the web. See the github page for more information: https://github.com/schteppe/cannon.js
	 */

	var CANNON = CANNON || {};

// Maintain compatibility with older browsers
// @todo: check so ordinary Arrays work.
	if(!this.Int32Array){
		this.Int32Array=Array;
		this.Float32Array=Array;
	}/*global CANNON:true */

	/**
	 * @class CANNON.Broadphase
	 * @author schteppe
	 * @brief Base class for broadphase implementations
	 */
	CANNON.Broadphase = function(){
		/// The world to search for collisions in.
		this.world = null;
	};
	CANNON.Broadphase.prototype.constructor = CANNON.BroadPhase;

	/**
	 * @fn collisionPairs
	 * @memberof CANNON.Broadphase
	 * @brief Get the collision pairs from the world
	 * @param CANNON.World world The world to search in
	 * @return array An array with two subarrays of body indices
	 */
	CANNON.Broadphase.prototype.collisionPairs = function(world){
		throw "collisionPairs not implemented for this BroadPhase class!";
	};

	/*global CANNON:true */

	/**
	 * @class CANNON.NaiveBroadphase
	 * @brief Naive broadphase implementation, used in lack of better ones. The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
	 * @extends CANNON.Broadphase
	 */
	CANNON.NaiveBroadphase = function(){
		this.temp = {
			r: new CANNON.Vec3(),
			normal: new CANNON.Vec3(),
			quat: new CANNON.Quaternion()
		};
	};
	CANNON.NaiveBroadphase.prototype = new CANNON.Broadphase();
	CANNON.NaiveBroadphase.prototype.constructor = CANNON.NaiveBroadphase;

	/**
	 * @fn collisionPairs
	 * @memberof CANNON.NaiveBroadphase
	 * @brief Get all the collision pairs in the physics world
	 * @param CANNON.World world
	 * @return array An array containing two arrays of integers. The integers corresponds to the body indices.
	 */
	CANNON.NaiveBroadphase.prototype.collisionPairs = function(world){
		var pairs1 = [], pairs2 = [];
		var n = world.numObjects(),
			bodies = world.bodies;

		// Local fast access
		var types = CANNON.Shape.types;
		var BOX_SPHERE_COMPOUND_CONVEX = types.SPHERE | types.BOX | types.COMPOUND | types.CONVEXPOLYHEDRON,
			PLANE = types.PLANE,
			STATIC_OR_KINEMATIC = CANNON.Body.STATIC | CANNON.Body.KINEMATIC;

		// Temp vecs
		var r = this.temp.r;
		var normal = this.temp.normal;
		var quat = this.temp.quat;

		// Naive N^2 ftw!
		for(var i=0; i<n; i++){
			for(var j=0; j<i; j++){
				var bi = bodies[i], bj = bodies[j];
				if(bi.shape && bj.shape){
					var ti = bi.shape.type, tj = bj.shape.type;

					if(((bi.motionstate & STATIC_OR_KINEMATIC)!==0 || bi.isSleeping()) &&
						((bj.motionstate & STATIC_OR_KINEMATIC)!==0 || bj.isSleeping())) {
						// Both bodies are static, kinematic or sleeping. Skip.
						continue;
					}

					// --- Box / sphere / compound / convexpolyhedron collision ---
					if((ti & BOX_SPHERE_COMPOUND_CONVEX) && (tj & BOX_SPHERE_COMPOUND_CONVEX)){
						// Rel. position
						bj.position.vsub(bi.position,r);

						var boundingRadiusSum = bi.shape.boundingSphereRadius() + bj.shape.boundingSphereRadius();
						if(r.norm2()<boundingRadiusSum*boundingRadiusSum){
							pairs1.push(bi);
							pairs2.push(bj);
						}

						// --- Sphere/box/compound/convexpoly versus plane ---
					} else if((ti & BOX_SPHERE_COMPOUND_CONVEX) && (tj & types.PLANE) || (tj & BOX_SPHERE_COMPOUND_CONVEX) && (ti & types.PLANE)){
						var pi = (ti===PLANE) ? i : j, // Plane
							oi = (ti!==PLANE) ? i : j; // Other

						// Rel. position
						bodies[oi].position.vsub(bodies[pi].position,r);
						bodies[pi].quaternion.vmult(bodies[pi].shape.normal,normal);

						var q = r.dot(normal) - bodies[oi].shape.boundingSphereRadius();
						if(q<0.0){
							pairs1.push(bi);
							pairs2.push(bj);
						}
					}
				}
			}
		}
		return [pairs1,pairs2];
	};
	/*global CANNON:true */

	/**
	 * @class CANNON.Ray
	 * @author Originally written by mr.doob / http://mrdoob.com/ for Three.js. Cannon.js-ified by schteppe.
	 * @brief A ray is a line in 3D space that can intersect bodies and return intersection points.
	 * @param CANNON.Vec3 origin
	 * @param CANNON.Vec3 direction
	 */
	CANNON.Ray = function(origin, direction){
		this.origin = origin || new CANNON.Vec3();
		this.direction = direction || new CANNON.Vec3();

		var precision = 0.0001;

		/**
		 * @fn setPrecision
		 * @memberof CANNON.Ray
		 * @param float value
		 * @brief Sets the precision of the ray. Used when checking parallelity etc.
		 */
		this.setPrecision = function ( value ) {
			precision = value;
		};

		var a = new CANNON.Vec3();
		var b = new CANNON.Vec3();
		var c = new CANNON.Vec3();
		var d = new CANNON.Vec3();

		var directionCopy = new CANNON.Vec3();

		var vector = new CANNON.Vec3();
		var normal = new CANNON.Vec3();
		var intersectPoint = new CANNON.Vec3()

		/**
		 * @fn intersectBody
		 * @memberof CANNON.Ray
		 * @param CANNON.RigidBody body
		 * @brief Shoot a ray at a body, get back information about the hit.
		 * @return Array An array of results. The result objects has properties: distance (float), point (CANNON.Vec3) and body (CANNON.RigidBody).
		 */
		this.intersectBody = function ( body ) {
			if(body.shape instanceof CANNON.ConvexPolyhedron){
				return this.intersectShape(body.shape,
					body.quaternion,
					body.position,
					body);
			} else if(body.shape instanceof CANNON.Box){
				return this.intersectShape(body.shape.convexPolyhedronRepresentation,
					body.quaternion,
					body.position,
					body);
			} else
				console.warn("Ray intersection is this far only implemented for ConvexPolyhedron and Box shapes.");
		};

		/**
		 * @fn intersectShape
		 * @memberof CANNON.Ray
		 * @param CANNON.Shape shape
		 * @param CANNON.Quaternion quat
		 * @param CANNON.Vec3 position
		 * @param CANNON.RigidBody body
		 * @return Array See intersectBody()
		 */
		this.intersectShape = function(shape,quat,position,body){

			var intersect, intersects = [];

			if ( shape instanceof CANNON.ConvexPolyhedron ) {
				// Checking boundingSphere

				var distance = distanceFromIntersection( this.origin, this.direction, position );
				if ( distance > shape.boundingSphereRadius() ) {
					return intersects;
				}

				// Checking faces
				var dot, scalar, faces = shape.faces, vertices = shape.vertices, normals = shape.faceNormals;

				for ( fi = 0; fi < faces.length; fi++ ) {

					var face = faces[ fi ];
					var faceNormal = normals[ fi ];
					var q = quat;
					var x = position;

					// determine if ray intersects the plane of the face
					// note: this works regardless of the direction of the face normal

					// Get plane point
					var vector = new CANNON.Vec3();
					vertices[face[0]].copy(vector);
					vector.vsub(this.origin,vector);
					q.vmult(vector,vector);
					vector.vadd(x,vector);

					// Get plane normal
					var normal = new CANNON.Vec3();
					q.vmult(faceNormal,normal);

					dot = this.direction.dot(normal);

					// bail if ray and plane are parallel

					if ( Math.abs( dot ) < precision ) continue;

					// calc distance to plane

					scalar = normal.dot( vector ) / dot;

					// if negative distance, then plane is behind ray
					if ( scalar < 0 ) continue;

					if (  dot < 0 ) {

						// Intersection point is origin + direction * scalar
						this.direction.mult(scalar,intersectPoint);
						intersectPoint.vadd(this.origin,intersectPoint);

						// a is the point we compare points b and c with.
						vertices[ face[0] ].copy(a);
						q.vmult(a,a);
						x.vadd(a,a);

						for(var i=1; i<face.length-1; i++){
							// Transform 3 vertices to world coords
							vertices[ face[i] ].copy(b);
							vertices[ face[i+1] ].copy(c);
							q.vmult(b,b);
							q.vmult(c,c);
							x.vadd(b,b);
							x.vadd(c,c);

							if ( pointInTriangle( intersectPoint, a, b, c ) ) {

								intersect = {

									distance: this.origin.distanceTo( intersectPoint ),
									point: intersectPoint.copy(),
									face: face,
									body: body

								};

								intersects.push( intersect );
								break;

							}

						}
					}

				}

			}


			return intersects;

		}

		/**
		 * @fn intersectBodies
		 * @memberof CANNON.Ray
		 * @param Array bodies An array of CANNON.RigidBody objects.
		 * @return Array See intersectBody
		 */
		this.intersectBodies = function ( bodies ) {

			var intersects = [];

			for ( var i = 0, l = bodies.length; i < l; i ++ ) {
				var result = this.intersectBody( bodies[ i ] );
				Array.prototype.push.apply( intersects, result );

			}

			intersects.sort( function ( a, b ) { return a.distance - b.distance; } );

			return intersects;

		};

		var v0 = new CANNON.Vec3(), intersect = new CANNON.Vec3();
		var dot, distance;

		function distanceFromIntersection( origin, direction, position ) {

			// v0 is vector from origin to position
			position.vsub(origin,v0);
			dot = v0.dot( direction );

			// intersect = direction*dot + origin
			direction.mult(dot,intersect);
			intersect.vadd(origin,intersect);

			distance = position.distanceTo( intersect );

			return distance;

		}

		// http://www.blackpawn.com/texts/pointinpoly/default.html

		var dot00, dot01, dot02, dot11, dot12, invDenom, u, v;
		var v1 = new CANNON.Vec3(), v2 = new CANNON.Vec3();

		function pointInTriangle( p, a, b, c ) {
			c.vsub(a,v0);
			b.vsub(a,v1);
			p.vsub(a,v2);

			dot00 = v0.dot( v0 );
			dot01 = v0.dot( v1 );
			dot02 = v0.dot( v2 );
			dot11 = v1.dot( v1 );
			dot12 = v1.dot( v2 );

			invDenom = 1 / ( dot00 * dot11 - dot01 * dot01 );
			u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			return ( u >= 0 ) && ( v >= 0 ) && ( u + v < 1 );
		}
	};
	CANNON.Ray.prototype.constructor = CANNON.Ray;
	/*global CANNON:true */

	/**
	 * @class CANNON.Mat3
	 * @brief Produce a 3x3 matrix. Columns first!
	 * @param array elements Array of nine elements. Optional.
	 * @author schteppe / http://github.com/schteppe
	 */
	CANNON.Mat3 = function(elements){
		/**
		 * @property Float32Array elements
		 * @memberof CANNON.Mat3
		 * @brief A vector of length 9, containing all matrix elements
		 */
		if(elements){
			this.elements = new Float32Array(elements);
		} else {
			this.elements = new Float32Array(9);
		}
	};

	/**
	 * @fn identity
	 * @memberof CANNON.Mat3
	 * @brief Sets the matrix to identity
	 * @todo Should perhaps be renamed to setIdentity() to be more clear.
	 * @todo Create another function that immediately creates an identity matrix eg. eye()
	 */
	CANNON.Mat3.prototype.identity = function(){
		this.elements[0] = 1;
		this.elements[1] = 0;
		this.elements[2] = 0;

		this.elements[3] = 0;
		this.elements[4] = 1;
		this.elements[5] = 0;

		this.elements[6] = 0;
		this.elements[7] = 0;
		this.elements[8] = 1;
	};

	/**
	 * @fn vmult
	 * @memberof CANNON.vmult
	 * @brief Matrix-Vector multiplication
	 * @param CANNON.Vec3 v The vector to multiply with
	 * @param CANNON.Vec3 target Optional, target to save the result in.
	 */
	CANNON.Mat3.prototype.vmult = function(v,target){
		if(target===undefined){
			target = new CANNON.Vec3();
		}

		var vec = [v.x, v.y, v.z];
		var targetvec = [0, 0, 0];
		for(var i=0; i<3; i++){
			for(var j=0; j<3; j++){
				targetvec[i] += this.elements[i+3*j]*vec[i];
			}
		}

		target.x = targetvec[0];
		target.y = targetvec[1];
		target.z = targetvec[2];
		return target;
	};

	/**
	 * @fn smult
	 * @memberof CANNON.Mat3
	 * @brief Matrix-scalar multiplication
	 * @param float s
	 */
	CANNON.Mat3.prototype.smult = function(s){
		for(var i=0; i<this.elements.length; i++){
			this.elements[i] *= s;
		}
	};

	/**
	 * @fn mmult
	 * @memberof CANNON.Mat3
	 * @brief Matrix multiplication
	 * @param CANNON.Mat3 m Matrix to multiply with from left side.
	 * @return CANNON.Mat3 The result.
	 */
	CANNON.Mat3.prototype.mmult = function(m){
		var r = new CANNON.Mat3();
		for(var i=0; i<3; i++){
			for(var j=0; j<3; j++){
				var sum = 0.0;
				for(var k=0; k<3; k++){
					sum += this.elements[i+k] * m.elements[k+j*3];
				}
				r.elements[i+j*3] = sum;
			}
		}
		return r;
	};

	/**
	 * @fn solve
	 * @memberof CANNON.Mat3
	 * @brief Solve Ax=b
	 * @param CANNON.Vec3 b The right hand side
	 * @param CANNON.Vec3 target Optional. Target vector to save in.
	 * @return CANNON.Vec3 The solution x
	 */
	CANNON.Mat3.prototype.solve = function(b,target){

		target = target || new CANNON.Vec3();

		// Construct equations
		var nr = 3; // num rows
		var nc = 4; // num cols
		var eqns = new Float32Array(nr*nc);
		var i,j;
		for(i=0; i<3; i++){
			for(j=0; j<3; j++){
				eqns[i+nc*j] = this.elements[i+3*j];
			}
		}
		eqns[3+4*0] = b.x;
		eqns[3+4*1] = b.y;
		eqns[3+4*2] = b.z;

		// Compute right upper triangular version of the matrix - Gauss elimination
		var n = 3, k = n, np;
		var kp = 4; // num rows
		var p, els;
		do {
			i = k - n;
			if (eqns[i+nc*i] === 0) {
				for (j = i + 1; j < k; j++) {
					if (eqns[i+nc*j] !== 0) {
						els = [];
						np = kp;
						do {
							p = kp - np;
							els.push(eqns[p+nc*i] + eqns[p+nc*j]);
						} while (--np);
						eqns[i+nc*0] = els[0];
						eqns[i+nc*1] = els[1];
						eqns[i+nc*2] = els[2];
						break;
					}
				}
			}
			if (eqns[i+nc*i] !== 0) {
				for (j = i + 1; j < k; j++) {
					var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
					els = [];
					np = kp;
					do {
						p = kp - np;
						els.push(p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier);
					} while (--np);
					eqns[j+nc*0] = els[0];
					eqns[j+nc*1] = els[1];
					eqns[j+nc*2] = els[2];
				}
			}
		} while (--n);
		// Get the solution
		target.z = eqns[2*nc+3] / eqns[2*nc+2];
		target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];
		target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];

		if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){
			throw "Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";
		}

		return target;
	};

	/**
	 * @fn e
	 * @memberof CANNON.Mat3
	 * @brief Get an element in the matrix by index. Index starts at 0, not 1!!!
	 * @param int i
	 * @param int j
	 * @param float value Optional. If provided, the matrix element will be set to this value.
	 * @return float
	 */
	CANNON.Mat3.prototype.e = function(i,j,value){
		if(value===undefined){
			return this.elements[i+3*j];
		} else {
			// Set value
			this.elements[i+3*j] = value;
		}
	};

	/**
	 * @fn copy
	 * @memberof CANNON.Mat3
	 * @brief Copy the matrix
	 * @param CANNON.Mat3 target Optional. Target to save the copy in.
	 * @return CANNON.Mat3
	 */
	CANNON.Mat3.prototype.copy = function(target){
		target = target || new CANNON.Mat3();
		for(var i=0; i<this.elements.length; i++){
			target.elements[i] = this.elements[i];
		}
		return target;
	};

	/**
	 * @fn toString
	 * @memberof CANNON.Mat3
	 * @brief Returns a string representation of the matrix.
	 * @return string
	 */
	CANNON.Mat3.prototype.toString = function(){
		var r = "";
		var sep = ",";
		for(var i=0; i<9; i++){
			r += this.elements[i] + sep;
		}
		return r;
	};/*global CANNON:true */

	/**
	 * @class CANNON.Vec3
	 * @brief 3-dimensional vector
	 * @param float x
	 * @param float y
	 * @param float z
	 * @author schteppe
	 */
	CANNON.Vec3 = function(x,y,z){
		/**
		 * @property float x
		 * @memberof CANNON.Vec3
		 */
		this.x = x||0.0;
		/**
		 * @property float y
		 * @memberof CANNON.Vec3
		 */
		this.y = y||0.0;
		/**
		 * @property float z
		 * @memberof CANNON.Vec3
		 */
		this.z = z||0.0;
	};

	/**
	 * @fn cross
	 * @memberof CANNON.Vec3
	 * @brief Vector cross product
	 * @param CANNON.Vec3 v
	 * @param CANNON.Vec3 target Optional. Target to save in.
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.cross = function(v,target){
		target = target || new CANNON.Vec3();
		var A = [this.x, this.y, this.z];
		var B = [v.x, v.y, v.z];

		target.x = (A[1] * B[2]) - (A[2] * B[1]);
		target.y = (A[2] * B[0]) - (A[0] * B[2]);
		target.z = (A[0] * B[1]) - (A[1] * B[0]);

		return target;
	};

	/**
	 * @fn set
	 * @memberof CANNON.Vec3
	 * @brief Set the vectors' 3 elements
	 * @param float x
	 * @param float y
	 * @param float z
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.set = function(x,y,z){
		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	};

	/**
	 * @fn vadd
	 * @memberof CANNON.Vec3
	 * @brief Vector addition
	 * @param CANNON.Vec3 v
	 * @param CANNON.Vec3 target Optional.
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.vadd = function(v,target){
		if(target){
			target.x = v.x + this.x;
			target.y = v.y + this.y;
			target.z = v.z + this.z;
		} else {
			return new CANNON.Vec3(this.x + v.x,
				this.y + v.y,
				this.z + v.z);
		}
	};

	/**
	 * @fn vsub
	 * @memberof CANNON.Vec3
	 * @brief Vector subtraction
	 * @param CANNON.Vec3 v
	 * @param CANNON.Vec3 target Optional. Target to save in.
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.vsub = function(v,target){
		if(target){
			target.x = this.x - v.x;
			target.y = this.y - v.y;
			target.z = this.z - v.z;
		} else {
			return new CANNON.Vec3(this.x-v.x,
				this.y-v.y,
				this.z-v.z);
		}
	};

	/**
	 * @fn crossmat
	 * @memberof CANNON.Vec3
	 * @brief Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
	 * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
	 * @return CANNON.Mat3
	 */
	CANNON.Vec3.prototype.crossmat = function(){
		return new CANNON.Mat3([      0,  -this.z,   this.y,
			this.z,        0,  -this.x,
			-this.y,   this.x,        0]);
	};

	/**
	 * @fn normalize
	 * @memberof CANNON.Vec3
	 * @brief Normalize the vector. Note that this changes the values in the vector.
	 * @return float Returns the norm of the vector
	 */
	CANNON.Vec3.prototype.normalize = function(){
		var n = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
		if(n>0.0){
			this.x /= n;
			this.y /= n;
			this.z /= n;
		} else {
			// Make something up
			this.x = 0;
			this.y = 0;
			this.z = 0;
		}
		return n;
	};

	/**
	 * @fn unit
	 * @memberof CANNON.Vec3
	 * @brief Get the version of this vector that is of length 1.
	 * @param CANNON.Vec3 target Optional target to save in
	 * @return CANNON.Vec3 Returns the unit vector
	 */
	CANNON.Vec3.prototype.unit = function(target){
		target = target || new CANNON.Vec3();
		var ninv = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
		if(ninv>0.0){
			ninv = 1.0/ninv;
			target.x = this.x * ninv;
			target.y = this.y * ninv;
			target.z = this.z * ninv;
		} else {
			target.x = 0;
			target.y = 0;
			target.z = 0;
		}
		return target;
	};

	/**
	 * @fn norm
	 * @memberof CANNON.Vec3
	 * @brief Get the 2-norm (length) of the vector
	 * @return float
	 */
	CANNON.Vec3.prototype.norm = function(){
		return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
	};

	/**
	 * @fn norm2
	 * @memberof CANNON.Vec3
	 * @brief Get the squared length of the vector
	 * @return float
	 */
	CANNON.Vec3.prototype.norm2 = function(){
		return this.dot(this);
	};

	CANNON.Vec3.prototype.distanceTo = function(p){
		return Math.sqrt((p.x-this.x)*(p.x-this.x)+
			(p.y-this.y)*(p.y-this.y)+
			(p.z-this.z)*(p.z-this.z));
	};

	/**
	 * @fn mult
	 * @memberof CANNON.Vec3
	 * @brief Multiply the vector with a scalar
	 * @param float scalar
	 * @param CANNON.Vec3 target
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.mult = function(scalar,target){
		if(!target)
			target = new CANNON.Vec3();
		target.x = scalar*this.x;
		target.y = scalar*this.y;
		target.z = scalar*this.z;
		return target;
	};

	/**
	 * @fn dot
	 * @memberof CANNON.Vec3
	 * @brief Calculate dot product
	 * @param CANNON.Vec3 v
	 * @return float
	 */
	CANNON.Vec3.prototype.dot = function(v){
		return (this.x * v.x + this.y * v.y + this.z * v.z);
	};

	/**
	 * @fn isZero
	 * @memberof CANNON.Vec3
	 * @return bool
	 */
	CANNON.Vec3.prototype.isZero = function(){
		return this.x===0 && this.y===0 && this.z===0;
	}

	/**
	 * @fn negate
	 * @memberof CANNON.Vec3
	 * @brief Make the vector point in the opposite direction.
	 * @param CANNON.Vec3 target Optional target to save in
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.negate = function(target){
		target = target || new CANNON.Vec3();
		target.x = -this.x;
		target.y = -this.y;
		target.z = -this.z;
		return target;
	};

	/**
	 * @fn tangents
	 * @memberof CANNON.Vec3
	 * @brief Compute two artificial tangents to the vector
	 * @param CANNON.Vec3 t1 Vector object to save the first tangent in
	 * @param CANNON.Vec3 t2 Vector object to save the second tangent in
	 */
	CANNON.Vec3.prototype.tangents = function(t1,t2){
		var norm = this.norm();
		if(norm>0.0){
			var n = new CANNON.Vec3(this.x/norm,
				this.y/norm,
				this.z/norm);
			if(n.x<0.9){
				var rand = Math.random();
				n.cross(new CANNON.Vec3(rand,0.0000001,0).unit(),t1);
			} else
				n.cross(new CANNON.Vec3(0.0000001,rand,0).unit(),t1);
			n.cross(t1,t2);
		} else {
			// The normal length is zero, make something up
			t1.set(1,0,0).normalize();
			t2.set(0,1,0).normalize();
		}
	};

	/**
	 * @fn toString
	 * @memberof CANNON.Vec3
	 * @brief Converts to a more readable format
	 * @return string
	 */
	CANNON.Vec3.prototype.toString = function(){
		return this.x+","+this.y+","+this.z;
	};

	/**
	 * @fn copy
	 * @memberof CANNON.Vec3
	 * @brief Copy the vector.
	 * @param CANNON.Vec3 target
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.copy = function(target){
		target = target || new CANNON.Vec3();
		target.x = this.x;
		target.y = this.y;
		target.z = this.z;
		return target;
	};


	/**
	 * @fn lerp
	 * @memberof CANNON.Vec3
	 * @brief Do a linear interpolation between two vectors
	 * @param CANNON.Vec3 v
	 * @param float t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
	 * @param CANNON.Vec3 target
	 */
	CANNON.Vec3.prototype.lerp = function(v,t,target){
		target.x = this.x + (v.x-this.x)*t;
		target.y = this.y + (v.y-this.y)*t;
		target.z = this.z + (v.z-this.z)*t;
	};

	/**
	 * @fn almostEquals
	 * @memberof CANNON.Vec3
	 * @brief Check if a vector equals is almost equal to another one.
	 * @param CANNON.Vec3 v
	 * @param float precision
	 * @return bool
	 */
	CANNON.Vec3.prototype.almostEquals = function(v,precision){
		if(precision===undefined)
			precision = 1e-6;
		if(Math.abs(this.x-v.x)>precision ||
			Math.abs(this.y-v.y)>precision ||
			Math.abs(this.z-v.z)>precision)
			return false;
		return true;
	}

	/**
	 * Check if a vector is almost zero
	 */
	CANNON.Vec3.prototype.almostZero = function(precision){
		if(precision===undefined)
			precision = 1e-6;
		if(Math.abs(this.x)>precision ||
			Math.abs(this.y)>precision ||
			Math.abs(this.z)>precision)
			return false;
		return true;
	}/*global CANNON:true */

	/**
	 * @class CANNON.Quaternion
	 * @brief A Quaternion describes a rotation in 3D space. It is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
	 * @param float x Multiplier of the imaginary basis vector i.
	 * @param float y Multiplier of the imaginary basis vector j.
	 * @param float z Multiplier of the imaginary basis vector k.
	 * @param float w Multiplier of the real part.
	 * @see http://en.wikipedia.org/wiki/Quaternion
	 */
	CANNON.Quaternion = function(x,y,z,w){
		/**
		 * @property float x
		 * @memberof CANNON.Quaternion
		 */
		this.x = x!=undefined ? x : 0;
		/**
		 * @property float y
		 * @memberof CANNON.Quaternion
		 */
		this.y = y!=undefined ? y : 0;
		/**
		 * @property float z
		 * @memberof CANNON.Quaternion
		 */
		this.z = z!=undefined ? z : 0;
		/**
		 * @property float w
		 * @memberof CANNON.Quaternion
		 * @brief The multiplier of the real quaternion basis vector.
		 */
		this.w = w!=undefined ? w : 1;
	};

	/**
	 * Set the value of the quaternion.
	 */
	CANNON.Quaternion.prototype.set = function(x,y,z,w){
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	};

	/**
	 * @fn toString
	 * @memberof CANNON.Quaternion
	 * @brief Convert to a readable format
	 * @return string
	 */
	CANNON.Quaternion.prototype.toString = function(){
		return this.x+","+this.y+","+this.z+","+this.w;
	};

	/**
	 * @fn setFromAxisAngle
	 * @memberof CANNON.Quaternion
	 * @brief Set the quaternion components given an axis and an angle.
	 * @param CANNON.Vec3 axis
	 * @param float angle in radians
	 */
	CANNON.Quaternion.prototype.setFromAxisAngle = function(axis,angle){
		var s = Math.sin(angle*0.5);
		this.x = axis.x * s;
		this.y = axis.y * s;
		this.z = axis.z * s;
		this.w = Math.cos(angle*0.5);
	};

// saves axis to targetAxis and returns 
	CANNON.Quaternion.prototype.toAxisAngle = function(targetAxis){
		targetAxis = targetAxis || new CANNON.Vec3();
		this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
		var angle = 2 * Math.acos(this.w);
		var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
		if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
			// if s close to zero then direction of axis not important
			targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
			targetAxis.y = this.y;
			targetAxis.z = this.z;
		} else {
			targetAxis.x = this.x / s; // normalise axis
			targetAxis.y = this.y / s;
			targetAxis.z = this.z / s;
		}
		return [targetAxis,angle];
	};

	/**
	 * @fn setFromVectors
	 * @memberof CANNON.Quaternion
	 * @brief Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
	 * @param CANNON.Vec3 u
	 * @param CANNON.Vec3 v
	 */
	CANNON.Quaternion.prototype.setFromVectors = function(u,v){
		var a = u.cross(v);
		this.x = a.x;
		this.y = a.y;
		this.z = a.z;
		this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);
		this.normalize();
	};

	/**
	 * @fn mult
	 * @memberof CANNON.Quaternion
	 * @brief Quaternion multiplication
	 * @param CANNON.Quaternion q
	 * @param CANNON.Quaternion target Optional.
	 * @return CANNON.Quaternion
	 */
	CANNON.Quaternion.prototype.mult = function(q,target){
		if(target==undefined)
			target = new CANNON.Quaternion();

		var va = new CANNON.Vec3(this.x,this.y,this.z);
		var vb = new CANNON.Vec3(q.x,q.y,q.z);
		target.w = this.w*q.w - va.dot(vb);
		vaxvb = va.cross(vb);
		target.x = this.w * vb.x + q.w*va.x + vaxvb.x;
		target.y = this.w * vb.y + q.w*va.y + vaxvb.y;
		target.z = this.w * vb.z + q.w*va.z + vaxvb.z;
		return target;
	};

	/**
	 * @fn inverse
	 * @memberof CANNON.Quaternion
	 * @brief Get the inverse quaternion rotation.
	 * @param CANNON.Quaternion target
	 * @return CANNON.Quaternion
	 */
	CANNON.Quaternion.prototype.inverse = function(target){
		if(target==undefined)
			target = new CANNON.Quaternion();

		this.conjugate(target);
		var inorm2 = 1/(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w);
		target.x *= inorm2;
		target.y *= inorm2;
		target.z *= inorm2;
		target.w *= inorm2;

		return target;
	};

	/**
	 * @fn conjugate
	 * @memberof CANNON.Quaternion
	 * @brief Get the quaternion conjugate
	 * @param CANNON.Quaternion target
	 * @return CANNON.Quaternion
	 */
	CANNON.Quaternion.prototype.conjugate = function(target){
		if(target==undefined)
			target = new CANNON.Quaternion();

		target.x = -this.x;
		target.y = -this.y;
		target.z = -this.z;
		target.w = this.w;

		return target;
	};

	/**
	 * @fn normalize
	 * @memberof CANNON.Quaternion
	 * @brief Normalize the quaternion. Note that this changes the values of the quaternion.
	 */
	CANNON.Quaternion.prototype.normalize = function(){
		var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
		if ( l === 0 ) {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		} else {
			l = 1 / l;
			this.x *= l;
			this.y *= l;
			this.z *= l;
			this.w *= l;
		}
	};

	/**
	 * @fn normalizeFast
	 * @memberof CANNON.Quaternion
	 * @brief Approximation of quaternion normalization. Works best when quat is already almost-normalized.
	 * @see http://jsperf.com/fast-quaternion-normalization
	 * @author unphased, https://github.com/unphased
	 */
	CANNON.Quaternion.prototype.normalizeFast = function () {
		var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;
		if ( f === 0 ) {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		} else {
			this.x *= f;
			this.y *= f;
			this.z *= f;
			this.w *= f;
		}
	}

	/**
	 * @fn vmult
	 * @memberof CANNON.Quaternion
	 * @brief Multiply the quaternion by a vector
	 * @param CANNON.Vec3 v
	 * @param CANNON.Vec3 target Optional
	 * @return CANNON.Vec3
	 */
	CANNON.Quaternion.prototype.vmult = function(v,target){
		target = target || new CANNON.Vec3();
		if(this.w==0.0){
			target.x = v.x;
			target.y = v.y;
			target.z = v.z;
		} else {

			var x = v.x,
				y = v.y,
				z = v.z;

			var qx = this.x,
				qy = this.y,
				qz = this.z,
				qw = this.w;

			// q*v
			var ix =  qw * x + qy * z - qz * y,
				iy =  qw * y + qz * x - qx * z,
				iz =  qw * z + qx * y - qy * x,
				iw = -qx * x - qy * y - qz * z;

			target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		}

		return target;
	};

	/**
	 * @fn copy
	 * @memberof CANNON.Quaternion
	 * @param CANNON.Quaternion target
	 */
	CANNON.Quaternion.prototype.copy = function(target){
		target.x = this.x;
		target.y = this.y;
		target.z = this.z;
		target.w = this.w;
	};

	/**
	 * @fn toEuler
	 * @memberof CANNON.Quaternion
	 * @brief Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
	 * @param CANNON.Vec3 target
	 * @param string order Three-character string e.g. "YZX", which also is default.
	 */
	CANNON.Quaternion.prototype.toEuler = function(target,order){
		order = order || "YZX";

		var heading, attitude, bank;
		var x = this.x, y = this.y, z = this.z, w = this.w;

		switch(order){
			case "YZX":
				var test = x*y + z*w;
				if (test > 0.499) { // singularity at north pole
					heading = 2 * Math.atan2(x,w);
					attitude = Math.PI/2;
					bank = 0;
				}
				if (test < -0.499) { // singularity at south pole
					heading = -2 * Math.atan2(x,w);
					attitude = - Math.PI/2;
					bank = 0;
				}
				if(isNaN(heading)){
					var sqx = x*x;
					var sqy = y*y;
					var sqz = z*z;
					heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading
					attitude = Math.asin(2*test); // attitude
					bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank
				}
				break;
			default:
				throw new Error("Euler order "+order+" not supported yet.");
				break;
		}

		target.y = heading;
		target.z = attitude;
		target.x = bank;
	};/*global CANNON:true */

	/**
	 * @class CANNON.Shape
	 * @author schteppe
	 * @brief Base class for shapes
	 */
	CANNON.Shape = function(){

		/**
		 * @property int type
		 * @memberof CANNON.Shape
		 * @brief The type of this shape. Must be set to an int > 0 by subclasses.
		 * @see CANNON.Shape.types
		 */
		this.type = 0;

		this.aabbmin = new CANNON.Vec3();
		this.aabbmax = new CANNON.Vec3();
	};
	CANNON.Shape.prototype.constructor = CANNON.Shape;

	/**
	 * @fn boundingSphereRadius
	 * @memberof CANNON.Shape
	 * @brief Get the bounding sphere radius from this shape
	 * @return float
	 */
	CANNON.Shape.prototype.boundingSphereRadius = function(){
		throw "boundingSphereRadius() not implemented for shape type "+this.type;
	};

	/**
	 * @fn volume
	 * @memberof CANNON.Shape
	 * @brief Get the volume of this shape
	 * @return float
	 */
	CANNON.Shape.prototype.volume = function(){
		throw "volume() not implemented for shape type "+this.type;
	};

	/**
	 * @fn calculateLocalInertia
	 * @memberof CANNON.Shape
	 * @brief Calculates the inertia in the local frame for this shape.
	 * @return CANNON.Vec3
	 * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
	 */
	CANNON.Shape.prototype.calculateLocalInertia = function(mass,target){
		throw "calculateLocalInertia() not implemented for shape type "+this.type;
	};

	/**
	 * @fn calculateTransformedInertia
	 * @memberof CANNON.Shape
	 * @brief Calculates inertia in a specified frame for this shape.
	 * @return CANNON.Vec3
	 */
	CANNON.Shape.prototype.calculateTransformedInertia = function(mass,quat,target){
		if(target==undefined)
			target = new CANNON.Vec3();

		// Compute inertia in the world frame
		quat.normalize();
		var localInertia = this.calculateLocalInertia(mass);

		// @todo Is this rotation OK? Check!
		var worldInertia = quat.vmult(localInertia);
		target.x = Math.abs(worldInertia.x);
		target.y = Math.abs(worldInertia.y);
		target.z = Math.abs(worldInertia.z);
		return target;
		//throw "calculateInertia() not implemented for shape type "+this.type;
	};

	/**
	 * @enum CANNON.Shape.types
	 * @brief The available shape types.
	 */
	CANNON.Shape.types = {
		SPHERE:1,
		PLANE:2,
		BOX:4,
		COMPOUND:8,
		CONVEXPOLYHEDRON:16
	};

	/*global CANNON:true */

	/**
	 * @class CANNON.Body
	 * @brief Base class for all body types.
	 * @param string type
	 */
	CANNON.Body = function(type){

		CANNON.EventTarget.apply(this);

		this.type = type;

		var that = this;

		/**
		 * @property CANNON.World world
		 * @memberof CANNON.Body
		 * @brief Reference to the world the body is living in
		 */
		this.world = null;

		/**
		 * @property function preStep
		 * @memberof CANNON.Body
		 * @brief Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this CANNON.Body object.
		 * @todo dispatch an event from the World instead
		 */
		this.preStep = null;

		/**
		 * @property function postStep
		 * @memberof CANNON.Body
		 * @brief Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this CANNON.Body object.
		 * @todo dispatch an event from the World instead
		 */
		this.postStep = null;
	};

	/**
	 * @brief A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
	 */
	CANNON.Body.DYNAMIC = 1;

	/**
	 * @brief A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
	 */
	CANNON.Body.STATIC = 2;

	/**
	 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
	 */
	CANNON.Body.KINEMATIC = 4;/*global CANNON:true */

	/**
	 * @class CANNON.Particle
	 * @param float mass
	 * @param CANNON.Material material
	 */
	CANNON.Particle = function(mass,material){

		// Check input
		if(typeof(mass)!="number")
			throw new Error("Argument 1 (mass) must be a number.");
		if(typeof(material)!="undefined" && !(material instanceof(CANNON.Material)))
			throw new Error("Argument 3 (material) must be an instance of CANNON.Material.");

		CANNON.Body.call(this,"particle");

		var that = this;

		/**
		 * @property CANNON.Vec3 position
		 * @memberof CANNON.Particle
		 */
		this.position = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 initPosition
		 * @memberof CANNON.Particle
		 * @brief Initial position of the body
		 */
		this.initPosition = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 velocity
		 * @memberof CANNON.Particle
		 */
		this.velocity = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 initVelocity
		 * @memberof CANNON.Particle
		 */
		this.initVelocity = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 force
		 * @memberof CANNON.Particle
		 * @brief Linear force on the body
		 */
		this.force = new CANNON.Vec3();

		/**
		 * @property float mass
		 * @memberof CANNON.Particle
		 */
		this.mass = mass;

		/**
		 * @property float invMass
		 * @memberof CANNON.Particle
		 */
		this.invMass = mass>0 ? 1.0/mass : 0;

		/**
		 * @property CANNON.Material material
		 * @memberof CANNON.Particle
		 */
		this.material = material;

		/**
		 * @property float linearDamping
		 * @memberof CANNON.Particle
		 */
		this.linearDamping = 0.01; // Perhaps default should be zero here?

		/**
		 * @property int motionstate
		 * @memberof CANNON.Particle
		 * @brief One of the states CANNON.Body.DYNAMIC, CANNON.Body.STATIC and CANNON.Body.KINEMATIC
		 */
		this.motionstate = (mass <= 0.0 ? CANNON.Body.STATIC : CANNON.Body.DYNAMIC);

		/**
		 * @property bool allowSleep
		 * @memberof CANNON.Particle
		 * @brief If true, the body will automatically fall to sleep.
		 */
		this.allowSleep = true;

		// 0:awake, 1:sleepy, 2:sleeping
		var sleepState = 0;

		/**
		 * @fn isAwake
		 * @memberof CANNON.Particle
		 */
		this.isAwake = function(){ return sleepState == 0; }

		/**
		 * @fn isSleepy
		 * @memberof CANNON.Particle
		 */
		this.isSleepy = function(){ return sleepState == 1; }

		/**
		 * @fn isSleeping
		 * @memberof CANNON.Particle
		 */
		this.isSleeping = function(){ return sleepState == 2; }

		/**
		 * @property float sleepSpeedLimit
		 * @memberof CANNON.Particle
		 * @brief If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
		 */
		this.sleepSpeedLimit = 0.1;

		/**
		 * @property float sleepTimeLimit
		 * @memberof CANNON.Particle
		 * @brief If the body has been sleepy for this sleepTimeLimit milliseconds, it is considered sleeping.
		 */
		this.sleepTimeLimit = 1000;
		var timeLastSleepy = new Date().getTime();

		/**
		 * @fn wakeUp
		 * @memberof CANNON.Particle
		 * @brief Wake the body up.
		 */
		this.wakeUp = function(){
			sleepState = 0;
			that.dispatchEvent({type:"wakeup"});
		};

		/**
		 * @fn sleep
		 * @memberof CANNON.Particle
		 * @brief Force body sleep
		 */
		this.sleep = function(){
			sleepState = 2;
		};

		/**
		 * @fn sleepTick
		 * @memberof CANNON.Particle
		 * @brief Called every timestep to update internal sleep timer and change sleep state if needed.
		 */
		this.sleepTick = function(){
			if(that.allowSleep){
				if(sleepState==0 && that.velocity.norm()<that.sleepSpeedLimit){
					sleepState = 1; // Sleepy
					timeLastSleepy = new Date().getTime();
					that.dispatchEvent({type:"sleepy"});
				} else if(sleepState==1 && that.velocity.norm()>that.sleepSpeedLimit){
					that.wakeUp(); // Wake up
				} else if(sleepState==1 && (new Date().getTime() - timeLastSleepy)>that.sleepTimeLimit){
					sleepState = 2; // Sleeping
					that.dispatchEvent({type:"sleep"});
				}
			}
		};
	};
	/*global CANNON:true */

	/**
	 * @class CANNON.RigidBody
	 * @brief Rigid body base class
	 * @param float mass
	 * @param CANNON.Shape shape
	 * @param CANNON.Material material
	 */
	CANNON.RigidBody = function(mass,shape,material){

		// Check input
		if(typeof(mass)!="number")
			throw new Error("Argument 1 (mass) must be a number.");
		if(typeof(shape)!="object" || !(shape instanceof(CANNON.Shape)))
			throw new Error("Argument 2 (shape) must be an instance of CANNON.Shape.");
		if(typeof(material)!="undefined" && !(material instanceof(CANNON.Material)))
			throw new Error("Argument 3 (material) must be an instance of CANNON.Material.");

		CANNON.Particle.call(this,mass,material);

		var that = this;

		/**
		 * @property CANNON.Vec3 tau
		 * @memberof CANNON.RigidBody
		 * @brief Rotational force on the body, around center of mass
		 */
		this.tau = new CANNON.Vec3();

		/**
		 * @property CANNON.Quaternion quaternion
		 * @memberof CANNON.RigidBody
		 * @brief Orientation of the body
		 */
		this.quaternion = new CANNON.Quaternion();

		/**
		 * @property CANNON.Quaternion initQuaternion
		 * @memberof CANNON.RigidBody
		 */
		this.initQuaternion = new CANNON.Quaternion();

		/**
		 * @property CANNON.Vec3 angularVelocity
		 * @memberof CANNON.RigidBody
		 */
		this.angularVelocity = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 initAngularVelocity
		 * @memberof CANNON.RigidBody
		 */
		this.initAngularVelocity = new CANNON.Vec3();

		/**
		 * @property CANNON.Shape shape
		 * @memberof CANNON.RigidBody
		 */
		this.shape = shape;

		/**
		 * @property CANNON.Vec3 inertia
		 * @memberof CANNON.RigidBody
		 */
		this.inertia = new CANNON.Vec3();
		shape.calculateLocalInertia(mass,this.inertia);

		/**
		 * @property CANNON.Vec3 intInertia
		 * @memberof CANNON.RigidBody
		 */
		this.invInertia = new CANNON.Vec3(this.inertia.x>0 ? 1.0/this.inertia.x : 0,
			this.inertia.y>0 ? 1.0/this.inertia.y : 0,
			this.inertia.z>0 ? 1.0/this.inertia.z : 0);

		/**
		 * @property float angularDamping
		 * @memberof CANNON.RigidBody
		 */
		this.angularDamping = 0.01; // Perhaps default should be zero here?
	};
	/*global CANNON:true */

	/**
	 * @brief Spherical rigid body
	 * @class CANNON.Sphere
	 * @extends CANNON.Shape
	 * @param float radius
	 * @author schteppe / http://github.com/schteppe
	 */
	CANNON.Sphere = function(radius){
		CANNON.Shape.call(this);
		this.radius = radius!=undefined ? Number(radius) : 1.0;
		this.type = CANNON.Shape.types.SPHERE;
	};
	CANNON.Sphere.prototype = new CANNON.Shape();
	CANNON.Sphere.prototype.constructor = CANNON.Sphere;

	CANNON.Sphere.prototype.calculateLocalInertia = function(mass,target){
		target = target || new CANNON.Vec3();
		var I = 2.0*mass*this.radius*this.radius/5.0;
		target.x = I;
		target.y = I;
		target.z = I;
		return target;
	};

	CANNON.Sphere.prototype.volume = function(){
		return 4.0 * Math.PI * this.radius / 3.0;
	};

	CANNON.Sphere.prototype.boundingSphereRadius = function(){
		return this.radius;
	};/*global CANNON:true */

	/**
	 * @class CANNON.Box
	 * @brief A 3d box shape.
	 * @param CANNON.Vec3 halfExtents
	 * @author schteppe
	 * @extends CANNON.Shape
	 */
	CANNON.Box = function(halfExtents){
		CANNON.Shape.call(this);

		/**
		 * @property CANNON.Vec3 halfExtents
		 * @memberof CANNON.Box
		 */
		this.halfExtents = halfExtents;
		this.type = CANNON.Shape.types.BOX;

		/**
		 *
		 */
		this.convexPolyhedronRepresentation = null;

		this.updateConvexPolyhedronRepresentation();
	};
	CANNON.Box.prototype = new CANNON.Shape();
	CANNON.Box.prototype.constructor = CANNON.Box;

	/**
	 * @fn updateConvexPolyhedronRepresentation
	 * @memberof CANNON.Box
	 * @brief Updates the local convex polyhedron representation used for some collisions.
	 */
	CANNON.Box.prototype.updateConvexPolyhedronRepresentation = function(){
		var sx = this.halfExtents.x;
		var sy = this.halfExtents.y;
		var sz = this.halfExtents.z;
		var v = CANNON.Vec3;
		var h = new CANNON.ConvexPolyhedron([new v(-sx,-sy,-sz),
			new v( sx,-sy,-sz),
			new v( sx, sy,-sz),
			new v(-sx, sy,-sz),
			new v(-sx,-sy, sz),
			new v( sx,-sy, sz),
			new v( sx, sy, sz),
			new v(-sx, sy, sz)],

			[
				[0,1,2,3], // -z
				[4,5,6,7], // +z
				[0,1,4,5], // -y
				[2,3,6,7], // +y
				[0,3,4,7], // -x
				[1,2,5,6], // +x
			],

			[new v( 0, 0,-1),
				new v( 0, 0, 1),
				new v( 0,-1, 0),
				new v( 0, 1, 0),
				new v(-1, 0, 0),
				new v( 1, 0, 0)]);
		this.convexPolyhedronRepresentation = h;
	};

	CANNON.Box.prototype.calculateLocalInertia = function(mass,target){
		target = target || new CANNON.Vec3();
		target.x = 1.0 / 12.0 * mass * (   2*this.halfExtents.y*2*this.halfExtents.y
			+ 2*this.halfExtents.z*2*this.halfExtents.z );
		target.y = 1.0 / 12.0 * mass * (   2*this.halfExtents.x*2*this.halfExtents.x
			+ 2*this.halfExtents.z*2*this.halfExtents.z );
		target.z = 1.0 / 12.0 * mass * (   2*this.halfExtents.y*2*this.halfExtents.y
			+ 2*this.halfExtents.x*2*this.halfExtents.x );
		return target;
	};

	/**
	 * @fn getCorners
	 * @memberof CANNON.Box
	 * @brief Get the box corners
	 * @param CANNON.Quaternion quat Orientation to apply to the corner vectors. If not provided, the vectors will be in respect to the local frame.
	 * @return array
	 */
	CANNON.Box.prototype.getCorners = function(quat){
		var corners = [];
		var ex = this.halfExtents;
		corners.push(new CANNON.Vec3(  ex.x,  ex.y,  ex.z));
		corners.push(new CANNON.Vec3( -ex.x,  ex.y,  ex.z));
		corners.push(new CANNON.Vec3( -ex.x, -ex.y,  ex.z));
		corners.push(new CANNON.Vec3( -ex.x, -ex.y, -ex.z));
		corners.push(new CANNON.Vec3(  ex.x, -ex.y, -ex.z));
		corners.push(new CANNON.Vec3(  ex.x,  ex.y, -ex.z));
		corners.push(new CANNON.Vec3( -ex.x,  ex.y, -ex.z));
		corners.push(new CANNON.Vec3(  ex.x, -ex.y,  ex.z));

		for(var i=0; quat!=undefined && i<corners.length; i++)
			quat.vmult(corners[i],corners[i]);

		return corners;
	};

	/**
	 * @fn getSideNormals
	 * @memberof CANNON.Box
	 * @brief Get the box 6 side normals
	 * @param bool includeNegative If true, this function returns 6 vectors. If false, it only returns 3 (but you get 6 by reversing those 3)
	 * @param CANNON.Quaternion quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
	 * @return array
	 */
	CANNON.Box.prototype.getSideNormals = function(includeNegative,quat){
		var sides = [];
		var ex = this.halfExtents;
		sides.push(new CANNON.Vec3(  ex.x,     0,     0));
		sides.push(new CANNON.Vec3(     0,  ex.y,     0));
		sides.push(new CANNON.Vec3(     0,     0,  ex.z));
		if(includeNegative!=undefined && includeNegative){
			sides.push(new CANNON.Vec3( -ex.x,     0,     0));
			sides.push(new CANNON.Vec3(     0, -ex.y,     0));
			sides.push(new CANNON.Vec3(     0,     0, -ex.z));
		}

		for(var i=0; quat!=undefined && i<sides.length; i++)
			quat.vmult(sides[i],sides[i]);

		return sides;
	};

	CANNON.Box.prototype.volume = function(){
		return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
	};

	CANNON.Box.prototype.boundingSphereRadius = function(){
		return this.halfExtents.norm();
	};/*global CANNON:true */

	/**
	 * @class CANNON.Plane
	 * @extends CANNON.Shape
	 * @param CANNON.Vec3 normal
	 * @brief An infinite plane, facing in the direction of the given normal.
	 * @author schteppe
	 */
	CANNON.Plane = function(normal){
		CANNON.Shape.call(this);
		normal.normalize();
		this.normal = normal;
		this.type = CANNON.Shape.types.PLANE;
	};
	CANNON.Plane.prototype = new CANNON.Shape();
	CANNON.Plane.prototype.constructor = CANNON.Plane;

	CANNON.Plane.prototype.calculateLocalInertia = function(mass,target){
		target = target || new CANNON.Vec3();
		return target;
	};

	CANNON.Plane.prototype.volume = function(){
		return Infinity; // The plane is infinite...
	};/*global CANNON:true */

	/**
	 * @class CANNON.Compound
	 * @extends CANNON.Shape
	 * @brief A shape that is built of several other shapes, in this context called child shapes.
	 * @author schteppe
	 */
	CANNON.Compound = function(){
		CANNON.Shape.call(this);
		this.type = CANNON.Shape.types.COMPOUND;
		this.childShapes = [];
		this.childOffsets = [];
		this.childOrientations = [];
	};
	CANNON.Compound.prototype = new CANNON.Shape();
	CANNON.Compound.prototype.constructor = CANNON.Compound;

	/**
	 * @fn addChild
	 * @memberof CANNON.Compound
	 * @brief Add a child shape.
	 * @param CANNON.Shape shape
	 * @param CANNON.Vec3 offset
	 * @param CANNON.Quaternion orientation
	 */
	CANNON.Compound.prototype.addChild = function(shape,offset,orientation){
		offset = offset || new CANNON.Vec3();
		orientation = orientation || new CANNON.Quaternion();
		this.childShapes.push(shape);
		this.childOffsets.push(offset);
		this.childOrientations.push(orientation);
	};

	CANNON.Compound.prototype.volume = function(){
		var r = 0.0;
		for(var i = 0; i<this.childShapes.length; i++)
			r += this.childShapes[i].volume();
		return r;
	};

	CANNON.Compound.prototype.calculateLocalInertia = function(mass,target){
		target = target || new CANNON.Vec3();

		// Calculate the total volume, we will spread out this objects' mass on the sub shapes
		var V = this.volume();

		for(var i = 0; i<this.childShapes.length; i++){
			// Get child information
			var b = this.childShapes[i];
			var o = this.childOffsets[i];
			var q = this.childOrientations[i];
			var m = b.volume() / V * mass;

			// Get the child inertia, transformed relative to local frame
			var inertia = b.calculateTransformedInertia(m,q);

			// Add its inertia using the parallel axis theorem, i.e.
			// I += I_child;    
			// I += m_child * r^2

			target.vadd(inertia,target);
			var mr2 = new CANNON.Vec3(m*o.x*o.x,
				m*o.y*o.y,
				m*o.z*o.z);
			target.vadd(mr2,target);
		}
		return target;
	};

	CANNON.Compound.prototype.boundingSphereRadius = function(){
		var r = 0.0;
		for(var i = 0; i<this.childShapes.length; i++){
			var candidate = this.childOffsets[i].norm() + this.childShapes[i].boundingSphereRadius();
			if(r < candidate)
				r = candidate;
		}
		return r;
	};/**
	 * @class CANNON.ConvexPolyhedron
	 * @extends CANNON.Shape
	 * @brief A set of points in space describing a convex shape.
	 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
	 * @author schteppe / https://github.com/schteppe
	 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
	 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
	 * @todo move the clipping functions to ContactGenerator?
	 * @param array points An array of CANNON.Vec3's
	 * @param array faces Deprecated - fix autogenerator for these
	 * @param array normals Deprecated - fix autogenerator for these
	 */
	CANNON.ConvexPolyhedron = function( points , faces , normals ) {
		var that = this;
		CANNON.Shape.call( this );
		this.type = CANNON.Shape.types.CONVEXPOLYHEDRON;

		/**
		 * @property array vertices
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Array of CANNON.Vec3
		 */
		this.vertices = [];

		/**
		 * @property array faces
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Array of integer arrays, indicating which vertices each face consists of
		 * @todo Needed?
		 */
		this.faces = faces;

		/**
		 * @property array faceNormals
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Array of CANNON.Vec3
		 * @todo Needed?
		 */
		this.faceNormals = normals;

		/**
		 * @property array uniqueEdges
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Array of CANNON.Vec3
		 */
		this.uniqueEdges = [];

		for(pi in points){
			var p = points[pi];
			if(!(p instanceof CANNON.Vec3)){
				throw "Argument 1 must be instance of CANNON.Vec3";
				return false;
			}
			this.vertices.push(p);
		}

		for(var i=0; i<faces.length; i++){
			var numVertices = faces[i].length;
			var NbTris = numVertices;
			for(var j=0; j<NbTris; j++){
				var k = ( j+1 ) % numVertices;
				var edge = new CANNON.Vec3();
				this.vertices[faces[i][j]].vsub(this.vertices[faces[i][k]],edge);
				edge.normalize();
				var found = false;
				for(var p=0;p<this.uniqueEdges.length;p++){
					if (this.uniqueEdges[p].almostEquals(edge) ||
						this.uniqueEdges[p].almostEquals(edge)){
						found = true;
						break;
					}
				}

				// What is this for???
				if (!found){
					this.uniqueEdges.push(edge);
				}

				if (edge) {
					edge.face1 = i;
				} else {
					var ed;
					ed.m_face0 = i;
					edges.insert(vp,ed);
				}
			}
		}

		/**
		 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
		 * @param CANNON.ConvexPolyhedron hull
		 * @param CANNON.Vec3 axis
		 * @param CANNON.Vec3 pos
		 * @param CANNON.Quaternion quat
		 * @param array maxmin maxmin[0] and maxmin[1] will be set to maximum and minimum, respectively.
		 */
		function project(hull,axis,pos,quat,maxmin){
			var n = hull.vertices.length;
			var max = null;
			var min = null;
			var vs = hull.vertices;
			var worldVertex = new CANNON.Vec3();
			for(var i=0; i<n; i++){
				vs[i].copy(worldVertex);
				//console.log("orig:",worldVertex.toString());
				quat.vmult(worldVertex,worldVertex);
				//console.log("after the quat ",quat.toString(),":",worldVertex.toString());
				worldVertex.vadd(pos,worldVertex);
				//console.log("after adding pos",pos.toString(),"worldvertex:",worldVertex.toString());
				var val = worldVertex.dot(axis);
				if(max===null || val>max)
					max = val;
				if(min===null || val<min){
					min = val;
				}
			}

			if(min>max){
				// Inconsistent - swap
				var temp = min;
				min = max;
				max = temp;
			}

			// Output
			maxmin[0] = max;
			maxmin[1] = min;
		}

		/**
		 * @fn testSepAxis
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
		 * @param CANNON.Vec3 axis
		 * @param CANNON.ConvexPolyhedron hullB
		 * @param CANNON.Vec3 posA
		 * @param CANNON.Quaternion quatA
		 * @param CANNON.Vec3 posB
		 * @param CANNON.Quaternion quatB
		 * @return float The overlap depth, or FALSE if no penetration.
		 */
		this.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){
			var maxminA=[], maxminB=[], hullA=this;
			project(hullA, axis, posA, quatA, maxminA);
			project(hullB, axis, posB, quatB, maxminB);
			var maxA = maxminA[0];
			var minA = maxminA[1];
			var maxB = maxminB[0];
			var minB = maxminB[1];
			if(maxA<minB || maxB<minA){
				//console.log(minA,maxA,minB,maxB);
				return false; // Separated
			}

			var d0 = maxA - minB;
			var d1 = maxB - minA;
			depth = d0<d1 ? d0:d1;
			return depth;
		}

		/**
		 * @fn findSeparatingAxis
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Find the separating axis between this hull and another
		 * @param CANNON.ConvexPolyhedron hullB
		 * @param CANNON.Vec3 posA
		 * @param CANNON.Quaternion quatA
		 * @param CANNON.Vec3 posB
		 * @param CANNON.Quaternion quatB
		 * @param CANNON.Vec3 target The target vector to save the axis in
		 * @return bool Returns false if a separation is found, else true
		 */
		this.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target){
			var dmin = Infinity;
			var hullA = this;
			var curPlaneTests=0;
			var numFacesA = hullA.faces.length;

			// Test normals from hullA
			var faceANormalWS = new CANNON.Vec3();
			for(var i=0; i<numFacesA; i++){
				// Get world face normal
				hullA.faceNormals[i].copy(faceANormalWS);
				quatA.vmult(faceANormalWS,faceANormalWS);
				//posA.vadd(faceANormalWS,faceANormalWS); // Needed?
				//console.log("face normal:",hullA.faceNormals[i].toString(),"world face normal:",faceANormalWS);

				var d = hullA.testSepAxis(faceANormalWS, hullB, posA, quatA, posB, quatB);
				if(d===false){
					return false;
				}

				if(d<dmin){
					dmin = d;
					faceANormalWS.copy(target);
				}
			}

			// Test normals from hullB
			var WorldNormal = new CANNON.Vec3();
			var numFacesB = hullB.faces.length;
			for(var i=0;i<numFacesB;i++){
				hullB.faceNormals[i].copy(WorldNormal);
				quatB.vmult(WorldNormal,WorldNormal);
				//posB.vadd(WorldNormal,WorldNormal);
				//console.log("facenormal",hullB.faceNormals[i].toString(),"world:",WorldNormal.toString());
				curPlaneTests++;
				var d = hullA.testSepAxis(WorldNormal, hullB,posA,quatA,posB,quatB);
				if(d===false){
					return false;
				}

				if(d<dmin){
					dmin = d;
					WorldNormal.copy(target);
				}
			}

			var edgeAstart,edgeAend,edgeBstart,edgeBend;

			var curEdgeEdge = 0;
			// Test edges
			var WorldEdge0 = new CANNON.Vec3();
			var WorldEdge1 = new CANNON.Vec3();
			var Cross = new CANNON.Vec3();
			for(var e0=0; e0<hullA.uniqueEdges.length; e0++){
				// Get world edge
				hullA.uniqueEdges[e0].copy(WorldEdge0);
				quatA.vmult(WorldEdge0,WorldEdge0);
				//posA.vadd(WorldEdge0,WorldEdge0); // needed?

				//console.log("edge0:",WorldEdge0.toString());

				for(var e1=0; e1<hullB.uniqueEdges.length; e1++){
					hullB.uniqueEdges[e1].copy(WorldEdge1);
					quatB.vmult(WorldEdge1,WorldEdge1);
					//posB.vadd(WorldEdge1,WorldEdge1); // needed?
					//console.log("edge1:",WorldEdge1.toString());

					WorldEdge0.cross(WorldEdge1,Cross);

					curEdgeEdge++;
					if(!Cross.almostZero()){
						Cross.normalize();
						var dist = hullA.testSepAxis( Cross, hullB, posA,quatA,posB,quatB);
						if(dist===false){
							return false;
						}

						if(dist<dmin){
							dmin = dist;
							Cross.copy(target);
						}
					}
				}
			}

			var deltaC = new CANNON.Vec3();
			posB.vsub(posA,deltaC);
			if((deltaC.dot(target))>0.0)
				target.negate(target);

			return true;
		}

		/**
		 * @fn clipAgainstHull
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Clip this hull against another hull
		 * @param CANNON.Vec3 posA
		 * @param CANNON.Quaternion quatA
		 * @param CANNON.ConvexPolyhedron hullB
		 * @param CANNON.Vec3 posB
		 * @param CANNON.Quaternion quatB
		 * @param CANNON.Vec3 separatingNormal
		 * @param float minDist Clamp distance
		 * @param float maxDist
		 * @param array result The an array of contact point objects, see clipFaceAgainstHull
		 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
		 */
		this.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){
			if(!(posA instanceof CANNON.Vec3))
				throw new Error("posA must be Vec3");
			if(!(quatA instanceof CANNON.Quaternion))
				throw new Error("quatA must be Quaternion");
			var hullA = this;
			var curMaxDist = maxDist;
			var closestFaceB = -1;
			var dmax = -Infinity;
			var WorldNormal = new CANNON.Vec3();
			for(var face=0; face < hullB.faces.length; face++){
				hullB.faceNormals[face].copy(WorldNormal);
				quatB.vmult(WorldNormal,WorldNormal);
				posB.vadd(WorldNormal,WorldNormal);

				var d = WorldNormal.dot(separatingNormal);
				if (d > dmax){
					dmax = d;
					closestFaceB = face;
				}
			}
			var worldVertsB1 = [];
			polyB = hullB.faces[closestFaceB];
			var numVertices = polyB.length;
			for(var e0=0; e0<numVertices; e0++){
				var b = hullB.vertices[polyB[e0]];
				var worldb = new CANNON.Vec3();
				b.copy(worldb);
				quatB.vmult(worldb,worldb);
				posB.vadd(worldb,worldb);
				worldVertsB1.push(worldb);
			}
			//console.log("--- clipping face: ",worldVertsB1);
			if (closestFaceB>=0)
				this.clipFaceAgainstHull(separatingNormal,
					posA,
					quatA,
					worldVertsB1,
					minDist,
					maxDist,
					result);
		};

		/**
		 * @fn clipFaceAgainstHull
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Clip a face against a hull.
		 * @param CANNON.Vec3 separatingNormal
		 * @param CANNON.Vec3 posA
		 * @param CANNON.Quaternion quatA
		 * @param Array worldVertsB1 An array of CANNON.Vec3 with vertices in the world frame.
		 * @param float minDist Distance clamping
		 * @param float maxDist
		 * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
		 */
		this.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){
			if(!(separatingNormal instanceof CANNON.Vec3))
				throw new Error("sep normal must be vector");
			if(!(worldVertsB1 instanceof Array))
				throw new Error("world verts must be array");
			minDist = Number(minDist);
			maxDist = Number(maxDist);
			var hullA = this;
			var worldVertsB2 = [];
			var pVtxIn = worldVertsB1;
			var pVtxOut = worldVertsB2;

			// Find the face with normal closest to the separating axis
			var closestFaceA = -1;
			var dmin = Infinity;
			var faceANormalWS = new CANNON.Vec3();
			for(var face=0; face<hullA.faces.length; face++){
				hullA.faceNormals[face].copy(faceANormalWS);
				quatA.vmult(faceANormalWS,faceANormalWS);
				posA.vadd(faceANormalWS,faceANormalWS);
				var d = faceANormalWS.dot(separatingNormal);
				if (d < dmin){
					dmin = d;
					closestFaceA = face;
				}
			}
			if (closestFaceA<0){
				console.log("--- did not find any closest face... ---");
				return;
			}
			//console.log("closest A: ",closestFaceA);

			// Get the face and construct connected faces
			var polyA = hullA.faces[closestFaceA];
			polyA.connectedFaces = [];
			for(var i=0; i<hullA.faces.length; i++)
				for(var j=0; j<hullA.faces[i].length; j++)
					if(polyA.indexOf(hullA.faces[i][j])!==-1 && // Sharing a vertex
						i!==closestFaceA && // Not the one we are looking for connections from
						polyA.connectedFaces.indexOf(i)===-1 // Not already added
						)
						polyA.connectedFaces.push(i);

			// Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
			var numContacts = pVtxIn.length;
			var numVerticesA = polyA.length;
			var edge0 = new CANNON.Vec3();
			var WorldEdge0 = new CANNON.Vec3();
			var worldPlaneAnormal1 = new CANNON.Vec3();
			var planeNormalWS1 = new CANNON.Vec3();
			var res = [];
			for(var e0=0; e0<numVerticesA; e0++){
				var a = hullA.vertices[polyA[e0]];
				var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];
				a.vsub(b,edge0);
				edge0.copy(WorldEdge0);
				quatA.vmult(WorldEdge0,WorldEdge0);
				posA.vadd(WorldEdge0,WorldEdge0);
				this.faceNormals[closestFaceA].copy(worldPlaneAnormal1);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
				quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);
				posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);
				WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);
				planeNormalWS1.negate(planeNormalWS1);
				var worldA1 = new CANNON.Vec3();
				a.copy(worldA1);
				quatA.vmult(worldA1,worldA1);
				posA.vadd(worldA1,worldA1);
				var planeEqWS1 = -worldA1.dot(planeNormalWS1);

				if(true){
					var otherFace = polyA.connectedFaces[e0];
					var localPlaneNormal = new CANNON.Vec3();
					this.faceNormals[otherFace].copy(localPlaneNormal);
					var localPlaneEq = planeConstant(otherFace);

					var planeNormalWS = new CANNON.Vec3();
					localPlaneNormal.copy(planeNormalWS);
					quatA.vmult(planeNormalWS,planeNormalWS);
					//posA.vadd(planeNormalWS,planeNormalWS);
					var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
				} else  {
					var planeNormalWS = planeNormalWS1;
					var planeEqWS = planeEqWS1;
				}

				// Clip face against our constructed plane
				//console.log("clipping polygon ",printFace(closestFaceA)," against plane ",planeNormalWS, planeEqWS);
				this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);
				//console.log(" - clip result: ",pVtxOut);

				// Throw away all clipped points, but save the reamining until next clip
				while(pVtxIn.length)  pVtxIn.shift();
				while(pVtxOut.length) pVtxIn.push(pVtxOut.shift());
			}

			//console.log("Resulting points after clip:",pVtxIn);

			// only keep contact points that are behind the witness face
			var localPlaneNormal = new CANNON.Vec3();
			this.faceNormals[closestFaceA].copy(localPlaneNormal);

			var localPlaneEq = planeConstant(closestFaceA);
			var planeNormalWS = new CANNON.Vec3();
			localPlaneNormal.copy(planeNormalWS);
			quatA.vmult(planeNormalWS,planeNormalWS);

			var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
			for (var i=0; i<pVtxIn.length; i++){
				var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
				/*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
				if (depth <=minDist){
					console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
					depth = minDist;
				}

				if (depth <=maxDist){
					var point = pVtxIn[i];
					/*console.log("Got contact point ",point.toString(),
					 ", depth=",depth,
					 "contact normal=",separatingNormal.toString(),
					 "plane",planeNormalWS.toString(),
					 "planeConstant",planeEqWS);*/
					var p = {
						point:point,
						normal:planeNormalWS,
						depth: depth,
					};
					result.push(p);
				}
			}
		}

		/**
		 * @fn clipFaceAgainstPlane
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Clip a face in a hull against the back of a plane.
		 * @param Array inVertices
		 * @param Array outVertices
		 * @param CANNON.Vec3 planeNormal
		 * @param float planeConstant The constant in the mathematical plane equation
		 */
		this.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){
			if(!(planeNormal instanceof CANNON.Vec3))
				throw new Error("planeNormal must be Vec3, "+planeNormal+" given");
			if(!(inVertices instanceof Array))
				throw new Error("invertices must be Array, "+inVertices+" given");
			if(!(outVertices instanceof Array))
				throw new Error("outvertices must be Array, "+outVertices+" given");
			var n_dot_first, n_dot_last;
			var numVerts = inVertices.length;

			if(numVerts < 2)
				return outVertices;

			var firstVertex = inVertices[inVertices.length-1];
			var lastVertex =   inVertices[0];

			n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

			for(var vi = 0; vi < numVerts; vi++){
				lastVertex = inVertices[vi];
				n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
				if(n_dot_first < 0){
					if(n_dot_last < 0){
						// Start < 0, end < 0, so output lastVertex
						var newv = new CANNON.Vec3();
						lastVertex.copy(newv);
						outVertices.push(newv);
					} else {
						// Start < 0, end >= 0, so output intersection
						var newv = new CANNON.Vec3();
						firstVertex.lerp(lastVertex,
							n_dot_first / (n_dot_first - n_dot_last),
							newv);
						outVertices.push(newv);
					}
				} else {
					if(n_dot_last<0){
						// Start >= 0, end < 0 so output intersection and end
						var newv = new CANNON.Vec3();
						firstVertex.lerp(lastVertex,
							n_dot_first / (n_dot_first - n_dot_last),
							newv);
						outVertices.push(newv);
						outVertices.push(lastVertex);
					}
				}
				firstVertex = lastVertex;
				n_dot_first = n_dot_last;
			}
			return outVertices;
		}

		/**
		 * Whether the face is visible from the vertex
		 * @param array face
		 * @param CANNON.Vec3 vertex
		 */
		function visible( face, vertex ) {
			var va = that.vertices[ face[ 0 ] ];
			var vb = that.vertices[ face[ 1 ] ];
			var vc = that.vertices[ face[ 2 ] ];

			var n = new CANNON.Vec3();
			normal( va, vb, vc, n );

			// distance from face to origin
			var dist = n.dot( va );

			return n.dot( vertex ) >= dist;
		}

		var that = this;
		function normalOfFace(i,target){
			var f = that.faces[i];
			var va = that.vertices[f[0]];
			var vb = that.vertices[f[1]];
			var vc = that.vertices[f[2]];
			return normal(va,vb,vc,target);
		}

		function planeConstant(face_i,target){
			var f = that.faces[face_i];
			var n = that.faceNormals[face_i];
			var v = that.vertices[f[0]];
			var c = -n.dot(v);
			return c;
		}

		/**
		 * @brief Get face normal given 3 vertices
		 * @param CANNON.Vec3 va
		 * @param CANNON.Vec3 vb
		 * @param CANNON.Vec3 vc
		 * @param CANNON.Vec3 target
		 * @todo unit test?
		 */
		function normal( va, vb, vc, target ) {
			var cb = new CANNON.Vec3();
			var ab = new CANNON.Vec3();

			vb.vsub(va,ab);
			vc.vsub(vb,cb);
			cb.cross(ab,target);

			if ( !target.isZero() ) {
				target.normalize();
			}
		}

		function printFace(i){
			var f = that.faces[i], s = "";
			for(var j=0; j<f.length; j++)
				s += " ("+that.vertices[f[j]]+")";
			return s;
		}

		/**
		 * Detect whether two edges are equal.
		 * Note that when constructing the convex hull, two same edges can only
		 * be of the negative direction.
		 * @return bool
		 */
		function equalEdge( ea, eb ) {
			return ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ];
		}

		/**
		 * Create a random offset between -1e-6 and 1e-6.
		 * @return float
		 */
		function randomOffset() {
			return ( Math.random() - 0.5 ) * 2 * 1e-6;
		}

		this.calculateLocalInertia = function(mass,target){
			// Approximate with box inertia
			// Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
			var x = this.aabbmax.x - this.aabbmin.x,
				y = this.aabbmax.y - this.aabbmin.y,
				z = this.aabbmax.z - this.aabbmin.z;
			target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );
			target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );
			target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );
		}

		this.computeAABB = function(){
			var n = this.vertices.length,
				aabbmin = this.aabbmin,
				aabbmax = this.aabbmax,
				vertices = this.vertices;
			aabbmin.set(Infinity,Infinity,Infinity);
			aabbmax.set(-Infinity,-Infinity,-Infinity);
			for(var i=0; i<n; i++){
				var v = vertices[i];
				if     (v.x < aabbmin.x) aabbmin.x = v.x;
				else if(v.x > aabbmax.x) aabbmax.x = v.x;
				if     (v.y < aabbmin.y) aabbmin.y = v.y;
				else if(v.y > aabbmax.y) aabbmax.y = v.y;
				if     (v.z < aabbmin.z) aabbmin.z = v.z;
				else if(v.z > aabbmax.z) aabbmax.z = v.z;
			}
		}

		this.boundingSphereRadius = function(){
			// Assume points are distributed with local (0,0,0) as center
			var max2 = 0;
			for(var i=0; i<this.vertices.length; i++) {
				var norm2 = this.vertices[i].norm2();
				if(norm2>max2)
					max2 = norm2;
			}
			return Math.sqrt(max2);
		}

		this.computeAABB();
	};

	CANNON.ConvexPolyhedron.prototype = new CANNON.Shape();
	CANNON.ConvexPolyhedron.prototype.constructor = CANNON.ConvexPolyhedron;/*global CANNON:true */

	/**
	 * @class CANNON.Solver
	 * @brief Constraint solver.
	 * @todo The spook parameters should be specified for each constraint, not globally.
	 * @author schteppe / https://github.com/schteppe
	 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
	 */
	CANNON.Solver = function(){

		/**
		 * @property int iterations
		 * @brief The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
		 * @todo write more about solver and iterations in the wiki
		 * @memberof CANNON.Solver
		 */
		this.iterations = 10;

		/**
		 * @property float h
		 * @brief Time step size. The larger timestep, the less computationally heavy will your simulation be. But watch out, you don't want your bodies to tunnel each instead of colliding!
		 * @memberof CANNON.Solver
		 */
		this.h = 1.0/60.0;

		/**
		 * @property float k
		 * @brief SPOOK parameter, spring stiffness
		 * @memberof CANNON.Solver
		 */
		this.k = 1000;

		/**
		 * @property float d
		 * @brief SPOOK parameter, similar to damping
		 * @memberof CANNON.Solver
		 */
		this.d = 4;

		/**
		 * @property float a
		 * @brief SPOOK parameter
		 * @memberof CANNON.Solver
		 */
		this.a = 0.0;

		/**
		 * @property float b
		 * @brief SPOOK parameter
		 * @memberof CANNON.Solver
		 */
		this.b = 0.0;

		/**
		 * @property float eps
		 * @brief SPOOK parameter
		 * @memberof CANNON.Solver
		 */
		this.eps = 0.0;

		this.setSpookParams(this.k,this.d);
		this.reset(0);

		/**
		 * @property bool debug
		 * @brief Debug flag, will output solver data to console if true
		 * @memberof CANNON.Solver
		 */
		this.debug = false;

		if(this.debug)
			console.log("a:",this.a,"b",this.b,"eps",this.eps,"k",this.k,"d",this.d);
	};

	/**
	 * @fn setSpookParams
	 * @memberof CANNON.Solver
	 * @brief Sets the SPOOK parameters k and d, and updates the other parameters a, b and eps accordingly.
	 * @param float k
	 * @param float d
	 */
	CANNON.Solver.prototype.setSpookParams = function(k,d){
		var h=this.h;

		this.k = k;
		this.d = d;
		this.a = 4.0 / (h * (1 + 4 * d));
		this.b = (4.0 * d) / (1 + 4 * d);
		this.eps = 4.0 / (h * h * k * (1 + 4 * d));
	};

	/**
	 * @fn reset
	 * @memberof CANNON.Solver
	 * @brief Resets the solver, removes all constraints and prepares for a new round of solving
	 * @param int numbodies The number of bodies in the new system
	 * @todo vlambda does not need to be instantiated again if the number of bodies is the same. Set to zero instead.
	 */
	CANNON.Solver.prototype.reset = function(numbodies){

		// Don't know number of constraints yet... Use dynamic arrays
		this.G = [];
		this.MinvTrace = [];
		this.Fext = [];
		this.q = [];
		this.qdot = [];
		this.n = 0;
		this.upper = [];
		this.lower = [];
		this.hasupper = [];
		this.haslower = [];
		this.i = []; // To keep track of body id's
		this.j = [];

		this.vxlambda = [];
		this.vylambda = [];
		this.vzlambda = [];
		this.wxlambda = [];
		this.wylambda = [];
		this.wzlambda = [];
		for(var i=0; i<numbodies; i++){
			this.vxlambda.push(0);
			this.vylambda.push(0);
			this.vzlambda.push(0);
			this.wxlambda.push(0);
			this.wylambda.push(0);
			this.wzlambda.push(0);
		}
	};

	/**
	 * @fn addConstraint
	 * @memberof CANNON.Solver
	 * @brief Add a constraint to the solver
	 * @param array G Jacobian vector, 12 elements (6 dof per body)
	 * @param array MinvTrace The trace of the Inverse mass matrix (12 elements). The mass matrix is 12x12 elements from the beginning and 6x6 matrix per body (mass matrix and inertia matrix).
	 * @param array q The constraint violation vector in generalized coordinates (12 elements)
	 * @param array qdot The time-derivative of the constraint violation vector q.
	 * @param array Fext External forces (12 elements)
	 * @param float lower Lower constraint force bound
	 * @param float upper Upper constraint force bound
	 * @param int body_i The first body index
	 * @param int body_j The second body index - set to -1 if none
	 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
	 */
	CANNON.Solver.prototype.addConstraint = function(G,MinvTrace,q,qdot,Fext,lower,upper,body_i,body_j){
		if(this.debug){
			console.log("Adding constraint ",this.n," between body ",body_i," and ",body_j);
			console.log("G:",G);
			console.log("q:",q);
			console.log("qdot:",qdot);
			console.log("Fext:",Fext);
			console.log("lower:",lower);
			console.log("upper:",upper);
		}

		for(var i=0; i<12; i++){
			this.q.push(q[i]);
			this.qdot.push(qdot[i]);
			this.MinvTrace.push(MinvTrace[i]);
			this.G.push(G[i]);
			this.Fext.push(Fext[i]);
		}

		this.upper.push(upper);
		this.hasupper.push(!isNaN(upper));
		this.lower.push(lower);
		this.haslower.push(!isNaN(lower));

		this.i.push(body_i);
		this.j.push(body_j);

		this.n += 1;

		// Return result index
		return this.n - 1;
	};

	/**
	 * New version of the addConstraint function, still experimental
	 */
	CANNON.Solver.prototype.addConstraint2 = function(c,i,j){
		c.update();
		for(var k=0; k<c.equations.length; k++){
			var e = c.equations[k];
			this.addConstraint([e.G1.x,e.G1.y,e.G1.z,
				e.G2.x,e.G2.y,e.G2.z,
				e.G3.x,e.G3.y,e.G3.z,
				e.G4.x,e.G4.y,e.G4.z],

				[e.iM1.x,e.iM1.y,e.iM1.z,
					e.iM2.x,e.iM2.y,e.iM2.z,
					e.iM3.x,e.iM3.y,e.iM3.z,
					e.iM4.x,e.iM4.y,e.iM4.z],

				[e.g1.x,e.g1.y,e.g1.z,
					e.g2.x,e.g2.y,e.g2.z,
					e.g3.x,e.g3.y,e.g3.z,
					e.g4.x,e.g4.y,e.g4.z],

				[e.W1.x,e.W1.y,e.W1.z,
					e.W2.x,e.W2.y,e.W2.z,
					e.W3.x,e.W3.y,e.W3.z,
					e.W4.x,e.W4.y,e.W4.z],

				[e.f1.x,e.f1.y,e.f1.z,
					e.f2.x,e.f2.y,e.f2.z,
					e.f3.x,e.f3.y,e.f3.z,
					e.f4.x,e.f4.y,e.f4.z],

				e.lambdamin,
				e.lambdamax,

				i,
				j);
		}
	};


	/**
	 * @fn addNonPenetrationConstraint
	 * @memberof CANNON.Solver
	 * @brief Add a non-penetration constraint to the solver
	 * @param CANNON.Vec3 ni
	 * @param CANNON.Vec3 ri
	 * @param CANNON.Vec3 rj
	 * @param CANNON.Vec3 iMi
	 * @param CANNON.Vec3 iMj
	 * @param CANNON.Vec3 iIi
	 * @param CANNON.Vec3 iIj
	 * @param CANNON.Vec3 v1
	 * @param CANNON.Vec3 v2
	 * @param CANNON.Vec3 w1
	 * @param CANNON.Vec3 w2
	 */
	CANNON.Solver.prototype.addNonPenetrationConstraint
		= function(i,j,xi,xj,ni,ri,rj,iMi,iMj,iIi,iIj,vi,vj,wi,wj,fi,fj,taui,tauj){

		var rxn = ri.cross(ni);
		var u = vj.vsub(vi); // vj.vadd(rj.cross(wj)).vsub(vi.vadd(ri.cross(wi)));

		// g = ( xj + rj - xi - ri ) .dot ( ni )
		var qvec = xj.vadd(rj).vsub(xi.vadd(ri));
		var q = qvec.dot(ni);

		if(q<0.0){
			if(this.debug){
				console.log("i:",i,"j",j,"xi",xi.toString(),"xj",xj.toString());
				console.log("ni",ni.toString(),"ri",ri.toString(),"rj",rj.toString());
				console.log("iMi",iMi.toString(),"iMj",iMj.toString(),"iIi",iIi.toString(),"iIj",iIj.toString(),"vi",vi.toString(),"vj",vj.toString(),"wi",wi.toString(),"wj",wj.toString(),"fi",fi.toString(),"fj",fj.toString(),"taui",taui.toString(),"tauj",tauj.toString());
			}
			this.addConstraint( // Non-penetration constraint jacobian
				[ -ni.x,  -ni.y,  -ni.z,
					-rxn.x, -rxn.y, -rxn.z,
					ni.x,   ni.y,   ni.z,
					rxn.x,  rxn.y,  rxn.z],

				// Inverse mass matrix & inertia
				[iMi.x, iMi.y, iMi.z,
					iIi.z, iIi.y, iIi.z,
					iMj.x, iMj.y, iMj.z,
					iIj.z, iIj.y, iIj.z],

				// q - constraint violation
				[-qvec.x,-qvec.y,-qvec.z,
					0,0,0,
					qvec.x,qvec.y,qvec.z,
					0,0,0],

				// qdot - motion along penetration normal
				[-u.x, -u.y, -u.z,
					0,0,0,
					u.x, u.y, u.z,
					0,0,0],

				// External force - forces & torques
				[fi.x,fi.y,fi.z,
					taui.x,taui.y,taui.z,
					fj.x,fj.y,fj.z,
					tauj.x,tauj.y,tauj.z],

				0,
				'inf',
				i,
				j);
		}
	};

	/**
	 * @fn solve
	 * @memberof CANNON.Solver
	 * @brief Solves the system, and sets the vlambda and wlambda properties of the Solver object
	 */
	CANNON.Solver.prototype.solve = function(){
		var n = this.n,
			lambda = [],
			dlambda = [],
			ulambda = [],
			B = [],
			c = [],
			precomp = [],
			iterations = this.iterations,
			G = this.G,
			debug = this.debug,
			a = this.a,
			eps = this.eps;

		var lower = this.lower,
			haslower = this.haslower,
			upper = this.upper,
			hasupper = this.hasupper;

		var vxlambda = this.vxlambda,
			vylambda = this.vylambda,
			vzlambda = this.vzlambda,
			wxlambda = this.wxlambda,
			wylambda = this.wylambda,
			wzlambda = this.wzlambda;
		var MinvTrace = this.MinvTrace;

		for(var i=0; i<n; i++){
			lambda.push(0);
			dlambda.push(0);
			B.push(0);
			c.push(0);
			precomp.push(0);
			for(var j=0; j<12; j++)
				dlambda.push(0);
		}

		for(var k = 0; k<iterations; k++){
			for(var l=0; l<n; l++){

				// Bodies participating in constraint
				var body_i = this.i[l];
				var body_j = this.j[l];

				var l12 = 12*l;

				if(!precomp[l]){
					// Precompute constants c[l] and B[l] for contact l
					var G_Minv_Gt = 0.0;
					var Gq = 0.0;
					var GW = 0.0;
					var GMinvf = 0.0;
					// Only add normal contributions here? See eq. 27 in spooknotes
					for(var i=0; i<12; i++){
						var addi = l12+i;
						G_Minv_Gt += G[addi] * MinvTrace[addi] * G[addi];
						Gq +=        G[addi] * this.q[addi];
						GW +=        G[addi] * this.qdot[addi];
						GMinvf +=    G[addi] * MinvTrace[addi] * this.Fext[addi];
					}
					c[l] = 1.0 / (G_Minv_Gt + eps); // 1.0 / ( G*Minv*Gt + eps)
					B[l] = ( - a * Gq
						- this.b * GW
						- this.h * GMinvf);
					precomp[l] = 1;

					if(debug){
						console.log("G_Minv_Gt["+l+"]:",G_Minv_Gt);
						console.log("Gq["+l+"]:",Gq);
						console.log("GW["+l+"]:",GW);
						console.log("GMinvf["+l+"]:",GMinvf);
					}
				}

				var Gulambda = 0.0;

				//console.log("debuuug2.1",vxlambda[0],Gulambda,body_i);
				if(body_i>=0){
					Gulambda += G[0+l12] * vxlambda[body_i]; // previuously calculated lambdas
					Gulambda += G[1+l12] * vylambda[body_i];
					Gulambda += G[2+l12] * vzlambda[body_i];
					Gulambda += G[3+l12] * wxlambda[body_i];
					Gulambda += G[4+l12] * wylambda[body_i];
					Gulambda += G[5+l12] * wzlambda[body_i];
					if(debug && isNaN(Gulambda))
						console.log("found NaN Gulambda",vxlambda);
				}

				if(body_j!==-1){
					Gulambda += G[6+l12] * vxlambda[body_j];
					Gulambda += G[7+l12] * vylambda[body_j];
					Gulambda += G[8+l12] * vzlambda[body_j];
					Gulambda += G[9+l12] * wxlambda[body_j];
					Gulambda += G[10+l12] * wylambda[body_j];
					Gulambda += G[11+l12] * wzlambda[body_j];
				}

				dlambda[l] = c[l] * ( B[l] - Gulambda - eps * lambda[l]);
				if(debug)
					console.log("dlambda["+l+"]=",dlambda[l],"rest = ",c[l],B[l],Gulambda,eps,lambda[l],l,body_i,body_j);
				lambda[l] = lambda[l] + dlambda[l];

				// Clamp lambda if out of bounds
				// @todo check if limits are numbers
				if(haslower[l] && lambda[l]<lower[l]){
					if(debug)
						console.log("hit lower bound for constraint "+l+", truncating "+lambda[l]+" to the bound "+lower[l]);
					lambda[l] = lower[l];
					dlambda[l] = lower[l]-lambda[l];
				}
				if(hasupper && lambda[l]>upper[l]){
					if(debug)
						console.log("hit upper bound for constraint "+l+", truncating "+lambda[l]+" to the bound "+upper[l]);
					lambda[l] = upper[l];
					dlambda[l] = upper[l]-lambda[l];
				}

				// Add velocity changes to keep track of them
				if(body_i!==-1){
					vxlambda[body_i] += dlambda[l] * MinvTrace[l12+0] * G[l12+0];
					vylambda[body_i] += dlambda[l] * MinvTrace[l12+1] * G[l12+1];
					vzlambda[body_i] += dlambda[l] * MinvTrace[l12+2] * G[l12+2];
					wxlambda[body_i] += dlambda[l] * MinvTrace[l12+3] * G[l12+3];
					wylambda[body_i] += dlambda[l] * MinvTrace[l12+4] * G[l12+4];
					wzlambda[body_i] += dlambda[l] * MinvTrace[l12+5] * G[l12+5];
				}
				if(body_j!==-1){
					vxlambda[body_j] += dlambda[l] * MinvTrace[l12+6] * G[l12+6];
					vylambda[body_j] += dlambda[l] * MinvTrace[l12+7] * G[l12+7];
					vzlambda[body_j] += dlambda[l] * MinvTrace[l12+8] * G[l12+8];
					wxlambda[body_j] += dlambda[l] * MinvTrace[l12+9] * G[l12+9];
					wylambda[body_j] += dlambda[l] * MinvTrace[l12+10] * G[l12+10];
					wzlambda[body_j] += dlambda[l] * MinvTrace[l12+11] * G[l12+11];
				}
			}
		}

		if(debug)
			for(var i=0; i<this.vxlambda.length; i++)
				console.log("dv["+i+"]=",
					vxlambda[i],
					vylambda[i],
					vzlambda[i],
					wxlambda[i],
					wylambda[i],
					wzlambda[i]);
	};
	/*global CANNON:true */

	/**
	 * @class CANNON.EventTarget
	 * @see https://github.com/mrdoob/eventtarget.js/
	 */
	CANNON.EventTarget = function () {

		var listeners = {};

		this.addEventListener = function ( type, listener ) {

			if ( listeners[ type ] == undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		};

		this.dispatchEvent = function ( event ) {

			for ( var listener in listeners[ event.type ] ) {

				listeners[ event.type ][ listener ]( event );

			}

		};

		this.removeEventListener = function ( type, listener ) {

			var index = listeners[ type ].indexOf( listener );

			if ( index !== - 1 ) {

				listeners[ type ].splice( index, 1 );

			}

		};

	};/*global CANNON:true */

	/**
	 * @class CANNON.ObjectPool
	 */
	CANNON.ObjectPool = function(){
		this.objects = [];
		this.type = Object;
	};

	CANNON.ObjectPool.prototype.release = function(){
		for(var i in arguments)
			this.objects.push(arguments[i]);
	};

	CANNON.ObjectPool.prototype.get = function(){
		if(this.objects.length===0)
			return this.constructObject();
		else
			return this.objects.pop();
	};

	CANNON.ObjectPool.prototype.constructObject = function(){
		throw new Error("constructObject() not implemented in this ObjectPool subclass yet!");
	};/*global CANNON:true */

	/**
	 * @class CANNON.Vec3Pool
	 */
	CANNON.Vec3Pool = function(){
		CANNON.ObjectPool.call(this);
		this.type = CANNON.Vec3;
	};
	CANNON.Vec3Pool.prototype = new CANNON.ObjectPool();

	CANNON.Vec3Pool.prototype.constructObject = function(){
		return new CANNON.Vec3();
	};/*global CANNON:true */

	/**
	 * @class CANNON.Material
	 * @brief Defines a physics material.
	 * @param string name
	 * @author schteppe
	 */
	CANNON.Material = function(name){
		/**
		 * @property string name
		 * @memberof CANNON.Material
		 */
		this.name = name;
		this.id = -1;
	};

	/*global CANNON:true */

	/**
	 * @class CANNON.ContactMaterial
	 * @brief Defines what happens when two materials meet.
	 * @param CANNON.Material m1
	 * @param CANNON.Material m2
	 * @param float friction
	 * @param float restitution
	 * @todo Contact solving parameters here too?
	 */
	CANNON.ContactMaterial = function(m1, m2, friction, restitution){

		/// Contact material index in the world, -1 until added to the world
		this.id = -1;

		/// The two materials participating in the contact
		this.materials = [m1,m2];

		/// Kinetic friction
		this.friction = friction!=undefined ? Number(friction) : 0.3;

		/// Restitution
		this.restitution =      restitution!=undefined ?      Number(restitution) :      0.3;

	};

	/*global CANNON:true */

	/**
	 * @class CANNON.World
	 * @brief The physics world
	 */
	CANNON.World = function(){

		CANNON.EventTarget.apply(this);

		/// Makes bodies go to sleep when they've been inactive
		this.allowSleep = false;

		/// The wall-clock time since simulation start
		this.time = 0.0;

		/// Number of timesteps taken since start
		this.stepnumber = 0;

		/// Default and last timestep sizes
		this.default_dt = 1/60;
		this.last_dt = this.default_dt;

		this.nextId = 0;
		this.gravity = new CANNON.Vec3();
		this.broadphase = null;
		this.bodies = [];

		var th = this;

		/// The constraint solver
		this.solver = new CANNON.Solver();

		// User defined constraints
		this.constraints = [];

		// Contact generator
		this.contactgen = new CANNON.ContactGenerator();

		// Materials
		this.materials = []; // References to all added materials
		this.contactmaterials = []; // All added contact materials
		this.mats2cmat = []; // Hash: (mat1_id, mat2_id) => contactmat_id

		this.temp = {
			gvec:new CANNON.Vec3(),
			vi:new CANNON.Vec3(),
			vj:new CANNON.Vec3(),
			wi:new CANNON.Vec3(),
			wj:new CANNON.Vec3(),
			t1:new CANNON.Vec3(),
			t2:new CANNON.Vec3(),
			rixn:new CANNON.Vec3(),
			rjxn:new CANNON.Vec3(),
			step_q:new CANNON.Quaternion(),
			step_w:new CANNON.Quaternion(),
			step_wq:new CANNON.Quaternion()
		};
	};

	/**
	 * @fn getContactMaterial
	 * @memberof CANNON.World
	 * @brief Get the contact material between materials m1 and m2
	 * @param CANNON.Material m1
	 * @param CANNON.Material m2
	 * @return CANNON.Contactmaterial The contact material if it was found.
	 */
	CANNON.World.prototype.getContactMaterial = function(m1,m2){
		if((m1 instanceof CANNON.Material) &&
			(m2 instanceof CANNON.Material)){

			var i = m1.id;
			var j = m2.id;

			if(i<j){
				var temp = i;
				i = j;
				j = temp;
			}
			return this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
		}
	};

	/**
	 * @private
	 * @fn _addImpulse
	 * @memberof CANNON.World
	 * @brief Add an impulse to the colliding bodies i and j
	 * @param int i Body number 1
	 * @param int i Body number 2
	 * @param CANNON.Vec3 ri Vector from body 1's center of mass to the contact point on its surface
	 * @param CANNON.Vec3 ri Vector from body 1's center of mass to the contact point on its surface
	 * @param CANNON.Vec3 ui The relative velocity eg. vj+wj*rj - (vi+wj*rj)
	 * @param CANNON.Vec3 ni The contact normal pointing out from body i.
	 * @param float e The coefficient of restitution
	 * @param float mu The contact friction
	 * @todo Use it in the code!
	 */
	CANNON.World.prototype._addImpulse = function(i,j,ri,rj,ui,ni,e,mu){

		var ri_star = ri.crossmat();
		var rj_star = rj.crossmat();

		// Inverse inertia matrices
		var ii = this.inertiax[i]>0 ? 1.0/this.inertiax[i] : 0.0;
		var Iinv_i = new CANNON.Mat3([ii,0,0,
			0,ii,0,
			0,0,ii]);
		ii = this.inertiax[j]>0 ? 1.0/this.inertiax[j] : 0.0;
		var Iinv_j = new CANNON.Mat3([ii,0,0,
			0,ii,0,
			0,0,ii]);

		// Collision matrix:
		// K = 1/mi + 1/mj - ri_star*I_inv_i*ri_star - rj_star*I_inv_j*rj_star;
		var im = this.invm[i] + this.invm[j];
		var K = new CANNON.Mat3([im,0,0,
			0,im,0,
			0,0,im]);
		var rIr_i = ri_star.mmult(Iinv_i.mmult(ri_star));
		var rIr_j = rj_star.mmult(Iinv_j.mmult(rj_star));

		/*
		 // @todo add back when this works
		 for(var el = 0; el<9; el++)
		 K.elements[el] -= (rIr_i.elements[el] + rIr_j.elements[el]);
		 */

		// First assume stick friction
		// Final velocity if stick:
		var v_f = ni.mult(-e * ui.dot(ni));

		var J =  K.solve(v_f.vsub(ui));

		// Check if slide mode (J_t > J_n) - outside friction cone
		var mu = 0.0; // quick fix
		if(mu>0){
			var J_n = ni.mult(J.dot(ni));
			var J_t = J.vsub(J_n);
			if(J_t.norm() > J_n.mult(mu).norm()){

				// Calculate impulse j = -(1+e)u_n / nK(n-mu*t)
				var v_tang = ui.vsub(ni.mult(ui.dot(ni)));
				var tangent = v_tang.mult(1.0/(v_tang.norm() + 0.0001));
				var impulse = -(1+e)*(ui.dot(ni))/(ni.dot(K.vmult((ni.vsub(tangent.mult(mu))))));
				J = ni.mult(impulse).vsub(tangent.mult(mu * impulse));
			}
		}

		// Add to velocities
		var imi = this.invm[i];
		var imj = this.invm[j];

		// du = uprim - u
		//   => uprim = du + u
		// vi = vi + J/mi
		// vj = vj - J/mj

		// Convert back to non-relative velocities:
		// u_rel = vj - vi
		// vi = vj - u_rel
		// vj = vi + u_rel

		this.vx[i] +=  J.x * imi - (this.vx[j] - ui.x);
		this.vy[i] +=  J.y * imi - (this.vy[j] - ui.y);
		this.vz[i] +=  J.z * imi - (this.vz[j] - ui.z);
		this.vx[j] -=  J.x * imj + (this.vx[i] + ui.x);
		this.vy[j] -=  J.y * imj + (this.vy[i] + ui.y);
		this.vz[j] -=  J.z * imj + (this.vz[i] + ui.z);

		var cr = ri.cross(J);
		var wadd = cr.mult(1.0/this.inertiax[i]);

		/*
		 // Add rotational impulses
		 this.wx[i] += wadd.x;
		 this.wy[i] += wadd.y;
		 this.wz[i] += wadd.z;
		 cr = rj.cross(J);
		 wadd = cr.mult(1.0/this.inertiax[j]); // @todo fix to suit asymmetric inertia
		 this.wx[j] -= wadd.x;
		 this.wy[j] -= wadd.y;
		 this.wz[j] -= wadd.z;
		 */
	};

	/**
	 * @fn numObjects
	 * @memberof CANNON.World
	 * @brief Get number of objects in the world.
	 * @return int
	 */
	CANNON.World.prototype.numObjects = function(){
		return this.bodies.length;
	};

	/**
	 * @fn clearCollisionState
	 * @memberof CANNON.World
	 * @brief Clear the contact state for a body.
	 * @param CANNON.Body body
	 */
	CANNON.World.prototype.clearCollisionState = function(body){
		var n = this.numObjects();
		var i = body.id;
		for(var idx=0; idx<n; idx++){
			var j = idx;
			if(i>j) this.collision_matrix[j+i*n] = 0;
			else    this.collision_matrix[i+j*n] = 0;
		}
	};

	/**
	 * @fn add
	 * @memberof CANNON.World
	 * @brief Add a rigid body to the simulation.
	 * @param CANNON.Body body
	 * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
	 * @todo Adding an array of bodies should be possible. This would save some loops too
	 */
	CANNON.World.prototype.add = function(body){
		var n = this.numObjects();
		this.bodies.push(body);
		body.id = this.id();
		body.world = this;
		body.position.copy(body.initPosition);
		body.velocity.copy(body.initVelocity);
		if(body instanceof CANNON.RigidBody){
			body.angularVelocity.copy(body.initAngularVelocity);
			body.quaternion.copy(body.initQuaternion);
		}

		// Create collision matrix
		this.collision_matrix = new Int16Array((n+1)*(n+1));
	};

	/**
	 * @fn addConstraint
	 * @memberof CANNON.World
	 * @brief Add a constraint to the simulation.
	 * @param CANNON.Constraint c
	 */
	CANNON.World.prototype.addConstraint = function(c){
		if(c instanceof CANNON.Constraint){
			this.constraints.push(c);
			c.id = this.id();
		}
	};

	/**
	 * @fn id
	 * @memberof CANNON.World
	 * @brief Generate a new unique integer identifyer
	 * @return int
	 */
	CANNON.World.prototype.id = function(){
		return this.nextId++;
	};

	/**
	 * @fn remove
	 * @memberof CANNON.World
	 * @brief Remove a rigid body from the simulation.
	 * @param CANNON.Body body
	 */
	CANNON.World.prototype.remove = function(body){
		body.world = null;
		var n = this.numObjects();
		var bodies = this.bodies;
		for(var i in bodies)
			if(bodies[i].id == body.id)
				bodies.splice(i,1);

		// Reset collision matrix
		this.collision_matrix = new Int16Array((n-1)*(n-1));
	};

	/**
	 * @fn addMaterial
	 * @memberof CANNON.World
	 * @brief Adds a material to the World. A material can only be added once, it's added more times then nothing will happen.
	 * @param CANNON.Material m
	 */
	CANNON.World.prototype.addMaterial = function(m){
		if(m.id==-1){
			this.materials.push(m);
			m.id = this.materials.length-1;

			// Enlarge matrix
			var newcm = new Int16Array((this.materials.length)
				* (this.materials.length));
			for(var i=0; i<newcm.length; i++)
				newcm[i] = -1;

			// Copy over old values
			for(var i=0; i<this.materials.length-1; i++)
				for(var j=0; j<this.materials.length-1; j++)
					newcm[i+this.materials.length*j] = this.mats2cmat[i+(this.materials.length-1)*j];
			this.mats2cmat = newcm;

		}
	};

	/**
	 * @fn addContactMaterial
	 * @memberof CANNON.World
	 * @brief Adds a contact material to the World
	 * @param CANNON.ContactMaterial cmat
	 */
	CANNON.World.prototype.addContactMaterial = function(cmat) {

		// Add materials if they aren't already added
		this.addMaterial(cmat.materials[0]);
		this.addMaterial(cmat.materials[1]);

		// Save (material1,material2) -> (contact material) reference for easy access later
		// Make sure i>j, ie upper right matrix
		if(cmat.materials[0].id > cmat.materials[1].id){
			i = cmat.materials[0].id;
			j = cmat.materials[1].id;
		} else {
			j = cmat.materials[0].id;
			i = cmat.materials[1].id;
		}

		// Add contact material
		this.contactmaterials.push(cmat);
		cmat.id = this.contactmaterials.length-1;

		// Add current contact material to the material table
		this.mats2cmat[i+this.materials.length*j] = cmat.id; // index of the contact material
	};

// Get the index given body id. Returns -1 on fail
	CANNON.World.prototype._id2index = function(id){
		// ugly but works
		for(var j=0; j<this.bodies.length; j++)
			if(this.bodies[j].id === id)
				return j;
		return -1;
	};

	/**
	 * @fn step
	 * @memberof CANNON.World
	 * @brief Step the simulation
	 * @param float dt
	 */
	CANNON.World.prototype.step = function(dt){
		var world = this,
			that = this,
			N = this.numObjects(),
			bodies = this.bodies;

		if(dt==undefined){
			if(this.last_dt)
				dt = this.last_dt;
			else
				dt = this.default_dt;
		}

		// Add gravity to all objects
		for(var i=0; i<N; i++){
			var bi = bodies[i];
			if(bi.motionstate & CANNON.Body.DYNAMIC){ // Only for dynamic bodies
				var f = bodies[i].force, m = bodies[i].mass;
				f.x += world.gravity.x * m;
				f.y += world.gravity.y * m;
				f.z += world.gravity.z * m;
			}
		}

		// 1. Collision detection
		var pairs = this.broadphase.collisionPairs(this);
		var p1 = pairs[0];
		var p2 = pairs[1];

		// Get references to things that are accessed often. Will save some lookup time.
		var SPHERE = CANNON.Shape.types.SPHERE;
		var PLANE = CANNON.Shape.types.PLANE;
		var BOX = CANNON.Shape.types.BOX;
		var COMPOUND = CANNON.Shape.types.COMPOUND;

		// Keep track of contacts for current and previous timestep
		// 0: No contact between i and j
		// 1: Contact
		function collisionMatrixGet(i,j,current){
			if(typeof(current)=="undefined") current = true;
			// i == column
			// j == row
			if((current && i<j) || // Current uses upper part of the matrix
				(!current && i>j)){ // Previous uses lower part of the matrix
				var temp = j;
				j = i;
				i = temp;
			}
			return that.collision_matrix[i+j*N];
		}

		function collisionMatrixSet(i,j,value,current){
			if(typeof(current)=="undefined") current = true;
			if((current && i<j) || // Current uses upper part of the matrix
				(!current && i>j)){ // Previous uses lower part of the matrix
				var temp = j;
				j = i;
				i = temp;
			}
			that.collision_matrix[i+j*N] = parseInt(value);
		}

		// transfer old contact state data to T-1
		function collisionMatrixTick(){
			for(var i=0; i<bodies.length; i++){
				for(var j=0; j<i; j++){
					var currentState = collisionMatrixGet(i,j,true);
					collisionMatrixSet(i,j,currentState,false);
					collisionMatrixSet(i,j,0,true);
				}
			}
		}

		collisionMatrixTick();

		// Reset contact solver
		this.solver.reset(N);

		// Generate contacts
		var oldcontacts = this.contacts;
		this.contacts = [];
		this.contactgen.getContacts(p1,p2,
			this,
			this.contacts,
			oldcontacts // To be reused
		);

		// Loop over all collisions
		var temp = this.temp;
		for(var k=0; k<this.contacts.length; k++){

			// Current contact
			var c = this.contacts[k];

			// Get current collision indeces
			var bi = c.bi,
				bj = c.bj;

			// Resolve indeces
			var i = this._id2index(bi.id),
				j = this._id2index(bj.id);

			// Check last step stats
			var lastCollisionState = collisionMatrixGet(i,j,false);

			// Get collision properties
			var mu = 0.3, e = 0.2;
			var cm = this.getContactMaterial(bi.material,
				bj.material);
			if(cm){
				mu = cm.friction;
				e = cm.restitution;
			}

			// g = ( xj + rj - xi - ri ) .dot ( ni )
			var gvec = temp.gvec;
			gvec.set(bj.position.x + c.rj.x - bi.position.x - c.ri.x,
				bj.position.y + c.rj.y - bi.position.y - c.ri.y,
				bj.position.z + c.rj.z - bi.position.z - c.ri.z);
			var g = gvec.dot(c.ni); // Gap, negative if penetration

			// Action if penetration
			if(g<0.0){
				// Now we know that i and j are in contact. Set collision matrix state
				collisionMatrixSet(i,j,1,true);

				if(collisionMatrixGet(i,j,true)!=collisionMatrixGet(i,j,false)){
					bi.dispatchEvent({type:"collide", "with":bj});
					bj.dispatchEvent({type:"collide", "with":bi});
					bi.wakeUp();
					bj.wakeUp();
				}

				var vi = bi.velocity;
				var wi = bi.angularVelocity;
				var vj = bj.velocity;
				var wj = bj.angularVelocity;

				var n = c.ni;
				var tangents = [temp.t1, temp.t2];
				n.tangents(tangents[0],tangents[1]);

				var v_contact_i = vi.vadd(wi.cross(c.ri));
				var v_contact_j = vj.vadd(wj.cross(c.rj));
				var u_rel = v_contact_j.vsub(v_contact_i);
				var w_rel = wj.cross(c.rj).vsub(wi.cross(c.ri));

				var u = (vj.vsub(vi)); // Contact velo
				var uw = (c.rj.cross(wj)).vsub(c.ri.cross(wi));
				u.vsub(uw,u);

				// Get mass properties
				var iMi = bi.invMass;
				var iMj = bj.invMass;
				var iIxi = bi.invInertia.x;
				var iIyi = bi.invInertia.y;
				var iIzi = bi.invInertia.z;
				var iIxj = bj.invInertia.x;
				var iIyj = bj.invInertia.y;
				var iIzj = bj.invInertia.z;

				// Add contact constraint
				var rixn = temp.rixn;
				var rjxn = temp.rjxn;
				c.ri.cross(n,rixn);
				c.rj.cross(n,rjxn);

				var un_rel = n.mult(u_rel.dot(n)*0.5);
				var u_rixn_rel = rixn.unit().mult(w_rel.dot(rixn.unit()));
				var u_rjxn_rel = rjxn.unit().mult(-w_rel.dot(rjxn.unit()));

				var gn = c.ni.mult(g);
				this.solver
					.addConstraint( // Non-penetration constraint jacobian
					[-n.x,-n.y,-n.z,
						-rixn.x,-rixn.y,-rixn.z,
						n.x,n.y,n.z,
						rjxn.x,rjxn.y,rjxn.z],

					// Inverse mass matrix
					[iMi,iMi,iMi,
						iIxi,iIyi,iIzi,
						iMj,iMj,iMj,
						iIxj,iIyj,iIzj],

					// g - constraint violation / gap
					[-gn.x,-gn.y,-gn.z,
						0,0,0,//-gn.x,-gn.y,-gn.z,
						gn.x,gn.y,gn.z,
						0,0,0//gn.x,gn.y,gn.z
					],

					[-un_rel.x,-un_rel.y,-un_rel.z,
						0,0,0,//-u_rixn_rel.x,-u_rixn_rel.y,-u_rixn_rel.z,
						un_rel.x,un_rel.y,un_rel.z,
						0,0,0//u_rjxn_rel.x,u_rjxn_rel.y,u_rjxn_rel.z
					],

					// External force - forces & torques
					[bi.force.x,bi.force.y,bi.force.z,
						bi.tau.x,bi.tau.y,bi.tau.z,
						-bj.force.x,-bj.force.y,-bj.force.z,
						-bj.tau.x,-bj.tau.y,-bj.tau.z],
					0,
					'inf',
					i, // These are id's, not indeces...
					j);

				// Friction constraints
				if(mu>0.0){
					var g = that.gravity.norm();
					for(var ti=0; ti<tangents.length; ti++){
						var t = tangents[ti];
						var rixt = c.ri.cross(t);
						var rjxt = c.rj.cross(t);

						var ut_rel = t.mult(u_rel.dot(t));
						var u_rixt_rel = rixt.unit().mult(u_rel.dot(rixt.unit()));
						var u_rjxt_rel = rjxt.unit().mult(-u_rel.dot(rjxt.unit()));
						this.solver
							.addConstraint( // Non-penetration constraint jacobian
							[-t.x,-t.y,-t.z,
								-rixt.x,-rixt.y,-rixt.z,
								t.x,t.y,t.z,
								rjxt.x,rjxt.y,rjxt.z
							],

							// Inverse mass matrix
							[iMi,iMi,iMi,
								iIxi,iIyi,iIzi,
								iMj,iMj,iMj,
								iIxj,iIyj,iIzj],

							// g - constraint violation / gap
							[0,0,0,
								0,0,0,
								0,0,0,
								0,0,0],

							[-ut_rel.x,-ut_rel.y,-ut_rel.z,
								0,0,0,//-u_rixt_rel.x,-u_rixt_rel.y,-u_rixt_rel.z,
								ut_rel.x,ut_rel.y,ut_rel.z,
								0,0,0//u_rjxt_rel.x,u_rjxt_rel.y,u_rjxt_rel.z
							],

							// External force - forces & torques
							[bi.force.x,bi.force.y,bi.force.z,
								bi.tau.x,bi.tau.y,bi.tau.z,
								bj.force.x,bj.force.y,bj.force.z,
								bj.tau.x,bj.tau.y,bj.tau.z],

							-mu*100*(bi.mass+bj.mass),
							mu*100*(bi.mass+bj.mass),

							i, // id, not index
							j);
					}
				}
			}
		}

		// Add user-defined constraints
		for(var i=0; i<this.constraints.length; i++){
			// Preliminary - ugly but works
			var bj=-1, bi=-1;
			for(var j=0; j<this.bodies.length; j++)
				if(this.bodies[j].id === this.constraints[i].body_i.id)
					bi = j;
				else if(this.bodies[j].id === this.constraints[i].body_j.id)
					bj = j;
			this.solver.addConstraint2(this.constraints[i],bi,bj);
		}

		var bi;
		if(this.solver.n){

			this.solver.h = dt;
			this.solver.solve();

			// Apply constraint velocities
			for(var i=0; i<N; i++){
				bi = bodies[i];
				if(bi.motionstate & CANNON.Body.DYNAMIC){ // Only for dynamic bodies
					var b = bodies[i];
					b.velocity.x += this.solver.vxlambda[i];
					b.velocity.y += this.solver.vylambda[i];
					b.velocity.z += this.solver.vzlambda[i];
					if(b.angularVelocity){
						b.angularVelocity.x += this.solver.wxlambda[i];
						b.angularVelocity.y += this.solver.wylambda[i];
						b.angularVelocity.z += this.solver.wzlambda[i];
					}
				}
			}
		}

		// Apply damping
		for(var i=0; i<N; i++){
			bi = bodies[i];
			if(bi.motionstate & CANNON.Body.DYNAMIC){ // Only for dynamic bodies
				var ld = 1.0 - bi.linearDamping;
				var ad = 1.0 - bi.angularDamping;
				bi.velocity.mult(ld,bi.velocity);
				if(bi.angularVelocity)
					bi.angularVelocity.mult(ad,bi.angularVelocity);
			}
		}

		that.dispatchEvent({type:"preStep"});

		// Invoke pre-step callbacks
		for(var i in bodies){
			var bi = bodies[i];
			bi.preStep && bi.preStep.call(bi);
		}

		// Leap frog
		// vnew = v + h*f/m
		// xnew = x + h*vnew
		var q = temp.step_q;
		var w = temp.step_w;
		var wq = temp.step_wq;
		var DYNAMIC_OR_KINEMATIC = CANNON.Body.DYNAMIC | CANNON.Body.KINEMATIC;
		for(var i=0; i<N; i++){
			var b = bodies[i];
			if((b.motionstate & DYNAMIC_OR_KINEMATIC)){ // Only for dynamic

				b.velocity.x += b.force.x * b.invMass * dt;
				b.velocity.y += b.force.y * b.invMass * dt;
				b.velocity.z += b.force.z * b.invMass * dt;

				if(b.angularVelocity){
					b.angularVelocity.x += b.tau.x * b.invInertia.x * dt;
					b.angularVelocity.y += b.tau.y * b.invInertia.y * dt;
					b.angularVelocity.z += b.tau.z * b.invInertia.z * dt;
				}

				// Use new velocity  - leap frog
				if(!b.isSleeping()){
					b.position.x += b.velocity.x * dt;
					b.position.y += b.velocity.y * dt;
					b.position.z += b.velocity.z * dt;

					if(b.angularVelocity){
						w.set(b.angularVelocity.x,
							b.angularVelocity.y,
							b.angularVelocity.z,
							0);
						w.mult(b.quaternion,wq);

						b.quaternion.x += dt * 0.5 * wq.x;
						b.quaternion.y += dt * 0.5 * wq.y;
						b.quaternion.z += dt * 0.5 * wq.z;
						b.quaternion.w += dt * 0.5 * wq.w;
						if(world.stepnumber % 3 === 0)
							b.quaternion.normalizeFast();
					}
				}
			}
			b.force.set(0,0,0);
			if(b.tau) b.tau.set(0,0,0);
		}

		// Update world time
		world.time += dt;
		world.stepnumber += 1;

		that.dispatchEvent({type:"postStep"});

		// Invoke post-step callbacks
		for(var i in bodies){
			var bi = bodies[i];
			bi.postStep && bi.postStep.call(bi);
		}

		// Sleeping update
		if(world.allowSleep){
			for(var i=0; i<N; i++){
				var bi = bodies[i];
				bi.sleepTick();
			}
		}
	};

	/**
	 * @class ContactPoint
	 * @brief A representation of a contact point between two bodies. Should be generated by the ContactGenerator
	 * @param CANNON.Body bi
	 * @param CANNON.Body bj
	 * @param CANNON.Vec3 ri Optional. The vector from the center of mass of bi to the contact.
	 * @param CANNON.Vec3 rj Optional. The vector from the center of mass of bj to the contact.
	 * @param CANNON.Vec3 ni Optional. Contact normal vector, pointing out of body bi.
	 */
	CANNON.ContactPoint = function(bi,bj,ri,rj,ni){
		/**
		 * @property CANNON.Vec3 ri
		 * @memberof CANNON.ContactPoint
		 */
		this.ri = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 rj
		 * @memberof CANNON.ContactPoint
		 */
		this.rj = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 ni
		 * @memberof CANNON.ContactPoint
		 */
		this.ni = new CANNON.Vec3();

		// Copy over data if arguments were passed
		if(ri) ri.copy(this.ri);
		if(rj) rj.copy(this.rj);
		if(ni) ni.copy(this.ni);

		/**
		 * @property CANNON.Body bi
		 * @memberof CANNON.ContactPoint
		 */
		this.bi = bi;

		/**
		 * @property CANNON.Body bj
		 * @memberof CANNON.ContactPoint
		 */
		this.bj = bj;
	};/*global CANNON:true */

	/**
	 * @class CANNON.ContactGenerator
	 * @brief Helper class for the World. Generates ContactPoints.
	 */
	CANNON.ContactGenerator = function(){

		/**
		 * @property bool contactReduction
		 * @memberof CANNON.ContactGenerator
		 * @brief Turns on or off contact reduction. Can be handy to turn off when debugging new collision types.
		 */
		this.contactReduction = true;

		// Contact point objects that can be reused
		var contactPointPool = [];

		var v3pool = new CANNON.Vec3Pool();

		/**
		 * Near phase calculation, get the contact point, normal, etc.
		 * @param array result The result one will get back with all the contact point information
		 * @param Shape si Colliding shape
		 * @param Shape sj
		 * @param Vec3 xi Position of the center of mass
		 * @param Vec3 xj
		 * @param Quaternion qi Rotation around the center of mass
		 * @param Quaternion qj
		 * @todo All collision cases
		 */
		function nearPhase(result,si,sj,xi,xj,qi,qj,bi,bj){
			var swapped = false;
			if(si.type>sj.type){
				var temp;
				temp=sj;   sj=si;   si=temp;
				temp=xj;   xj=xi;   xi=temp;
				temp=qj;   qj=qi;   qi=temp;
				temp=bj;   bj=bi;   bi=temp;
				swapped = true;
			}

			/**
			 * Make a contact object.
			 * @return object
			 * @todo reuse old contact point objects
			 */
			function makeResult(bi,bj){
				if(contactPointPool.length){
					var c = contactPointPool.pop();
					c.bi = bi;
					c.bj = bj;
					return c;
				} else
					return new CANNON.ContactPoint(bi,bj);
			}

			/**
			 * Swaps the body references in the contact
			 * @param object r
			 */
			function swapResult(r){
				var temp;
				temp = r.ri; r.ri = r.rj; r.rj = temp;
				r.ni.negate(r.ni);
				temp = r.bi; r.bi = r.bj; r.bj = temp;
			}

			/**
			 * Go recursive for compound shapes
			 * @param Shape si
			 * @param CompoundShape sj
			 */
			function recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj){
				for(var i=0; i<sj.childShapes.length; i++){
					var r = [];
					nearPhase(r,
						si,
						sj.childShapes[i],
						xi,
						xj.vadd(qj.vmult(sj.childOffsets[i])), // Transform the shape to its local frame
						qi,
						qj.mult(sj.childOrientations[i]),
						bi,
						bj);
					// Transform back
					for(var j=0; j<r.length; j++){
						r[j].rj.vadd(qj.vmult(sj.childOffsets[i]),r[j].rj);
						result.push(r[j]);
					}
				}
			}

			if(si.type==CANNON.Shape.types.SPHERE){
				if(sj.type==CANNON.Shape.types.SPHERE){ // sphere-sphere

					// We will have one contact in this case
					var r = makeResult(bi,bj);

					// Contact normal
					xj.vsub(xi,r.ni);
					r.ni.normalize();

					// Contact point locations
					r.ni.copy(r.ri);
					r.ni.copy(r.rj);
					r.ri.mult(si.radius,r.ri);
					r.rj.mult(-sj.radius,r.rj);
					result.push(r);

				} else if(sj.type==CANNON.Shape.types.PLANE){ // sphere-plane

					// We will have one contact in this case
					var r = makeResult(bi,bj);

					// Contact normal
					sj.normal.copy(r.ni);
					qj.vmult(r.ni,r.ni);
					r.ni.negate(r.ni); // body i is the sphere, flip normal
					r.ni.normalize();

					// Vector from sphere center to contact point
					r.ni.mult(si.radius,r.ri);

					// Project down sphere on plane
					var point_on_plane_to_sphere = xi.vsub(xj);
					var plane_to_sphere_ortho = r.ni.mult(r.ni.dot(point_on_plane_to_sphere));
					r.rj = point_on_plane_to_sphere.vsub(plane_to_sphere_ortho); // The sphere position projected to plane
					if(plane_to_sphere_ortho.norm() <= si.radius)
						result.push(r);

				} else if(sj.type==CANNON.Shape.types.BOX){ // sphere-box

					// we refer to the box as body j
					var box_to_sphere =  xi.vsub(xj);
					var sides = sj.getSideNormals(true,qj);
					var R =     si.radius;
					var penetrating_sides = [];

					// Check side (plane) intersections
					var found = false;
					for(var idx=0; idx<sides.length && !found; idx++){ // Max 3 penetrating sides
						var ns = sides[idx].copy();
						var h = ns.norm();
						ns.normalize();
						var dot = box_to_sphere.dot(ns);
						if(dot<h+R && dot>0){
							// Intersects plane. Now check the other two dimensions
							var ns1 = sides[(idx+1)%3].copy();
							var ns2 = sides[(idx+2)%3].copy();
							var h1 = ns1.norm();
							var h2 = ns2.norm();
							ns1.normalize();
							ns2.normalize();
							var dot1 = box_to_sphere.dot(ns1);
							var dot2 = box_to_sphere.dot(ns2);
							if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){
								found = true;
								var r = makeResult(bi,bj);
								ns.mult(-R,r.ri); // Sphere r
								ns.copy(r.ni);
								r.ni.negate(r.ni); // Normal should be out of sphere
								ns.mult(h).vadd(ns1.mult(dot1)).vadd(ns2.mult(dot2),r.rj); // box
								result.push(r);
							}
						}
					}

					// Check corners
					var rj = v3pool.get();
					for(var j=0; j<2 && !found; j++){
						for(var k=0; k<2 && !found; k++){
							for(var l=0; l<2 && !found; l++){
								rj.set(0,0,0);
								if(j) rj.vadd(sides[0],rj);
								else  rj.vsub(sides[0],rj);
								if(k) rj.vadd(sides[1],rj);
								else  rj.vsub(sides[1],rj);
								if(l) rj.vadd(sides[2],rj);
								else  rj.vsub(sides[2],rj);

								// World position of corner
								var sphere_to_corner = xj.vadd(rj).vsub(xi);
								if(sphere_to_corner.norm()<R){
									found = true;
									var r = makeResult(bi,bj);
									sphere_to_corner.copy(r.ri);
									r.ri.normalize();
									r.ri.copy(r.ni);
									r.ri.mult(R,r.ri);
									rj.copy(r.rj);
									result.push(r);
								}
							}
						}
					}
					v3pool.release(rj);
					rj = null;

					// Check edges
					var edgeTangent = v3pool.get();
					var edgeCenter = v3pool.get();
					var r = v3pool.get(); // r = edge center to sphere center
					var orthogonal = v3pool.get();
					var dist = v3pool.get();
					for(var j=0; j<sides.length && !found; j++){
						for(var k=0; k<sides.length && !found; k++){
							if(j%3!=k%3){
								// Get edge tangent
								sides[k].cross(sides[j],edgeTangent);
								edgeTangent.normalize();
								sides[j].vadd(sides[k], edgeCenter);
								xi.copy(r);
								r.vsub(edgeCenter,r);
								r.vsub(xj,r);
								var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
								edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction

								// Find the third side orthogonal to this one
								var l = 0;
								while(l==j%3 || l==k%3) l++;

								// vec from edge center to sphere projected to the plane orthogonal to the edge tangent
								xi.copy(dist);
								dist.vsub(orthogonal,dist);
								dist.vsub(edgeCenter,dist);
								dist.vsub(xj,dist);

								// Distances in tangent direction and distance in the plane orthogonal to it
								var tdist = Math.abs(orthonorm);
								var ndist = dist.norm();

								if(tdist < sides[l].norm() && ndist<R){
									found = true;
									var res = makeResult(bi,bj);
									edgeCenter.vadd(orthogonal,res.rj); // box rj
									res.rj.copy(res.rj);
									dist.negate(res.ni);
									res.ni.normalize();

									res.rj.copy(res.ri);
									res.ri.vadd(xj,res.ri);
									res.ri.vsub(xi,res.ri);
									res.ri.normalize();
									res.ri.mult(R,res.ri);

									result.push(res);
								}
							}
						}
					}
					v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);

				} else if(sj.type==CANNON.Shape.types.COMPOUND){ // sphere-compound
					recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // sphere-convexpolyhedron
					throw new Error("sphere/convexpolyhedron contacts not implemented yet.");
				}

			} else if(si.type==CANNON.Shape.types.PLANE){

				if(sj.type==CANNON.Shape.types.PLANE){ // plane-plane
					throw "Plane-plane collision... wait, you did WHAT?";

				} else if(sj.type==CANNON.Shape.types.BOX){ // plane-box

					// Collision normal
					var n = si.normal.copy();

					// Loop over corners
					var numcontacts = 0;
					var corners = sj.getCorners(qj);
					for(var idx=0; idx<corners.length && numcontacts<=4; idx++){ // max 4 corners against plane
						var r = makeResult(bi,bj);
						var worldCorner = corners[idx].vadd(xj);
						corners[idx].copy(r.rj);

						// Project down corner to plane to get xj
						var point_on_plane_to_corner = worldCorner.vsub(xi);
						var d = n.dot(point_on_plane_to_corner);
						if(d<=0){
							numcontacts++;
							var plane_to_corner = n.mult(d);
							point_on_plane_to_corner.vsub(plane_to_corner,r.ri);

							// Set contact normal
							n.copy(r.ni);

							// Add contact
							result.push(r);
						}
					}

				} else if(sj.type==CANNON.Shape.types.COMPOUND){ // plane-compound
					recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // plane-convex polyhedron
					// Separating axis is the plane normal
					// Create a virtual box polyhedron for the plane
					var t1 = v3pool.get();
					var t2 = v3pool.get();
					si.normal.tangents(t1,t2);
					t1.mult(100000,t1);
					t2.mult(100000,t2);
					var n = v3pool.get();
					si.normal.copy(n);
					var verts = [new CANNON.Vec3(-t1.x -t2.x -n.x, -t1.y -t2.y -n.y, -t1.z -t2.z -n.z), // ---
						new CANNON.Vec3( t1.x -t2.x +0*n.x,  t1.y -t2.y +0*n.y,  t1.z -t2.z +0*n.z), // +-+
						new CANNON.Vec3( t1.x +t2.x -n.x,  t1.y +t2.y -n.y,  t1.z +t2.z -n.z), // ++- 
						new CANNON.Vec3(-t1.x +t2.x -n.x, -t1.y +t2.y -n.y, -t1.z +t2.z -n.z), // -+-
						new CANNON.Vec3(-t1.x -t2.x +0*n.x, -t1.y -t2.y +0*n.y, -t1.z -t2.z +0*n.z), // --+
						new CANNON.Vec3(+t1.x -t2.x +0*n.x,  t1.y -t2.y +0*n.y,  t1.z -t2.z +0*n.z), // +-+
						new CANNON.Vec3(+t1.x +t2.x +0*n.x, +t1.y +t2.y +0*n.y,  t1.z +t2.z +0*n.z), // +++
						new CANNON.Vec3(-t1.x +t2.x +0*n.x, -t1.y +t2.y +0*n.y, -t1.z +t2.z +0*n.z)]; // -++
					t1.normalize();
					t2.normalize();
					var planehull = new CANNON.ConvexPolyhedron(verts,
						[
							[0,1,2,3], // -z
							[4,5,6,7], // +z
							[0,1,4,5], // -y
							[2,3,6,7], // +y
							[0,3,4,7], // -x
							[1,2,5,6], // +x
						],

						[new CANNON.Vec3( -n.x, -n.y, -n.z),
							new CANNON.Vec3(  n.x,  n.y,  n.z),
							new CANNON.Vec3(-t2.x,-t2.y,-t2.z),
							new CANNON.Vec3( t2.x, t2.y, t2.z),
							new CANNON.Vec3(-t1.x,-t1.y,-t1.z),
							new CANNON.Vec3( t1.x, t1.y, t1.z)]);

					var sepAxis = v3pool.get();
					n.negate(sepAxis);
					var q = v3pool.get();
					if(sj.testSepAxis(sepAxis,planehull,xj,qj,xi,qi)!==false){
						var res = [];
						planehull.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
						for(var j=0; j<res.length; j++){
							var r = makeResult(bi,bj);
							sepAxis.negate(r.ni);
							res[j].normal.negate(q);
							q.mult(res[j].depth,q);
							r.ri.set(res[j].point.x + q.x,
								res[j].point.y + q.y,
								res[j].point.z + q.z);
							r.rj.set(res[j].point.x,
								res[j].point.y,
								res[j].point.z);
							// Contact points are in world coordinates. Transform back to relative
							r.rj.vsub(xj,r.rj);
							r.ri.vsub(xi,r.ri);
							result.push(r);
						}
					}
					v3pool.release(q,t1,t2,sepAxis,n);
				}

			} else if(si.type==CANNON.Shape.types.BOX){

				if(sj.type==CANNON.Shape.types.BOX){ // box-box
					// Do convex polyhedron instead
					nearPhase(result,
						si.convexPolyhedronRepresentation,
						sj.convexPolyhedronRepresentation,
						xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.COMPOUND){ // box-compound
					recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // box-convexpolyhedron
					nearPhase(result,
						si.convexPolyhedronRepresentation,
						sj,xi,xj,qi,qj,bi,bj);
				}

			} else if(si.type==CANNON.Shape.types.COMPOUND){

				if(sj.type==CANNON.Shape.types.COMPOUND){ // compound-compound
					recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // compound-convex polyhedron
					recurseCompound(result,sj,si,xj,xi,qj,qi,bj,bi);
				}

			} else if(si.type==CANNON.Shape.types.CONVEXPOLYHEDRON){

				if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // convex polyhedron - convex polyhedron
					var sepAxis = new CANNON.Vec3();
					if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis)){
						var res = [];
						var q = new CANNON.Vec3();
						si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
						for(var j=0; j<res.length; j++){
							var r = makeResult(bi,bj);
							sepAxis.negate(r.ni);
							res[j].normal.negate(q);
							q.mult(res[j].depth,q);
							r.ri.set(res[j].point.x + q.x,
								res[j].point.y + q.y,
								res[j].point.z + q.z);
							r.rj.set(res[j].point.x,
								res[j].point.y,
								res[j].point.z);
							// Contact points are in world coordinates. Transform back to relative
							r.rj.vsub(xj,r.rj);
							r.ri.vsub(xi,r.ri);
							result.push(r);
						}
					}
				}
			}

			// Swap back if we swapped bodies in the beginning
			for(var i=0; swapped && i<result.length; i++)
				swapResult(result[i]);
		}

		/**
		 * @fn reduceContacts
		 * @memberof CANNON.ContactGenerator
		 * @brief Removes unnecessary members of an array of CANNON.ContactPoint.
		 */
		this.reduceContacts = function(contacts){

		}

		/**
		 * @fn getContacts
		 * @memberof CANNON.ContactGenerator
		 * @param array p1 Array of body indices
		 * @param array p2 Array of body indices
		 * @param CANNON.World world
		 * @param array result Array to store generated contacts
		 * @param array oldcontacts Optional. Array of reusable contact objects
		 */
		this.getContacts = function(p1,p2,world,result,oldcontacts){

			// Save old contact objects
			for(var i=0; oldcontacts && i<oldcontacts.length; i++)
				contactPointPool.push(oldcontacts[i]);

			for(var k=0; k<p1.length; k++){
				// Get current collision indeces
				var bi = p1[k],
					bj = p2[k];

				// Get contacts
				nearPhase(result,
					bi.shape,
					bj.shape,
					bi.position,
					bj.position,
					bi.quaternion,
					bj.quaternion,
					bi,
					bj
				);
			}
		}
	};/*global CANNON:true */

	/**
	 * Constraint base class
	 * @author schteppe
	 */
	CANNON.Constraint = function(){

		/**
		 * @property array equations
		 * @brief A number of CANNON.Equation's that belongs to this Constraint
		 */
		this.equations = [];

		this.id = -1;

	};
	CANNON.Constraint.prototype.constructor = CANNON.Constraint;

	/**
	 * @brief Updates the internal numbers, calculates the Jacobian etc.
	 */
	CANNON.Constraint.prototype.update = function(){
		throw "update() not implemented in this Constraint subclass!";
	};
	/**
	 * Contact constraint class
	 * @author schteppe
	 * @param CANNON.RigidBody bodyA
	 * @param CANNON.RigidBody bodyB
	 * @param float friction
	 * @todo test
	 */
	CANNON.ContactConstraint = function(bodyA,bodyB,slipForce){
		CANNON.Constraint.call(this);
		this.body_i = bodyA;
		this.body_j = bodyB;
		this.contact = contact;
		this.slipForce = slipForce;
		this.unused_equations = [];
		this.temp = {
			rixn:new CANNON.Vec3(),
			rjxn:new CANNON.Vec3(),
			t1:new CANNON.Vec3(),
			t2:new CANNON.Vec3()
		};
	};

	CANNON.ContactConstraint.prototype = new CANNON.Constraint();
	CANNON.ContactConstraint.prototype.constructor = CANNON.ContactConstraint;

	CANNON.ContactConstraint.prototype.update = function(){

		/*
		 if(friction>0.0){
		 for(var i=0; i<3; i++)
		 this.equations.push(new CANNON.Equation(bodyA,bodyB)); // Normal+2tangents
		 } else
		 this.equations.push(new CANNON.Equation(bodyA,bodyB)); // Normal
		 */

		var bi = this.body_i,
			bj = this.body_j;

		var vi = bi.velocity,
			wi = bi.angularVelocity,
			vj = bj.velocity,
			wj = bj.angularVelocity;

		var tangents = [this.temp.t1, this.temp.t2];
		for(var i in bi.contacts){
			for(var j in bj.contacts){
				if(bi.contacts[i].to.id==bj.id && bj.contacts[j].to.id==bi.id){
					var ri = bi.contacts[i].r,
						rj = bj.contacts[j].r,
						ni = bi.contacts[i].n; // normals should be the same anyways

					n.tangents(tangents[0],tangents[1]);

					var v_contact_i = vi.vadd(wi.cross(c.ri));
					var v_contact_j = vj.vadd(wj.cross(c.rj));
					var u_rel = v_contact_j.vsub(v_contact_i);
					var w_rel = wj.cross(c.rj).vsub(wi.cross(c.ri));

					var u = (vj.vsub(vi));
					var uw = (c.rj.cross(wj)).vsub(c.ri.cross(wi));
					u.vsub(uw,u);

					// Get mass properties
					var iMi = bi.invMass;
					var iMj = bj.invMass;
					var iIxi = bi.invInertia.x;
					var iIyi = bi.invInertia.y;
					var iIzi = bi.invInertia.z;
					var iIxj = bj.invInertia.x;
					var iIyj = bj.invInertia.y;
					var iIzj = bj.invInertia.z;

					// Add contact constraint
					var rixn = this.temp.rixn;
					var rjxn = this.temp.rjxn;
					c.ri.cross(n,rixn);
					c.rj.cross(n,rjxn);

					var un_rel = n.mult(u_rel.dot(n));
					var u_rixn_rel = rixn.unit().mult(w_rel.dot(rixn.unit()));
					var u_rjxn_rel = rjxn.unit().mult(-w_rel.dot(rjxn.unit()));

					var gn = c.ni.mult(g);

					// Jacobian, eq. 25 in spooknotes
					n.negate(eq.G1);
					rixn.negate(eq.G2);
					n.copy(eq.G3);
					rjxn.copy(eq.G4);

					eq.setDefaultMassProps();

					// g - constraint violation / gap
					gn.negate(eq.g1);
					gn.copy(eq.g3);

					// W
					un_rel.negate(eq.W1);
					un_rel.copy(eq.W3);

					// External force - forces & torques
					bi.force.copy(eq.f1);
					bi.tau.copy(eq.f2);
					bj.force.copy(eq.f3);
					bj.tau.copy(eq.f4);

					eq.lambdamin = 0;
					eq.lambdamax = 'inf';
					/*
					 // Friction constraints
					 if(mu>0.0){
					 var g = that.gravity.norm();
					 for(var ti=0; ti<tangents.length; ti++){
					 var t = tangents[ti];
					 var rixt = c.ri.cross(t);
					 var rjxt = c.rj.cross(t);

					 var ut_rel = t.mult(u_rel.dot(t));
					 var u_rixt_rel = rixt.unit().mult(u_rel.dot(rixt.unit()));
					 var u_rjxt_rel = rjxt.unit().mult(-u_rel.dot(rjxt.unit()));
					 this.solver
					 .addConstraint( // Non-penetration constraint jacobian
					 [-t.x,-t.y,-t.z,
					 -rixt.x,-rixt.y,-rixt.z,
					 t.x,t.y,t.z,
					 rjxt.x,rjxt.y,rjxt.z
					 ],

					 // Inverse mass matrix
					 [iMi,iMi,iMi,
					 iIxi,iIyi,iIzi,
					 iMj,iMj,iMj,
					 iIxj,iIyj,iIzj],

					 // g - constraint violation / gap
					 [0,0,0,
					 0,0,0,
					 0,0,0,
					 0,0,0],

					 [-ut_rel.x,-ut_rel.y,-ut_rel.z,
					 0,0,0,//-u_rixt_rel.x,-u_rixt_rel.y,-u_rixt_rel.z,
					 ut_rel.x,ut_rel.y,ut_rel.z,
					 0,0,0//u_rjxt_rel.x,u_rjxt_rel.y,u_rjxt_rel.z
					 ],

					 // External force - forces & torques
					 [bi.force.x,bi.force.y,bi.force.z,
					 bi.tau.x,bi.tau.y,bi.tau.z,
					 bj.force.x,bj.force.y,bj.force.z,
					 bj.tau.x,bj.tau.y,bj.tau.z],

					 -mu*g*(bi.mass+bj.mass),
					 mu*g*(bi.mass+bj.mass),

					 i,
					 j);
					 }
					 }
					 */

				}
			}
		}
	};
	/**
	 * Distance constraint class
	 * @author schteppe
	 * @param CANNON.Body bodyA
	 * @param CANNON.Body bodyB Could optionally be a CANNON.Vec3 to constrain a body to a static point in space
	 * @param float distance
	 * @todo test
	 */
	CANNON.DistanceConstraint = function(bodyA,bodyB,distance){
		CANNON.Constraint.call(this);
		this.body_i = bodyA;
		this.body_j = bodyB;
		this.distance = Number(distance);
		var eq = new CANNON.Equation(bodyA, bodyB instanceof CANNON.Vec3 ? null : bodyB);
		this.equations.push(eq);
	};

	CANNON.DistanceConstraint.prototype = new CANNON.Constraint();
	CANNON.DistanceConstraint.prototype.constructor = CANNON.DistanceConstraint;

	CANNON.DistanceConstraint.prototype.update = function(){
		var eq = this.equations[0], bi = this.body_i, bj = this.body_j;
		var pair = typeof(bj.mass)=="number";

		// Jacobian is the distance unit vector
		if(pair)
			bj.position.vsub(bi.position, eq.G1);
		else{
			bi.position.vsub(bj,eq.G1);
		}
		eq.G1.normalize();
		if(eq.G1.isZero()) eq.G1.set(1,0,0);
		eq.G1.negate(eq.G3);
		//console.log(eq.G1.toString());

		// Mass properties
		eq.setDefaultMassProps();
		eq.setDefaultForce();

		// Constraint violation
		eq.g1.set((pair ? bj.position.x : bj.x) - bi.position.x - eq.G1.x*this.distance,
			(pair ? bj.position.y : bj.y) - bi.position.y - eq.G1.y*this.distance,
			(pair ? bj.position.z : bj.z) - bi.position.z - eq.G1.z*this.distance);
		eq.g1.negate(eq.g1);
		eq.g1.negate(eq.g3);
	};

	CANNON.DistanceConstraint.prototype.setMaxForce = function(f){
		// @todo rescale with masses
		this.equations[0].lambdamax = Math.abs(f);
		this.equations[0].lambdamin = -this.equations[0].lambdamax;
	};/**
	 * Equation class
	 * @author schteppe
	 * @brief Something for the solver to chew on. Its mostly a holder of vectors
	 * @todo try with the solver
	 * @param CANNON.Body bi Could optionally be null
	 * @param CANNON.Body bj Could optionally be null
	 */
	CANNON.Equation = function(bi,bj){

		// Jacobian
		this.G1 = new CANNON.Vec3();
		this.G2 = new CANNON.Vec3();
		this.G3 = new CANNON.Vec3();
		this.G4 = new CANNON.Vec3();

		// Inverse mass matrix
		this.iM1 = new CANNON.Vec3();
		this.iM2 = new CANNON.Vec3();
		this.iM3 = new CANNON.Vec3();
		this.iM4 = new CANNON.Vec3();

		// Constraint violation, g
		this.g1 = new CANNON.Vec3();
		this.g2 = new CANNON.Vec3();
		this.g3 = new CANNON.Vec3();
		this.g4 = new CANNON.Vec3();

		// Derivative of g, gdot
		this.W1 = new CANNON.Vec3();
		this.W2 = new CANNON.Vec3();
		this.W3 = new CANNON.Vec3();
		this.W4 = new CANNON.Vec3();

		// External force, f
		this.f1 = new CANNON.Vec3();
		this.f2 = new CANNON.Vec3();
		this.f3 = new CANNON.Vec3();
		this.f4 = new CANNON.Vec3();

		// Clamping for multipliers (see as max constraint force)
		this.lambdamax =  1e6;
		this.lambdamin = -1e6;

		// Bodies to apply the constraint forces on
		this.body_i = bi;
		this.body_j = bj;
	};

	CANNON.Equation.prototype.setDefaultMassProps = function(){
		var bi = this.body_i, bj = this.body_j;
		if(bi){
			this.iM1.set(bi.invMass,
				bi.invMass,
				bi.invMass);
			if(bi.invInertia)
				bi.invInertia.copy(this.iM2);
		}
		if(bj){
			this.iM3.set(bj.invMass,
				bj.invMass,
				bj.invMass);
			if(bj.invInertia)
				bj.invInertia.copy(this.iM4);
		}
	};

	CANNON.Equation.prototype.setDefaultForce = function(){
		var bi = this.body_i, bj = this.body_j;
		if(bi){
			bi.force.copy(this.f1);
			if(bi.tau) bi.tau.copy(this.f2);
		}
		if(bj){
			bj.force.copy(this.f3);
			if(bj.tau) bj.tau.copy(this.f4);
		}
	};/*global CANNON:true */

	/**
	 * Point to point constraint class
	 * @author schteppe
	 * @param CANNON.Body bodyA
	 * @param CANNON.Vec3 pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
	 * @param CANNON.Body bodyB Optional. If specified, pivotB must also be specified, and bodyB will be constrained in a similar way to the same point as bodyA. We will therefore get sort of a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
	 * @param CANNON.Vec3 pivotB Optional.
	 */
	CANNON.PointToPointConstraint = function(bodyA,pivotA,bodyB,pivotB){
		CANNON.Constraint.call(this);
		this.body_i = bodyA;
		this.body_j = bodyB;
		this.pivot_i = pivotA;
		this.pivot_j = pivotB;

		// Need 3 equations, 1 normal + 2 tangent
		for(var i=0; i<3; i++)
			this.equations.push(new Equation(bodyA,bodyB));
	};

	CANNON.PointToPointConstraint.prototype = new CANNON.Constraint();
	CANNON.PointToPointConstraint.prototype.constructor = CANNON.PointToPointConstraint;

	/**
	 * @todo
	 */
	CANNON.PointToPointConstraint.prototype.update = function(){
		/*
		 var eq = this.equations[0], bi = this.body_i, bj = this.body_j;

		 // Jacobian is the distance unit vector
		 bj.position.vsub(bi.position,eq.G1);
		 eq.G1.normalize();
		 eq.G1.negate(eq.G3);

		 // Mass properties
		 eq.setDefaultMassProps();
		 eq.setDefaultForce();

		 // Constraint violation
		 eq.g1.set(bj.position.x - bi.position.x - eq.G1.x*dist,
		 bj.position.y - bi.position.y - eq.G1.y*dist,
		 bj.position.z - bi.position.z - eq.G1.z*dist);
		 eq.g1.negate(eq.g3);  
		 */
	};if (typeof module !== 'undefined') {
		// export for node
		module.exports = CANNON;
	} else {
		// assign to window
		this.CANNON = CANNON;
	}

}).apply(this);
},{}],43:[function(_dereq_,module,exports){
//"use strict"; // We use arguments.callee in here, cannot have strict mode on this module

var appCore = _dereq_('irrelon-appcore');

appCore.module('printStackTrace', function () {
	// Domain Public by Eric Wendelin http://eriwen.com/ (2008)
	//                  Luke Smith http://lucassmith.name/ (2008)
	//                  Loic Dachary <loic@dachary.org> (2008)
	//                  Johan Euphrosine <proppy@aminche.com> (2008)
	//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
	//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)
	
	/**
	 * Main function giving a function stack trace with a forced or passed in Error
	 *
	 * @cfg {Error} e The error to create a stacktrace from (optional)
	 * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions
	 * @return {Array} of Strings with functions, lines, files, and arguments where possible
	 */
	function printStackTrace(options) {
		options = options || {guess: true};
		var ex = options.e || null, guess = !!options.guess;
		var p = new printStackTrace.implementation(), result = p.run(ex);
		var res = (guess) ? p.guessAnonymousFunctions(result) : result;
		for (var k = 0; k < 4; k++) {
			res.shift();
		}
		return res;
	}
	
	printStackTrace.implementation = function() {};
	
	printStackTrace.implementation.prototype = {
		run: function(ex) {
			ex = ex || this.createException();
			// Do not use the stored mode: different exceptions in Chrome
			// may or may not have arguments or stack
			var mode = this.mode(ex);
			// Use either the stored mode, or resolve it
			//var mode = this._mode || this.mode(ex);
			if (mode === 'other') {
				return this.other(arguments.callee);
			} else {
				return this[mode](ex);
			}
		},
		
		createException: function() {
			try {
				this.undef();
				return null;
			} catch (e) {
				return e;
			}
		},
		
		/**
		 * @return {String} mode of operation for the environment in question.
		 */
		mode: function(e) {
			if (e['arguments'] && e.stack) {
				return (this._mode = 'chrome');
			} else if (e.message && typeof window !== 'undefined' && window.opera) {
				return (this._mode = e.stacktrace ? 'opera10' : 'opera');
			} else if (e.stack) {
				return (this._mode = 'firefox');
			}
			return (this._mode = 'other');
		},
		
		/**
		 * Given a context, function name, and callback function, overwrite it so that it calls
		 * printStackTrace() first with a callback and then runs the rest of the body.
		 *
		 * @param {Object} context of execution (e.g. window)
		 * @param {String} functionName to instrument
		 * @param {Function} function to call with a stack trace on invocation
		 */
		instrumentFunction: function(context, functionName, callback) {
			context = context || window;
			var original = context[functionName];
			context[functionName] = function instrumented() {
				callback.call(this, printStackTrace().slice(4));
				return context[functionName]._instrumented.apply(this, arguments);
			};
			context[functionName]._instrumented = original;
		},
		
		/**
		 * Given a context and function name of a function that has been
		 * instrumented, revert the function to it's original (non-instrumented)
		 * state.
		 *
		 * @param {Object} context of execution (e.g. window)
		 * @param {String} functionName to de-instrument
		 */
		deinstrumentFunction: function(context, functionName) {
			if (context[functionName].constructor === Function &&
				context[functionName]._instrumented &&
				context[functionName]._instrumented.constructor === Function) {
				context[functionName] = context[functionName]._instrumented;
			}
		},
		
		/**
		 * Given an Error object, return a formatted Array based on Chrome's stack string.
		 *
		 * @param e - Error object to inspect
		 * @return Array<String> of function calls, files and line numbers
		 */
		chrome: function(e) {
			var stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/gm, '').
			replace(/^\s+at\s+/gm, '').
			replace(/^([^\(]+?)([\n$])/gm, '{anonymous}()@$1$2').
			replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}()@$1').split('\n');
			stack.pop();
			return stack;
		},
		
		/**
		 * Given an Error object, return a formatted Array based on Firefox's stack string.
		 *
		 * @param e - Error object to inspect
		 * @return Array<String> of function calls, files and line numbers
		 */
		firefox: function(e) {
			return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/gm, '{anonymous}(').split('\n');
		},
		
		/**
		 * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.
		 *
		 * @param e - Error object to inspect
		 * @return Array<String> of function calls, files and line numbers
		 */
		opera10: function(e) {
			var stack = e.stacktrace;
			var lines = stack.split('\n'), ANON = '{anonymous}', lineRE = /.*line (\d+), column (\d+) in ((<anonymous function\:?\s*(\S+))|([^\(]+)\([^\)]*\))(?: in )?(.*)\s*$/i, i, j, len;
			for (i = 2, j = 0, len = lines.length; i < len - 2; i++) {
				if (lineRE.test(lines[i])) {
					var location = RegExp.$6 + ':' + RegExp.$1 + ':' + RegExp.$2;
					var fnName = RegExp.$3;
					fnName = fnName.replace(/<anonymous function\:?\s?(\S+)?>/g, ANON);
					lines[j++] = fnName + '@' + location;
				}
			}
			
			lines.splice(j, lines.length - j);
			return lines;
		},
		
		// Opera 7.x-9.x only!
		opera: function(e) {
			var lines = e.message.split('\n'), ANON = '{anonymous}', lineRE = /Line\s+(\d+).*script\s+(http\S+)(?:.*in\s+function\s+(\S+))?/i, i, j, len;
			
			for (i = 4, j = 0, len = lines.length; i < len; i += 2) {
				//TODO: RegExp.exec() would probably be cleaner here
				if (lineRE.test(lines[i])) {
					lines[j++] = (RegExp.$3 ? RegExp.$3 + '()@' + RegExp.$2 + RegExp.$1 : ANON + '()@' + RegExp.$2 + ':' + RegExp.$1) + ' -- ' + lines[i + 1].replace(/^\s+/, '');
				}
			}
			
			lines.splice(j, lines.length - j);
			return lines;
		},
		
		// Safari, IE, and others
		other: function(curr) {
			var ANON = '{anonymous}', fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], fn, args, maxStackSize = 10;
			while (curr && stack.length < maxStackSize) {
				fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
				args = Array.prototype.slice.call(curr['arguments'] || []);
				stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
				curr = curr.caller;
			}
			return stack;
		},
		
		/**
		 * Given arguments array as a String, subsituting type names for non-string types.
		 *
		 * @param {Arguments} object
		 * @return {Array} of Strings with stringified arguments
		 */
		stringifyArguments: function(args) {
			var slice = Array.prototype.slice;
			for (var i = 0; i < args.length; ++i) {
				var arg = args[i];
				if (arg === undefined) {
					args[i] = 'undefined';
				} else if (arg === null) {
					args[i] = 'null';
				} else if (arg.constructor) {
					if (arg.constructor === Array) {
						if (arg.length < 3) {
							args[i] = '[' + this.stringifyArguments(arg) + ']';
						} else {
							args[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
						}
					} else if (arg.constructor === Object) {
						args[i] = '#object';
					} else if (arg.constructor === Function) {
						args[i] = '#function';
					} else if (arg.constructor === String) {
						args[i] = '"' + arg + '"';
					}
				}
			}
			return args.join(',');
		},
		
		sourceCache: {},
		
		/**
		 * @return {*} the text from a given URL.
		 */
		ajax: function(url) {
			var req = this.createXMLHTTPObject();
			if (!req) {
				return;
			}
			req.open('GET', url, false);
			//req.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
			req.send('');
			return req.responseText;
		},
		
		/**
		 * Try XHR methods in order and store XHR factory.
		 *
		 * @return <Function> XHR function or equivalent
		 */
		createXMLHTTPObject: function() {
			var xmlhttp, XMLHttpFactories = [
				function() {
					return new XMLHttpRequest();
				}, function() {
					return new ActiveXObject('Msxml2.XMLHTTP');
				}, function() {
					return new ActiveXObject('Msxml3.XMLHTTP');
				}, function() {
					return new ActiveXObject('Microsoft.XMLHTTP');
				}
			];
			for (var i = 0; i < XMLHttpFactories.length; i++) {
				try {
					xmlhttp = XMLHttpFactories[i]();
					// Use memoization to cache the factory
					this.createXMLHTTPObject = XMLHttpFactories[i];
					return xmlhttp;
				} catch (e) {
				}
			}
		},
		
		/**
		 * Given a URL, check if it is in the same domain (so we can get the source
		 * via Ajax).
		 *
		 * @param url <String> source url
		 * @return False if we need a cross-domain request
		 */
		isSameDomain: function(url) {
			return url.indexOf(location.hostname) !== -1;
		},
		
		/**
		 * Get source code from given URL if in the same domain.
		 *
		 * @param url <String> JS source URL
		 * @return <Array> Array of source code lines
		 */
		getSource: function(url) {
			if (!(url in this.sourceCache)) {
				this.sourceCache[url] = this.ajax(url).split('\n');
			}
			return this.sourceCache[url];
		},
		
		guessAnonymousFunctions: function(stack) {
			for (var i = 0; i < stack.length; ++i) {
				var reStack = /\{anonymous\}\(.*\)@(\w+:\/\/([\-\w\.]+)+(:\d+)?[^:]+):(\d+):?(\d+)?/;
				var frame = stack[i], m = reStack.exec(frame);
				if (m) {
					var file = m[1], lineno = m[4], charno = m[7] || 0; //m[7] is character position in Chrome
					if (file && this.isSameDomain(file) && lineno) {
						var functionName = this.guessAnonymousFunction(file, lineno, charno);
						stack[i] = frame.replace('{anonymous}', functionName);
					}
				}
			}
			return stack;
		},
		
		guessAnonymousFunction: function(url, lineNo, charNo) {
			var ret;
			try {
				ret = this.findFunctionName(this.getSource(url), lineNo);
			} catch (e) {
				ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
			}
			return ret;
		},
		
		findFunctionName: function(source, lineNo) {
			// FIXME findFunctionName fails for compressed source
			// (more than one function on the same line)
			// TODO use captured args
			// function {name}({args}) m[1]=name m[2]=args
			var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
			// {name} = function ({args}) TODO args capture
			// /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
			var reFunctionExpression = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function\b/;
			// {name} = eval()
			var reFunctionEvaluation = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
			// Walk backwards in the source lines until we find
			// the line which matches one of the patterns above
			var code = "", line, maxLines = 10, m;
			for (var i = 0; i < maxLines; ++i) {
				// FIXME lineNo is 1-based, source[] is 0-based
				line = source[lineNo - i];
				if (line) {
					code = line + code;
					
					m = reFunctionExpression.exec(code);
					if (m && m[1]) {
						return m[1];
					}
					m = reFunctionDeclaration.exec(code);
					if (m && m[1]) {
						//return m[1] + "(" + (m[2] || "") + ")";
						return m[1];
					}
					m = reFunctionEvaluation.exec(code);
					if (m && m[1]) {
						return m[1];
					}
				}
			}
			return '(?)';
		}
	};
	
	return printStackTrace;
});
},{"irrelon-appcore":125}],44:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('$game', function () {
	var $game = function () {
		// Determine the environment we are executing in
		this.isServer = (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined' && typeof window === 'undefined');
		this.isClient = !this.isServer;
	};
	
	return new $game();
});
},{"irrelon-appcore":125}],45:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('$ige', function () {
	var $ige = function () {
		// Determine the environment we are executing in
		this.isServer = (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined' && typeof window === 'undefined');
		this.isClient = !this.isServer;
		
		this._currentViewport = null; // Set in IgeViewport.js tick(), holds the current rendering viewport
		this._currentCamera = null; // Set in IgeViewport.js tick(), holds the current rendering viewport's camera
		this._currentRoutePath = '';
		this._routeQueue = [];
		this._route = {};
	};
	
	/**
	 * Creates a new instance of the component argument passing
	 * the options argument to the component as it is initialised.
	 * The new component instance is then added to "this" via
	 * a property name that is defined in the component class as
	 * "componentId".
	 * @param {Function} component The class definition of the component.
	 * @param {Object=} options An options parameter to pass to the component
	 * on init.
	 * @example #Add the velocity component to an entity
	 *     var entity = new IgeEntity();
	 *     entity.addComponent(IgeVelocityComponent);
	 *
	 *     // Now that the component is added, we can access
	 *     // the component via it's namespace. Call the
	 *     // "byAngleAndPower" method of the velocity component:
	 *     entity.velocity.byAngleAndPower(Math.radians(20), 0.1);
	 */
	$ige.prototype.addComponent = function (component, options) {
		var newComponent = new component(this, options);
		this[newComponent.componentId] = newComponent;
		
		// Add the component reference to the class component array
		this._components = this._components || [];
		this._components.push(newComponent);
		
		return this;
	};
	
	/**
	 * Gets / sets a route for the engine routing system.
	 * @param {String=} path The path for the route being get or set.
	 * @param {Object=} definition The definition to set to the
	 * specified path. If not passed, returns the current definition
	 * for the path.
	 * @returns {*}
	 */
	$ige.prototype.route = function (path, definition) {
		if (path !== undefined) {
			if (definition !== undefined) {
				this._route = this._route || {};
				this._route[path] = definition;
				
				return this;
			}
			
			return this._route[path];
		}
		
		return this._route;
	};
	
	/**
	 * Gets / sets route data by path.
	 * @param {String} path The path to get / set data for.
	 * @param {*=} data The data to set for the path.
	 * @returns {*}
	 */
	$ige.prototype.routeData = function (path, data) {
		if (path !== undefined) {
			this._routeData = this._routeData || {};
			
			if (data !== undefined) {
				this._routeData[path] = data;
				return this;
			}
			
			return this._routeData[path];
		}
		
		return this._routeData;
	};
	
	/**
	 * Tells the engine to navigate to the passed path. The current
	 * path will be exited before the new path is navigated to.
	 * @param {String} path The new path to navigate to.
	 */
	$ige.prototype.go = function (path) {
		var self = this,
			currentRoutePath,
			rootPathString,
			currentPathParts,
			newPathParts,
			tempPath,
			i;
		
		// Check for a route definition first
		if (!this._route[path]) {
			throw('Attempt to navigate to undefined route: ' + path);
		}
		
		currentRoutePath = self._currentRoutePath;
		rootPathString = '';
		currentPathParts = currentRoutePath.split('.');
		newPathParts = path.split('.');
		
		// Check current path
		if (self._currentRoutePath) {
			// Remove duplicate beginning parts from arrays
			while(currentPathParts.length && newPathParts.length && currentPathParts[0] === newPathParts[0]) {
				rootPathString += '.' + currentPathParts.shift();
				newPathParts.shift();
			}
			
			// Inform routes that they are being destroyed
			if (currentPathParts.length) {
				tempPath = rootPathString;
				currentPathParts.reverse();
				
				for (i = 0; i < currentPathParts.length; i++) {
					self._routeRemove(currentPathParts[i]);
				}
			}
		}
		
		// Now route to the new path
		if (newPathParts.length) {
			tempPath = rootPathString;
			
			for (i = 0; i < newPathParts.length; i++) {
				self._routeAdd(newPathParts[i]);
			}
		}
	};
	
	/**
	 * Adds a path section to the current path and executes the
	 * various parts of the path definition such as the designated
	 * scene graph, textures and controller.
	 * @param {String} path The path section to navigate to.
	 * @private
	 */
	$ige.prototype._routeAdd = function (path) {
		var self = this,
			definition,
			routeSteps,
			routeData,
			thisFullPath,
			queue;
		
		self._currentRoutePath += self._currentRoutePath ? '.' + path : path;
		thisFullPath = self._currentRoutePath;
		
		queue = this._routeQueue;
		
		queue.push(function (finished) {
			definition = self._route[thisFullPath];
			routeSteps = [];
			
			// Check for non-universal route (both client and server have different
			// definitions for the same route)
			if (definition.client && definition.server) {
				if (self.isClient) {
					definition = definition.client;
				}
				
				if (self.isServer) {
					definition = definition.server;
				}
			}
			
			if (!definition.controller) {
				self.log('$ige.engine._routeAdd() encounterd a route that has no controller specified: ' + thisFullPath, 'error');
			}
			
			routeData = {
				controllerModule: appCore.module(definition.controller),
				texturesModule: definition.textures ? appCore.module(definition.textures) : undefined,
				sceneGraphModule: definition.sceneGraph ? appCore.module(definition.sceneGraph) : undefined
			};
			
			self.routeData(thisFullPath, routeData);
			
			if (definition.textures) {
				routeSteps.push(function (finished) {
					routeData.texturesModule.emit('loading');
					appCore.run([definition.textures, function (textures) {
						if (!self.$textures.texturesLoaded()) {
							self.$textures.on('texturesLoaded', function () {
								routeData.texturesModule.emit('loaded');
								finished(false);
							});
							return;
						}
						
						routeData.texturesModule.emit('loaded');
						return finished(false);
					}]);
				});
			}
			
			routeSteps.push(function (finished) {
				routeData.controllerModule.emit('loading');
				appCore.run([definition.controller, function (Controller) {
					var controller = new Controller();
					
					self.routeData(thisFullPath).controllerModuleInstance = controller;
					routeData.controllerModule.emit('loaded');
					finished(false, controller);
				}]);
			});
			
			if (definition.sceneGraph) {
				routeSteps.push(function (controller, finished) {
					appCore.module('$controller', function () {
						return controller;
					});
					
					appCore
						.module(definition.sceneGraph)
						.$controller = controller;
					
					routeData.sceneGraphModule.emit('loading');
					appCore.run([definition.sceneGraph, function (sceneGraph) {
						self.engine.addGraph(definition.sceneGraph);
						
						routeData.sceneGraphModule.emit('loaded');
						finished(false);
					}]);
				});
			}
			
			routeSteps.waterfall(function () {
				if (routeData.texturesModule) { routeData.texturesModule.emit('ready'); }
				routeData.controllerModule.emit('ready');
				if (routeData.sceneGraphModule) { routeData.sceneGraphModule.emit('ready'); }
				
				finished();
			});
		});
		
		queue.series(function () {}, true);
	};
	
	/**
	 * Removes a path section from the current path and fires the
	 * "destroying" and finally "destroyed" events for any textures,
	 * scene graph and controller.
	 * @param {String} path The path section to navigate from.
	 * @private
	 */
	$ige.prototype._routeRemove = function (path) {
		var self = this,
			routeData,
			thisFullPath,
			definition,
			queue;
		
		thisFullPath = self._currentRoutePath;
		queue = this._routeQueue;
		
		queue.push(function (finished) {
			routeData = self.routeData(thisFullPath);
			definition = self._route[thisFullPath];
			
			if (!routeData) {
				throw('Attempting to routeRemove() a path that has no routeData: ' + thisFullPath);
			}
			
			if (routeData.sceneGraphModule) {
				routeData.sceneGraphModule.emit('destroying');
				self.engine.removeGraph(definition.sceneGraph);
			}
			
			if (routeData.texturesModule) {
				routeData.texturesModule.emit('destroying');
			}
			routeData.controllerModule.emit('destroying');
			
			if (routeData.sceneGraphModule) {
				routeData.sceneGraphModule.emit('destroyed');
			}
			
			if (routeData.texturesModule) {
				routeData.texturesModule.emit('destroyed');
			}
			routeData.controllerModule.emit('destroyed');
			
			self._currentRoutePath = self._currentRoutePath.replace(new RegExp('[\.]*?' + path + '$'), '');
			
			finished();
		});
		
		queue.series(function () {}, true);
	}
	
	return new $ige();
});
},{"irrelon-appcore":125}],46:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('$requestAnimFrame', function () {
	var requestAnimFrame;
	
	if (typeof window !== 'undefined') {
		/**
		 * A cross-browser/platform requestAnimationFrame method.
		 */
		requestAnimFrame = (function () {
			return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function (callback, element) {
					setTimeout(function () {
						callback(new Date().getTime());
					}, 1000 / 60);
				};
		}());
	} else {
		/**
		 * A node.js requestAnimationFrame method.
		 */
		requestAnimFrame = (function () {
			return function (callback, element) {
				setTimeout(function () {
					callback(new Date().getTime());
				}, 1000 / 60);
			};
		}());
	}
	
	return requestAnimFrame;
});
},{"irrelon-appcore":125}],47:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore'),
	emitter = _dereq_('irrelon-emitter');

appCore.module('$textures', function ($ige) {
	var $textures = function () {
		$ige.$textures = this;
		
		this._store = {};
		this._arr = [];
		this._textureImageStore = {};
		this._texturesLoading = 0; // Holds a count of currently loading textures
		this._texturesTotal = 0; // Holds total number of textures loading / loaded
		this._globalSmoothing = false; // Determines the default smoothing setting for new textures
	};
	
	$textures.prototype.add = function (name, texture) {
		this._store[name] = texture;
	};
	
	$textures.prototype.addGroup = function (group) {
		var i;
		
		for (i in group) {
			if (group.hasOwnProperty(i)) {
				this.add(i, group[i]);
			}
		}
	};
	
	$textures.prototype.remove = function (name) {
		var texture = this._store[name];
		
		if (texture) {
			texture.destroy();
			delete this._store[name];
		}
	};
	
	$textures.prototype.removeGroup = function (group) {
		var i;
		
		for (i in group) {
			if (group.hasOwnProperty(i)) {
				this.remove(i);
			}
		}
	};
	
	$textures.prototype.get = function (name) {
		var tex = this._store[name];
		if (!tex) {
			throw('Attempted to get texture that does not exist: ' + name);
		}
		
		return tex;
	};
	
	/**
	 * Adds one to the number of textures currently loading.
	 */
	$textures.prototype.textureLoadStart = function (url, textureObj) {
		this._texturesLoading++;
		this._texturesTotal++;
		
		$ige.engine.updateProgress();
		
		this.emit('textureLoadStart', textureObj);
	};
	
	/**
	 * Subtracts one from the number of textures currently loading and if no more need
	 * to load, it will also call the _allTexturesLoaded() method.
	 */
	$textures.prototype.textureLoadEnd = function (url, textureObj) {
		var self = this;
		
		if (!textureObj._destroyed) {
			// Add the texture to the _arr array
			this._arr.push(textureObj);
		}
		
		// Decrement the overall loading number
		this._texturesLoading--;
		
		$ige.engine.updateProgress();
		
		this.emit('textureLoadEnd', textureObj);
		
		// If we've finished...
		if (this._texturesLoading === 0) {
			// All textures have finished loading
			$ige.engine.updateProgress();
			
			setTimeout(function () {
				self._allTexturesLoaded();
			}, 100);
		}
	};
	
	/**
	 * Returns a texture from the texture store by it's url.
	 * @param {String} url
	 * @return {IgeTexture}
	 */
	$textures.prototype.textureFromUrl = function (url) {
		var arr = this._arr,
			arrCount = arr.length,
			item;
		
		while (arrCount--) {
			item = arr[arrCount];
			if (item._url === url) {
				return item;
			}
		}
	};
	
	/**
	 * Checks if all textures have finished loading and returns true if so.
	 * @return {Boolean}
	 */
	$textures.prototype.texturesLoaded = function () {
		return this._texturesLoading === 0;
	};
	
	/**
	 * Emits the "texturesLoaded" event.
	 * @private
	 */
	$textures.prototype._allTexturesLoaded = function () {
		if (!this._loggedATL) {
			this._loggedATL = true;
			$ige.engine.log('All textures have loaded');
		}
		
		// Fire off an event about this
		this.emit('texturesLoaded');
	};
	
	/**
	 * Gets / sets the default smoothing value for all new
	 * IgeTexture class instances. If set to true, all newly
	 * created textures will have smoothing enabled by default.
	 * @param val
	 * @return {*}
	 */
	$textures.prototype.globalSmoothing = function (val) {
		if (val !== undefined) {
			this._globalSmoothing = val;
			return this;
		}
		
		return this._globalSmoothing;
	};
	
	// Add event emitter functionality to the class
	emitter($textures);
	
	return new $textures();
});
},{"irrelon-appcore":125,"irrelon-emitter":127}],48:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('$time', function () {
	var $time = function () {
		this._tickStart = 0;
		this._lastTick = 0;
		this._tickTime = 'NA'; // The time the tick took to process
		this._updateTime = 'NA'; // The time the tick update section took to process
		this._renderTime = 'NA'; // The time the tick render section took to process
		this._tickDelta = 0; // The time between the last tick and the current one
		this._fpsRate = 60; // Sets the frames per second to execute engine tick's at
		this._drawCount = 0; // Holds the number of draws since the last frame (calls to drawImage)
		this._dps = 0; // Number of draws that occurred last tick
		this._dpf = 0;
		this._frames = 0; // Number of frames looped through since last second tick
		this._fps = 0; // Number of achieved frames per second
		this._clientNetDiff = 0; // The difference between the server and client comms (only non-zero on clients)
		this._currentTime = 0; // The current engine time
	};
	
	return new $time();
});
},{"irrelon-appcore":125}],49:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeArray', function (IgeEntity) {
	var IgeArray = function () {};
	IgeArray.prototype = [];

	// Empower the IgeArray with all the method calls of the an IgeEntity
	for (var methodName in IgeEntity.prototype) {
		if (IgeEntity.prototype.hasOwnProperty(methodName)) {
			if (methodName !== 'init') {
				IgeArray.prototype[methodName] = function (methodName) {
					return function () {
						var c = this.length;
						for (var i = 0; i < c; i++) {
							this[i][methodName].apply(this[i], arguments);
						}
					};
				}(methodName);
			}
		}
	}
	
	return IgeArray;
});
},{"irrelon-appcore":125}],50:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

/**
 * IgeBase is a module that configures a bunch of JS native type
 * extensions and must never have any other module dependencies
 * so that you can be absolutely sure if you include it, you will
 * not have circular dependency issues.
 */
appCore.module('igeBase', function () {
	var IgeBase = function () {
		// When setting a new version please use this format:
		// v{MAJOR}.{MINOR}.{SUB}@{YYYY-MM-DD}.{REVISION}
		//
		// For example, to tag version 1.1.2 on 25th April 2013
		// as the third revision of the day:
		// v1.1.2@2013-04-25.003
		this._version = 'v2.0.0@2017-09-07.002';
		
		// Define the global storage object for classes
		this.igeClassStore = {};
		
		// Define a config object
		this.igeConfig = {
			debug: {
				_enabled: true,
				_node: typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined',
				_level: ['log', 'warning', 'error'],
				_stacks: true,
				_throwErrors: true,
				_timing: true,
				enabled: function (val) {
					if (val !== undefined) {
						this._enabled = val;
						
						return this;
					}
					
					return this._enabled;
				}
			}
		};
		
		if (this.igeConfig.debug._node) {
			this.igeConfig.debug._util = _dereq_('util');
		}
	};
	
	/**
	 * Gets the engine build version.
	 * @returns {String}
	 */
	IgeBase.prototype.version = function () {
		return this._version;
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Object.prototype, 'theSameAs', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Augments all objects with the theSameAs() method. Checks if the
	 * property values of this object are equal to the property values
	 * of the passed object. If they are the same then this method will
	 * return true. Objects must not contain circular references!
	 * @param {Object} obj The object to compare this one to.
	 * @return {Boolean}
	 */
	Object.prototype.theSameAs = function (obj) {
		return JSON.stringify(this) === JSON.stringify(obj);
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'clone', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Clones the array and returns a new non-referenced
	 * array.
	 * @return {*}
	 */
	Array.prototype.clone = function () {
		var i, newArray = [];
		for (i in this) {
			if (this.hasOwnProperty(i)) {
				if (this[i] instanceof Array) {
					newArray[i] = this[i].clone();
				} else {
					newArray[i] = this[i];
				}
			}
		}
		
		return newArray;
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'pull', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Removes the passed item from an array, the opposite of push().
	 * @param item
	 * @return {*}
	 */
	Array.prototype.pull = function (item) {
		var index = this.indexOf(item);
		if (index > -1) {
			this.splice(index, 1);
			return index;
		} else {
			return -1;
		}
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'pushUnique', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Adds an item to an array, only if it does not already exist in the array.
	 * @param item
	 * @return {Boolean} True if the item was added, false if it already exists.
	 */
	Array.prototype.pushUnique = function (item) {
		var index = this.indexOf(item);
		if (index === -1) {
			this.push(item);
			return true;
		}
		
		return false;
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'each', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Iterates through an array's items and calls the callback method
	 * passing each item one by one.
	 * @param {Function} callback
	 */
	Array.prototype.each = function (callback) {
		var len = this.length,
			i;
		
		for (i = 0; i < len; i++) {
			callback(this[i]);
		}
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'eachReverse', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Iterates through an array's items and calls the callback method
	 * passing each item one by one in reverse order.
	 * @param {Function} callback
	 */
	Array.prototype.eachReverse = function (callback) {
		var arrCount = this.length,
			i;
		
		for (i = arrCount - 1; i >= 0; i--) {
			callback(this[i]);
		}
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'destroyAll', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Iterates through an array's items and calls each item's
	 * destroy() method if it exists. Useful for destroying an
	 * array of IgeEntity instances.
	 */
	Array.prototype.destroyAll = function () {
		var arrCount = this.length,
			i;
		
		for (i = arrCount - 1; i >= 0; i--) {
			if (typeof(this[i].destroy) === 'function') {
				this[i].destroy();
			}
		}
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'eachIsolated', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Iterates through an array's items and calls the callback method
	 * passing each item one by one. Altering the array's structure
	 * during the callback method will not affect the iteration of the
	 * items.
	 *
	 * @param {Function} callback
	 */
	Array.prototype.eachIsolated = function (callback) {
		var arr = [],
			arrCount = arr.length,
			i;
		
		// Create a copy of the array
		for (i = 0; i < arrCount; i++) {
			arr[i] = this[i];
		}
		
		// Now iterate the array, passing the copied
		// array value at the index(i). Any changes to
		// "this" will not affect the index(i) values.
		for (i = 0; i < arrCount; i++) {
			callback(arr[i]);
		}
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'series', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Basically the same functionality as async.series without
	 * importing the entire async library. Calls each function
	 * in the array one at a time passing in a callback and waiting
	 * for the callback to be called before proceeding to call
	 * the next function in the array. When all functions have
	 * been called, calls the function specified by "complete".
	 * @param {Function=} complete Optional callback to call once
	 * all functions in the series have been executed.
	 * @return {*}
	 */
	Array.prototype.series = function (complete, reference) {
		var self = this,
			callArr,
			callFunc;
		
		if (this._executingSeries) {
			return;
		}
		
		callArr = reference ? this : this.clone();
		this._executingSeries = true;
		
		if (!callArr.length) {
			delete self._executingSeries;
			
			if (complete) {
				complete();
			}
			return;
		}
		
		callFunc = function () {
			var func = callArr.shift();
			
			if (!func) {
				delete self._executingSeries;
				
				if (complete) {
					complete();
				}
				return;
			}
			
			func(function (err) {
				setTimeout(function () {
					callFunc();
				}, 1);
			});
		};
		
		callFunc();
	};
	
	/**
	 * Basically the same functionality as async.waterfall without
	 * importing the entire async library. Calls each function
	 * in the array one at a time passing in a callback and waiting
	 * for the callback to be called before proceeding to call
	 * the next function in the array. When all functions have
	 * been called, calls the function specified by "complete".
	 * @param {Function=} complete Optional callback to call once
	 * all functions in the series have been executed.
	 * @return {*}
	 */
	Array.prototype.waterfall = function (complete) {
		var callArr = this.clone(),
			callFunc;
		
		if  (!callArr.length) {
			if (complete) {
				complete();
			}
			return;
		}
		
		callFunc = function (waterfallArgs) {
			var func = callArr.shift();
			
			if (!func) {
				if (complete) {
					complete(false);
				}
				return;
			}
			
			waterfallArgs = waterfallArgs || [];
			waterfallArgs.push(function (err) {
				var args = [],
					i;
				
				if (err) {
					complete(err);
					return;
				}
				
				// Skip the error argument and copy the rest
				for (i = 1; i < arguments.length; i++) {
					args.push(arguments[i]);
				}
				
				setTimeout(function () {
					callFunc(args);
				}, 1);
			});
			
			func.apply(func, waterfallArgs);
		};
		
		callFunc();
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Math, 'PI180', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Stores a pre-calculated PI / 180 value.
	 * @type {Number}
	 */
	Math.PI180 = Math.PI / 180;
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Math, 'PI180R', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Stores a pre-calculated 180 / PI value.
	 * @type {Number}
	 */
	Math.PI180R = 180 / Math.PI;
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Math, 'toIso', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	Math.toIso = function (x, y, z) {
		var sx = x - y,
			sy = (-z) * 1.2247 + (x + y) * 0.5;
		
		return {x: sx, y: sy};
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Math, 'radians', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Converts degrees to radians.
	 * @param {Number} degrees
	 * @return {Number} radians
	 */
	Math.radians = function (degrees) {
		return degrees * Math.PI180;
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Math, 'degrees', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Converts radians to degrees.
	 * @param {Number} radians
	 * @return {Number} degrees
	 */
	Math.degrees = function (radians) {
		return radians * Math.PI180R;
	};
	
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Math, 'distance', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Calculates the distance from the first point to the second point.
	 * @param x1
	 * @param y1
	 * @param x2
	 * @param y2
	 * @return {Number}
	 */
	Math.distance = function (x1, y1, x2, y2) {
		return Math.sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));
	};
	
	if (typeof(CanvasRenderingContext2D) !== 'undefined') {
		// Extend the canvas context to add some helper methods
		/**
		 * Make property non-enumerable.
		 */
		Object.defineProperty(CanvasRenderingContext2D.prototype, 'circle', {
			enumerable: false,
			writable: true,
			configurable: true
		});
		
		Object.defineProperty(CanvasRenderingContext2D.prototype, 'strokeCircle', {
			enumerable: false,
			writable: true,
			configurable: true
		});
		
		Object.defineProperty(CanvasRenderingContext2D.prototype, 'fillCircle', {
			enumerable: false,
			writable: true,
			configurable: true
		});
		
		CanvasRenderingContext2D.prototype.circle = function (x, y, radius) {
			this.arc(x, y, radius, 0, 2 * Math.PI, false);
		};
		
		CanvasRenderingContext2D.prototype.strokeCircle = function (x, y, radius) {
			this.save();
			this.beginPath();
			this.arc(x, y, radius, 0, 2 * Math.PI, false);
			this.stroke();
			this.restore();
		};
		
		CanvasRenderingContext2D.prototype.fillCircle = function (x, y, radius) {
			this.save();
			this.beginPath();
			this.arc(x, y, radius, 0, 2 * Math.PI, false);
			this.fill();
			this.restore();
		};
	}
	
	if (typeof(ImageData) !== 'undefined') {
		/**
		 * Make property non-enumerable.
		 */
		Object.defineProperty(ImageData.prototype, 'pixelAt', {
			enumerable: false,
			writable: true,
			configurable: true
		});
		
		/**
		 * Augments the canvas context getImageData() object "ImageData" with the
		 * pixelAt() method. Gets the pixel color data for the given pixel at the
		 * x, y co-ordinates specified.
		 * @param {Number} x The x co-ordinate of the pixel.
		 * @param {Number} y The y co-ordinate of the pixel.
		 * @return {Object} An object containing the pixel color data in properties
		 * {r, g, b, a}.
		 */
		ImageData.prototype.pixelAt = function (x, y) {
			var data = this.data,
				pixelStart = (y * this.width * 4) + (x * 4);
			
			return {
				r: data[pixelStart],
				g: data[pixelStart + 1],
				b: data[pixelStart + 2],
				a: data[pixelStart + 3]
			};
		};
		
		/**
		 * Make property non-enumerable.
		 */
		Object.defineProperty(ImageData.prototype, 'isTransparent', {
			enumerable: false,
			writable: true,
			configurable: true
		});
		
		/**
		 * Augments the canvas context getImageData() object "ImageData" with the
		 * isTransparent() method. Determines if the pixel at the passed x, y is
		 * fully transparent or not.
		 * @param {Number} x The x co-ordinate of the pixel.
		 * @param {Number} y The y co-ordinate of the pixel.
		 * @return {Boolean} True if fully transparent, false if not.
		 */
		ImageData.prototype.isTransparent = function (x, y) {
			var data = this.data,
				pixelStart = (y * this.width * 4) + (x * 4);
			
			return data[pixelStart + 3] === 0;
		};
		
		/**
		 * Make property non-enumerable.
		 */
		Object.defineProperty(ImageData.prototype, 'makeTransparent', {
			enumerable: false,
			writable: true,
			configurable: true
		});
		
		/**
		 * Augments the canvas context getImageData() object "ImageData" with the
		 * makeTransparent() method. Makes the pixel at the passed x, y fully
		 * transparent.
		 * @param {Number} x The x co-ordinate of the pixel.
		 * @param {Number} y The y co-ordinate of the pixel.
		 */
		ImageData.prototype.makeTransparent = function (x, y) {
			var data = this.data,
				pixelStart = (y * this.width * 4) + (x * 4);
			
			data[pixelStart + 3] = 0;
		};
	}
	
	/**
	 * Turn off the right-click default behaviour in the browser for the passed element.
	 * @param obj
	 */
	IgeBase.prototype.disableContextMenu = function (obj) {
		if (obj !== null) {
			//this.log('Disabling context menus for ' + obj, 'info');
			obj.oncontextmenu = function () {
				return false;
			};
		}
	};
	
	/**
	 * Adds the indexOf method to all array objects if it does not already exist which
	 * would you believe can still happen even in 2012!
	 */
	if (!Array.prototype.indexOf) {
		/**
		 * Make property non-enumerable.
		 */
		Object.defineProperty(Array.prototype, 'indexOf', {
			enumerable: false,
			writable: true,
			configurable: true
		});
		
		/**
		 * Get the index of the passed item.
		 * @param {*} obj The item to find the index for.
		 * @return {Number} The index of the passed item or -1 if not found.
		 */
		Array.prototype.indexOf = function (obj) {
			var i, l = this.length;
			for (i = 0; i < l; i++) {
				if (this[i] === obj) {
					return i;
				}
			}
			return -1;
		};
	}
	
	// Check console method existence
	if (typeof(console) === 'object') {
		if (typeof(console.log) === 'function') {
			if (typeof(console.info) === 'undefined') {
				// We have console.log but not console.info so add it as a replica of console.log
				console.info = console.log;
			}
			
			if (typeof(console.warn) === 'undefined') {
				// We have console.log but not console.warn so add it as a replica of console.log
				console.warn = console.log;
			}
		}
	} else {
		// Create dummy console
		console = {
			log: function () {
			},
			warn: function () {
			},
			info: function () {
			},
			error: function () {
			}
		};
	}
	
	return new IgeBase();
});

appCore.module('igeBase').run(function (IgeTween) {
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Object.prototype, 'tween', {
		enumerable: false,
		writable: true,
		configurable: true
	});
	
	/**
	 * Augments all objects with the tween() method. Creates a new IgeTween
	 * with the passed parameters that will act upon the object's properties.
	 * The returned tween will not start tweening until a call to start() is
	 * made.
	 * @param {Object} props
	 * @param {Number} durationMs
	 * @param {Object=} options
	 * @return {IgeTween}
	 */
	Object.prototype.tween = function (props, durationMs, options) {
		var newTween = new IgeTween()
			.targetObj(this)
			.properties(props)
			.duration(durationMs);
		
		if (options) {
			if (options.beforeTween) {
				newTween.beforeTween(options.beforeTween);
			}
			if (options.afterTween) {
				newTween.afterTween(options.afterTween);
			}
			if (options.easing) {
				newTween.easing(options.easing);
			}
			if (options.startTime) {
				newTween.startTime(options.startTime);
			}
		}
		
		return newTween;
	};
});
},{"irrelon-appcore":125,"util":132}],51:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeBaseScene', function ($ige, IgeSceneGraph, IgeScene2d, IgeViewport) {
	/**
	 * When loaded into memory using $ige.engine.addGraph('IgeBaseScene') will create
	 * the scene "baseScene" and the viewport "vp1" that are used in almost all
	 * examples and can be used as the base for your scenegraph as well.
	 */
	var IgeBaseScene = IgeSceneGraph.extend({
		classId: 'IgeBaseScene',
		
		init: function () {
		},
		
		/**
		 * Called when loading the graph data via $ige.engine.addGraph().
		 * @param options
		 */
		addGraph: function (options) {
			// Clear existing graph data
			if ($ige.engine.$('baseScene')) {
				this.removeGraph();
			}
			
			// Create the scene
			var baseScene = new IgeScene2d()
				.id('baseScene');
			
			// Create the main viewport to look at "baseScene"
			new IgeViewport()
				.id('vp1')
				.autoSize(true)
				.scene(baseScene)
				.drawBounds(false)
				.mount($ige.engine);
		},
		
		/**
		 * The method called when the graph items are to be removed from the
		 * active graph.
		 */
		removeGraph: function () {
			// Destroy the viewport
			$ige.engine.$('vp1').destroy();
			
			// Destroy the baseScene
			$ige.engine.$('baseScene').destroy();
		}
	});
	
	return IgeBaseScene;
});
},{"irrelon-appcore":125}],52:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeCamera', function (IgeEntity) {
	/**
	 * Creates a new camera that will be attached to a viewport.
	 */
	var IgeCamera = IgeEntity.extend({
		classId: 'IgeCamera',
		
		init: function (entity) {
			IgeEntity.prototype.init.call(this);
			
			this._trackRotateTarget = undefined;
			this._trackTranslateTarget = undefined;
			this._trackRotateSmoothing = undefined;
			this._trackTranslateSmoothing = undefined;
			
			// Store the viewport this camera is attached to
			this._entity = entity;
		},
		
		/**
		 * Gets / sets the rectangle that the camera translate
		 * will be limited to using an IgeRect instance.
		 * @param {IgeRect=} rect
		 * @return {*}
		 */
		limit: function (rect) {
			// TODO: Write the usage of this limit data, currently does nothing
			if (rect !== undefined) {
				this._limit = rect;
				return this._entity;
			}
			
			return this._limit;
		},
		
		/**
		 * Pan (tween) the camera to the new specified point in
		 * the specified time.
		 * @param {IgePoint3d} point The point describing the co-ordinates to pan to.
		 * @param {Number} durationMs The number of milliseconds to span the pan operation over.
		 * @param {String=} easing Optional easing method name.
		 */
		panTo: function (point, durationMs, easing) {
			if (point !== undefined) {
				this._translate.tween()
					.properties({
						x: point.x,
						y: point.y,
						z: point.z
					})
					.duration(durationMs)
					.easing(easing)
					.start();
			}
			
			return this._entity;
		},
		
		/**
		 * Pan (tween) the camera by the new specified point in
		 * the specified time.
		 * @param {IgePoint3d} point The point describing the co-ordinates to pan by.
		 * @param {Number} durationMs The number of milliseconds to span the pan operation over.
		 * @param {String=} easing Optional easing method name.
		 */
		panBy: function (point, durationMs, easing) {
			if (point !== undefined) {
				this._translate.tween()
					.properties({
						x: point.x + this._translate.x,
						y: point.y + this._translate.y,
						z: point.z + this._translate.z
					})
					.duration(durationMs)
					.easing(easing)
					.start();
			}
			
			return this._entity;
		},
		
		/**
		 * Tells the camera to track the movement of the specified
		 * target entity. The camera will center on the entity.
		 * @param {IgeEntity} entity
		 * @param {Number=} smoothing Determines how quickly the camera
		 * will track the target, the higher the number, the slower the
		 * tracking will be.
		 * @param {Boolean=} rounding Sets if the smoothing system is
		 * allowed to use floating point values or not. If enabled then
		 * it will not use floating point values.
		 * @return {*}
		 */
		trackTranslate: function (entity, smoothing, rounding) {
			if (entity !== undefined) {
				this.log('Camera on viewport ' + this._entity.id() + ' is now tracking translation target ' + entity.id());
				if (rounding !== undefined) {
					this._trackTranslateRounding = rounding;
				}
				
				if (smoothing !== undefined) {
					this._trackTranslateSmoothing = smoothing >= 1 ? smoothing : 0;
				}
				
				this._trackTranslateTarget = entity;
				return this._entity;
			}
			
			return this._trackTranslateTarget;
		},
		
		/**
		 * Gets / sets the translate tracking smoothing value.
		 * @param {Number=} val
		 * @return {*}
		 */
		trackTranslateSmoothing: function (val) {
			if (val !== undefined) {
				this._trackTranslateSmoothing = val;
				return this;
			}
			
			return this._trackTranslateSmoothing;
		},
		
		/**
		 * Gets / sets the translate tracking smoothing rounding
		 * either enabled or disabled. When enabled the translate
		 * smoothing value will be rounded so that floating point
		 * values are not used which can help when smoothing on a
		 * scene that has texture smoothing disabled so sub-pixel
		 * rendering doesn't work and objects appear to "snap"
		 * into position as the smoothing interpolates.
		 * @param {Boolean=} val
		 * @return {*}
		 */
		trackTranslateRounding: function (val) {
			if (val !== undefined) {
				this._trackTranslateRounding = val;
				return this;
			}
			
			return this._trackTranslateRounding;
		},
		
		/**
		 * Stops tracking the current tracking target's translation.
		 */
		unTrackTranslate: function () {
			delete this._trackTranslateTarget;
		},
		
		/**
		 * Tells the camera to track the rotation of the specified
		 * target entity.
		 * @param {IgeEntity} entity
		 * @param {Number=} smoothing Determines how quickly the camera
		 * will track the target, the higher the number, the slower the
		 * tracking will be.
		 * @return {*}
		 */
		trackRotate: function (entity, smoothing) {
			if (entity !== undefined) {
				this.log('Camera on viewport ' + this._entity.id() + ' is now tracking rotation of target ' + entity.id());
				this._trackRotateSmoothing = smoothing >= 1 ? smoothing : 0;
				this._trackRotateTarget = entity;
				return this._entity;
			}
			
			return this._trackRotateTarget;
		},
		
		/**
		 * Gets / sets the rotate tracking smoothing value.
		 * @param {Number=} val
		 * @return {*}
		 */
		trackRotateSmoothing: function (val) {
			if (val !== undefined) {
				this._trackRotateSmoothing = val;
				return this;
			}
			
			return this._trackRotateSmoothing;
		},
		
		/**
		 * Stops tracking the current tracking target.
		 */
		unTrackRotate: function () {
			delete this._trackRotateTarget;
		},
		
		/**
		 * Translates the camera to the center of the specified entity so
		 * that the camera is "looking at" the entity.
		 * @param {IgeEntity} entity The entity to look at.
		 * @param {Number=} durationMs If specified, will cause the
		 * camera to tween to the location of the entity rather than
		 * snapping to it instantly.
		 * @param {String=} easing The easing method name to use if
		 * tweening by duration.
		 * @return {*}
		 */
		lookAt: function (entity, durationMs, easing) {
			if (entity !== undefined) {
				entity.updateTransform();
				
				if (!durationMs) {
					// Copy the target's world matrix translate data
					this._translate.x = Math.floor(entity._worldMatrix.matrix[2]);
					this._translate.y = Math.floor(entity._worldMatrix.matrix[5]);
				} else {
					this._translate.tween()
						.properties({
							x: Math.floor(entity._worldMatrix.matrix[2]),
							y: Math.floor(entity._worldMatrix.matrix[5]),
							z: 0
						})
						.duration(durationMs)
						.easing(easing)
						.start();
				}
				
				this.updateTransform();
			}
			
			return this;
		},
		
		update: function (ctx) {
			// Process any behaviours assigned to the camera
			this._processUpdateBehaviours(ctx);
			
			// Check if we are tracking the translate value of a target
			if (this._trackTranslateTarget) {
				var targetEntity = this._trackTranslateTarget,
					targetMatrix = targetEntity._worldMatrix.matrix,
					targetX = targetMatrix[2],
					targetY = targetMatrix[5],
					sourceX, sourceY, distX, distY, destinationX, destinationY;
				
				if (!this._trackTranslateSmoothing) {
					// Copy the target's world matrix translate data
					this.lookAt(this._trackTranslateTarget);
				} else {
					// Ease between the current and target values
					sourceX = this._translate.x;
					sourceY = this._translate.y;
					
					distX = Math.round(targetX - sourceX);
					distY = Math.round(targetY - sourceY);
					
					if (this._trackTranslateRounding) {
						destinationX = this._translate.x + Math.round(distX / this._trackTranslateSmoothing);
						destinationY = this._translate.y + Math.round(distY / this._trackTranslateSmoothing);
					} else {
						destinationX = this._translate.x + distX / this._trackTranslateSmoothing;
						destinationY = this._translate.y + distY / this._trackTranslateSmoothing;
					}
					
					// Check camera Limits
					if (this._limit) {
						
						if (destinationX < this._limit.x) {
							destinationX = this._limit.x;
						}
						if (destinationX > this._limit.x + this._limit.width) {
							destinationX = this._limit.x + this._limit.width;
						}
						if (destinationY < this._limit.y) {
							destinationY = this._limit.y;
						}
						if (destinationY > this._limit.y + this._limit.height) {
							destinationY = this._limit.y + this._limit.height;
						}
						
					}
					
					this._translate.x = destinationX;
					this._translate.y = destinationY;
					
				}
			}
			
			// Check if we are tracking the rotation values of a target
			if (this._trackRotateTarget) {
				var targetParentRZ = this._trackRotateTarget._parent !== undefined ? this._trackRotateTarget._parent._rotate.z : 0,
					targetZ = -(targetParentRZ + this._trackRotateTarget._rotate.z),
					sourceZ, distZ;
				
				if (!this._trackRotateSmoothing) {
					// Copy the target's rotate data
					this._rotate.z = targetZ;
				} else {
					// Interpolate between the current and target values
					sourceZ = this._rotate.z;
					distZ = targetZ - sourceZ;
					
					this._rotate.z += distZ / this._trackRotateSmoothing;
				}
			}
			
			this.updateTransform();
		},
		
		/**
		 * Process operations during the engine tick.
		 * @param {CanvasRenderingContext2D} ctx
		 */
		tick: function (ctx) {
			// Process any behaviours assigned to the camera
			this._processTickBehaviours(ctx);
			
			// Updated local transform matrix and then transform the context
			this._localMatrix.transformRenderingContext(ctx);
		},
		
		/**
		 * Checks the current transform values against the previous ones. If
		 * any value is different, the appropriate method is called which will
		 * update the transformation matrix accordingly. This version of the
		 * method is specifically designed for cameras!
		 */
		updateTransform: function () {
			this._localMatrix.identity();
			
			// On cameras we do the rotation and scaling FIRST
			this._localMatrix.multiply(this._localMatrix._newRotate(this._rotate.z));
			this._localMatrix.multiply(this._localMatrix._newScale(this._scale.x, this._scale.y));
			
			// 2d translation - cameras are never in iso mode!
			this._localMatrix.multiply(this._localMatrix._newTranslate(-this._translate.x, -this._translate.y));
			
			if (this._parent) {
				this._worldMatrix.copy(this._parent._worldMatrix);
				this._worldMatrix.multiply(this._localMatrix);
			} else {
				this._worldMatrix.copy(this._localMatrix);
			}
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object's properties via
		 * chained commands. This method will only check for
		 * properties that are directly related to this class.
		 * Other properties are handled by their own class method.
		 * @private
		 * @return {String}
		 */
		_stringify: function () {
			// Get the properties for all the super-classes
			var str = IgeEntity.prototype._stringify.call(this), i;
			
			// Loop properties and add property assignment code to string
			for (i in this) {
				if (this.hasOwnProperty(i) && this[i] !== undefined) {
					switch (i) {
						case '_trackTranslateTarget':
							str += ".trackTranslate($ige.engine.$('" + this._trackTranslateTarget.id() + "'), " + this.trackTranslateSmoothing() + ")";
							break;
						case '_trackRotateTarget':
							str += ".trackRotate($ige.engine.$('" + this._trackRotateTarget.id() + "'), " + this.trackRotateSmoothing() + ")";
							break;
					}
				}
			}
			
			return str;
		}
	});
	
	return IgeCamera;
});
},{"irrelon-appcore":125}],53:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeCellSheet', function (IgeTexture) {
	/**
	 * Creates a new cell sheet. Cell sheets are textures that are
	 * automatically split up into individual cells based on a cell
	 * width and height.
	 */
	var IgeCellSheet = IgeTexture.extend({
		classId: 'IgeCellSheet',
		IgeSpriteSheet: true,
		
		init: function (url, horizontalCells, verticalCells) {
			var self = this;
			
			self.horizontalCells(horizontalCells || 1);
			self.verticalCells(verticalCells || 1);
			
			IgeTexture.prototype.init.call(this, url);
		},
		
		_textureLoaded: function () {
			if (this.image) {
				// Store the cell sheet image
				this._sheetImage = this.image;
				this._applyCells();
			} else {
				// Unable to create cells from non-image texture
				// TODO: Low-priority - Support cell sheets from smart-textures
				this.log('Cannot create cell-sheet because texture has not loaded an image!', 'error');
			}
			
			IgeTexture.prototype._textureLoaded.call(this);
		},
		
		/**
		 * Returns the total number of cells in the cell sheet.
		 * @return {Number}
		 */
		cellCount: function () {
			return this.horizontalCells() * this.verticalCells();
		},
		
		/**
		 * Gets / sets the number of horizontal cells in the cell sheet.
		 * @param {Number=} val The integer count of the number of horizontal cells in the cell sheet.
		 */
		horizontalCells: function (val) {
			if (val !== undefined) {
				this._cellColumns = val;
				return this;
			}
			
			return this._cellColumns;
		},
		
		/**
		 * Gets / sets the number of vertical cells in the cell sheet.
		 * @param {Number=} val The integer count of the number of vertical cells in the cell sheet.
		 */
		verticalCells: function (val) {
			if (val !== undefined) {
				this._cellRows = val;
				return this;
			}
			
			return this._cellRows;
		},
		
		/**
		 * Sets the x, y, width and height of each sheet cell and stores
		 * that information in the this._cells array.
		 * @private
		 */
		_applyCells: function () {
			var imgWidth, imgHeight,
				rows, columns,
				cellWidth, cellHeight,
				cellIndex,
				xPos, yPos;
			
			// Do we have an image to use?
			if (this.image) {
				// Check we have the correct data for a uniform cell layout
				if (this._cellRows && this._cellColumns) {
					imgWidth = this._sizeX;
					imgHeight = this._sizeY;
					rows = this._cellRows;
					columns = this._cellColumns;
					
					// Store the width and height of a single cell
					cellWidth = this._cellWidth = imgWidth / columns;
					cellHeight = this._cellHeight = imgHeight / rows;
					
					// Check if the cell width and height are non-floating-point
					if (cellWidth !== parseInt(cellWidth, 10)) {
						this.log('Cell width is a floating-point number! (Image Width ' + imgWidth + ' / Number of Columns ' + columns + ' = ' + cellWidth + ') in file: ' + this._url, 'warning');
					}
					
					if (cellHeight !== parseInt(cellHeight, 10)) {
						this.log('Cell height is a floating-point number! (Image Height ' + imgHeight + ' / Number of Rows ' + rows + ' = ' + cellHeight + ')  in file: ' + this._url, 'warning');
					}
					
					// Check if we need to calculate individual cell data
					if (rows > 1 || columns > 1) {
						for (cellIndex = 1; cellIndex <= (rows * columns); cellIndex++) {
							yPos = (Math.ceil(cellIndex / columns) - 1);
							xPos = ((cellIndex - (columns * yPos)) - 1);
							
							// Store the xy in the sheet frames variable
							this._cells[cellIndex] = [(xPos * cellWidth), (yPos * cellHeight), cellWidth, cellHeight];
						}
					} else {
						// The cell data shows only one cell so just store the whole image data
						this._cells[1] = [0, 0, this._sizeX, this._sizeY];
					}
				}
			}
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object.
		 * @return {String}
		 */
		stringify: function () {
			var str = "new " + this.classId() + "('" + this.url() + "', " + this.horizontalCells() + ", " + this.verticalCells() + ")";
			
			// Every object has an ID, assign that first
			// IDs are automatically generated from texture urls
			//str += ".id('" + this.id() + "');";
			
			return str;
		}
	});
	
	return IgeCellSheet;
});
},{"irrelon-appcore":125}],54:[function(_dereq_,module,exports){
//"use strict"; // We use arguments.callee in here, cannot have strict mode on this module

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeClass', function ($ige, igeBase, printStackTrace) {
	/**
	 * The base class system.
	 */
	var IgeClass = (function () {
		var initializing = false,
			//fnTest = /xyz/.test(function (xyz) { xyz = null; }) ? /\b_super\b/ : /.*/,
			
			// The base Class implementation (does nothing)
			IgeClass = function () {},
			
			/**
			 * Provides logging capabilities to all IgeClass instances.
			 * @param {String} text The text to log.
			 * @param {String} type The type of log to output, can be 'log',
			 * 'info', 'warning' or 'error'.
			 * @param {Object=} obj An optional object that will be output
			 * before the log text is output.
			 * @example #Log a message
			 *     var entity = new IgeEntity();
			 *
			 *     // Will output:
			 *     //     IGE *log* [IgeEntity] : hello
			 *     entity.log('Hello');
			 * @example #Log an info message with an optional parameter
			 *     var entity = new IgeEntity(),
			 *         param = 'moo';
			 *
			 *     // Will output:
			 *     //    moo
			 *     //    IGE *log* [IgeEntity] : hello
			 *     entity.log('Hello', 'info', param);
			 * @example #Log a warning message (which will cause a stack trace to be shown)
			 *     var entity = new IgeEntity();
			 *
			 *     // Will output (stack trace is just an example here, real one will be more useful):
			 *     //    Stack: {anonymous}()@<anonymous>:2:8
			 *     //    ---- Object.InjectedScript._evaluateOn (<anonymous>:444:39)
			 *     //    ---- Object.InjectedScript._evaluateAndWrap (<anonymous>:403:52)
			 *     //    ---- Object.InjectedScript.evaluate (<anonymous>:339:21)
			 *     //    IGE *warning* [IgeEntity] : A test warning
			 *     entity.log('A test warning', 'warning');
			 * @example #Log an error message (which will cause an exception to be raised and a stack trace to be shown)
			 *     var entity = new IgeEntity();
			 *
			 *     // Will output (stack trace is just an example here, real one will be more useful):
			 *     //    Stack: {anonymous}()@<anonymous>:2:8
			 *     //    ---- Object.InjectedScript._evaluateOn (<anonymous>:444:39)
			 *     //    ---- Object.InjectedScript._evaluateAndWrap (<anonymous>:403:52)
			 *     //    ---- Object.InjectedScript.evaluate (<anonymous>:339:21)
			 *     //    IGE *error* [IgeEntity] : An error message
			 *     entity.log('An error message', 'error');
			 */
			log = function (text, type, obj) {
				if (igeBase.igeConfig.debug._enabled) {
					var indent = '',
						stack,
						thisId;
					
					if (typeof(this._id) !== 'undefined') {
						thisId = ':' + this._id;
					} else {
						thisId = '';
					}
					
					type = type || 'log';
					
					if (obj !== undefined) {
						console.warn(obj);
					}
					
					if (type === 'warning' || type === 'error') {
						if (igeBase.igeConfig.debug._stacks) {
							if (igeBase.igeConfig.debug._node) {
								if (console.trace) {
									console.trace();
								} else {
									stack = new Error().stack;
									//console.log(color.magenta('Stack:'), color.red(stack));
									console.log('Stack:', stack);
								}
							} else {
								if (typeof(printStackTrace) === 'function') {
									console.log('Stack:', printStackTrace().join('\n ---- '));
								}
							}
						}
					}
					
					if (type === 'error') {
						console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + 'Error encountered, stopping engine to prevent console spamming...');
						$ige.engine.stop();
						
						if (igeBase.igeConfig.debug._throwErrors) {
							throw(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
						} else {
							console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
						}
					} else {
						console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
					}
				}
				
				return this;
			},
			
			/**
			 * Returns the class id. Primarily used to help identify
			 * what class an instance was instantiated with and is also
			 * output during the $ige.engine.scenegraph() method's console logging
			 * to show what class an object belongs to.
			 * @example #Get the class id of an object
			 *     var entity = new IgeEntity();
			 *
			 *     // Will output "IgeEntity"
			 *     console.log(entity.classId());
			 */
			classId = function () {
				return this._classId;
			},
			
			/**
			 * Creates a new instance of the component argument passing
			 * the options argument to the component as it is initialised.
			 * The new component instance is then added to "this" via
			 * a property name that is defined in the component class as
			 * "componentId".
			 * @param {IgeClass} component The class definition of the component.
			 * @param {Object=} options An options parameter to pass to the component
			 * on init.
			 * @example #Add the velocity component to an entity
			 *     var entity = new IgeEntity();
			 *     entity.addComponent(IgeVelocityComponent);
			 *
			 *     // Now that the component is added, we can access
			 *     // the component via it's namespace. Call the
			 *     // "byAngleAndPower" method of the velocity component:
			 *     entity.velocity.byAngleAndPower(Math.radians(20), 0.1);
			 */
			addComponent = function (component, options) {
				var newComponent = new component(this, options);
				this[newComponent.componentId] = newComponent;
				
				// Add the component reference to the class component array
				this._components = this._components || [];
				this._components.push(newComponent);
				
				return this;
			},
			
			/**
			 * Removes a component by it's id.
			 * @param {String} componentId The id of the component to remove.
			 * @example #Remove a component by it's id (namespace)
			 *     var entity = new IgeEntity();
			 *
			 *     // Let's add the velocity component
			 *     entity.addComponent(IgeVelocityComponent);
			 *
			 *     // Now that the component is added, let's remove
			 *     // it via it's id ("velocity")
			 *     entity.removeComponent('velocity');
			 */
			removeComponent = function (componentId) {
				// If the component has a destroy method, call it
				if (this[componentId] && this[componentId].destroy) {
					this[componentId].destroy();
				}
				
				// Remove the component from the class component array
				if (this._components) {
					this._components.pull(this[componentId]);
				}
				
				// Remove the component namespace from the class object
				delete this[componentId];
				return this;
			},
			
			/**
			 * Copies all properties and methods from the classObj object
			 * to "this". If the overwrite flag is not set or set to false,
			 * only properties and methods that don't already exists in
			 * "this" will be copied. If overwrite is true, they will be
			 * copied regardless.
			 * @param {Function} classObj
			 * @param {Boolean} overwrite
			 * @example #Implement all the methods of an object into another object
			 *     // Create a couple of test entities with ids
			 *     var entity1 = new IgeEntity().id('entity1'),
			 *         entity2 = new IgeEntity().id('entity2');
			 *
			 *     // Let's define an object with a couple of methods
			 *     var obj = {
			 *         newMethod1: function () {
			 *             console.log('method1 called on object: ' + this.id());
			 *         },
			 *
			 *         newMethod2: function () {
			 *             console.log('method2 called on object: ' + this.id());
			 *         }
			 *     };
			 *
			 *     // Now let's implement the methods on our entities
			 *     entity1.implement(obj);
			 *     entity2.implement(obj);
			 *
			 *     // The entities now have the newMethod1 and newMethod2
			 *     // methods as part of their instance so we can call them:
			 *     entity1.newMethod1();
			 *
			 *     // The output to the console is:
			 *     //    method1 called on object: entity1
			 *
			 *     // Now let's call newMethod2 on entity2:
			 *     entity2.newMethod2();
			 *
			 *     // The output to the console is:
			 *     //    method2 called on object: entity2
			 *
			 *     // As you can see, this is a great way to add extra modular
			 *     // functionality to objects / entities at runtime.
			 */
			implement = function (classObj, overwrite) {
				var i, obj = classObj.prototype || classObj;
				
				// Copy the class object's properties to (this)
				for (i in obj) {
					// Only copy the property if this doesn't already have it
					if (obj.hasOwnProperty(i) && (overwrite || this[i] === undefined)) {
						this[i] = obj[i];
					}
				}
				return this;
			},
			
			/**
			 * Gets / sets a key / value pair in the object's data object. Useful for
			 * storing arbitrary game data in the object.
			 * @param {String} key The key under which the data resides.
			 * @param {*=} value The data to set under the specified key.
			 * @example #Set some arbitrary data key value pair
			 *     var entity = new IgeEntity();
			 *     entity.data('playerScore', 100);
			 *     entity.data('playerName', 'iRock');
			 * @example #Get the value of a data key
			 *     console.log(entity.data('playerScore'));
			 *     console.log(entity.data('playerName'));
			 * @return {*}
			 */
			data = function (key, value) {
				if (key !== undefined) {
					if (value !== undefined) {
						this._data = this._data || {};
						this._data[key] = value;
						
						return this;
					}
					
					if (this._data) {
						return this._data[key];
					} else {
						return null;
					}
				}
			};
		
		/**
		 * Create a new IgeClass that inherits from this class
		 * @name extend
		 * @example #Creating a new class by extending an existing one
		 *     var NewClass = IgeClass.extend({
		 *         // Init is your constructor
		 *         init: function () {
		 *             console.log('I\'m alive!');
		 *         }
		 *     });
		 *
		 * Further reading: [Extending Classes](http://www.isogenicengine.com/documentation/isogenic-game-engine/versions/1-1-0/manual/engine-fundamentals/classes/extending-classes/)
		 * @return {Function}
		 */
		IgeClass.extend = function () {
			var name,
				prototype,
				// Set prop to the last argument passed
				prop = arguments[arguments.length - 1],
				extensionArray = arguments[0],
				extensionItem,
				extensionOverwrite,
				extensionIndex,
				propertyIndex,
				propertyObject;
			
			// Check that the class has been assigned a classId and bug out if not
			if (!prop.classId) {
				console.log(prop);
				throw('Cannot create a new class without giving the class a classId property!');
			}
			
			// Check that the classId is not already in use
			if (igeBase.igeClassStore[prop.classId]) {
				// This classId has already been used, bug out
				throw('Cannot create class with classId "' + prop.classId + '" because a class with that ID has already been created!');
			}
			
			// Instantiate a base class (but only create the instance,
			// don't run the init constructor)
			initializing = true;
			prototype = new this();
			initializing = false;
			
			// Copy the properties over onto the new prototype
			for (name in prop) {
				if (prop.hasOwnProperty(name)) {
					// Copy the property
					prototype[name] = prop[name];
				}
			}
			
			// Now implement any other extensions
			if (arguments.length > 1) {
				if (extensionArray && extensionArray.length) {
					for (extensionIndex = 0; extensionIndex < extensionArray.length; extensionIndex++) {
						extensionItem = extensionArray[extensionIndex];
						propertyObject = extensionItem.extension.prototype || extensionItem.extension;
						extensionOverwrite = extensionItem.overwrite;
						
						// Copy the class object's properties to (this)
						for (propertyIndex in propertyObject) {
							// Only copy the property if this doesn't already have it or
							// the extension is set to overwrite any existing properties
							if (propertyObject.hasOwnProperty(propertyIndex) && (extensionOverwrite || prototype[propertyIndex] === undefined)) {
								prototype[propertyIndex] = propertyObject[propertyIndex];
							}
						}
					}
				}
			}
			
			//prototype._superClass = this.prototype;
			//console.log(prop.classId, 'extends', this.prototype._classId);
			
			// The dummy class constructor
			function IgeClass() {
				if (!initializing && this.init) {
					// Call the class init method
					this.init.apply(this, arguments);
				}
			}
			
			// Populate our constructed prototype object
			IgeClass.prototype = prototype;
			
			// Enforce the constructor to be what we expect
			IgeClass.prototype.constructor = IgeClass;
			
			// And make this class extensible
			IgeClass.extend = arguments.callee; // jshint ignore:line
			
			// Add log capability
			IgeClass.prototype.log = log;
			
			// Add data capability
			IgeClass.prototype.data = data;
			
			// Add class name capability
			IgeClass.prototype.classId = classId; // This is a method that returns _classId
			IgeClass.prototype._classId = prop.classId || 'IgeClass';
			
			// Add the addComponent method
			IgeClass.prototype.addComponent = addComponent;
			
			// Add the removeComponent method
			IgeClass.prototype.removeComponent = removeComponent;
			
			// Add the implement method
			IgeClass.prototype.implement = implement;
			
			// Add editor settings
			IgeClass.prototype.__igeEditor = prop.editorOptions;
			
			// Register the class with the class store
			igeBase.igeClassStore[prop.classId] = IgeClass;
			
			return IgeClass;
		};
		
		/**
		 * Test method
		 * @param prop
		 * @return {Function}
		 */
		IgeClass.vanilla = function (prop) {
			var IgeClass = prop.init || function () {},
				prototype = new this(),
				name;
			
			// Copy the properties over onto the new prototype
			for (name in prop) {
				if (prop.hasOwnProperty(name) && name !== 'init') {
					// Copy the property
					prototype[name] = prop[name];
				}
			}
			
			// Populate our constructed prototype object
			IgeClass.prototype = prototype;
			
			// Enforce the constructor to be what we expect
			IgeClass.prototype.constructor = IgeClass;
			
			// And make this class extensible
			IgeClass.extend = this.extend;
			
			// Add log capability
			IgeClass.prototype.log = log;
			
			// Add data capability
			IgeClass.prototype.data = data;
			
			// Add class name capability
			IgeClass.prototype.classId = classId; // This is a method that returns _classId
			IgeClass.prototype._classId = prop.classId || 'IgeClass';
			
			// Add the addComponent method
			IgeClass.prototype.addComponent = addComponent;
			
			// Add the removeComponent method
			IgeClass.prototype.removeComponent = removeComponent;
			
			// Add the implement method
			IgeClass.prototype.implement = implement;
			
			// Register the class with the class store
			igeBase.igeClassStore[prop.classId] = IgeClass;
			
			return IgeClass;
		};
		
		IgeClass.prototype._classId = 'IgeClass';
		
		return IgeClass;
	}());
	
	return IgeClass;
});
},{"irrelon-appcore":125}],55:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeCollisionMap2d', function (IgeEntity, IgeMap2d) {
	var IgeCollisionMap2d = IgeEntity.extend({
		classId: 'IgeCollisionMap2d',
		
		init: function (tileWidth, tileHeight) {
			IgeEntity.prototype.init.call(this);
			this.map = new IgeMap2d();
		},
		
		mapData: function (val) {
			if (val !== undefined) {
				this.map.mapData(val);
				return this;
			}
			
			return this.map.mapData();
		}
	});
	
	return IgeCollisionMap2d;
});
},{"irrelon-appcore":125}],56:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeDummyCanvas', function (IgeDummyContext) {
	var IgeDummyCanvas = function () {
			this.dummy = true;
			this.width = 0;
			this.height = 0;
		};
	
	IgeDummyCanvas.prototype.getContext = function () {
		return IgeDummyContext;
	};
	
	return IgeDummyCanvas;
});
},{"irrelon-appcore":125}],57:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeDummyContext', function () {
	var nullMethod = function () {},
		IgeDummyContext = {
			dummy: true,
			save: nullMethod,
			restore: nullMethod,
			translate: nullMethod,
			rotate: nullMethod,
			scale: nullMethod,
			drawImage: nullMethod,
			fillRect: nullMethod,
			strokeRect: nullMethod,
			stroke: nullMethod,
			fill: nullMethod,
			rect: nullMethod,
			moveTo: nullMethod,
			lineTo: nullMethod,
			arc: nullMethod,
			clearRect: nullMethod,
			beginPath: nullMethod,
			clip: nullMethod,
			transform: nullMethod,
			setTransform: nullMethod,
			fillText: nullMethod
		};
	
	return IgeDummyContext;
});
},{"irrelon-appcore":125}],58:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEngine', function (
	igeBase,
	$ige,
	$textures,
	$time,
	$requestAnimFrame,
	IgeEntity,
	IgeCocoonJsComponent,
	IgeInputComponent,
	IgeTweenComponent,
	IgeTimeComponent,
	IgeUiManagerComponent,
	IgePoint3d,
	IgeDummyContext,
	IgeArray) {
		/**
		 * The base engine class definition.
		 */
		var IgeEngine = IgeEntity.extend({
			classId: 'IgeEngine',
			
			init: function () {
				var self = this;
				
				$ige.engine = self;
				
				// Deal with some debug settings first
				if (igeBase.igeConfig.debug) {
					if (!igeBase.igeConfig.debug._enabled) {
						// Debug is not enabled so ensure that
						// timing debugs are disabled
						igeBase.igeConfig.debug._timing = false;
					}
				}
				
				this._alwaysInView = true;
				
				this._id = 'ige';
				
				// Expose appCore instance
				this.appCore = appCore;
				
				if ($ige.isClient) {
					window.ige = this;
				}
				
				// Output our header
				console.log('------------------------------------------------------------------------------');
				console.log('* Powered by the Isogenic Game Engine ' + igeBase.version() + '                  *');
				console.log('* (C)opyright ' + new Date().getFullYear() + ' Irrelon Software Limited                                  *');
				console.log('* http://www.isogenicengine.com                                              *');
				console.log('------------------------------------------------------------------------------');
				
				IgeEntity.prototype.init.call(this);
				
				// Check if we are running client-side
				if ($ige.isClient) {
					// Enable cocoonJS support because we are running client-side
					this.addComponent(IgeCocoonJsComponent);
				}
				
				// Set the initial id as the current time in milliseconds. This ensures that under successive
				// restarts of the engine, new ids will still always be created compared to earlier runs -
				// which is important when storing persistent data with ids etc
				this._idCounter = new Date().getTime();
				
				// Setup components
				this.addComponent(IgeInputComponent);
				this.addComponent(IgeTweenComponent);
				this.addComponent(IgeTimeComponent);
				
				if ($ige.isClient) {
					// Enable UI element (virtual DOM) support
					this.addComponent(IgeUiManagerComponent);
				}
				
				// Set some defaults
				this._renderModes = [
					'2d',
					'three'
				];
				
				this._requireScriptTotal = 0;
				this._requireScriptLoading = 0;
				this._loadingPreText = undefined; // The text to put in front of the loading percent on the loading progress screen
				this._enableUpdates = true;
				this._enableRenders = true;
				this._showSgTree = false;
				this._debugEvents = {}; // Holds debug event booleans for named events
				this._renderContext = '2d'; // The rendering context, default is 2d
				this._renderMode = this._renderModes[this._renderContext]; // Integer representation of the render context
				this._state = 0; // Currently stopped
				this._dependencyQueue = []; // Holds an array of functions that must all return true for the engine to start
				this._frameAlternator = false; // Is set to the boolean not of itself each frame
				this._viewportDepth = false;
				this._mousePos = new IgePoint3d(0, 0, 0);
				this._register = {
					'ige': this
				}; // Holds a reference to every item in the scenegraph by it's ID
				this._categoryRegister = {}; // Holds reference to every item with a category
				this._groupRegister = {}; // Holds reference to every item with a group
				this._postTick = []; // An array of methods that are called upon tick completion
				this._timeSpentInUpdate = {}; // An object holding time-spent-in-update (total time spent in this object's update method)
				this._timeSpentLastUpdate = {}; // An object holding time-spent-last-update (time spent in this object's update method last tick)
				this._timeSpentInTick = {}; // An object holding time-spent-in-tick (total time spent in this object's tick method)
				this._timeSpentLastTick = {}; // An object holding time-spent-last-tick (time spent in this object's tick method last tick)
				this._timeScale = 1; // The default time scaling factor to speed up or slow down engine time
				this._globalScale = new IgePoint3d(1, 1, 1);
				this._graphInstances = []; // Holds an array of instances of graph classes
				this._spawnQueue = []; // Holds an array of entities that are yet to be born
				this._minimumDrawRatio = 1; // Determines what the minimum acceptable pixel draw ratio is for the canvas
				
				// Set the context to a dummy context to start
				// with in case we are in "headless" mode and
				// a replacement context never gets assigned
				this._ctx = IgeDummyContext;
				this._headless = true;
				
				this.dependencyTimeout(30000); // Wait 30 seconds to load all dependencies then timeout
				
				// Add the textures loaded dependency
				this._dependencyQueue.push($textures.texturesLoaded.bind($textures));
				//this._dependencyQueue.push(this.canvasReady);
				
				// Start a timer to record every second of execution
				this._secondTimer = setInterval(this._secondTick.bind(self), 1000);
			},
			
			/**
			 * Returns an object from the engine's object register by
			 * the object's id. If the item passed is not a string id
			 * then the item is returned as is. If no item is passed
			 * the engine itself is returned.
			 * @param {String || Object} item The id of the item to return,
			 * or if an object, returns the object as-is.
			 */
			$: function (item) {
				if (typeof(item) === 'string') {
					return this._register[item];
				} else if (typeof(item) === 'object') {
					return item;
				}
				
				return this;
			},
			
			/**
			 * Returns an array of all objects that have been assigned
			 * the passed category name.
			 * @param {String} categoryName The name of the category to return
			 * all objects for.
			 */
			$$: function (categoryName) {
				return this._categoryRegister[categoryName] || new IgeArray();
			},
			
			/**
			 * Returns an array of all objects that have been assigned
			 * the passed group name.
			 * @param {String} groupName The name of the group to return
			 * all objects for.
			 */
			$$$: function (groupName) {
				return this._groupRegister[groupName] || new IgeArray();
			},
			
			/**
			 * Register an object with the engine object register. The
			 * register allows you to access an object by it's id with
			 * a call to $ige.engine.$(objectId).
			 * @param {Object} obj The object to register.
			 * @return {*}
			 */
			register: function (obj) {
				if (obj !== undefined) {
					if (!this._register[obj.id()]) {
						this._register[obj.id()] = obj;
						obj._registered = true;
						
						return this;
					} else {
						obj._registered = false;
						
						this.log('Cannot add object id "' + obj.id() + '" to scenegraph because there is already another object in the graph with the same ID!', 'error');
						return false;
					}
				}
				
				return this._register;
			},
			
			/**
			 * Un-register an object with the engine object register. The
			 * object will no longer be accessible via $ige.engine.$().
			 * @param {Object} obj The object to un-register.
			 * @return {*}
			 */
			unRegister: function (obj) {
				if (obj !== undefined) {
					// Check if the object is registered in the ID lookup
					if (this._register[obj.id()]) {
						delete this._register[obj.id()];
						obj._registered = false;
					}
				}
				
				return this;
			},
			
			/**
			 * Register an object with the engine category register. The
			 * register allows you to access an object by it's category with
			 * a call to $ige.engine.$$(categoryName).
			 * @param {Object} obj The object to register.
			 * @return {*}
			 */
			categoryRegister: function (obj) {
				if (obj !== undefined) {
					this._categoryRegister[obj._category] = this._categoryRegister[obj._category] || new IgeArray();
					this._categoryRegister[obj._category].push(obj);
					obj._categoryRegistered = true;
				}
				
				return this._register;
			},
			
			/**
			 * Un-register an object with the engine category register. The
			 * object will no longer be accessible via $ige.engine.$$().
			 * @param {Object} obj The object to un-register.
			 * @return {*}
			 */
			categoryUnRegister: function (obj) {
				if (obj !== undefined) {
					if (this._categoryRegister[obj._category]) {
						this._categoryRegister[obj._category].pull(obj);
						obj._categoryRegistered = false;
					}
				}
				
				return this;
			},
			
			/**
			 * Register an object with the engine group register. The
			 * register allows you to access an object by it's groups with
			 * a call to $ige.engine.$$$(groupName).
			 * @param {Object} obj The object to register.
			 * @param {String} groupName The name of the group to register
			 * the object in.
			 * @return {*}
			 */
			groupRegister: function (obj, groupName) {
				if (obj !== undefined) {
					this._groupRegister[groupName] = this._groupRegister[groupName] || new IgeArray();
					this._groupRegister[groupName].push(obj);
					obj._groupRegistered = true;
				}
				
				return this._register;
			},
			
			/**
			 * Un-register an object with the engine group register. The
			 * object will no longer be accessible via $ige.engine.$$$().
			 * @param {Object} obj The object to un-register.
			 * @param {String} groupName The name of the group to un-register
			 * the object from.
			 * @return {*}
			 */
			groupUnRegister: function (obj, groupName) {
				if (obj !== undefined) {
					if (groupName !== undefined) {
						if (this._groupRegister[groupName]) {
							this._groupRegister[groupName].pull(obj);
							
							if (!obj.groupCount()) {
								obj._groupRegister = false;
							}
						}
					} else {
						// Call the removeAllGroups() method which will loop
						// all the groups that the object belongs to and
						// automatically un-register them
						obj.removeAllGroups();
					}
				}
				
				return this;
			},
			
			sync: function (method, attrArr) {
				if (typeof(attrArr) === 'string') {
					attrArr = [attrArr];
				}
				
				this._syncArr = this._syncArr || [];
				this._syncArr.push({method: method, attrArr: attrArr});
				
				if (this._syncArr.length === 1) {
					// Start sync waterfall
					this._syncIndex = 0;
					this._processSync();
				}
			},
			
			_processSync: function () {
				var self = this,
					syncEntry;
				
				if (this._syncIndex < this._syncArr.length) {
					syncEntry = this._syncArr[this._syncIndex];
					
					// Add the callback to the last attribute
					syncEntry.attrArr.push(function () {
						self._syncIndex++;
						setTimeout(self._processSync.bind(self), 1);
					});
					
					// Call the method
					syncEntry.method.apply(self, syncEntry.attrArr);
				} else {
					// Reached end of sync cycle
					delete this._syncArr;
					delete this._syncIndex;
					
					this.emit('syncComplete');
				}
			},
			
			/**
			 * Load a js script file into memory via a path or url.
			 * @param {String} url The file's path or url.
			 * @param {Function=} callback Optional callback when script loads.
			 */
			requireScript: function (url, callback) {
				if (url !== undefined) {
					var self = this;
					
					// Add to the load counter
					self._requireScriptTotal++;
					self._requireScriptLoading++;
					
					// Create the script element
					var elem = document.createElement('script');
					elem.addEventListener('load', function () {
						self._requireScriptLoaded(this);
						
						if (callback) {
							setTimeout(function () { callback(); }, 100);
						}
					});
					
					// For compatibility with CocoonJS
					document.body.appendChild(elem);
					
					// Set the source to load the url
					elem.src = url;
					
					this.log('Loading script from: ' + url);
					this.emit('requireScriptLoading', url);
				}
			},
			
			/**
			 * Called when a js script has been loaded via the requireScript
			 * method.
			 * @param {Element} elem The script element added to the DOM.
			 * @private
			 */
			_requireScriptLoaded: function (elem) {
				this._requireScriptLoading--;
				
				this.emit('requireScriptLoaded', elem.src);
				
				if (this._requireScriptLoading === 0) {
					// All scripts have loaded, fire the engine event
					this.emit('allRequireScriptsLoaded');
				}
			},
			
			/**
			 * Load a css style file into memory via a path or url.
			 * @param {String} url The file's path or url.
			 */
			requireStylesheet: function (url) {
				if (url !== undefined) {
					
					// Load the engine stylesheet
					var css = document.createElement('link');
					css.rel = 'stylesheet';
					css.type = 'text/css';
					css.media = 'all';
					css.href = url;
					
					document.getElementsByTagName('head')[0].appendChild(css);
					
					this.log('Load css stylesheet from: ' + url);
				}
			},
			
			/**
			 * Adds a scenegraph class into memory.
			 * @param {String} className The name of the scenegraph class.
			 * @param {Object=} options Optional object to pass to the scenegraph class graph() method.
			 * @returns {*}
			 */
			addGraph: function (className, options) {
				if (className !== undefined) {
					var classObj = this.getClass(className),
						classInstance;
					
					if (classObj) {
						this.log('Loading SceneGraph data class: ' + className);
						classInstance = this.newClassInstance(className);
						
						// Make sure the graph class implements the required methods "addGraph" and "removeGraph"
						if (typeof(classInstance.addGraph) === 'function' && typeof(classInstance.removeGraph) === 'function') {
							// Call the class's graph() method passing the options in
							classInstance.addGraph(options);
							
							// Add the graph instance to the holding array
							this._graphInstances[className] = classInstance;
						} else {
							this.log('Could not load graph for class name "' + className + '" because the class does not implement both the require methods "addGraph()" and "removeGraph()".', 'error');
						}
					} else {
						this.log('Cannot load graph for class name "' + className + '" because the class could not be found. Have you included it in your server/clientConfig.js file?', 'error');
					}
				}
				
				return this;
			},
			
			/**
			 * Removes a scenegraph class into memory.
			 * @param {String} className The name of the scenegraph class.
			 * @param {Object=} options Optional object to pass to the scenegraph class graph() method.
			 * @returns {*}
			 */
			removeGraph: function (className, options) {
				if (className !== undefined) {
					var classInstance = this._graphInstances[className];
					
					if (classInstance) {
						this.log('Removing SceneGraph data class: ' + className);
						
						// Call the class's graph() method passing the options in
						classInstance.removeGraph(options);
						
						// Now remove the graph instance from the graph instance array
						delete this._graphInstances[className];
					} else {
						this.log('Cannot remove graph for class name "' + className + '" because the class instance could not be found. Did you add it via $ige.engine.addGraph() ?', 'error');
					}
				}
				
				return this;
			},
			
			/**
			 * Allows the update() methods of the entire scenegraph to
			 * be temporarily enabled or disabled. Useful for debugging.
			 * @param {Boolean=} val If false, will disable all update() calls.
			 * @returns {*}
			 */
			enableUpdates: function (val) {
				if (val !== undefined) {
					this._enableUpdates = val;
					return this;
				}
				
				return this._enableUpdates;
			},
			
			/**
			 * Allows the tick() methods of the entire scenegraph to
			 * be temporarily enabled or disabled. Useful for debugging.
			 * @param {Boolean=} val If false, will disable all tick() calls.
			 * @returns {*}
			 */
			enableRenders: function (val) {
				if (val !== undefined) {
					this._enableRenders = val;
					return this;
				}
				
				return this._enableRenders;
			},
			
			/**
			 * Enables or disables the engine's debug mode. Enabled by default.
			 * @param {Boolean=} val If true, will enable debug mode.
			 * @returns {*}
			 */
			debugEnabled: function (val) {
				if (val !== undefined) {
					if (igeBase.igeConfig.debug) {
						igeBase.igeConfig.debug._enabled = val;
					}
					return this;
				}
				
				return igeBase.igeConfig.debug._enabled;
			},
			
			/**
			 * Enables or disables the engine's debug timing system. The
			 * timing system will time all update and rendering code down
			 * the scenegraph and is useful for tracking long-running code
			 * but comes with a small performance penalty when enabled.
			 * Enabled by default.
			 * @param {Boolean=} val If true, will enable debug timing mode.
			 * @returns {*}
			 */
			debugTiming: function (val) {
				if (val !== undefined) {
					if (igeBase.igeConfig.debug) {
						igeBase.igeConfig.debug._timing = val;
					}
					return this;
				}
				
				return igeBase.igeConfig.debug._timing;
			},
			
			debug: function (eventName) {
				if (this._debugEvents[eventName] === true || this._debugEvents[eventName] === $time._frames) {
					debugger; // jshint ignore:line
				}
			},
			
			debugEventOn: function (eventName) {
				this._debugEvents[eventName] = true;
			},
			
			debugEventOff: function (eventName) {
				this._debugEvents[eventName] = false;
			},
			
			triggerDebugEventFrame: function (eventName) {
				this._debugEvents[eventName] = $time._frames;
			},
			
			/**
			 * Sets the opacity of every object on the scenegraph to
			 * zero *except* the one specified by the given id argument.
			 * @param {String} id The id of the object not to hide.
			 */
			hideAllExcept: function (id) {
				var i,
					arr = this._register;
				
				for (i in arr) {
					if (i !== id) {
						arr[i].opacity(0);
					}
				}
			},
			
			/**
			 * Calls the show() method for every object on the scenegraph.
			 */
			showAll: function () {
				var i,
					arr = this._register;
				
				for (i in arr) {
					if (arr.hasOwnProperty(i)) {
						arr[i].show();
					}
				}
			},
			
			/**
			 * Sets the frame rate at which new engine steps are fired.
			 * Setting this rate will override the default requestAnimFrame()
			 * method as defined in IgeBase.js and on the client-side, will
			 * stop usage of any available requestAnimationFrame() method
			 * and will use a setTimeout()-based version instead.
			 * @param {Number} fpsRate
			 */
			setFps: function (fpsRate) {
				if (fpsRate !== undefined) {
					// Override the default requestAnimFrame handler and set
					// our own method up so that we can control the frame rate
					if ($ige.isServer) {
						// Server-side implementation
						$requestAnimFrame = function(callback, element){
							setTimeout(function () { callback(new Date().getTime()); }, 1000 / fpsRate);
						};
					} else {
						// Client-side implementation
						window.$requestAnimFrame = function(callback, element){
							setTimeout(function () { callback(new Date().getTime()); }, 1000 / fpsRate);
						};
					}
				}
			},
			
			showStats: function () {
				this.log('showStats has been removed from the ige in favour of the new editor component, please remove this call from your code.');
			},
			
			/**
			 * Defines a class in the engine's class repository.
			 * @param {String} id The unique class ID or name.
			 * @param {Object} obj The class definition.
			 */
			defineClass: function (id, obj) {
				igeBase.igeClassStore[id] = obj;
			},
			
			/**
			 * Retrieves a class by it's ID that was defined with
			 * a call to defineClass().
			 * @param {String} id The ID of the class to retrieve.
			 * @return {Object} The class definition.
			 */
			getClass: function (id) {
				return igeBase.igeClassStore[id];
			},
			
			/**
			 * Returns true if the class specified has been defined.
			 * @param {String} id The ID of the class to check for.
			 * @returns {*}
			 */
			classDefined: function (id) {
				return Boolean(igeBase.igeClassStore[id]);
			},
			
			/**
			 * Generates a new instance of a class defined with a call
			 * to the defineClass() method. Passes the options
			 * parameter to the new class during it's constructor call.
			 * @param id
			 * @param options
			 * @return {*}
			 */
			newClassInstance: function (id, options) {
				return new igeBase.igeClassStore[id](options);
			},
			
			/**
			 * Checks if all engine start dependencies have been satisfied.
			 * @return {Boolean}
			 */
			dependencyCheck: function () {
				var arr = this._dependencyQueue,
					arrCount = arr.length;
				
				while (arrCount--) {
					if (!this._dependencyQueue[arrCount]()) {
						console.log(this._dependencyQueue[arrCount].toString());
						return false;
					}
				}
				
				return true;
			},
			
			/**
			 * Gets / sets the flag that determines if viewports should be sorted by depth
			 * like regular entities, before they are processed for rendering each frame.
			 * Depth-sorting viewports increases processing requirements so if you do not
			 * need to stack viewports in a particular order, keep this flag false.
			 * @param {Boolean} val
			 * @return {Boolean}
			 */
			viewportDepth: function (val) {
				if (val !== undefined) {
					this._viewportDepth = val;
					return this;
				}
				
				return this._viewportDepth;
			},
			
			/**
			 * Sets the number of milliseconds before the engine gives up waiting for dependencies
			 * to be satisfied and cancels the startup procedure.
			 * @param val
			 */
			dependencyTimeout: function (val) {
				this._dependencyCheckTimeout = val;
			},
			
			/**
			 * Updates the loading screen DOM elements to show the update progress.
			 */
			updateProgress: function () {
				// Check for a loading progress bar DOM element
				if (typeof(document) !== 'undefined' && document.getElementById) {
					var elem = document.getElementById('loadingProgressBar'),
						textElem = document.getElementById('loadingText');
					
					if (elem) {
						// Calculate the width from progress
						var totalWidth = parseInt(elem.parentNode.offsetWidth),
							currentWidth = Math.floor((totalWidth / $textures._texturesTotal) * ($textures._texturesTotal - $textures._texturesLoading));
						
						// Set the current bar width
						elem.style.width = currentWidth + 'px';
						
						if (textElem) {
							if (this._loadingPreText === undefined) {
								// Fill the text to use
								this._loadingPreText = textElem.innerHTML;
							}
							textElem.innerHTML = this._loadingPreText + ' ' + Math.floor((100 / $textures._texturesTotal) * ($textures._texturesTotal - $textures._texturesLoading)) + '%';
						}
					}
				}
			},
			
			/**
			 * Checks to ensure that a canvas has been assigned to the engine or that the
			 * engine is in server mode.
			 * @return {Boolean}
			 */
			canvasReady: function () {
				return (this._canvas !== undefined || $ige.isServer);
			},
			
			/**
			 * Generates a new unique ID
			 * @return {String}
			 */
			newId: function () {
				this._idCounter++;
				return String(this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17)));
			},
			
			/**
			 * Generates a new 16-character hexadecimal unique ID
			 * @return {String}
			 */
			newIdHex: function () {
				this._idCounter++;
				return (this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17))).toString(16);
			},
			
			/**
			 * Generates a new 16-character hexadecimal ID based on
			 * the passed string. Will always generate the same ID
			 * for the same string.
			 * @param {String} str A string to generate the ID from.
			 * @return {String}
			 */
			newIdFromString: function (str) {
				if (str !== undefined) {
					var id,
						val = 0,
						count = str.length,
						i;
					
					for (i = 0; i < count; i++) {
						val += str.charCodeAt(i) * Math.pow(10, 17);
					}
					
					id = (val).toString(16);
					
					// Check if the ID is already in use
					while (this.$(id)) {
						val += Math.pow(10, 17);
						id = (val).toString(16);
					}
					
					return id;
				}
			},
			
			/**
			 * Starts the engine.
			 * @param callback
			 */
			start: function (callback) {
				var self = this;
				
				if (!this._state) {
					// Check if we are able to start based upon any registered dependencies
					if (this.dependencyCheck()) {
						// Start the engine
						this.log('Starting engine...');
						this._state = 1;
						
						// Check if we have a DOM, that there is an igeLoading element
						// and if so, remove it from the DOM now
						if ($ige.isClient) {
							if (document.getElementsByClassName && document.getElementsByClassName('igeLoading')) {
								var arr = document.getElementsByClassName('igeLoading'),
									arrCount = arr.length;
								
								while (arrCount--) {
									arr[arrCount].parentNode.removeChild(arr[arrCount]);
								}
							}
						}
						
						$requestAnimFrame(this.engineStep.bind(this));
						
						this.log('Engine started');
						
						// Fire the callback method if there was one
						if (typeof(callback) === 'function') {
							callback(true);
						}
					} else {
						// Get the current timestamp
						var curTime = new Date().getTime();
						
						// Record when we first started checking for dependencies
						if (!this._dependencyCheckStart) {
							this._dependencyCheckStart = curTime;
						}
						
						// Check if we have timed out
						if (curTime - this._dependencyCheckStart > this._dependencyCheckTimeout) {
							this.log('Engine start failed because the dependency check timed out after ' + (this._dependencyCheckTimeout / 1000) + ' seconds', 'error');
							if (typeof(callback) === 'function') {
								callback(false);
							}
						} else {
							// Start a timer to keep checking dependencies
							setTimeout(function () { self.start(callback); }, 200);
						}
					}
				}
			},
			
			/**
			 * Stops the engine.
			 * @return {Boolean}
			 */
			stop: function () {
				// If we are running, stop the engine
				if (this._state) {
					this.log('Stopping engine...');
					this._state = 0;
					
					return true;
				} else {
					return false;
				}
			},
			
			/**
			 * Gets / sets the _autoSize property. If set to true, the engine will listen
			 * for any change in screen size and resize the front-buffer (canvas) element
			 * to match the new screen size.
			 * @param val
			 * @return {Boolean}
			 */
			autoSize: function (val) {
				if (val !== undefined) {
					this._autoSize = val;
					return this;
				}
				
				return this._autoSize;
			},
			
			/**
			 * Set to true if you want the canvas to automatically scale rendering for
			 * high definition screens (and screens with pixel ratios other than 1).
			 * @param {Boolean} val True or false. Defaults to true.
			 * @returns {*}
			 */
			pixelRatioScaling: function (val) {
				if (val !== undefined) {
					this._pixelRatioScaling = val;
					return this;
				}
				
				return this._pixelRatioScaling;
			},
			
			/**
			 * Sets the minimum draw ratio (pixels) that the canvas should accept.
			 * Defaults to 1 so that lower ratios don't look crap.
			 * @param {Number} val Your minimum ratio.
			 * @returns {*}
			 */
			minimumDrawRatio: function (val) {
				if (val !== undefined) {
					this._minimumDrawRatio = val;
					return this;
				}
				
				return this._minimumDrawRatio;
			},
			
			/**
			 * Gets / sets the rendering context that will be used when getting the
			 * context from canvas elements.
			 * @param {String=} contextId The context such as '2d'. Defaults to '2d'.
			 * @return {*}
			 */
			renderContext: function (contextId) {
				if (contextId !== undefined) {
					this._renderContext = contextId;
					this._renderMode = this._renderModes[contextId];
					
					this.log('Rendering mode set to: ' + contextId);
					
					return this;
				}
				
				return this._renderContext;
			},
			
			/**
			 * Creates a front-buffer or "drawing surface" for the renderer.
			 *
			 * @param {Boolean} autoSize Determines if the canvas will auto-resize
			 * when the browser window changes dimensions. If true the canvas will
			 * automatically fill the window when it is resized.
			 *
			 * @param {Boolean=} dontScale If set to true, IGE will ignore device
			 * pixel ratios when setting the width and height of the canvas and will
			 * therefore not take into account "retina", high-definition displays or
			 * those whose pixel ratio is different from 1 to 1.
			 */
			createFrontBuffer: function (autoSize, dontScale) {
				if ($ige.isClient) {
					if (!this._canvas) {
						this._createdFrontBuffer = true;
						
						if (this._pixelRatioScaling === undefined) {
							this._pixelRatioScaling = !dontScale;
						}
						
						this._frontBufferSetup(autoSize, dontScale);
					}
				}
			},
			
			_frontBufferSetup: function (autoSize, dontScale) {
				// Create a new canvas element to use as the
				// rendering front-buffer
				var tempCanvas = document.createElement('canvas');
				
				// Set the canvas element id
				tempCanvas.id = 'igeFrontBuffer';
				
				this.canvas(tempCanvas, autoSize);
				document.body.appendChild(tempCanvas);
			},
			
			/**
			 * Sets the canvas element that will be used as the front-buffer.
			 * @param elem The canvas element.
			 * @param autoSize If set to true, the engine will automatically size
			 * the canvas to the width and height of the window upon window resize.
			 */
			canvas: function (elem, autoSize) {
				if (elem !== undefined) {
					if (!this._canvas) {
						// Setup front-buffer canvas element
						this._canvas = elem;
						this._ctx = this._canvas.getContext(this._renderContext);
						
						// Handle pixel ratio settings
						if (this._pixelRatioScaling) {
							// Support high-definition devices and "retina" (stupid marketing name)
							// displays by adjusting for device and back store pixels ratios
							this._devicePixelRatio = window.devicePixelRatio || 1;
							this._backingStoreRatio = this._ctx.webkitBackingStorePixelRatio ||
								this._ctx.mozBackingStorePixelRatio ||
								this._ctx.msBackingStorePixelRatio ||
								this._ctx.oBackingStorePixelRatio ||
								this._ctx.backingStorePixelRatio || 1;
							
							this._deviceFinalDrawRatio = this._devicePixelRatio / this._backingStoreRatio;
							if (this._deviceFinalDrawRatio < this._minimumDrawRatio) {
								this._deviceFinalDrawRatio = this._minimumDrawRatio;
							}
						} else {
							// No auto-scaling
							this._devicePixelRatio = 1;
							this._backingStoreRatio = 1;
							this._deviceFinalDrawRatio = 1;
						}
						
						if (autoSize) {
							this._autoSize = autoSize;
						}
						
						// Add some event listeners even if autosize is off
						window.addEventListener('resize', this._resizeEvent.bind(this));
						
						// Fire the resize event for the first time
						// which sets up initial canvas dimensions
						this._resizeEvent();
						this._ctx = this._canvas.getContext(this._renderContext);
						this._headless = false;
						
						// Ask the input component to setup any listeners it has
						this.input.setupListeners(this._canvas);
					}
				}
				
				return this._canvas;
			},
			
			/**
			 * Clears the entire canvas.
			 */
			clearCanvas: function () {
				if (this._ctx) {
					// Clear the whole canvas
					this._ctx.clearRect(
						0,
						0,
						this._canvas.width,
						this._canvas.height
					);
				}
			},
			
			/**
			 * Removes the engine's canvas from the DOM.
			 */
			removeCanvas: function () {
				// Stop listening for input events
				if (this.input) {
					this.input.destroyListeners();
				}
				
				// Remove event listener
				window.removeEventListener('resize', this._resizeEvent);
				
				if (this._createdFrontBuffer) {
					// Remove the canvas from the DOM
					document.body.removeChild(this._canvas);
				}
				
				// Clear internal references
				delete this._canvas;
				delete this._ctx;
				this._ctx = IgeDummyContext;
				this._headless = true;
			},
			
			/**
			 * Opens a new window to the specified url. When running in a
			 * native wrapper, will load the url in place of any existing
			 * page being displayed in the native web view.
			 * @param url
			 */
			openUrl: function (url) {
				if (url !== undefined) {
					
					if (this.cocoonJs && this.cocoonJs.detected) {
						// Open URL via CocoonJS webview
						this.cocoonJs.openUrl(url);
					} else {
						// Open via standard JS open window
						window.open(url);
					}
				}
			},
			
			/**
			 * Loads the specified URL as an HTML overlay on top of the
			 * front buffer in an iFrame. If running in a native wrapper,
			 * will load the url in place of any existing page being
			 * displayed in the native web view.
			 *
			 * When the overlay is in use, no mouse or touch events will
			 * be fired on the front buffer. Once you are finished with the
			 * overlay, call hideOverlay() to re-enable interaction with
			 * the front buffer.
			 * @param {String=} url
			 */
			showWebView: function (url) {
				if (this.cocoonJs && this.cocoonJs.detected) {
					// Open URL via CocoonJS webview
					this.cocoonJs.showWebView(url);
				} else {
					// Load the iFrame url
					var overlay = document.getElementById('igeOverlay');
					
					if (!overlay) {
						// No overlay was found, create one
						overlay = document.createElement('iframe');
						
						// Setup overlay styles
						overlay.id = 'igeOverlay';
						overlay.style.position = 'absolute';
						overlay.style.border = 'none';
						overlay.style.left = '0px';
						overlay.style.top = '0px';
						overlay.style.width = '100%';
						overlay.style.height = '100%';
						
						// Append overlay to body
						document.body.appendChild(overlay);
					}
					
					// If we have a url, set it now
					if (url !== undefined) {
						overlay.src = url;
					}
					
					// Show the overlay
					overlay.style.display = 'block';
				}
				
				return this;
			},
			
			/**
			 * Hides the web view overlay.
			 * @return {*}
			 */
			hideWebView: function () {
				if (this.cocoonJs && this.cocoonJs.detected) {
					// Hide the cocoonJS webview
					this.cocoonJs.hideWebView();
				} else {
					var overlay = document.getElementById('igeOverlay');
					if (overlay) {
						overlay.style.display = 'none';
					}
				}
				
				return this;
			},
			
			/**
			 * Evaluates javascript sent from another frame, usually used
			 * when operating with a wrapper system like cocoonjs.
			 * @param js
			 */
			layerCall: function (js) {
				if (js !== undefined) {
					eval(js); // jshint ignore:line
				}
			},
			
			/**
			 * Returns the mouse position relative to the main front buffer. Mouse
			 * position is set by the $ige.engine.input component (IgeInputComponent)
			 * @return {IgePoint3d}
			 */
			mousePos: function () {
				return $ige._mousePos.clone();
			},
			
			/**
			 * Walks the scenegraph and returns an array of all entities that the mouse
			 * is currently over, ordered by their draw order from drawn last (above other
			 * entities) to first (underneath other entities).
			 */
			mouseOverList: function (obj, entArr) {
				var arr,
					arrCount,
					mp,
					mouseTriggerPoly,
					first = false;
				
				if (!obj) {
					obj = this;
					entArr = [];
					first = true;
				}
				
				if (obj === this) {
					// Loop viewports
					arr = obj._children;
					
					if (arr) {
						arrCount = arr.length;
						
						// Loop our children
						while (arrCount--) {
							if (arr[arrCount]._scene) {
								if (arr[arrCount]._scene._shouldRender) {
									this.mouseOverList(arr[arrCount]._scene, entArr);
								}
							}
						}
					}
				} else {
					// Check if the mouse is over this entity
					mp = this.mousePosWorld();
					
					if (mp && obj.aabb) {
						// Trigger mode is against the AABB
						mouseTriggerPoly = obj.aabb(); //this.localAabb();
						
						// Check if the current mouse position is inside this aabb
						if (mouseTriggerPoly.xyInside(mp.x, mp.y)) {
							entArr.push(obj);
						}
					}
					
					// Check if the entity has children
					arr = obj._children;
					
					if (arr) {
						arrCount = arr.length;
						
						// Loop our children
						while (arrCount--) {
							this.mouseOverList(arr[arrCount], entArr);
						}
					}
				}
				
				if (first) {
					entArr.reverse();
				}
				
				return entArr;
			},
			
			/**
			 * Handles the screen resize event.
			 * @param event
			 * @private
			 */
			_resizeEvent: function (event) {
				var canvasBoundingRect;
				
				if (this._autoSize) {
					var newWidth = window.innerWidth,
						newHeight = window.innerHeight,
						arr = this._children,
						arrCount = arr.length;
					
					// Only update canvas dimensions if it exists
					if (this._canvas) {
						// Check if we can get the position of the canvas
						canvasBoundingRect = this._canvasPosition();
						
						// Adjust the newWidth and newHeight by the canvas offset
						newWidth -= parseInt(canvasBoundingRect.left);
						newHeight -= parseInt(canvasBoundingRect.top);
						
						// Make sure we can divide the new width and height by 2...
						// otherwise minus 1 so we get an even number so that we
						// negate the blur effect of sub-pixel rendering
						if (newWidth % 2) { newWidth--; }
						if (newHeight % 2) { newHeight--; }
						
						this._canvas.width = newWidth * this._deviceFinalDrawRatio;
						this._canvas.height = newHeight * this._deviceFinalDrawRatio;
						
						if (this._deviceFinalDrawRatio !== 1) {
							this._canvas.style.width = newWidth + 'px';
							this._canvas.style.height = newHeight + 'px';
							
							// Scale the canvas context to account for the change
							this._ctx.scale(this._deviceFinalDrawRatio, this._deviceFinalDrawRatio);
						}
					}
					
					this._bounds2d = new IgePoint3d(newWidth, newHeight, 0);
					
					// Loop any mounted children and check if
					// they should also get resized
					while (arrCount--) {
						arr[arrCount]._resizeEvent(event);
					}
				} else {
					if (this._canvas) {
						this._bounds2d = new IgePoint3d(this._canvas.width, this._canvas.height, 0);
					}
				}
				
				if (this._showSgTree) {
					var sgTreeElem = document.getElementById('igeSgTree');
					
					canvasBoundingRect = this._canvasPosition();
					
					sgTreeElem.style.top = (parseInt(canvasBoundingRect.top) + 5) + 'px';
					sgTreeElem.style.left = (parseInt(canvasBoundingRect.left) + 5) + 'px';
					sgTreeElem.style.height = (this._bounds2d.y - 30) + 'px';
				}
				
				this._resized = true;
			},
			
			/**
			 * Gets the bounding rectangle for the HTML canvas element being
			 * used as the front buffer for the engine. Uses DOM methods.
			 * @returns {ClientRect}
			 * @private
			 */
			_canvasPosition: function () {
				try {
					return this._canvas.getBoundingClientRect();
				} catch (e) {
					return {
						top: this._canvas.offsetTop,
						left: this._canvas.offsetLeft
					};
				}
			},
			
			/**
			 * Toggles full-screen output of the main ige canvas. Only works
			 * if called from within a user-generated HTML event listener.
			 */
			toggleFullScreen: function () {
				var elem = this._canvas;
				
				if (elem.requestFullscreen) {
					elem.requestFullscreen();
				} else if (elem.mozRequestFullScreen) {
					elem.mozRequestFullScreen();
				} else if (elem.webkitRequestFullscreen) {
					elem.webkitRequestFullscreen();
				}
			},
			
			/**
			 * Adds a new watch expression to the watch list which will be
			 * displayed in the stats overlay during a call to _statsTick().
			 * @param {*} evalStringOrObject The expression to evaluate and
			 * display the result of in the stats overlay, or an object that
			 * contains a "value" property.
			 * @returns {Integer} The index of the new watch expression you
			 * just added to the watch array.
			 */
			watchStart: function (evalStringOrObject) {
				this._watch = this._watch || [];
				this._watch.push(evalStringOrObject);
				
				return this._watch.length - 1;
			},
			
			/**
			 * Removes a watch expression by it's array index.
			 * @param {Number} index The index of the watch expression to
			 * remove from the watch array.
			 */
			watchStop: function (index) {
				this._watch = this._watch || [];
				this._watch.splice(index, 1);
			},
			
			/**
			 * Sets a trace up on the setter of the passed object's
			 * specified property. When the property is set by any
			 * code the debugger line is activated and code execution
			 * will be paused allowing you to step through code or
			 * examine the call stack to see where the property set
			 * originated.
			 * @param {Object} obj The object whose property you want
			 * to trace.
			 * @param {String} propName The name of the property you
			 * want to put the trace on.
			 * @param {Number} sampleCount The number of times you
			 * want the trace to break with the debugger line before
			 * automatically switching off the trace.
			 * @param {Function=} callbackEvaluator Optional callback
			 * that if returns true, will fire debugger. Method is passed
			 * the setter value as first argument.
			 */
			traceSet: function (obj, propName, sampleCount, callbackEvaluator) {
				var self = this;
				
				obj.___igeTraceCurrentVal = obj.___igeTraceCurrentVal || {};
				obj.___igeTraceCurrentVal[propName] = obj[propName];
				obj.___igeTraceMax = sampleCount || 1;
				obj.___igeTraceCount = 0;
				
				Object.defineProperty(obj, propName, {
					get: function () {
						return obj.___igeTraceCurrentVal[propName];
					},
					set: function (val) {
						if (callbackEvaluator){
							if (callbackEvaluator(val)) {
								debugger; // jshint ignore:line
							}
						} else {
							debugger; // jshint ignore:line
						}
						
						obj.___igeTraceCurrentVal[propName] = val;
						obj.___igeTraceCount++;
						
						if (obj.___igeTraceCount === obj.___igeTraceMax) {
							// Maximum amount of trace samples reached, turn off
							// the trace system
							self.traceSetOff(obj, propName);
						}
					}
				});
			},
			
			/**
			 * Turns off a trace that was created by calling traceSet.
			 * @param {Object} object The object whose property you want
			 * to disable a trace against.
			 * @param {String} propName The name of the property you
			 * want to disable the trace for.
			 */
			traceSetOff: function (object, propName) {
				Object.defineProperty(object, propName, {set: function (val) { this.___igeTraceCurrentVal[propName] = val; }});
			},
			
			/**
			 * Finds the first Ige* based class that the passed object
			 * has been derived from.
			 * @param obj
			 * @return {*}
			 */
			findBaseClass: function (obj) {
				if (obj && obj._classId) {
					if (obj._classId.substr(0, 3) === 'Ige') {
						return obj._classId;
					} else {
						if (Object.getPrototypeOf(obj)._classId) {
							return this.findBaseClass(Object.getPrototypeOf(obj));
						} else {
							return '';
						}
					}
				} else {
					return '';
				}
			},
			
			/**
			 * Returns an array of all classes the passed object derives from
			 * in order from current to base.
			 * @param obj
			 * @param arr
			 * @return {*}
			 */
			getClassDerivedList: function (obj, arr) {
				if (!arr) {
					arr = [];
				} else {
					if (obj._classId) {
						arr.push(obj._classId);
					}
				}
				
				if (Object.getPrototypeOf(obj)._classId) {
					this.getClassDerivedList(Object.getPrototypeOf(obj), arr);
				}
				
				return arr;
			},
			
			spawnQueue: function (ent) {
				if (ent !== undefined) {
					this._spawnQueue.push(ent);
					return this;
				}
				
				return this._spawnQueue;
			},
			
			/**
			 * Is called every second and does things like calculate the current FPS.
			 * @private
			 */
			_secondTick: function () {
				// Store frames per second
				$time._fps = $time._frames;
				
				// Store draws per second
				$time._dps = $time._dpf * $time._fps;
				
				// Zero out counters
				$time._frames = 0;
				$time._drawCount = 0;
			},
			
			/**
			 * Gets / sets the current time scalar value. The engine's internal
			 * time is multiplied by this value and it's default is 1. You can set it to
			 * 0.5 to slow down time by half or 1.5 to speed up time by half. Negative
			 * values will reverse time but not all engine systems handle this well
			 * at the moment.
			 * @param {Number=} val The time scale value.
			 * @returns {*}
			 */
			timeScale: function (val) {
				if (val !== undefined) {
					this._timeScale = val;
					return this;
				}
				
				return this._timeScale;
			},
			
			/**
			 * Increments the engine's interal time by the passed number of milliseconds.
			 * @param {Number} val The number of milliseconds to increment time by.
			 * @param {Number=} lastVal The last internal time value, used to calculate
			 * delta internally in the method.
			 * @returns {Number}
			 */
			incrementTime: function (val, lastVal) {
				if (!this._pause) {
					if (!lastVal) { lastVal = val; }
					$time._currentTime += ((val - lastVal) * this._timeScale);
				}
				return $time._currentTime;
			},
			
			/**
			 * Get the current time from the engine.
			 * @return {Number} The current time.
			 */
			currentTime: function () {
				return $time._currentTime;
			},
			
			/**
			 * Gets / sets the pause flag. If set to true then the engine's
			 * internal time will no longer increment and will instead stay static.
			 * @param val
			 * @returns {*}
			 */
			pause: function (val) {
				if (val !== undefined) {
					this._pause = val;
					return this;
				}
				
				return this._pause;
			},
			
			/**
			 * Gets / sets the option to determine if the engine should
			 * schedule it's own ticks or if you want to manually advance
			 * the engine by calling tick when you wish to.
			 * @param {Boolean=} val
			 * @return {*}
			 */
			useManualTicks: function (val) {
				if (val !== undefined) {
					this._useManualTicks = val;
					return this;
				}
				
				return this._useManualTicks;
			},
			
			/**
			 * Schedules a manual tick.
			 */
			manualTick: function () {
				if (this._manualFrameAlternator !== this._frameAlternator) {
					this._manualFrameAlternator = this._frameAlternator;
					$requestAnimFrame(this.engineStep.bind(this));
				}
			},
			
			/**
			 * Gets / sets the option to determine if the engine should
			 * render on every tick or wait for a manualRender() call.
			 * @param {Boolean=} val True to enable manual rendering, false
			 * to disable.
			 * @return {*}
			 */
			useManualRender: function (val) {
				if (val !== undefined) {
					this._useManualRender = val;
					return this;
				}
				
				return this._useManualRender;
			},
			
			/**
			 * Manually render a frame on demand. This is used in conjunction
			 * with the $ige.engine.useManualRender(true) call which will cause the
			 * engine to only render new graphics frames from the scenegraph
			 * once this method is called. You must call this method every time
			 * you wish to update the graphical output on screen.
			 *
			 * Calling this method multiple times during a single engine tick
			 * will NOT make it draw more than one frame, therefore it is safe
			 * to call multiple times if required by different sections of game
			 * logic without incurring extra rendering cost.
			 */
			manualRender: function () {
				this._manualRender = true;
			},
			
			/**
			 * Called each frame to traverse and render the scenegraph.
			 */
			engineStep: function (timeStamp, ctx) {
				/* TODO:
				 Make the scenegraph process simplified. Walk the scenegraph once and grab the order in a flat array
				 then process updates and ticks. This will also allow a layered rendering system that can render the
				 first x number of entities then stop, allowing a step through of the renderer in realtime.
				 */
				var self = this,
					st,
					et,
					updateStart,
					renderStart,
					ptArr = self._postTick,
					ptCount = ptArr.length,
					ptIndex,
					unbornQueue,
					unbornCount,
					unbornIndex,
					unbornEntity;
				
				// Scale the timestamp according to the current
				// engine's time scaling factor
				self.incrementTime(timeStamp, self._timeScaleLastTimestamp);
				
				self._timeScaleLastTimestamp = timeStamp;
				timeStamp = Math.floor($time._currentTime);
				
				if (igeBase.igeConfig.debug._timing) {
					st = new Date().getTime();
				}
				
				if (self._state) {
					// Check if we were passed a context to work with
					if (ctx === undefined) {
						ctx = self._ctx;
					}
					
					// Alternate the boolean frame alternator flag
					self._frameAlternator = !self._frameAlternator;
					
					// If the engine is not in manual tick mode...
					if (!self._useManualTicks) {
						// Schedule a new frame
						$requestAnimFrame(self.engineStep.bind(self));
					} else {
						self._manualFrameAlternator = !self._frameAlternator;
					}
					
					// Get the current time in milliseconds
					$time._tickStart = timeStamp;
					
					// Adjust the tickStart value by the difference between
					// the server and the client clocks (this is only applied
					// when running as the client - the server always has a
					// clientNetDiff of zero)
					$time._tickStart -= $time._clientNetDiff;
					
					if (!$time._lastTick) {
						// This is the first time we've run so set some
						// default values and set the delta to zero
						$time._lastTick = 0;
						$time._tickDelta = 0;
					} else {
						// Calculate the frame delta
						$time._tickDelta = $time._tickStart - $time._lastTick;
					}
					
					// Check for unborn entities that should be born now
					unbornQueue = self._spawnQueue;
					unbornCount = unbornQueue.length;
					for (unbornIndex = unbornCount - 1; unbornIndex >= 0; unbornIndex--) {
						unbornEntity = unbornQueue[unbornIndex];
						
						if ($time._currentTime >= unbornEntity._bornTime) {
							// Now birth this entity
							unbornEntity.mount(self.$(unbornEntity._birthMount));
							unbornQueue.splice(unbornIndex, 1);
						}
					}
					
					// Update the scenegraph
					if (self._enableUpdates) {
						if (igeBase.igeConfig.debug._timing) {
							updateStart = new Date().getTime();
							self.updateSceneGraph(ctx);
							$time._updateTime = new Date().getTime() - updateStart;
						} else {
							self.updateSceneGraph(ctx);
						}
					}
					
					// Render the scenegraph
					if (self._enableRenders) {
						if (!self._useManualRender) {
							if (igeBase.igeConfig.debug._timing) {
								renderStart = new Date().getTime();
								self.renderSceneGraph(ctx);
								$time._renderTime = new Date().getTime() - renderStart;
							} else {
								self.renderSceneGraph(ctx);
							}
						} else {
							if (self._manualRender) {
								if (igeBase.igeConfig.debug._timing) {
									renderStart = new Date().getTime();
									self.renderSceneGraph(ctx);
									$time._renderTime = new Date().getTime() - renderStart;
								} else {
									self.renderSceneGraph(ctx);
								}
								self._manualRender = false;
							}
						}
					}
					
					// Call post-tick methods
					for (ptIndex = 0; ptIndex < ptCount; ptIndex++) {
						ptArr[ptIndex]();
					}
					
					// Record the lastTick value so we can
					// calculate delta on the next tick
					$time._lastTick = $time._tickStart;
					$time._frames++;
					$time._dpf = $time._drawCount;
					$time._drawCount = 0;
					
					// Call the input system tick to reset any flags etc
					self.input.tick();
				}
				
				self._resized = false;
				
				if (igeBase.igeConfig.debug._timing) {
					et = new Date().getTime();
					$time._tickTime = et - st;
				}
			},
			
			updateSceneGraph: function (ctx) {
				var arr = this._children,
					arrCount, us, ud,
					tickDelta = $time._tickDelta;
				
				// Process any behaviours assigned to the engine
				this._processUpdateBehaviours(ctx, tickDelta);
				
				if (arr) {
					arrCount = arr.length;
					
					// Loop our viewports and call their update methods
					if (igeBase.igeConfig.debug._timing) {
						while (arrCount--) {
							us = new Date().getTime();
							arr[arrCount].update(ctx, tickDelta);
							ud = new Date().getTime() - us;
							
							if (arr[arrCount]) {
								if (!this._timeSpentInUpdate[arr[arrCount].id()]) {
									this._timeSpentInUpdate[arr[arrCount].id()] = 0;
								}
								
								if (!this._timeSpentLastUpdate[arr[arrCount].id()]) {
									this._timeSpentLastUpdate[arr[arrCount].id()] = {};
								}
								
								this._timeSpentInUpdate[arr[arrCount].id()] += ud;
								this._timeSpentLastUpdate[arr[arrCount].id()].ms = ud;
							}
						}
					} else {
						while (arrCount--) {
							arr[arrCount].update(ctx, tickDelta);
						}
					}
				}
			},
			
			renderSceneGraph: function (ctx) {
				var ts, td;
				
				// Process any behaviours assigned to the engine
				this._processTickBehaviours(ctx);
				
				// Depth-sort the viewports
				if (this._viewportDepth) {
					if (igeBase.igeConfig.debug._timing) {
						ts = new Date().getTime();
						this.depthSortChildren();
						td = new Date().getTime() - ts;
						
						if (!this._timeSpentLastTick[this.id()]) {
							this._timeSpentLastTick[this.id()] = {};
						}
						
						this._timeSpentLastTick[this.id()].depthSortChildren = td;
					} else {
						this.depthSortChildren();
					}
				}
				
				ctx.save();
				ctx.translate(this._bounds2d.x2, this._bounds2d.y2);
				//ctx.scale(this._globalScale.x, this._globalScale.y);
				
				// Process the current engine tick for all child objects
				var arr = this._children,
					arrCount;
				
				if (arr) {
					arrCount = arr.length;
					
					// Loop our viewports and call their tick methods
					if (igeBase.igeConfig.debug._timing) {
						while (arrCount--) {
							ctx.save();
							ts = new Date().getTime();
							arr[arrCount].tick(ctx);
							td = new Date().getTime() - ts;
							if (arr[arrCount]) {
								if (!this._timeSpentInTick[arr[arrCount].id()]) {
									this._timeSpentInTick[arr[arrCount].id()] = 0;
								}
								
								if (!this._timeSpentLastTick[arr[arrCount].id()]) {
									this._timeSpentLastTick[arr[arrCount].id()] = {};
								}
								
								this._timeSpentInTick[arr[arrCount].id()] += td;
								this._timeSpentLastTick[arr[arrCount].id()].ms = td;
							}
							ctx.restore();
						}
					} else {
						while (arrCount--) {
							ctx.save();
							arr[arrCount].tick(ctx);
							ctx.restore();
						}
					}
				}
				
				ctx.restore();
			},
			
			fps: function () {
				return $time._fps;
			},
			
			dpf: function () {
				return $time._dpf;
			},
			
			dps: function () {
				return $time._dps;
			},
			
			analyseTiming: function () {
				if (!igeBase.igeConfig.debug._timing) {
					this.log('Cannot analyse timing because the igeBase.igeConfig.debug._timing flag is not enabled so no timing data has been recorded!', 'warning');
				}
			},
			
			saveSceneGraph: function (item) {
				var arr, arrCount, i;
				
				if (!item) {
					item = this.getSceneGraphData();
				}
				
				if (item.obj.stringify) {
					item.str = item.obj.stringify();
				} else {
					console.log('Class ' + item.classId + ' has no stringify() method! For object: ' + item.id, item.obj);
				}
				arr = item.items;
				
				if (arr) {
					arrCount = arr.length;
					
					for (i = 0; i < arrCount; i++) {
						this.saveSceneGraph(arr[i]);
					}
				}
				
				return item;
			},
			
			/**
			 * Walks the scene graph and outputs a console map of the graph.
			 */
			sceneGraph: function (obj, currentDepth, lastDepth) {
				var depthSpace = '',
					di,
					timingString,
					arr,
					arrCount;
				
				if (currentDepth === undefined) { currentDepth = 0; }
				
				if (!obj) {
					// Set the obj to the main ige instance
					obj = this;
				}
				
				for (di = 0; di < currentDepth; di++) {
					depthSpace += '----';
				}
				
				if (igeBase.igeConfig.debug._timing) {
					timingString = '';
					
					timingString += 'T: ' + this._timeSpentInTick[obj.id()];
					if (this._timeSpentLastTick[obj.id()]) {
						if (typeof(this._timeSpentLastTick[obj.id()].ms) === 'number') {
							timingString += ' | LastTick: ' + this._timeSpentLastTick[obj.id()].ms;
						}
						
						if (typeof(this._timeSpentLastTick[obj.id()].depthSortChildren) === 'number') {
							timingString += ' | ChildDepthSort: ' + this._timeSpentLastTick[obj.id()].depthSortChildren;
						}
					}
					
					console.log(depthSpace + obj.id() + ' (' + obj._classId + ') : ' + obj._inView + ' Timing(' + timingString + ')');
				} else {
					console.log(depthSpace + obj.id() + ' (' + obj._classId + ') : ' + obj._inView);
				}
				
				currentDepth++;
				
				if (obj === this) {
					// Loop the viewports
					arr = obj._children;
					
					if (arr) {
						arrCount = arr.length;
						
						// Loop our children
						while (arrCount--) {
							if (arr[arrCount]._scene) {
								if (arr[arrCount]._scene._shouldRender) {
									if (igeBase.igeConfig.debug._timing) {
										timingString = '';
										
										timingString += 'T: ' + this._timeSpentInTick[arr[arrCount].id()];
										if (this._timeSpentLastTick[arr[arrCount].id()]) {
											if (typeof(this._timeSpentLastTick[arr[arrCount].id()].ms) === 'number') {
												timingString += ' | LastTick: ' + this._timeSpentLastTick[arr[arrCount].id()].ms;
											}
											
											if (typeof(this._timeSpentLastTick[arr[arrCount].id()].depthSortChildren) === 'number') {
												timingString += ' | ChildDepthSort: ' + this._timeSpentLastTick[arr[arrCount].id()].depthSortChildren;
											}
										}
										
										console.log(depthSpace + '----' + arr[arrCount].id() + ' (' + arr[arrCount]._classId + ') : ' + arr[arrCount]._inView + ' Timing(' + timingString + ')');
									} else {
										console.log(depthSpace + '----' + arr[arrCount].id() + ' (' + arr[arrCount]._classId + ') : ' + arr[arrCount]._inView);
									}
									this.sceneGraph(arr[arrCount]._scene, currentDepth + 1);
								}
							}
						}
					}
				} else {
					arr = obj._children;
					
					if (arr) {
						arrCount = arr.length;
						
						// Loop our children
						while (arrCount--) {
							this.sceneGraph(arr[arrCount], currentDepth);
						}
					}
				}
			},
			
			/**
			 * Walks the scenegraph and returns a data object of the graph.
			 */
			getSceneGraphData: function (obj, noRef) {
				var item, items = [], tempItem, tempItem2, tempCam,
					arr, arrCount;
				
				if (!obj) {
					// Set the obj to the main ige instance
					obj = this;
				}
				
				item = {
					text: '[' + obj._classId + '] ' + obj.id(),
					id: obj.id(),
					classId: obj.classId()
				};
				
				if (!noRef) {
					item.parent = obj._parent;
					item.obj = obj;
				} else {
					if (obj._parent) {
						item.parentId = obj._parent.id();
					} else {
						item.parentId = 'sceneGraph';
					}
				}
				
				if (obj === this) {
					// Loop the viewports
					arr = obj._children;
					
					if (arr) {
						arrCount = arr.length;
						
						// Loop our children
						while (arrCount--) {
							tempItem = {
								text: '[' + arr[arrCount]._classId + '] ' + arr[arrCount].id(),
								id: arr[arrCount].id(),
								classId: arr[arrCount].classId()
							};
							
							if (!noRef) {
								tempItem.parent = arr[arrCount]._parent;
								tempItem.obj = arr[arrCount];
							} else {
								if (arr[arrCount]._parent) {
									tempItem.parentId = arr[arrCount]._parent.id();
								}
							}
							
							if (arr[arrCount].camera) {
								// Add the viewport camera as an object on the scenegraph
								tempCam = {
									text: '[IgeCamera] ' + arr[arrCount].id(),
									id: arr[arrCount].camera.id(),
									classId: arr[arrCount].camera.classId()
								};
								
								if (!noRef) {
									tempCam.parent = arr[arrCount];
									tempCam.obj = arr[arrCount].camera;
								} else {
									tempCam.parentId = arr[arrCount].id();
								}
								
								if (arr[arrCount]._scene) {
									tempItem2 = this.getSceneGraphData(arr[arrCount]._scene, noRef);
									tempItem.items = [tempCam, tempItem2];
								}
							} else {
								if (arr[arrCount]._scene) {
									tempItem2 = this.getSceneGraphData(arr[arrCount]._scene, noRef);
									tempItem.items = [tempItem2];
								}
							}
							
							items.push(tempItem);
						}
					}
				} else {
					arr = obj._children;
					
					if (arr) {
						arrCount = arr.length;
						
						// Loop our children
						while (arrCount--) {
							tempItem = this.getSceneGraphData(arr[arrCount], noRef);
							items.push(tempItem);
						}
					}
				}
				
				if (items.length > 0) {
					item.items = items;
				}
				
				return item;
			},
			
			/**
			 * Called in IgeObject when a child is mounted to the engine
			 * instance. Checks if the item is an IgeViewport and if so
			 * checks if an existing viewport has been set as current.
			 * If no viewport has been set as current, the child is set
			 * as current viewport by default.
			 * @param {IgeObject} child The child that has been mounted
			 * to this entity.
			 * @private
			 */
			_childMounted: function (child) {
				if (child.IgeViewport) {
					// The first mounted viewport gets set as the current
					// one before any rendering is done
					if (!this._currentViewport) {
						this._currentViewport = child;
						this._currentCamera = child.camera;
					}
				}
				
				IgeEntity.prototype._childMounted.call(this, child);
			},
			
			/**
			 * Destroys the engine instance and all scenegraph elements
			 * mounted to it.
			 */
			destroy: function () {
				// Stop the engine and kill any timers
				this.stop();
				
				// Remove the front buffer (canvas) if we created it
				if ($ige.isClient) {
					this.removeCanvas();
				}
				
				// Call class destroy() super method
				IgeEntity.prototype.destroy.call(this);
				
				this.log('Engine destroy complete.');
			}
		});
		
		return IgeEngine;
	});
},{"irrelon-appcore":125}],59:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEntity', function ($ige, $textures, $time, IgeObject, IgePoint2d, IgePoint3d, IgeMatrix2d, IgeDummyCanvas, IgePoly2d, IgeRect) {
	/**
	 * Creates an entity and handles the entity's life cycle and
	 * all related entity actions / methods.
	 */
	var IgeEntity = IgeObject.extend({
		classId: 'IgeEntity',
	
		init: function () {
			IgeObject.prototype.init.call(this);
			
			// Register the IgeEntity special properties handler for
			// serialise and de-serialise support
			this._specialProp.push('_texture');
			this._specialProp.push('_eventListeners');
			this._specialProp.push('_aabb');
	
			this._anchor = new IgePoint2d(0, 0);
			this._renderPos = {x: 0, y: 0};
	
			this._computedOpacity = 1;
			this._opacity = 1;
			this._cell = 1;
	
			this._deathTime = undefined;
			this._bornTime = $time._currentTime;
	
			this._translate = new IgePoint3d(0, 0, 0);
			this._oldTranslate = new IgePoint3d(0, 0, 0);
			this._rotate = new IgePoint3d(0, 0, 0);
			this._scale = new IgePoint3d(1, 1, 1);
			this._origin = new IgePoint3d(0.5, 0.5, 0.5);
	
			this._bounds2d = new IgePoint2d(40, 40);
			this._bounds3d = new IgePoint3d(0, 0, 0);
			
			this._oldBounds2d = new IgePoint2d(40, 40);
			this._oldBounds3d = new IgePoint3d(0, 0, 0);
	
			this._highlight = false;
			this._mouseEventsActive = false;
			
			this._velocity = new IgePoint3d(0, 0, 0);
	
			this._localMatrix = new IgeMatrix2d();
			this._worldMatrix = new IgeMatrix2d();
			this._oldWorldMatrix = new IgeMatrix2d();
	
			this._inView = true;
			this._hidden = false;
			
			//this._mouseEventTrigger = 0;
	
			/* CEXCLUDE */
			if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
				// Set the stream floating point precision to 2 as default
				this.streamFloatPrecision(2);
			}
			/* CEXCLUDE */
	
			// Set the default stream sections as just the transform data
			this.streamSections(['transform']);
		},
	
		/**
		 * Sets the entity as visible and able to be interacted with.
		 * @example #Show a hidden entity
		 *     entity.show();
		 * @return {*} The object this method was called from to allow
		 * method chaining.
		 */
		show: function () {
			this._hidden = false;
			return this;
		},
	
		/**
		 * Sets the entity as hidden and cannot be interacted with.
		 * @example #Hide a visible entity
		 *     entity.hide();
		 * @return {*} The object this method was called from to allow
		 * method chaining.
		 */
		hide: function () {
			this._hidden = true;
			return this;
		},
	
		/**
		 * Checks if the entity is visible.
		 * @returns {boolean} True if the entity is visible.
		 */
		isVisible: function () {
			return this._hidden === false;
		},
		
		/**
		 * Checks if the entity is hidden.
		 * @returns {boolean} True if the entity is hidden.
		 */
		isHidden: function () {
			return this._hidden === true;
		},
	
		/**
		 * Gets / sets the cache flag that determines if the entity's
		 * texture rendering output should be stored on an off-screen
		 * canvas instead of calling the texture.render() method each
		 * tick. Useful for expensive texture calls such as rendering
		 * fonts etc. If enabled, this will automatically disable advanced
		 * composite caching on this entity with a call to
		 * compositeCache(false).
		 * @param {Boolean=} val True to enable caching, false to
		 * disable caching.
		 * @example #Enable entity caching
		 *     entity.cache(true);
		 * @example #Disable entity caching
		 *     entity.cache(false);
		 * @example #Get caching flag value
		 *     var val = entity.cache();
		 * @return {*}
		 */
		cache: function (val) {
			if (val !== undefined) {
				this._cache = val;
				
				if (val) {
					// Create the off-screen canvas
					if ($ige.isClient) {
						// Use a real canvas
						this._cacheCanvas = document.createElement('canvas');
					} else {
						// Use dummy objects for canvas and context
						this._cacheCanvas = new IgeDummyCanvas();
					}
					
					this._cacheCtx = this._cacheCanvas.getContext('2d');
					this._cacheDirty = true;
					
					// Set smoothing mode
					var smoothing = this._cacheSmoothing !== undefined ? this._cacheSmoothing : $textures._globalSmoothing;
					if (!smoothing) {
						this._cacheCtx.imageSmoothingEnabled = false;
						this._cacheCtx.mozImageSmoothingEnabled = false;
					} else {
						this._cacheCtx.imageSmoothingEnabled = true;
						this._cacheCtx.mozImageSmoothingEnabled = true;
					}
	
					// Switch off composite caching
					if (this.compositeCache()) {
						this.compositeCache(false);
					}
				} else {
					// Remove the off-screen canvas
					delete this._cacheCanvas;
				}
	
				return this;
			}
	
			return this._cache;
		},
	
		/**
		 * When using the caching system, this boolean determines if the
		 * cache canvas should have image smoothing enabled or not. If
		 * not set, the ige global smoothing setting will be used instead.
		 * @param {Boolean=} val True to enable smoothing, false to disable.
		 * @returns {*}
		 */
		cacheSmoothing: function (val) {
			if (val !== undefined) {
				this._cacheSmoothing = val;
				return this;
			}
			
			return this._cacheSmoothing;
		},
	
		/**
		 * Gets / sets composite caching. Composite caching draws this entity
		 * and all of it's children (and their children etc) to a single off
		 * screen canvas so that the entity does not need to be redrawn with
		 * all it's children every tick. For composite entities where little
		 * change occurs this will massively increase rendering performance.
		 * If enabled, this will automatically disable simple caching on this
		 * entity with a call to cache(false).
		 * @param {Boolean=} val
		 * @example #Enable entity composite caching
		 *     entity.compositeCache(true);
		 * @example #Disable entity composite caching
		 *     entity.compositeCache(false);
		 * @example #Get composite caching flag value
		 *     var val = entity.cache();
		 * @return {*}
		 */
		compositeCache: function (val) {
			if ($ige.isClient) {
				if (val !== undefined) {
					if (val) {
						// Switch off normal caching
						this.cache(false);
						
						// Create the off-screen canvas
						this._cacheCanvas = document.createElement('canvas');
						this._cacheCtx = this._cacheCanvas.getContext('2d');
						this._cacheDirty = true;
						
						// Set smoothing mode
						var smoothing = this._cacheSmoothing !== undefined ? this._cacheSmoothing : $textures._globalSmoothing;
						if (!smoothing) {
							this._cacheCtx.imageSmoothingEnabled = false;
							this._cacheCtx.mozImageSmoothingEnabled = false;
						} else {
							this._cacheCtx.imageSmoothingEnabled = true;
							this._cacheCtx.mozImageSmoothingEnabled = true;
						}
					}
					
					// Loop children and set _compositeParent to the correct value
					this._children.each(function () {
						if (val) {
							this._compositeParent = true;
						} else {
							delete this._compositeParent;
						}
					});
					
					this._compositeCache = val;
					return this;
				}
				
				return this._compositeCache;
			} else {
				return this;
			}
		},
	
		/**
		 * Gets / sets the cache dirty flag. If set to true this will
		 * instruct the entity to re-draw it's cached image from the
		 * assigned texture. Once that occurs the flag will automatically
		 * be set back to false. This works in either standard cache mode
		 * or composite cache mode.
		 * @param {Boolean=} val True to force a cache update.
		 * @example #Get cache dirty flag value
		 *     var val = entity.cacheDirty();
		 * @example #Set cache dirty flag value
		 *     entity.cacheDirty(true);
		 * @return {*}
		 */
		cacheDirty: function (val) {
			if (val !== undefined) {
				this._cacheDirty = val;
				
				// Check if the entity is a child of a composite or composite
				// entity chain and propagate the dirty cache up the chain
				if (val && this._compositeParent && this._parent) {
					this._parent.cacheDirty(val);
					
					if (!this._cache && !this._compositeCache) {
						// Set clean immediately as no caching is enabled on this child
						this._cacheDirty = false;
					}
				}
				
				return this;
			}
	
			return this._cacheDirty;
		},
	
		/**
		 * Gets the position of the mouse relative to this entity's
		 * center point.
		 * @param {IgeViewport=} viewport The viewport to use as the
		 * base from which the mouse position is determined. If no
		 * viewport is specified then the current viewport the engine
		 * is rendering to is used instead.
		 * @example #Get the mouse position relative to the entity
		 *     // The returned value is an object with properties x, y, z
		 *     var mousePos = entity.mousePos();
		 * @return {IgePoint3d} The mouse point relative to the entity
		 * center.
		 */
		mousePos: function (viewport) {
			viewport = viewport || $ige._currentViewport;
			if (viewport) {
				var mp = viewport._mousePos.clone();
				
				mp.x += viewport._translate.x;
				mp.y += viewport._translate.y;
				this._transformPoint(mp);
				return mp;
			} else {
				return new IgePoint3d(0, 0, 0);
			}
		},
	
		/**
		 * Gets the position of the mouse relative to this entity not
		 * taking into account viewport translation.
		 * @param {IgeViewport=} viewport The viewport to use as the
		 * base from which the mouse position is determined. If no
		 * viewport is specified then the current viewport the engine
		 * is rendering to is used instead.
		 * @example #Get absolute mouse position
		 *     var mousePosAbs = entity.mousePosAbsolute();
		 * @return {IgePoint3d} The mouse point relative to the entity
		 * center.
		 */
		mousePosAbsolute: function (viewport) {
			viewport = viewport || $ige._currentViewport;
			if (viewport) {
				var mp = viewport._mousePos.clone();
				this._transformPoint(mp);
				return mp;
			}
	
			return new IgePoint3d(0, 0, 0);
		},
	
		/**
		 * Gets the position of the mouse in world co-ordinates.
		 * @param {IgeViewport=} viewport The viewport to use as the
		 * base from which the mouse position is determined. If no
		 * viewport is specified then the current viewport the engine
		 * is rendering to is used instead.
		 * @example #Get mouse position in world co-ordinates
		 *     var mousePosWorld = entity.mousePosWorld();
		 * @return {IgePoint3d} The mouse point relative to the world
		 * center.
		 */
		mousePosWorld: function (viewport) {
			viewport = viewport || $ige._currentViewport;
			var mp = this.mousePos(viewport);
			this.localToWorldPoint(mp, viewport);
	
			return mp;
		},
	
		/**
		 * Rotates the entity to point at the target point around the z axis.
		 * @param {IgePoint3d} point The point in world co-ordinates to
		 * point the entity at.
		 * @example #Point the entity at another entity
		 *     entity.rotateToPoint(otherEntity.worldPosition());
		 * @example #Point the entity at mouse
		 *     entity.rotateToPoint($ige._currentViewport.mousePos());
		 * @example #Point the entity at an arbitrary point x, y
		 *     entity.rotateToPoint(new IgePoint3d(x, y, 0));
		 * @return {*}
		 */
		rotateToPoint: function (point) {
			var worldPos = this.worldPosition();
			this.rotateTo(
				this._rotate.x,
				this._rotate.y,
				(Math.atan2(worldPos.y - point.y, worldPos.x - point.x) - this._parent._rotate.z) + Math.radians(270)
			);
	
			return this;
		},
	
		/**
		 * Gets / sets the texture to use as the background
		 * pattern for this entity.
		 * @param {IgeTexture} texture The texture to use as
		 * the background.
		 * @param {String=} repeat The type of repeat mode either: "repeat",
		 * "repeat-x", "repeat-y" or "none".
		 * @param {Boolean=} trackCamera If set to true, will track the camera
		 * translation and "move" the background with the camera.
		 * @param {Boolean=} isoTile If true the tiles of the background will
		 * be treated as isometric and will therefore be drawn so that they are
		 * layered seamlessly in isometric view.
		 * @example #Set a background pattern for this entity with 2d tiling
		 *     var texture = new IgeTexture('path/to/my/texture.png');
		 *     entity.backgroundPattern(texture, 'repeat', true, false);
		 * @example #Set a background pattern for this entity with isometric tiling
		 *     var texture = new IgeTexture('path/to/my/texture.png');
		 *     entity.backgroundPattern(texture, 'repeat', true, true);
		 * @return {*}
		 */
		backgroundPattern: function (texture, repeat, trackCamera, isoTile) {
			if (texture !== undefined) {
				this._backgroundPattern = texture;
				this._backgroundPatternRepeat = repeat || 'repeat';
				this._backgroundPatternTrackCamera = trackCamera;
				this._backgroundPatternIsoTile = isoTile;
				this._backgroundPatternFill = null;
				return this;
			}
	
			return this._backgroundPattern;
		},
	
		/**
		 * Set the object's width to the number of tile width's specified.
		 * @param {Number} val Number of tiles.
		 * @param {Boolean=} lockAspect If true, sets the height according
		 * to the texture aspect ratio and the new width.
		 * @example #Set the width of the entity based on the tile width of the map the entity is mounted to
		 *     // Set the entity width to the size of 1 tile with
		 *     // lock aspect enabled which will automatically size
		 *     // the height as well so as to maintain the aspect
		 *     // ratio of the entity
		 *     entity.widthByTile(1, true);
		 * @return {*} The object this method was called from to allow
		 * method chaining.
		 */
		widthByTile: function (val, lockAspect) {
			if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
				var tileSize = this._mode === 0 ? this._parent._tileWidth : this._parent._tileWidth * 2,
					ratio;
	
				this.width(val * tileSize);
	
				if (lockAspect) {
					if (this._texture) {
						// Calculate the height based on the new width
						ratio = this._texture._sizeX / this._bounds2d.x;
						this.height(this._texture._sizeY / ratio);
					} else {
						this.log('Cannot set height based on texture aspect ratio and new width because no texture is currently assigned to the entity!', 'error');
					}
				}
			} else {
				this.log('Cannot set width by tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
			}
	
			return this;
		},
	
		/**
		 * Set the object's height to the number of tile height's specified.
		 * @param {Number} val Number of tiles.
		 * @param {Boolean=} lockAspect If true, sets the width according
		 * to the texture aspect ratio and the new height.
		 * @example #Set the height of the entity based on the tile height of the map the entity is mounted to
		 *     // Set the entity height to the size of 1 tile with
		 *     // lock aspect enabled which will automatically size
		 *     // the width as well so as to maintain the aspect
		 *     // ratio of the entity
		 *     entity.heightByTile(1, true);
		 * @return {*} The object this method was called from to allow
		 * method chaining.
		 */
		heightByTile: function (val, lockAspect) {
			if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
				var tileSize = this._mode === 0 ? this._parent._tileHeight : this._parent._tileHeight * 2,
					ratio;
	
				this.height(val * tileSize);
	
				if (lockAspect) {
					if (this._texture) {
						// Calculate the width based on the new height
						ratio = this._texture._sizeY / this._bounds2d.y;
						this.width(this._texture._sizeX / ratio);
					} else {
						this.log('Cannot set width based on texture aspect ratio and new height because no texture is currently assigned to the entity!', 'error');
					}
				}
			} else {
				this.log('Cannot set height by tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
			}
	
			return this;
		},
		
		/**
		 * Adds the object to the tile map at the passed tile co-ordinates. If
		 * no tile co-ordinates are passed, will use the current tile position
		 * and the tileWidth() and tileHeight() values.
		 * @param {Number=} x X co-ordinate of the tile to occupy.
		 * @param {Number=} y Y co-ordinate of the tile to occupy.
		 * @param {Number=} width Number of tiles along the x-axis to occupy.
		 * @param {Number=} height Number of tiles along the y-axis to occupy.
		 */
		occupyTile: function (x, y, width, height) {
			// Check that the entity is mounted to a tile map
			if (this._parent && this._parent.IgeTileMap2d) {
				if (x !== undefined && y !== undefined) {
					this._parent.occupyTile(x, y, width, height, this);
				} else {
					// Occupy tiles based upon tile point and tile width/height
					var trPoint = new IgePoint3d(this._translate.x - (((this._tileWidth / 2) - 0.5) * this._parent._tileWidth), this._translate.y - (((this._tileHeight / 2) - 0.5) * this._parent._tileHeight), 0),
						tilePoint = this._parent.pointToTile(trPoint);
		
					if (this._parent._mountMode === 1) {
						tilePoint.thisToIso();
					}
		
					this._parent.occupyTile(tilePoint.x, tilePoint.y, this._tileWidth, this._tileHeight, this);
				}
			}
			return this;
		},
		
		/**
		 * Removes the object from the tile map at the passed tile co-ordinates.
		 * If no tile co-ordinates are passed, will use the current tile position
		 * and the tileWidth() and tileHeight() values.
		 * @param {Number=} x X co-ordinate of the tile to un-occupy.
		 * @param {Number=} y Y co-ordinate of the tile to un-occupy.
		 * @param {Number=} width Number of tiles along the x-axis to un-occupy.
		 * @param {Number=} height Number of tiles along the y-axis to un-occupy.
		 * @private
		 */
		unOccupyTile: function (x, y, width, height) {
			// Check that the entity is mounted to a tile map
			if (this._parent && this._parent.IgeTileMap2d) {
				if (x !== undefined && y !== undefined) {
					this._parent.unOccupyTile(x, y, width, height);
				} else {
					// Un-occupy tiles based upon tile point and tile width/height
					var trPoint = new IgePoint3d(this._translate.x - (((this._tileWidth / 2) - 0.5) * this._parent._tileWidth), this._translate.y - (((this._tileHeight / 2) - 0.5) * this._parent._tileHeight), 0),
						tilePoint = this._parent.pointToTile(trPoint);
		
					if (this._parent._mountMode === 1) {
						tilePoint.thisToIso();
					}
		
					this._parent.unOccupyTile(tilePoint.x, tilePoint.y, this._tileWidth, this._tileHeight);
				}
			}
			return this;
		},
		
		/**
		 * Returns an array of tile co-ordinates that the object is currently
		 * over, calculated using the current world co-ordinates of the object
		 * as well as it's 3d geometry.
		 * @private
		 * @return {Array} The array of tile co-ordinates as IgePoint3d instances.
		 */
		overTiles: function () {
			// Check that the entity is mounted to a tile map
			if (this._parent && this._parent.IgeTileMap2d) {
				var x,
					y,
					tileWidth = this._tileWidth || 1,
					tileHeight = this._tileHeight || 1,
					tile = this._parent.pointToTile(this._translate),
					tileArr = [];
		
				for (x = 0; x < tileWidth; x++) {
					for (y = 0; y < tileHeight; y++) {
						tileArr.push(new IgePoint3d(tile.x + x, tile.y + y, 0));
					}
				}
		
				return tileArr;
			}
		},
	
		/**
		 * Gets / sets the anchor position that this entity's texture
		 * will be adjusted by.
		 * @param {Number=} x The x anchor value.
		 * @param {Number=} y The y anchor value.
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		anchor: function (x, y) {
			if (x !== undefined && y !== undefined) {
				this._anchor = new IgePoint2d(x, y);
				return this;
			}
	
			return this._anchor;
		},
	
		/**
		 * Gets / sets the geometry x value.
		 * @param {Number=} px The new x value in pixels.
		 * @example #Set the width of the entity
		 *     entity.width(40);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		width: function (px, lockAspect) {
			if (px !== undefined) {
				if (lockAspect) {
					// Calculate the height from the change in width
					var ratio = px / this._bounds2d.x;
					this.height(this._bounds2d.y * ratio);
				}
	
				this._bounds2d.x = px;
				this._bounds2d.x2 = (px / 2);
				return this;
			}
	
			return this._bounds2d.x;
		},
	
		/**
		 * Gets / sets the geometry y value.
		 * @param {Number=} px The new y value in pixels.
		 * @example #Set the height of the entity
		 *     entity.height(40);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		height: function (px, lockAspect) {
			if (px !== undefined) {
				if (lockAspect) {
					// Calculate the width from the change in height
					var ratio = px / this._bounds2d.y;
					this.width(this._bounds2d.x * ratio);
				}
	
				this._bounds2d.y = px;
				this._bounds2d.y2 = (px / 2);
				return this;
			}
	
			return this._bounds2d.y;
		},
		
		/**
		 * Gets / sets the 2d geometry of the entity. The x and y values are
		 * relative to the center of the entity. This geometry is used when
		 * rendering textures for the entity and positioning in world space as
		 * well as UI positioning calculations. It holds no bearing on isometric
		 * positioning.
		 * @param {Number=} x The new x value in pixels.
		 * @param {Number=} y The new y value in pixels.
		 * @example #Set the dimensions of the entity (width and height)
		 *     entity.bounds2d(40, 40);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		bounds2d: function (x, y) {
			if (x !== undefined && y !== undefined) {
				this._bounds2d = new IgePoint2d(x, y, 0);
				return this;
			}
			
			if (x !== undefined && y === undefined) {
				// x is considered an IgePoint2d instance
				this._bounds2d = new IgePoint2d(x.x, x.y);
			}
	
			return this._bounds2d;
		},
	
		/**
		 * Gets / sets the 3d geometry of the entity. The x and y values are
		 * relative to the center of the entity and the z value is wholly
		 * positive from the "floor". Used to define a 3d bounding cuboid for
		 * the entity used in isometric depth sorting and hit testing.
		 * @param {Number=} x The new x value in pixels.
		 * @param {Number=} y The new y value in pixels.
		 * @param {Number=} z The new z value in pixels.
		 * @example #Set the dimensions of the entity (width, height and length)
		 *     entity.bounds3d(40, 40, 20);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		bounds3d: function (x, y, z) {
			if (x !== undefined && y !== undefined && z !== undefined) {
				this._bounds3d = new IgePoint3d(x, y, z);
				return this;
			}
	
			return this._bounds3d;
		},
	
		/**
		 * @deprecated Use bounds3d instead
		 * @param x
		 * @param y
		 * @param z
		 */
		size3d: function (x, y, z) {
			this.log('size3d has been renamed to bounds3d but is exactly the same so please search/replace your code to update calls.', 'warning');
		},
	
		/**
		 * Gets / sets the life span of the object in milliseconds. The life
		 * span is how long the object will exist for before being automatically
		 * destroyed.
		 * @param {Number=} milliseconds The number of milliseconds the entity
		 * will live for from the current time.
		 * @param {Function=} deathCallback Optional callback method to call when
		 * the entity is destroyed from end of lifespan.
		 * @example #Set the lifespan of the entity to 2 seconds after which it will automatically be destroyed
		 *     entity.lifeSpan(2000);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		lifeSpan: function (milliseconds, deathCallback) {
			if (milliseconds !== undefined) {
				this.deathTime($time._currentTime + milliseconds, deathCallback);
				return this;
			}
	
			return this.deathTime() - $time._currentTime;
		},
	
		/**
		 * Gets / sets the timestamp in milliseconds that denotes the time
		 * that the entity will be destroyed. The object checks it's own death
		 * time during each tick and if the current time is greater than the
		 * death time, the object will be destroyed.
		 * @param {Number=} val The death time timestamp. This is a time relative
		 * to the engine's start time of zero rather than the current time that
		 * would be retrieved from new Date().getTime(). It is usually easier
		 * to call lifeSpan() rather than setting the deathTime directly.
		 * @param {Function=} deathCallback Optional callback method to call when
		 * the entity is destroyed from end of lifespan.
		 * @example #Set the death time of the entity to 60 seconds after engine start
		 *     entity.deathTime(60000);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		deathTime: function (val, deathCallback) {
			if (val !== undefined) {
				this._deathTime = val;
				
				if (deathCallback !== undefined) {
					this._deathCallBack = deathCallback;
				}
				return this;
			}
	
			return this._deathTime;
		},
	
		/**
		 * Gets / sets the entity opacity from 0.0 to 1.0.
		 * @param {Number=} val The opacity value.
		 * @example #Set the entity to half-visible
		 *     entity.opacity(0.5);
		 * @example #Set the entity to fully-visible
		 *     entity.opacity(1.0);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		opacity: function (val) {
			if (val !== undefined) {
				this._opacity = val;
				return this;
			}
	
			return this._opacity;
		},
	
		/**
		 * Gets / sets the noAabb flag that determines if the entity's axis
		 * aligned bounding box should be calculated every tick or not. If
		 * you don't need the AABB data (for instance if you don't need to
		 * detect mouse events on this entity or you DO want the AABB to be
		 * updated but want to control it manually by calling aabb(true)
		 * yourself as needed).
		 * @param {Boolean=} val If set to true will turn off AABB calculation.
		 * @returns {*}
		 */
		noAabb: function (val) {
			if (val !== undefined) {
				this._noAabb = val;
				return this;
			}
	
			return this._noAabb;
		},
	
		/**
		 * Gets / sets the texture to use when rendering the entity.
		 * @param {IgeTexture=} texture The texture object.
		 * @example #Set the entity texture (image)
		 *     var texture = new IgeTexture('path/to/some/texture.png');
		 *     entity.texture(texture);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		texture: function (texture) {
			if (texture !== undefined) {
				this._texture = texture;
				return this;
			}
	
			return this._texture;
		},
	
		/**
		 * Gets / sets the current texture cell used when rendering the game
		 * object's texture. If the texture is not cell-based, this value is
		 * ignored.
		 * @param {Number=} val The cell index.
		 * @example #Set the entity texture as a 4x4 cell sheet and then set the cell to use
		 *     var texture = new IgeCellSheet('path/to/some/cellSheet.png', 4, 4);
		 *     entity.texture(texture)
		 *         .cell(3);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		cell: function (val) {
			if (val > 0 || val === null) {
				this._cell = val;
				return this;
			}
	
			return this._cell;
		},
	
		/**
		 * Gets / sets the current texture cell used when rendering the game
		 * object's texture. If the texture is not cell-based, this value is
		 * ignored. This differs from cell() in that it accepts a string id
		 * as the cell
		 * @param {Number=} val The cell id.
		 * @example #Set the entity texture as a sprite sheet with cell ids and then set the cell to use
		 *     var texture = new IgeSpriteSheet('path/to/some/cellSheet.png', [
		 *         [0, 0, 40, 40, 'robotHead'],
		 *         [40, 0, 40, 40, 'humanHead'],
		 *     ]);
		 *
		 *     // Assign the texture, set the cell to use and then
		 *     // set the entity to the size of the cell automatically!
		 *     entity.texture(texture)
		 *         .cellById('robotHead')
		 *         .dimensionsFromCell();
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		cellById: function (val) {
			if (val !== undefined) {
				if (this._texture) {
					// Find the cell index this id corresponds to
					var i,
						tex = this._texture,
						cells = tex._cells;
	
					for (i = 1; i < cells.length; i++) {
						if (cells[i][4] === val) {
							// Found the cell id so assign this cell index
							this.cell(i);
							return this;
						}
					}
	
					// We were unable to find the cell index from the cell
					// id so produce an error
					this.log('Could not find the cell id "' + val + '" in the assigned entity texture ' + tex.id() + ', please check your sprite sheet (texture) cell definition to ensure the cell id "' + val + '" has been assigned to a cell!', 'error');
				} else {
					this.log('Cannot assign cell index from cell ID until an IgeSpriteSheet has been set as the texture for this entity. Please set the texture before calling cellById().', 'error');
				}
			}
	
			return this._cell;
		},
	
		/**
		 * Sets the geometry of the entity to match the width and height
		 * of the assigned texture.
		 * @param {Number=} percent The percentage size to resize to.
		 * @example #Set the entity dimensions based on the assigned texture
		 *     var texture = new IgeTexture('path/to/some/texture.png');
		 *
		 *     // Assign the texture, and then set the entity to the
		 *     // size of the texture automatically!
		 *     entity.texture(texture)
		 *         .dimensionsFromTexture();
		 * @return {*} The object this method was called from to allow
		 * method chaining.
		 */
		dimensionsFromTexture: function (percent) {
			if (this._texture) {
				if (percent === undefined) {
					this.width(this._texture._sizeX);
					this.height(this._texture._sizeY);
				} else {
					this.width(Math.floor(this._texture._sizeX / 100 * percent));
					this.height(Math.floor(this._texture._sizeY / 100 * percent));
				}
	
				// Recalculate localAabb
				this.localAabb(true);
			}
	
			return this;
		},
	
		/**
		 * Sets the geometry of the entity to match the width and height
		 * of the assigned texture cell. If the texture is not cell-based
		 * the entire texture width / height will be used.
		 * @param {Number=} percent The percentage size to resize to.
		 * @example #Set the entity dimensions based on the assigned texture and cell
		 *     var texture = new IgeSpriteSheet('path/to/some/cellSheet.png', [
		 *         [0, 0, 40, 40, 'robotHead'],
		 *         [40, 0, 40, 40, 'humanHead'],
		 *     ]);
		 *
		 *     // Assign the texture, set the cell to use and then
		 *     // set the entity to the size of the cell automatically!
		 *     entity.texture(texture)
		 *         .cellById('robotHead')
		 *         .dimensionsFromCell();
		 * @return {*} The object this method was called from to allow
		 * method chaining
		 */
		dimensionsFromCell: function (percent) {
			if (this._texture) {
				if (this._texture._cells && this._texture._cells.length) {
					if (percent === undefined) {
						this.width(this._texture._cells[this._cell][2]);
						this.height(this._texture._cells[this._cell][3]);
					} else {
						this.width(Math.floor(this._texture._cells[this._cell][2] / 100 * percent));
						this.height(Math.floor(this._texture._cells[this._cell][3] / 100 * percent));
					}
					
					// Recalculate localAabb
					this.localAabb(true);
				}
			}
	
			return this;
		},
	
		/**
		 * Gets / sets the highlight mode. True is on false is off.
		 * @param {Boolean} val The highlight mode true, false or optionally a string representing a globalCompositeOperation.
		 * https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing
		 * @example #Set the entity to render highlighted
		 *     entity.highlight(true);
		 * @example #Set the entity to render highlighted using 'screen' globalCompositeOperation
		 *     entity.highlight('screen');
		 * @example #Get the current highlight state
		 *     var isHighlighted = entity.highlight();
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		highlight: function (val) {
			if (val !== undefined) {
				this._highlight = val;
				return this;
			}
	
			return this._highlight;
		},
	
		/**
		 * Returns the absolute world position of the entity as an
		 * IgePoint3d.
		 * @example #Get the world position of the entity
		 *     var wordPos = entity.worldPosition();
		 * @return {IgePoint3d} The absolute world position of the
		 * entity.
		 */
		worldPosition: function () {
			return new IgePoint3d(this._worldMatrix.matrix[2], this._worldMatrix.matrix[5], 0);
		},
	
		/**
		 * Returns the absolute world rotation z of the entity as a
		 * value in radians.
		 * @example #Get the world rotation of the entity's z axis
		 *     var wordRot = entity.worldRotationZ();
		 * @return {Number} The absolute world rotation z of the
		 * entity.
		 */
		worldRotationZ: function () {
			return this._worldMatrix.rotationRadians();
		},
	
		/**
		 * Converts an array of points from local space to this entity's
		 * world space using it's world transform matrix. This will alter
		 * the points passed in the array directly.
		 * @param {Array} points The array of IgePoints to convert.
		 */
		localToWorld: function (points, viewport, inverse) {
			viewport = viewport || $ige._currentViewport;
			
			if (this._adjustmentMatrix) {
				// Apply the optional adjustment matrix
				this._worldMatrix.multiply(this._adjustmentMatrix);
			}
			
			if (!inverse) {
				this._worldMatrix.transform(points, this);
			} else {
				this._localMatrix.transform(points, this);
				//this._worldMatrix.getInverse().transform(points, this);
			}
		},
	
		/**
		 * Converts a point from local space to this entity's world space
		 * using it's world transform matrix. This will alter the point's
		 * data directly.
		 * @param {IgePoint3d} point The IgePoint3d to convert.
		 */
		localToWorldPoint: function (point, viewport) {
			viewport = viewport || $ige._currentViewport;
			this._worldMatrix.transform([point], this);
		},
		
		/**
		 * Returns the screen position of the entity as an IgePoint3d where x is the
		 * "left" and y is the "top", useful for positioning HTML elements at the
		 * screen location of an IGE entity. This method assumes that the top-left
		 * of the main canvas element is at 0, 0. If not you can adjust the values
		 * yourself to allow for offset.
		 * @example #Get the screen position of the entity
		 *     var screenPos = entity.screenPosition();
		 * @return {IgePoint3d} The screen position of the entity.
		 */
		screenPosition: function () {
			return new IgePoint3d(
				Math.floor(((this._worldMatrix.matrix[2] - $ige._currentCamera._translate.x) * $ige._currentCamera._scale.x) + $ige.engine._bounds2d.x2),
				Math.floor(((this._worldMatrix.matrix[5] - $ige._currentCamera._translate.y) * $ige._currentCamera._scale.y) + $ige.engine._bounds2d.y2),
				0
			);
		},
		
		/**
		 * @deprecated Use bounds3dPolygon instead
		 */
		localIsoBoundsPoly: function () {},
		
		localBounds3dPolygon: function (recalculate) {
			if (this._bounds3dPolygonDirty || !this._localBounds3dPolygon || recalculate) {
				var geom = this._bounds3d,
					poly = new IgePoly2d(),
					// Bottom face
					bf2 = Math.toIso(+(geom.x2), -(geom.y2),  -(geom.z2)),
					bf3 = Math.toIso(+(geom.x2), +(geom.y2),  -(geom.z2)),
					bf4 = Math.toIso(-(geom.x2), +(geom.y2),  -(geom.z2)),
					// Top face
					tf1 = Math.toIso(-(geom.x2), -(geom.y2),  (geom.z2)),
					tf2 = Math.toIso(+(geom.x2), -(geom.y2),  (geom.z2)),
					tf4 = Math.toIso(-(geom.x2), +(geom.y2),  (geom.z2));
				
				poly.addPoint(tf1.x, tf1.y)
					.addPoint(tf2.x, tf2.y)
					.addPoint(bf2.x, bf2.y)
					.addPoint(bf3.x, bf3.y)
					.addPoint(bf4.x, bf4.y)
					.addPoint(tf4.x, tf4.y)
					.addPoint(tf1.x, tf1.y);
				
				this._localBounds3dPolygon = poly;
				this._bounds3dPolygonDirty = false;
			}
			
			return this._localBounds3dPolygon;
		},
		
		/**
		 * @deprecated Use bounds3dPolygon instead
		 */
		isoBoundsPoly: function () {},
		
		bounds3dPolygon: function (recalculate) {
			if (this._bounds3dPolygonDirty || !this._bounds3dPolygon || recalculate) {
				var poly = this.localBounds3dPolygon(recalculate).clone();
				
				// Convert local co-ordinates to world based on entities world matrix
				this.localToWorld(poly._poly);
				
				this._bounds3dPolygon = poly;
			}
			
			return this._bounds3dPolygon;
		},
	
		/**
		 * @deprecated Use mouseInBounds3d instead
		 */
		mouseInIsoBounds: function () {},
		
		mouseInBounds3d: function (recalculate) {
			var poly = this.localBounds3dPolygon(recalculate),
				mp = this.mousePos();
			
			return poly.pointInside(mp);
		},
	
		/**
		 * Calculates and returns the current axis-aligned bounding box in
		 * world co-ordinates.
		 * @param {Boolean=} recalculate If true this will force the
		 * recalculation of the AABB instead of returning a cached
		 * value.
		 * @example #Get the entity axis-aligned bounding box dimensions
		 *     var aabb = entity.aabb();
		 *
		 *     console.log(aabb.x);
		 *     console.log(aabb.y);
		 *     console.log(aabb.width);
		 *     console.log(aabb.height);
		 * @example #Get the entity axis-aligned bounding box dimensions forcing the engine to update the values first
		 *     var aabb = entity.aabb(true); // Call with true to force update
		 *
		 *     console.log(aabb.x);
		 *     console.log(aabb.y);
		 *     console.log(aabb.width);
		 *     console.log(aabb.height);
		 * @return {IgeRect} The axis-aligned bounding box in world co-ordinates.
		 */
		aabb: function (recalculate, inverse) {
			if (this._aabbDirty || !this._aabb || recalculate) { //  && this.newFrame()
				var poly = new IgePoly2d(),
					minX, minY,
					maxX, maxY,
					box,
					anc = this._anchor,
					ancX = anc.x,
					ancY = anc.y,
					geom,
					geomX2,
					geomY2,
					x, y;
	
				geom = this._bounds2d;
				geomX2 = geom.x2;
				geomY2 = geom.y2;
				
				x = geomX2;
				y = geomY2;
	
				poly.addPoint(-x + ancX, -y + ancY);
				poly.addPoint(x + ancX, -y + ancY);
				poly.addPoint(x + ancX, y + ancY);
				poly.addPoint(-x + ancX, y + ancY);
	
				this._renderPos = {x: -x + ancX, y: -y + ancY};
	
				// Convert the poly's points from local space to world space
				this.localToWorld(poly._poly, null, inverse);
	
				// Get the extents of the newly transformed poly
				minX = Math.min(
					poly._poly[0].x,
					poly._poly[1].x,
					poly._poly[2].x,
					poly._poly[3].x
				);
	
				minY = Math.min(
					poly._poly[0].y,
					poly._poly[1].y,
					poly._poly[2].y,
					poly._poly[3].y
				);
	
				maxX = Math.max(
					poly._poly[0].x,
					poly._poly[1].x,
					poly._poly[2].x,
					poly._poly[3].x
				);
	
				maxY = Math.max(
					poly._poly[0].y,
					poly._poly[1].y,
					poly._poly[2].y,
					poly._poly[3].y
				);
	
				box = new IgeRect(minX, minY, maxX - minX, maxY - minY);
	
				this._aabb = box;
				this._aabbDirty = false;
			}
	
			return this._aabb;
		},
	
		/**
		 * Calculates and returns the local axis-aligned bounding box
		 * for the entity. This is the AABB relative to the entity's
		 * center point.
		 * @param {Boolean=} recalculate If true this will force the
		 * recalculation of the local AABB instead of returning a cached
		 * value.
		 * @example #Get the entity local axis-aligned bounding box dimensions
		 *     var aabb = entity.localAabb();
		 *
		 *     console.log(aabb.x);
		 *     console.log(aabb.y);
		 *     console.log(aabb.width);
		 *     console.log(aabb.height);
		 * @example #Get the entity local axis-aligned bounding box dimensions forcing the engine to update the values first
		 *     var aabb = entity.localAabb(true); // Call with true to force update
		 *
		 *     console.log(aabb.x);
		 *     console.log(aabb.y);
		 *     console.log(aabb.width);
		 *     console.log(aabb.height);
		 * @return {IgeRect} The local AABB.
		 */
		localAabb: function (recalculate) {
			if (!this._localAabb || recalculate) {
				var aabb = this.aabb();
				this._localAabb = new IgeRect(-Math.floor(aabb.width / 2), -Math.floor(aabb.height / 2), Math.floor(aabb.width), Math.floor(aabb.height));
			}
	
			return this._localAabb;
		},
	
		/**
		 * Calculates the axis-aligned bounding box for this entity, including
		 * all child entity bounding boxes and returns the final composite
		 * bounds.
		 * @example #Get the composite AABB
		 *     var entity = new IgeEntity(),
		 *         aabb = entity.compositeAabb();
		 * @return {IgeRect}
		 */
		compositeAabb: function (inverse) {
			var arr = this._children,
				arrCount,
				rect;
		
			if (inverse) {
				rect = this.aabb(true, inverse).clone();
			} else {
				rect = this.aabb().clone();
			}
	
			// Now loop all children and get the aabb for each of them
			// them add those bounds to the current rect
			if (arr) {
				arrCount = arr.length;
	
				while (arrCount--) {
					rect.thisCombineRect(arr[arrCount].compositeAabb(inverse));
				}
			}
	
			return rect;
		},
	
		/**
		 * Gets / sets the composite stream flag. If set to true, any objects
		 * mounted to this one will have their streamMode() set to the same
		 * value as this entity and will also have their compositeStream flag
		 * set to true. This allows you to easily automatically stream any
		 * objects mounted to a root object and stream them all.
		 * @param val
		 * @returns {*}
		 */
		compositeStream: function (val) {
			if (val !== undefined) {
				this._compositeStream = val;
				return this;
			}
			
			return this._compositeStream;
		},
	
		/**
		 * Override the _childMounted method and apply entity-based flags.
		 * @param {IgeEntity} child
		 * @private
		 */
		_childMounted: function (child) {
			// Check if we need to set the compositeStream and streamMode
			if (this.compositeStream()) {
				child.compositeStream(true);
				child.streamMode(this.streamMode());
				child.streamControl(this.streamControl());
			}
			
			IgeObject.prototype._childMounted.call(this, child);
					
			// Check if we are compositeCached and update the cache
			if (this.compositeCache()) {
				this.cacheDirty(true);
			}
		},
		
		/**
		 * Takes two values and returns them as an array where index [0]
		 * is the y argument and index[1] is the x argument. This method
		 * is used specifically in the 3d bounds intersection process to
		 * determine entity depth sorting.
		 * @param {Number} x The first value.
		 * @param {Number} y The second value.
		 * @return {Array} The swapped arguments.
		 * @private
		 */
		_swapVars: function (x, y) {
			return [y, x];
		},
	
		_internalsOverlap: function (x0, x1, y0, y1) {
			var tempSwap;
	
			if (x0 > x1) {
				tempSwap = this._swapVars(x0, x1);
				x0 = tempSwap[0];
				x1 = tempSwap[1];
			}
	
			if (y0 > y1) {
				tempSwap = this._swapVars(y0, y1);
				y0 = tempSwap[0];
				y1 = tempSwap[1];
			}
	
			if (x0 > y0) {
				tempSwap = this._swapVars(x0, y0);
				x0 = tempSwap[0];
				y0 = tempSwap[1];
	
				tempSwap = this._swapVars(x1, y1);
				x1 = tempSwap[0];
				y1 = tempSwap[1];
			}
	
			return y0 < x1;
		},
	
		_projectionOverlap: function (otherObject) {
			var thisG3d = this._bounds3d,
				thisMin = {
					x: this._translate.x - thisG3d.x / 2,
					y: this._translate.y - thisG3d.y / 2,
					z: this._translate.z - thisG3d.z
				},
				thisMax = {
					x: this._translate.x + thisG3d.x / 2,
					y: this._translate.y + thisG3d.y / 2,
					z: this._translate.z + thisG3d.z
				},
				otherG3d = otherObject._bounds3d,
				otherMin = {
					x: otherObject._translate.x - otherG3d.x / 2,
					y: otherObject._translate.y - otherG3d.y / 2,
					z: otherObject._translate.z - otherG3d.z
				},
				otherMax = {
					x: otherObject._translate.x + otherG3d.x / 2,
					y: otherObject._translate.y + otherG3d.y / 2,
					z: otherObject._translate.z + otherG3d.z
				};
	
			return this._internalsOverlap(
				thisMin.x - thisMax.y,
				thisMax.x - thisMin.y,
				otherMin.x - otherMax.y,
				otherMax.x - otherMin.y
			) && this._internalsOverlap(
				thisMin.x - thisMax.z,
				thisMax.x - thisMin.z,
				otherMin.x - otherMax.z,
				otherMax.x - otherMin.z
			) && this._internalsOverlap(
				thisMin.z - thisMax.y,
				thisMax.z - thisMin.y,
				otherMin.z - otherMax.y,
				otherMax.z - otherMin.y
			);
		},
	
		/**
		 * Compares the current entity's 3d bounds to the passed entity and
		 * determines if the current entity is "behind" the passed one. If an
		 * entity is behind another, it is drawn first during the scenegraph
		 * render phase.
		 * @param {IgeEntity} otherObject The other entity to check this
		 * entity's 3d bounds against.
		 * @example #Determine if this entity is "behind" another entity based on the current depth-sort
		 *     var behind = entity.isBehind(otherEntity);
		 * @return {Boolean} If true this entity is "behind" the passed entity
		 * or false if not.
		 */
		isBehind: function (otherObject) {
			var thisG3d = this._bounds3d,
				otherG3d = otherObject._bounds3d,
				thisTranslate = this._translate.clone(),
				otherTranslate = otherObject._translate.clone();
	
			// thisTranslate.thisToIso();
			// otherTranslate.thisToIso();
	
			if(this._origin.x !== 0.5 || this._origin.y !== 0.5) {
				thisTranslate.x += this._bounds2d.x * (0.5 - this._origin.x);
				thisTranslate.y += this._bounds2d.y * (0.5 - this._origin.y);
			}
			
			if(otherObject._origin.x !== 0.5 || otherObject._origin.y !== 0.5) {
				otherTranslate.x += otherObject._bounds2d.x * (0.5 - otherObject._origin.x);
				otherTranslate.y += otherObject._bounds2d.y * (0.5 - otherObject._origin.y);
			}
	
			var
				thisX = thisTranslate.x,
				thisY = thisTranslate.y,
				otherX = otherTranslate.x,
				otherY = otherTranslate.y,
				thisMin = new IgePoint3d(
					thisX - thisG3d.x / 2,
					thisY - thisG3d.y / 2,
					this._translate.z
				),
				thisMax = new IgePoint3d(
					thisX + thisG3d.x / 2,
					thisY + thisG3d.y / 2,
					this._translate.z + thisG3d.z
				),
				otherMin = new IgePoint3d(
					otherX - otherG3d.x / 2,
					otherY - otherG3d.y / 2,
					otherObject._translate.z
				),
				otherMax = new IgePoint3d(
					otherX + otherG3d.x / 2,
					otherY + otherG3d.y / 2,
					otherObject._translate.z + otherG3d.z
				);
	
			if (thisMax.x <= otherMin.x) {
				return false;
			}
	
			if (otherMax.x <= thisMin.x) {
				return true;
			}
	
			if (thisMax.y <= otherMin.y) {
				return false;
			}
	
			if (otherMax.y <= thisMin.y) {
				return true;
			}
	
			if (thisMax.z <= otherMin.z) {
				return false;
			}
	
			if (otherMax.z <= thisMin.z) {
				return true;
			}
	
			return (thisX + thisY + this._translate.z) > (otherX + otherY + otherObject._translate.z);
		},
	
		/**
		 * Get / set the flag determining if this entity will respond
		 * to mouse interaction or not. When you set a mouse* event e.g.
		 * mouseUp, mouseOver etc this flag will automatically be reset
		 * to true.
		 * @param {Boolean=} val The flag value true or false.
		 * @example #Set entity to ignore mouse events
		 *     entity.mouseEventsActive(false);
		 * @example #Set entity to receive mouse events
		 *     entity.mouseEventsActive(true);
		 * @example #Get current flag value
		 *     var val = entity.mouseEventsActive();
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		mouseEventsActive: function (val) {
			if (val !== undefined) {
				this._mouseEventsActive = val;
				return this;
			}
	
			return this._mouseEventsActive;
		},
	
		/**
		 * Sets the _ignoreCamera internal flag to the value passed for this
		 * and all child entities down the scenegraph.
		 * @param val
		 */
		ignoreCameraComposite: function (val) {
			var i,
				arr = this._children,
				arrCount = arr.length;
			
			this._ignoreCamera = val;
			
			for (i = 0; i < arrCount; i++) {
				if (arr[i].ignoreCameraComposite) {
					arr[i].ignoreCameraComposite(val);
				}
			}
		},
	
		/**
		 * Determines if the frame alternator value for this entity
		 * matches the engine's frame alternator value. The entity's
		 * frame alternator value will be set to match the engine's
		 * after each call to the entity.tick() method so the return
		 * value of this method can be used to determine if the tick()
		 * method has already been run for this entity.
		 *
		 * This is useful if you have multiple viewports which will
		 * cause the entity tick() method to fire once for each viewport
		 * but you only want to execute update code such as movement etc
		 * on the first time the tick() method is called.
		 *
		 * @example #Determine if the entity has already had it's tick method called
		 *     var tickAlreadyCalled = entity.newFrame();
		 * @return {Boolean} If false, the entity's tick method has
		 * not yet been processed for this tick.
		 */
		newFrame: function () {
			return $ige.engine._frameAlternator !== this._frameAlternatorCurrent;
		},
	
		/**
		 * Sets the canvas context transform properties to match the the game
		 * object's current transform values.
		 * @param {CanvasRenderingContext2D} ctx The canvas context to apply
		 * the transformation matrix to.
		 * @example #Transform a canvas context to the entity's local matrix values
		 *     var canvas = document.createElement('canvas');
		 *     canvas.width = 800;
		 *     canvas.height = 600;
		 *
		 *     var ctx = canvas.getContext('2d');
		 *     entity._transformContext(ctx);
		 * @private
		 */
		_transformContext: function (ctx, inverse) {
			if (this._parent) {
				ctx.globalAlpha = this._computedOpacity = this._parent._computedOpacity * this._opacity;
			} else {
				ctx.globalAlpha = this._computedOpacity = this._opacity;
			}
	
			if (!inverse) {
				this._localMatrix.transformRenderingContext(ctx);
			} else {
				this._localMatrix.getInverse().transformRenderingContext(ctx);
			}
		},
		
		mouseAlwaysInside: function (val) {
			if (val !== undefined) {
				this._mouseAlwaysInside = val;
				return this;
			}
			
			return this._mouseAlwaysInside;
		},
		
		/**
		 * Processes the updates required each render frame. Any code in the update()
		 * method will be called ONCE for each render frame BEFORE the tick() method.
		 * This differs from the tick() method in that the tick method can be called
		 * multiple times during a render frame depending on how many viewports your
		 * simulation is being rendered to, whereas the update() method is only called
		 * once. It is therefore the perfect place to put code that will control your
		 * entity's motion, AI etc.
		 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
		 * @param {Number} tickDelta The diffence in milliseconds between now and the
		 * last time update was called. Useful for calculating time-based effects on
		 * the entity such as how far it moved etc.
		 */
		update: function (ctx, tickDelta) {
			// Check if the entity should still exist
			if (this._deathTime !== undefined && this._deathTime <= $time._tickStart) {
				// Check if the deathCallBack was set
				if (this._deathCallBack) {
					this._deathCallBack.apply(this);
					delete this._deathCallback;
				}
				
				// The entity should be removed because it has died
				this.destroy();
			} else {
				// Check that the entity has been born
				if (this._bornTime === undefined || $time._currentTime >= this._bornTime) {
					// Remove the stream data cache
					delete this._streamDataCache;
		
					// Process any behaviours assigned to the entity
					this._processUpdateBehaviours(ctx, tickDelta);
					
					// Process velocity
					if (this._velocity.x || this._velocity.y) {
						this._translate.x += (this._velocity.x / 16) * tickDelta;
						this._translate.y += (this._velocity.y / 16) * tickDelta;
					}
		
					if (this._timeStream.length) {
						// Process any interpolation
						this._processInterpolate($time._tickStart - $ige.engine.network.stream._renderLatency);
					}
		
					// Check for changes to the transform values
					// directly without calling the transform methods
					this.updateTransform();
		
					if (!this._noAabb && this._aabbDirty) {
						// Update the aabb
						this.aabb();
					}
		
					this._oldTranslate = this._translate.clone();
		
					// Update this object's current frame alternator value
					// which allows us to determine if we are still on the
					// same frame
					this._frameAlternatorCurrent = $ige.engine._frameAlternator;
				} else {
					// The entity is not yet born, unmount it and add to the spawn queue
					this._birthMount = this._parent.id();
					this.unMount();
					
					$ige.engine.spawnQueue(this);
				}
			}
	
			// Process super class
			IgeObject.prototype.update.call(this, ctx, tickDelta);
		},
	
		/**
		 * Processes the actions required each render frame.
		 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
		 * @param {Boolean} dontTransform If set to true, the tick method will
		 * not transform the context based on the entity's matrices. This is useful
		 * if you have extended the class and want to process down the inheritance
		 * chain but have already transformed the entity in a previous overloaded
		 * method.
		 */
		tick: function (ctx, dontTransform) {
			if (!this._hidden && this._inView && (!this._parent || (this._parent._inView)) && !this._streamJustCreated) {
				// Process any behaviours assigned to the entity
				this._processTickBehaviours(ctx);
				
				// Process any mouse events we need to do
				if (this._mouseEventsActive) {
					if (this._processTriggerHitTests()) {
						// Point is inside the trigger bounds
						$ige.engine.input.queueEvent(this, this._mouseInTrigger, null);
					} else {
						if ($ige.engine.input.mouseMove) {
							// There is a mouse move event but we are not inside the entity
							// so fire a mouse out event (_handleMouseOut will check if the
							// mouse WAS inside before firing an out event).
							this._handleMouseOut($ige.engine.input.mouseMove);
						}
					}
				}
	
				if (!this._dontRender) {
					// Check for cached version
					if (this._cache || this._compositeCache) {
						// Caching is enabled
						if (this._cacheDirty) {
							// The cache is dirty, redraw it
							this._refreshCache(dontTransform);
						}
						
						// Now render the cached image data to the main canvas
						this._renderCache(ctx);
					} else {
						// Non-cached output
						// Transform the context by the current transform settings
						if (!dontTransform) {
							this._transformContext(ctx);
						}
						
						// Render the entity
						this._renderEntity(ctx, dontTransform);
					}
				}
	
				// Process any automatic-mode stream updating required
				if (this._streamMode === 1) {
					this.streamSync();
				}
	
				if (this._compositeCache) {
					if (this._cacheDirty) {
						// Process children
						IgeObject.prototype.tick.call(this, this._cacheCtx);
						this._renderCache(ctx);
						this._cacheDirty = false;
					}
				} else {
					// Process children
					IgeObject.prototype.tick.call(this, ctx);
				}
			}
		},
		
		_processTriggerHitTests: function () {
			var mp, mouseTriggerPoly;
	
			if ($ige._currentViewport) {
				if (!this._mouseAlwaysInside) {
					mp = this.mousePosWorld();
		
					if (mp) {
						// Use the trigger polygon if defined
						if (this._triggerPolygon && this[this._triggerPolygon]) {
							mouseTriggerPoly = this[this._triggerPolygon](mp);
						} else {
							// Default to either aabb or bounds3dPolygon depending on entity parent mounting mode
							if (this._parent && this._parent._mountMode === 1) {
								// Use bounds3dPolygon
								mouseTriggerPoly = this.bounds3dPolygon();
							} else {
								// Use aabb
								mouseTriggerPoly = this.aabb();
							}
						}
						
						// Check if the current mouse position is inside this aabb
						return mouseTriggerPoly.xyInside(mp.x, mp.y);
					}
				} else {
					return true;
				}
			}
			
			return false;
		},
		
		_refreshCache: function (dontTransform) {
			// The cache is not clean so re-draw it
			// Render the entity to the cache
			var _canvas = this._cacheCanvas,
				_ctx = this._cacheCtx;
	
			if (this._compositeCache) {
				// Get the composite entity AABB and alter the internal canvas
				// to the composite size so we can render the entire entity
				var aabbC = this.compositeAabb(true);
				
				this._compositeAabbCache = aabbC;
				
				if (aabbC.width > 0 && aabbC.height > 0) {
					_canvas.width = Math.ceil(aabbC.width);
					_canvas.height = Math.ceil(aabbC.height);
				} else {
					// We cannot set a zero size for a canvas, it will
					// cause the browser to freak out
					_canvas.width = 2;
					_canvas.height = 2;
				}
				
				// Translate to the center of the canvas
				_ctx.translate(-aabbC.x, -aabbC.y);
	
				/**
				 * Fires when the entity's composite cache is ready.
				 * @event IgeEntity#compositeReady
				 */
				this.emit('compositeReady');
			} else {
				if (this._bounds2d.x > 0 && this._bounds2d.y > 0) {
					_canvas.width = this._bounds2d.x;
					_canvas.height = this._bounds2d.y;
				} else {
					// We cannot set a zero size for a canvas, it will
					// cause the browser to freak out
					_canvas.width = 1;
					_canvas.height = 1;
				}
				
				// Translate to the center of the canvas
				_ctx.translate(this._bounds2d.x2, this._bounds2d.y2);
				
				this._cacheDirty = false;
			}
			
			// Transform the context by the current transform settings
			if (!dontTransform) {
				this._transformContext(_ctx);
			}
			
			this._renderEntity(_ctx, dontTransform);
		},
	
		/**
		 * Handles calling the texture.render() method if a texture
		 * is applied to the entity. This part of the tick process has
		 * been abstracted to allow it to be overridden by an extending
		 * class.
		 * @param {CanvasRenderingContext2D} ctx The canvas context to render
		 * the entity to.
		 * @private
		 */
		_renderEntity: function (ctx) {
			if (this._opacity > 0) {
				// Check if the entity has a background pattern
				if (this._backgroundPattern) {
					if (!this._backgroundPatternFill) {
						// We have a pattern but no fill produced
						// from it. Check if we have a context to
						// generate a pattern from
						if (ctx) {
							// Produce the pattern fill
							this._backgroundPatternFill = ctx.createPattern(this._backgroundPattern.image, this._backgroundPatternRepeat);
						}
					}
	
					if (this._backgroundPatternFill) {
						// Draw the fill
						ctx.save();
						ctx.fillStyle = this._backgroundPatternFill;
	
						// TODO: When firefox has fixed their bug regarding negative rect co-ordinates, revert this change
	
						// This is the proper way to do this but firefox has a bug which I'm gonna report
						// so instead I have to use ANOTHER translate call instead. So crap!
						//ctx.rect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);
						ctx.translate(-this._bounds2d.x2, -this._bounds2d.y2);
						ctx.rect(0, 0, this._bounds2d.x, this._bounds2d.y);
						if (this._backgroundPatternTrackCamera) {
							ctx.translate(-$ige._currentCamera._translate.x, -$ige._currentCamera._translate.y);
							ctx.scale($ige._currentCamera._scale.x, $ige._currentCamera._scale.y);
						}
						ctx.fill();
						$time._drawCount++;
	
						if (this._backgroundPatternIsoTile) {
							ctx.translate(-Math.floor(this._backgroundPattern.image.width) / 2, -Math.floor(this._backgroundPattern.image.height / 2));
							ctx.fill();
							$time._drawCount++;
						}
	
						ctx.restore();
					}
				}
	
				var texture = this._texture;
	
				// Check if the entity is visible based upon its opacity
				if (texture && texture._loaded) {
					// Draw the entity image
					texture.render(ctx, this, $time._tickDelta);
	
					if (this._highlight) {
						ctx.globalCompositeOperation = this._highlightToGlobalCompositeOperation(this._highlight);
						texture.render(ctx, this);
					}
				}
				
				if (this._compositeCache && $ige._currentViewport._drawCompositeBounds) {
					//console.log('moo');
					ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
					ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x,	this._bounds2d.y);
					ctx.fillStyle = '#ffffff';
					ctx.fillText('Composite Entity', -this._bounds2d.x2, -this._bounds2d.y2 - 15);
					ctx.fillText(this.id(), -this._bounds2d.x2, -this._bounds2d.y2 - 5);
				}
			}
		},
	
		/**
		 * Draws the cached off-screen canvas image data to the passed canvas
		 * context.
		 * @param {CanvasRenderingContext2D} ctx The canvas context to render
		 * the entity to.
		 * @private
		 */
		_renderCache: function (ctx) {
			ctx.save();
			if (this._compositeCache) {
				var aabbC = this._compositeAabbCache;
				ctx.translate(this._bounds2d.x2 + aabbC.x, this._bounds2d.y2 + aabbC.y);
			}
			
			// We have a clean cached version so output that
			ctx.drawImage(
				this._cacheCanvas,
				-this._bounds2d.x2, -this._bounds2d.y2
			);
			
			if ($ige._currentViewport._drawCompositeBounds) {
				ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
				ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._cacheCanvas.width,	this._cacheCanvas.height);
				ctx.fillStyle = '#ffffff';
				ctx.fillText('Composite Cache', -this._bounds2d.x2, -this._bounds2d.y2 - 15);
				ctx.fillText(this.id(), -this._bounds2d.x2, -this._bounds2d.y2 - 5);
			}
			
			$time._drawCount++;
	
			if (this._highlight) {
				ctx.globalCompositeOperation = this._highlightToGlobalCompositeOperation(this._highlight);
				ctx.drawImage(
					this._cacheCanvas,
					-this._bounds2d.x2, -this._bounds2d.y2
				);
				
				$time._drawCount++;
			}
			ctx.restore();
		},
	
		/**
		 * Transforms a point by the entity's parent world matrix and
		 * it's own local matrix transforming the point to this entity's
		 * world space.
		 * @param {IgePoint3d} point The point to transform.
		 * @example #Transform a point by the entity's world matrix values
		 *     var point = new IgePoint3d(0, 0, 0);
		 *     entity._transformPoint(point);
		 *
		 *     console.log(point);
		 * @return {IgePoint3d} The transformed point.
		 * @private
		 */
		_transformPoint: function (point) {
			if (this._parent) {
				var tempMat = new IgeMatrix2d();
				// Copy the parent world matrix
				tempMat.copy(this._parent._worldMatrix);
				// Apply any local transforms
				tempMat.multiply(this._localMatrix);
				// Now transform the point
				tempMat.getInverse().transformCoord(point, this);
			} else {
				this._localMatrix.transformCoord(point, this);
			}
	
			return point;
		},
		
		/**
		 * Helper method to transform an array of points using _transformPoint.
		 * @param {Array} points The points array to transform.
		 * @private
		 */
		_transformPoints: function (points) {
			var point, pointCount = points.length;
			
			while (pointCount--) {
				point = points[pointCount];
				if (this._parent) {
					var tempMat = new IgeMatrix2d();
					// Copy the parent world matrix
					tempMat.copy(this._parent._worldMatrix);
					// Apply any local transforms
					tempMat.multiply(this._localMatrix);
					// Now transform the point
					tempMat.getInverse().transformCoord(point, this);
				} else {
					this._localMatrix.transformCoord(point, this);
				}
			}
		},
	
		/**
		 * Generates a string containing a code fragment that when
		 * evaluated will reproduce this object's properties via
		 * chained commands. This method will only check for
		 * properties that are directly related to this class.
		 * Other properties are handled by their own class method.
		 * @return {String} The string code fragment that will
		 * reproduce this entity when evaluated.
		 */
		_stringify: function (options) {
			// Make sure we have an options object
			if (options === undefined) { options = {}; }
			
			// Get the properties for all the super-classes
			var str = IgeObject.prototype._stringify.call(this, options), i;
	
			// Loop properties and add property assignment code to string
			for (i in this) {
				if (this.hasOwnProperty(i) && this[i] !== undefined) {
					switch (i) {
						case '_opacity':
							str += ".opacity(" + this.opacity() + ")";
							break;
						case '_texture':
							str += ".texture($ige.engine.$('" + this.texture().id() + "'))";
							break;
						case '_cell':
							str += ".cell(" + this.cell() + ")";
							break;
						case '_translate':
							if (options.transform !== false && options.translate !== false) {
								str += ".translateTo(" + this._translate.x + ", " + this._translate.y + ", " + this._translate.z + ")";
							}
							break;
						case '_rotate':
							if (options.transform !== false && options.rotate !== false) {
								str += ".rotateTo(" + this._rotate.x + ", " + this._rotate.y + ", " + this._rotate.z + ")";
							}
							break;
						case '_scale':
							if (options.transform !== false && options.scale !== false) {
								str += ".scaleTo(" + this._scale.x + ", " + this._scale.y + ", " + this._scale.z + ")";
							}
							break;
						case '_origin':
							if (options.origin !== false) {
								str += ".originTo(" + this._origin.x + ", " + this._origin.y + ", " + this._origin.z + ")";
							}
							break;
						case '_anchor':
							if (options.anchor !== false) {
								str += ".anchor(" + this._anchor.x + ", " + this._anchor.y + ")";
							}
							break;
						case '_width':
							if (typeof(this.width()) === 'string') {
								str += ".width('" + this.width() + "')";
							} else {
								str += ".width(" + this.width() + ")";
							}
							break;
						case '_height':
							if (typeof(this.height()) === 'string') {
								str += ".height('" + this.height() + "')";
							} else {
								str += ".height(" + this.height() + ")";
							}
							break;
						case '_bounds3d':
							str += ".bounds3d(" + this._bounds3d.x + ", " + this._bounds3d.y + ", " + this._bounds3d.z + ")";
							break;
						case '_deathTime':
							if (options.deathTime !== false && options.lifeSpan !== false) {
								str += ".deathTime(" + this.deathTime() + ")";
							}
							break;
						case '_highlight':
							str += ".highlight(" + this.highlight() + ")";
							break;
					}
				}
			}
	
			return str;
		},
	
		/**
		 * Destroys the entity by removing it from the scenegraph,
		 * calling destroy() on any child entities and removing
		 * any active event listeners for the entity. Once an entity
		 * has been destroyed it's this._alive flag is also set to
		 * false.
		 * @example #Destroy the entity
		 *     entity.destroy();
		 */
		destroy: function () {
			this._alive = false;
			
			/* CEXCLUDE */
			// Check if the entity is streaming
			if (this._streamMode === 1) {
				delete this._streamDataCache;
				this.streamDestroy();
			}
			/* CEXCLUDE */
			
			/**
			 * Fires when the entity has been destroyed.
			 * @event IgeEntity#destroyed
			 * @param {IgeEntity} The entity that has been destroyed.
			 */
			this.emit('destroyed', this);
	
			// Call IgeObject.destroy()
			IgeObject.prototype.destroy.call(this);
		},
		
		saveSpecialProp: function (obj, i) {
			switch (i) {
				case '_texture':
					if (obj._texture) {
						return {_texture: obj._texture.id()};
					}
					break;
				
				default:
					// Call super-class saveSpecialProp
					return IgeObject.prototype.saveSpecialProp.call(this, obj, i);
			}
			
			return undefined;
		},
		
		loadSpecialProp: function (obj, i) {
			switch (i) {
				case '_texture':
					return {_texture: $ige.engine.$(obj[i])};
				
				default:
					// Call super-class loadSpecialProp
					return IgeObject.prototype.loadSpecialProp.call(this, obj, i);
			}
			
			return undefined;
		},
	
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// INTERACTION
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 * Gets / sets the callback that is fired when a mouse
		 * move event is triggered.
		 * @param {Function=} callback
		 * @example #Hook the mouse move event and stop it propagating further down the scenegraph
		 *     entity.mouseMove(function (event, control) {
		 *         // Mouse moved with button
		 *         console.log('Mouse move button: ' + event.button);
		 *
		 *         // Stop the event propagating further down the scenegraph
		 *         control.stopPropagation();
		 *
		 *         // You can ALSO stop propagation without the control object
		 *         // reference via the global reference:
		 *         $ige.engine.input.stopPropagation();
		 *     });
		 * @return {*}
		 */
		mouseMove: function (callback) {
			if (callback) {
				this._mouseMove = callback;
				this._mouseEventsActive = true;
				return this;
			}
	
			return this._mouseMove;
		},
	
		/**
		 * Gets / sets the callback that is fired when a mouse
		 * over event is triggered.
		 * @param {Function=} callback
		 * @example #Hook the mouse over event and stop it propagating further down the scenegraph
		 *     entity.mouseOver(function (event, control) {
		 *         // Mouse over with button
		 *         console.log('Mouse over button: ' + event.button);
		 *
		 *         // Stop the event propagating further down the scenegraph
		 *         control.stopPropagation();
		 *
		 *         // You can ALSO stop propagation without the control object
		 *         // reference via the global reference:
		 *         $ige.engine.input.stopPropagation();
		 *     });
		 * @return {*}
		 */
		mouseOver: function (callback) {
			if (callback) {
				this._mouseOver = callback;
				this._mouseEventsActive = true;
				return this;
			}
	
			return this._mouseOver;
		},
	
		/**
		 * Gets / sets the callback that is fired when a mouse
		 * out event is triggered.
		 * @param {Function=} callback
		 * @example #Hook the mouse out event and stop it propagating further down the scenegraph
		 *     entity.mouseOut(function (event, control) {
		 *         // Mouse out with button
		 *         console.log('Mouse out button: ' + event.button);
		 *
		 *         // Stop the event propagating further down the scenegraph
		 *         control.stopPropagation();
		 *
		 *         // You can ALSO stop propagation without the control object
		 *         // reference via the global reference:
		 *         $ige.engine.input.stopPropagation();
		 *     });
		 * @return {*}
		 */
		mouseOut: function (callback) {
			if (callback) {
				this._mouseOut = callback;
				this._mouseEventsActive = true;
				return this;
			}
	
			return this._mouseOut;
		},
	
		/**
		 * Gets / sets the callback that is fired when a mouse
		 * up event is triggered.
		 * @param {Function=} callback
		 * @example #Hook the mouse up event and stop it propagating further down the scenegraph
		 *     entity.mouseUp(function (event, control) {
		 *         // Mouse up with button
		 *         console.log('Mouse up button: ' + event.button);
		 *
		 *         // Stop the event propagating further down the scenegraph
		 *         control.stopPropagation();
		 *
		 *         // You can ALSO stop propagation without the control object
		 *         // reference via the global reference:
		 *         $ige.engine.input.stopPropagation();
		 *     });
		 * @return {*}
		 */
		mouseUp: function (callback) {
			if (callback) {
				this._mouseUp = callback;
				this._mouseEventsActive = true;
				return this;
			}
	
			return this._mouseUp;
		},
	
		/**
		 * Gets / sets the callback that is fired when a mouse
		 * down event is triggered.
		 * @param {Function=} callback
		 * @example #Hook the mouse down event and stop it propagating further down the scenegraph
		 *     entity.mouseDown(function (event, control) {
		 *         // Mouse down with button
		 *         console.log('Mouse down button: ' + event.button);
		 *
		 *         // Stop the event propagating further down the scenegraph
		 *         control.stopPropagation();
		 *
		 *         // You can ALSO stop propagation without the control object
		 *         // reference via the global reference:
		 *         $ige.engine.input.stopPropagation();
		 *     });
		 * @return {*}
		 */
		mouseDown: function (callback) {
			if (callback) {
				this._mouseDown = callback;
				this._mouseEventsActive = true;
				return this;
			}
	
			return this._mouseDown;
		},
		
		/**
		 * Gets / sets the callback that is fired when a mouse
		 * wheel event is triggered.
		 * @param {Function=} callback
		 * @example #Hook the mouse wheel event and stop it propagating further down the scenegraph
		 *     entity.mouseWheel(function (event, control) {
		 *         // Mouse wheel with button
		 *         console.log('Mouse wheel button: ' + event.button);
		 *         console.log('Mouse wheel delta: ' + event.wheelDelta);
		 *
		 *         // Stop the event propagating further down the scenegraph
		 *         control.stopPropagation();
		 *
		 *         // You can ALSO stop propagation without the control object
		 *         // reference via the global reference:
		 *         $ige.engine.input.stopPropagation();
		 *     });
		 * @return {*}
		 */
		mouseWheel: function (callback) {
			if (callback) {
				this._mouseWheel = callback;
				this._mouseEventsActive = true;
				return this;
			}
	
			return this._mouseWheel;
		},
		
		/**
		 * Removes the callback that is fired when a mouse
		 * move event is triggered.
		 */
		mouseMoveOff: function () {
			delete this._mouseMove;
	
			return this;
		},
	
		/**
		 * Removes the callback that is fired when a mouse
		 * over event is triggered.
		 */
		mouseOverOff: function () {
			delete this._mouseOver;
	
			return this;
		},
		
		/**
		 * Removes the callback that is fired when a mouse
		 * out event is triggered.
		 */
		mouseOutOff: function () {
			delete this._mouseOut;
	
			return this;
		},
	
		/**
		 * Removes the callback that is fired when a mouse
		 * up event is triggered.
		 */
		mouseUpOff: function () {
			delete this._mouseUp;
	
			return this;
		},
		
		/**
		 * Removes the callback that is fired when a mouse
		 * down event is triggered if the listener was registered
		 * via the mouseDown() method.
		 */
		mouseDownOff: function () {
			delete this._mouseDown;
	
			return this;
		},
	
		/**
		 * Removes the callback that is fired when a mouse
		 * wheel event is triggered.
		 */
		mouseWheelOff: function () {
			delete this._mouseWheel;
	
			return this;
		},
		
		triggerPolygon: function (poly) {
			if (poly !== undefined) {
				this._triggerPolygon = poly;
				return this;
			}
			
			return this._triggerPolygon;
		},
	
		/**
		 * Gets / sets the shape / polygon that the mouse events
		 * are triggered against. There are two options, 'aabb' and
		 * 'isoBounds'. The default is 'aabb'.
		 * @param val
		 * @returns {*}
		 * @deprecated
		 */
		mouseEventTrigger: function (val) {
			this.log('mouseEventTrigger is no longer in use. Please see triggerPolygon() instead.', 'warning');
			/*if (val !== undefined) {
				// Set default value
				this._mouseEventTrigger = 0;
				
				switch (val) {
					case 'isoBounds':
						this._mouseEventTrigger = 1;
						break;
					
					case 'custom':
						this._mouseEventTrigger = 2;
						break;
					
					case 'aabb':
						this._mouseEventTrigger = 0;
						break;
				}
				return this;
			}
			
			return this._mouseEventTrigger === 0 ? 'aabb' : 'isoBounds';*/
		},
	
		/**
		 * Handler method that determines which mouse-move event
		 * to fire, a mouse-over or a mouse-move.
		 * @private
		 */
		_handleMouseIn: function (event, evc, data) {
			// Check if the mouse move is a mouse over
			if (!this._mouseStateOver) {
				this._mouseStateOver = true;
				if (this._mouseOver) { this._mouseOver(event, evc, data); }
				
				/**
				 * Fires when the mouse moves over the entity.
				 * @event IgeEntity#mouseOver
				 * @param {Object} The DOM event object.
				 * @param {Object} The IGE event control object.
				 * @param {*} Any further event data.
				 */
				this.emit('mouseOver', [event, evc, data]);
			}
	
			if (this._mouseMove) { this._mouseMove(event, evc, data); }
			this.emit('mouseMove', [event, evc, data]);
		},
	
		/**
		 * Handler method that determines if a mouse-out event
		 * should be fired.
		 * @private
		 */
		_handleMouseOut: function (event, evc, data) {
			// The mouse went away from this entity so
			// set mouse-down to false, regardless of the situation
			this._mouseStateDown = false;
	
			// Check if the mouse move is a mouse out
			if (this._mouseStateOver) {
				this._mouseStateOver = false;
				if (this._mouseOut) { this._mouseOut(event, evc, data); }
				
				/**
				 * Fires when the mouse moves away from the entity.
				 * @event IgeEntity#mouseOut
				 * @param {Object} The DOM event object.
				 * @param {Object} The IGE event control object.
				 * @param {*} Any further event data.
				 */
				this.emit('mouseOut', [event, evc, data]);
			}
		},
		
		/**
		 * Handler method that determines if a mouse-wheel event
		 * should be fired.
		 * @private
		 */
		_handleMouseWheel: function (event, evc, data) {
			if (this._mouseWheel) { this._mouseWheel(event, evc, data); }
			
			/**
			 * Fires when the mouse wheel is moved over the entity.
			 * @event IgeEntity#mouseWheel
			 * @param {Object} The DOM event object.
			 * @param {Object} The IGE event control object.
			 * @param {*} Any further event data.
			 */
			this.emit('mouseWheel', [event, evc, data]);
		},
	
		/**
		 * Handler method that determines if a mouse-up event
		 * should be fired.
		 * @private
		 */
		_handleMouseUp: function (event, evc, data) {
			// Reset the mouse-down flag
			this._mouseStateDown = false;
			if (this._mouseUp) { this._mouseUp(event, evc, data); }
			
			/**
			 * Fires when a mouse up occurs on the entity.
			 * @event IgeEntity#mouseUp
			 * @param {Object} The DOM event object.
			 * @param {Object} The IGE event control object.
			 * @param {*} Any further event data.
			 */
			this.emit('mouseUp', [event, evc, data]);
		},
	
		/**
		 * Handler method that determines if a mouse-down event
		 * should be fired.
		 * @private
		 */
		_handleMouseDown: function (event, evc, data) {
			if (!this._mouseStateDown) {
				this._mouseStateDown = true;
				if (this._mouseDown) { this._mouseDown(event, evc, data); }
				
				/**
				 * Fires when a mouse down occurs on the entity.
				 * @event IgeEntity#mouseDown
				 * @param {Object} The DOM event object.
				 * @param {Object} The IGE event control object.
				 * @param {*} Any further event data.
				 */
				this.emit('mouseDown', [event, evc, data]);
			}
		},
		
		/**
		 * Checks mouse input types and fires the correct mouse event
		 * handler. This is an internal method that should never be
		 * called externally.
		 * @param {Object} evc The input component event control object.
		 * @param {Object} data Data passed by the input component into
		 * the new event.
		 * @private
		 */
		_mouseInTrigger: function (evc, data) {
			if ($ige.engine.input.mouseMove) {
				// There is a mouse move event
				this._handleMouseIn($ige.engine.input.mouseMove, evc, data);
			}
	
			if ($ige.engine.input.mouseDown) {
				// There is a mouse down event
				this._handleMouseDown($ige.engine.input.mouseDown, evc, data);
			}
	
			if ($ige.engine.input.mouseUp) {
				// There is a mouse up event
				this._handleMouseUp($ige.engine.input.mouseUp, evc, data);
			}
			
			if ($ige.engine.input.mouseWheel) {
				// There is a mouse wheel event
				this._handleMouseWheel($ige.engine.input.mouseWheel, evc, data);
			}
		},
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// TRANSFORM
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 * Enables tracing calls which inadvertently assign NaN values to
		 * transformation properties. When called on an entity this system
		 * will break with a debug line when a transform property is set
		 * to NaN allowing you to step back through the call stack and
		 * determine where the offending value originated.
		 * @returns {IgeEntity}
		 */
		debugTransforms: function () {
			$ige.engine.traceSet(this._translate, 'x', 1, function (val) {
				return isNaN(val);
			});
			
			$ige.engine.traceSet(this._translate, 'y', 1, function (val) {
				return isNaN(val);
			});
			
			$ige.engine.traceSet(this._translate, 'z', 1, function (val) {
				return isNaN(val);
			});
			
			$ige.engine.traceSet(this._rotate, 'x', 1, function (val) {
				return isNaN(val);
			});
			
			$ige.engine.traceSet(this._rotate, 'y', 1, function (val) {
				return isNaN(val);
			});
			
			$ige.engine.traceSet(this._rotate, 'z', 1, function (val) {
				return isNaN(val);
			});
			
			$ige.engine.traceSet(this._scale, 'x', 1, function (val) {
				return isNaN(val);
			});
			
			$ige.engine.traceSet(this._scale, 'y', 1, function (val) {
				return isNaN(val);
			});
			
			$ige.engine.traceSet(this._scale, 'z', 1, function (val) {
				return isNaN(val);
			});
			
			return this;
		},
		
		velocityTo: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._velocity.x = x;
				this._velocity.y = y;
				this._velocity.z = z;
			} else {
				this.log('velocityTo() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
		
		velocityBy: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._velocity.x += x;
				this._velocity.y += y;
				this._velocity.z += z;
			} else {
				this.log('velocityBy() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
		
		/**
		 * Translates the entity by adding the passed values to
		 * the current translation values.
		 * @param {Number} x The x co-ordinate.
		 * @param {Number} y The y co-ordinate.
		 * @param {Number} z The z co-ordinate.
		 * @example #Translate the entity by 10 along the x axis
		 *     entity.translateBy(10, 0, 0);
		 * @return {*}
		 */
		translateBy: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._translate.x += x;
				this._translate.y += y;
				this._translate.z += z;
			} else {
				this.log('translateBy() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
	
		/**
		 * Translates the entity to the passed values.
		 * @param {Number} x The x co-ordinate.
		 * @param {Number} y The y co-ordinate.
		 * @param {Number} z The z co-ordinate.
		 * @example #Translate the entity to 10, 0, 0
		 *     entity.translateTo(10, 0, 0);
		 * @return {*}
		 */
		translateTo: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._translate.x = x;
				this._translate.y = y;
				this._translate.z = z;
			} else {
				this.log('translateTo() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
	
		/**
		 * Translates the entity to the passed point.
		 * @param {IgePoint3d} point The point with co-ordinates.
		 * @example #Translate the entity to 10, 0, 0
		 *     var point = new IgePoint3d(10, 0, 0),
		 *         entity = new IgeEntity();
		 *
		 *     entity.translateToPoint(point);
		 * @return {*}
		 */
		translateToPoint: function (point) {
			if (point !== undefined) {
				this._translate.x = point.x;
				this._translate.y = point.y;
				this._translate.z = point.z;
			} else {
				this.log('translateToPoint() called with a missing or undefined point parameter!', 'error');
			}
	
			return this._entity || this;
		},
		
		/**
		 * Translates the object to the tile co-ordinates passed.
		 * @param {Number} x The x tile co-ordinate.
		 * @param {Number} y The y tile co-ordinate.
		 * @param {Number=} z The z tile co-ordinate.
		 * @example #Translate entity to tile
		 *     // Create a tile map
		 *     var tileMap = new IgeTileMap2d()
		 *         .tileWidth(40)
		 *         .tileHeight(40);
		 *
		 *     // Mount our entity to the tile map
		 *     entity.mount(tileMap);
		 *
		 *     // Translate the entity to the tile x:10, y:12
		 *     entity.translateToTile(10, 12, 0);
		 * @return {*} The object this method was called from to allow
		 * method chaining.
		 */
		translateToTile: function (x, y, z) {
			if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
				var finalZ;
	
				// Handle being passed a z co-ordinate
				if (z !== undefined) {
					finalZ = z * this._parent._tileWidth;
				} else {
					finalZ = this._translate.z;
				}
	
				this.translateTo((x * this._parent._tileWidth) + this._parent._tileWidth / 2, (y * this._parent._tileHeight) + this._parent._tileWidth / 2, finalZ);
			} else {
				this.log('Cannot translate to tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
			}
	
			return this;
		},
	
		/**
		 * Gets the translate accessor object.
		 * @example #Use the translate accessor object to alter the y co-ordinate of the entity to 10
		 *     entity.translate().y(10);
		 * @return {*}
		 */
		translate: function () {
			if (arguments.length) {
				this.log('You called translate with arguments, did you mean translateTo or translateBy instead of translate?', 'warning');
			}
	
			this.x = this._translateAccessorX;
			this.y = this._translateAccessorY;
			this.z = this._translateAccessorZ;
	
			return this._entity || this;
		},
	
		/**
		 * The translate accessor method for the x axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.translate().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_translateAccessorX: function (val) {
			if (val !== undefined) {
				this._translate.x = val;
				return this._entity || this;
			}
	
			return this._translate.x;
		},
	
		/**
		 * The translate accessor method for the y axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.translate().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_translateAccessorY: function (val) {
			if (val !== undefined) {
				this._translate.y = val;
				return this._entity || this;
			}
	
			return this._translate.y;
		},
	
		/**
		 * The translate accessor method for the z axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.translate().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_translateAccessorZ: function (val) {
			// TODO: Do we need to do anything to the matrix here for iso views?
			//this._localMatrix.translateTo(this._translate.x, this._translate.y);
			if (val !== undefined) {
				this._translate.z = val;
				return this._entity || this;
			}
	
			return this._translate.z;
		},
	
		/**
		 * Rotates the entity by adding the passed values to
		 * the current rotation values.
		 * @param {Number} x The x co-ordinate.
		 * @param {Number} y The y co-ordinate.
		 * @param {Number} z The z co-ordinate.
		 * @example #Rotate the entity by 10 degrees about the z axis
		 *     entity.rotateBy(0, 0, Math.radians(10));
		 * @return {*}
		 */
		rotateBy: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._rotate.x += x;
				this._rotate.y += y;
				this._rotate.z += z;
			} else {
				this.log('rotateBy() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
	
		/**
		 * Rotates the entity to the passed values.
		 * @param {Number} x The x co-ordinate.
		 * @param {Number} y The y co-ordinate.
		 * @param {Number} z The z co-ordinate.
		 * @example #Rotate the entity to 10 degrees about the z axis
		 *     entity.rotateTo(0, 0, Math.radians(10));
		 * @return {*}
		 */
		rotateTo: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._rotate.x = x;
				this._rotate.y = y;
				this._rotate.z = z;
			} else {
				this.log('rotateTo() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
	
		/**
		 * Gets the translate accessor object.
		 * @example #Use the rotate accessor object to rotate the entity about the z axis 10 degrees
		 *     entity.rotate().z(Math.radians(10));
		 * @return {*}
		 */
		rotate: function () {
			if (arguments.length) {
				this.log('You called rotate with arguments, did you mean rotateTo or rotateBy instead of rotate?', 'warning');
			}
			
			this.x = this._rotateAccessorX;
			this.y = this._rotateAccessorY;
			this.z = this._rotateAccessorZ;
	
			return this._entity || this;
		},
	
		/**
		 * The rotate accessor method for the x axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.rotate().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_rotateAccessorX: function (val) {
			if (val !== undefined) {
				this._rotate.x = val;
				return this._entity || this;
			}
	
			return this._rotate.x;
		},
	
		/**
		 * The rotate accessor method for the y axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.rotate().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_rotateAccessorY: function (val) {
			if (val !== undefined) {
				this._rotate.y = val;
				return this._entity || this;
			}
	
			return this._rotate.y;
		},
	
		/**
		 * The rotate accessor method for the z axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.rotate().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_rotateAccessorZ: function (val) {
			if (val !== undefined) {
				this._rotate.z = val;
				return this._entity || this;
			}
	
			return this._rotate.z;
		},
	
		/**
		 * Scales the entity by adding the passed values to
		 * the current scale values.
		 * @param {Number} x The x co-ordinate.
		 * @param {Number} y The y co-ordinate.
		 * @param {Number} z The z co-ordinate.
		 * @example #Scale the entity by 2 on the x axis
		 *     entity.scaleBy(2, 0, 0);
		 * @return {*}
		 */
		scaleBy: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._scale.x += x;
				this._scale.y += y;
				this._scale.z += z;
			} else {
				this.log('scaleBy() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
	
		/**
		 * Scale the entity to the passed values.
		 * @param {Number} x The x co-ordinate.
		 * @param {Number} y The y co-ordinate.
		 * @param {Number} z The z co-ordinate.
		 * @example #Set the entity scale to 1 on all axes
		 *     entity.scaleTo(1, 1, 1);
		 * @return {*}
		 */
		scaleTo: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._scale.x = x;
				this._scale.y = y;
				this._scale.z = z;
			} else {
				this.log('scaleTo() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
	
		/**
		 * Gets the scale accessor object.
		 * @example #Use the scale accessor object to set the scale of the entity on the x axis to 1
		 *     entity.scale().x(1);
		 * @return {*}
		 */
		scale: function () {
			if (arguments.length) {
				this.log('You called scale with arguments, did you mean scaleTo or scaleBy instead of scale?', 'warning');
			}
			
			this.x = this._scaleAccessorX;
			this.y = this._scaleAccessorY;
			this.z = this._scaleAccessorZ;
	
			return this._entity || this;
		},
	
		/**
		 * The scale accessor method for the x axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.scale().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_scaleAccessorX: function (val) {
			if (val !== undefined) {
				this._scale.x = val;
				return this._entity || this;
			}
	
			return this._scale.x;
		},
	
		/**
		 * The scale accessor method for the y axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.scale().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_scaleAccessorY: function (val) {
			if (val !== undefined) {
				this._scale.y = val;
				return this._entity || this;
			}
	
			return this._scale.y;
		},
	
		/**
		 * The scale accessor method for the z axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.scale().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_scaleAccessorZ: function (val) {
			if (val !== undefined) {
				this._scale.z = val;
				return this._entity || this;
			}
	
			return this._scale.z;
		},
	
		/**
		 * Sets the origin of the entity by adding the passed values to
		 * the current origin values.
		 * @param {Number} x The x co-ordinate.
		 * @param {Number} y The y co-ordinate.
		 * @param {Number} z The z co-ordinate.
		 * @example #Add 0.5 to the origin on the x axis
		 *     entity.originBy(0.5, 0, 0);
		 * @return {*}
		 */
		originBy: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._origin.x += x;
				this._origin.y += y;
				this._origin.z += z;
			} else {
				this.log('originBy() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
	
		/**
		 * Set the origin of the entity to the passed values.
		 * @param {Number} x The x co-ordinate.
		 * @param {Number} y The y co-ordinate.
		 * @param {Number} z The z co-ordinate.
		 * @example #Set the entity origin to 0.5 on all axes
		 *     entity.originTo(0.5, 0.5, 0.5);
		 * @return {*}
		 */
		originTo: function (x, y, z) {
			if (x !== undefined && y!== undefined && z !== undefined) {
				this._origin.x = x;
				this._origin.y = y;
				this._origin.z = z;
			} else {
				this.log('originTo() called with a missing or undefined x, y or z parameter!', 'error');
			}
	
			return this._entity || this;
		},
	
		/**
		 * Gets the origin accessor object.
		 * @example #Use the origin accessor object to set the origin of the entity on the x axis to 1
		 *     entity.origin().x(1);
		 * @return {*}
		 */
		origin: function () {
			this.x = this._originAccessorX;
			this.y = this._originAccessorY;
			this.z = this._originAccessorZ;
	
			return this._entity || this;
		},
	
		/**
		 * The origin accessor method for the x axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.origin().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_originAccessorX: function (val) {
			if (val !== undefined) {
				this._origin.x = val;
				return this._entity || this;
			}
	
			return this._origin.x;
		},
	
		/**
		 * The origin accessor method for the y axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.origin().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_originAccessorY: function (val) {
			if (val !== undefined) {
				this._origin.y = val;
				return this._entity || this;
			}
	
			return this._origin.y;
		},
	
		/**
		 * The origin accessor method for the z axis. This
		 * method is not called directly but is accessed through
		 * the accessor object obtained by calling entity.origin().
		 * @param {Number=} val The new value to apply to the co-ordinate.
		 * @return {*}
		 * @private
		 */
		_originAccessorZ: function (val) {
			if (val !== undefined) {
				this._origin.z = val;
				return this._entity || this;
			}
	
			return this._origin.z;
		},
	
		_rotatePoint: function (point, radians, origin) {
			var cosAngle = Math.cos(radians),
				sinAngle = Math.sin(radians);
	
			return {
				x: origin.x + (point.x - origin.x) * cosAngle + (point.y - origin.y) * sinAngle,
				y: origin.y - (point.x - origin.x) * sinAngle + (point.y - origin.y) * cosAngle
			};
		},
	
		/**
		 * Checks the current transform values against the previous ones. If
		 * any value is different, the appropriate method is called which will
		 * update the transformation matrix accordingly.
		 */
		updateTransform: function () {
			this._localMatrix.identity();
			
			if (this._mode === 0) {
				// 2d translation
				this._localMatrix.multiply(this._localMatrix._newTranslate(this._translate.x, this._translate.y));
			}
	
			if (this._mode === 1) {
				// iso translation
				var isoPoint = this._translateIso = new IgePoint3d(
					this._translate.x,
					this._translate.y,
					this._translate.z + this._bounds3d.z / 2
				).toIso();
	
				if (this._parent && this._parent._bounds3d.z) {
					// This adjusts the child entity so that 0, 0, 0 inside the
					// parent is the center of the base of the parent
					isoPoint.y += this._parent._bounds3d.z / 1.6;
				}
	
				this._localMatrix.multiply(this._localMatrix._newTranslate(isoPoint.x, isoPoint.y));
			}
			
			this._localMatrix.rotateBy(this._rotate.z);
			this._localMatrix.scaleBy(this._scale.x, this._scale.y);
			
			// Adjust local matrix for origin values if not at center
			if (this._origin.x !== 0.5 || this._origin.y !== 0.5) {
				this._localMatrix.translateBy(
					(this._bounds2d.x * (0.5 - this._origin.x)),
					(this._bounds2d.y * (0.5 - this._origin.y))
				);
			}
			
			// TODO: If the parent and local transforms are unchanged, we should used cached values
			if (this._parent) {
				this._worldMatrix.copy(this._parent._worldMatrix);
				this._worldMatrix.multiply(this._localMatrix);
			} else {
				this._worldMatrix.copy(this._localMatrix);
			}
			
			// Check if the world matrix has changed and if so, set a few flags
			// to allow other methods to know that a matrix change has occurred
			if (!this._worldMatrix.compare(this._oldWorldMatrix)) {
				this._oldWorldMatrix.copy(this._worldMatrix);
				this._transformChanged = true;
				this._aabbDirty = true;
				this._bounds3dPolygonDirty = true;
			} else {
				this._transformChanged = false;
			}
			
			// Check if the geometry has changed and if so, update the aabb dirty
			if (!this._oldBounds2d.compare(this._bounds2d)) {
				this._aabbDirty = true;
				
				// Record the new geometry to the oldGeometry data
				this._oldBounds2d.copy(this._bounds2d);
			}
			
			if (!this._oldBounds3d.compare(this._bounds3d)) {
				this._bounds3dPolygonDirty = true;
				
				// Record the new geometry to the oldGeometry data
				this._oldBounds3d.copy(this._bounds3d);
			}
			
			return this;
		},
	
		/**
		 * Gets / sets the disable interpolation flag. If set to true then
		 * stream data being received by the client will not be interpolated
		 * and will be instantly assigned instead. Useful if your entity's
		 * transformations should not be interpolated over time.
		 * @param val
		 * @returns {*}
		 */
		disableInterpolation: function (val) {
			if (val !== undefined) {
				this._disableInterpolation = val;
				return this;
			}
			
			return this._disableInterpolation;
		},
		
		/**
		 * Calculates the distance to the passed entity from this one.
		 * @param {IgeEntity} entity The entity to calculate distance
		 * to.
		 * @returns {Number} Distance.
		 */
		distanceTo: function (entity) {
			var a = this._translate.x - entity._translate.x,
				b = this._translate.y - entity._translate.y;
			
			return Math.sqrt(a * a + b * b);
		},
	
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// STREAM
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 * Gets / sets the array of sections that this entity will
		 * encode into its stream data.
		 * @param {Array=} sectionArray An array of strings.
		 * @example #Define the sections this entity will use in the network stream. Use the default "transform" section as well as a "custom1" section
		 *     entity.streamSections('transform', 'custom1');
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		streamSections: function (sectionArray) {
			if (sectionArray !== undefined) {
				this._streamSections = sectionArray;
				return this;
			}
	
			return this._streamSections;
		},
		
		/**
		 * Pushes a section into the stream sections array that this
		 * entity will encode into its stream data.
		 * @param {String} section The section to push into the sections array.
		 * @example #Push a section to the sections array this entity will use in the network stream.
		 *     entity.streamSectionsPush('transform');
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		streamSectionsPush: function (sectionName) {
			this._streamSections = this._streamSections || [];
			this._streamSections.push(sectionName);
	
			return this;
		},
	
		/**
		 * Removes a section into the existing streamed sections array.
		 * @param {String} sectionName The section name to remove.
		 */
		streamSectionsPull: function (sectionName) {
			if (this._streamSections) {
				this._streamSections.pull(sectionName);
			}
	
			return this;
		},
	
		/**
		 * Gets / sets a streaming property on this entity. If set, the
		 * property's new value is streamed to clients on the next packet.
		 *
		 * @param {String} propName The name of the property to get / set.
		 * @param {*=} propVal Optional. If provided, the property is set
		 * to this value.
		 * @return {*} "this" when a propVal argument is passed to allow method
		 * chaining or the current value if no propVal argument is specified.
		 */
		streamProperty: function (propName, propVal) {
			var stream = $ige.engine.network.stream;
			
			this._streamProperty = this._streamProperty || {};
			stream._streamPropertyChange = stream._streamPropertyChange || {};
			stream._streamPropertyChange[this._id] = stream._streamPropertyChange[this._id] || {};
	
			if (propName !== undefined) {
				if (propVal !== undefined) {
					if (this._streamProperty[propName] !== propVal) {
						stream._streamPropertyChange[this._id][propName] = true;
					}
					
					this._streamProperty[propName] = propVal;
	
					return this;
				}
	
				return this._streamProperty[propName];
			}
	
			return undefined;
		},
	
		/**
		 * Gets / sets the data for the specified data section id. This method
		 * is usually not called directly and instead is part of the network
		 * stream system. General use case is to write your own custom streamSectionData
		 * method in a class that extends IgeEntity so that you can control the
		 * data that the entity will send and receive over the network stream.
		 * @param {String} sectionId A string identifying the section to
		 * handle data get / set for.
		 * @param {*=} data If present, this is the data that has been sent
		 * from the server to the client for this entity.
		 * @param {Boolean=} bypassTimeStream If true, will assign transform
		 * directly to entity instead of adding the values to the time stream.
		 * @param {Boolean=} bypassChangeDetection If set to true, bypasses
		 * any change detection on stream data (useful especially when we are
		 * sending stream data to a client for the first time even if the data
		 * has existed on the server for a while - ensuring that even unchanged
		 * data makes it to the new client).
		 * @return {*} "this" when a data argument is passed to allow method
		 * chaining or the current value if no data argument is specified.
		 */
		streamSectionData: function (sectionId, data, bypassTimeStream, bypassChangeDetection) {
			var stream,
				geom,
				dataArr,
				newData,
				changed,
				newParent,
				parent,
				props,
				i;
			
			switch (sectionId) {
				case 'transform':
					if (data) {
						// We have received updated data
						dataArr = data.split(',');
		
						if (!this._disableInterpolation && !bypassTimeStream && !this._streamJustCreated) {
							// Translate
							if (dataArr[0]) { dataArr[0] = parseFloat(dataArr[0]); }
							if (dataArr[1]) { dataArr[1] = parseFloat(dataArr[1]); }
							if (dataArr[2]) { dataArr[2] = parseFloat(dataArr[2]); }
		
							// Scale
							if (dataArr[3]) { dataArr[3] = parseFloat(dataArr[3]); }
							if (dataArr[4]) { dataArr[4] = parseFloat(dataArr[4]); }
							if (dataArr[5]) { dataArr[5] = parseFloat(dataArr[5]); }
		
							// Rotate
							if (dataArr[6]) { dataArr[6] = parseFloat(dataArr[6]); }
							if (dataArr[7]) { dataArr[7] = parseFloat(dataArr[7]); }
							if (dataArr[8]) { dataArr[8] = parseFloat(dataArr[8]); }
		
							// Add it to the time stream
							this._timeStream.push([$ige.engine.network.stream._streamDataTime + $ige.engine.network._latency, dataArr]);
		
							// Check stream length, don't allow higher than 10 items
							if (this._timeStream.length > 10) {
								// Remove the first item
								this._timeStream.shift();
							}
						} else {
							// Assign all the transform values immediately
							if (dataArr[0]) { this._translate.x = parseFloat(dataArr[0]); }
							if (dataArr[1]) { this._translate.y = parseFloat(dataArr[1]); }
							if (dataArr[2]) { this._translate.z = parseFloat(dataArr[2]); }
		
							// Scale
							if (dataArr[3]) { this._scale.x = parseFloat(dataArr[3]); }
							if (dataArr[4]) { this._scale.y = parseFloat(dataArr[4]); }
							if (dataArr[5]) { this._scale.z = parseFloat(dataArr[5]); }
		
							// Rotate
							if (dataArr[6]) { this._rotate.x = parseFloat(dataArr[6]); }
							if (dataArr[7]) { this._rotate.y = parseFloat(dataArr[7]); }
							if (dataArr[8]) { this._rotate.z = parseFloat(dataArr[8]); }
							
							// If we are using composite caching ensure we update the cache
							if (this._compositeCache) {
								this.cacheDirty(true);
							}
						}
					} else {
						// We should return stringified data
						return this._translate.toString(this._streamFloatPrecision) + ',' + // translate
							this._scale.toString(this._streamFloatPrecision) + ',' + // scale
							this._rotate.toString(this._streamFloatPrecision) + ','; // rotate
					}
					break;
				
				case 'depth':
						if (data !== undefined) {
							if ($ige.isClient) {
								this.depth(parseInt(data));
							}
						} else {
							return String(this.depth());
						}
						break;
					
				case 'layer':
					if (data !== undefined) {
						if ($ige.isClient) {
							this.layer(parseInt(data));
						}
					} else {
						return String(this.layer());
					}
					break;
				
				case 'bounds2d':
					if (data !== undefined) {
						if ($ige.isClient) {
							geom = data.split(',');
							this.bounds2d(parseFloat(geom[0]), parseFloat(geom[1]));
						}
					} else {
						return String(this._bounds2d.x + ',' + this._bounds2d.y);
					}
					break;
				
				case 'bounds3d':
					if (data !== undefined) {
						if ($ige.isClient) {
							geom = data.split(',');
							this.bounds3d(parseFloat(geom[0]), parseFloat(geom[1]), parseFloat(geom[2]));
						}
					} else {
						return String(this._bounds3d.x + ',' + this._bounds3d.y + ',' + this._bounds3d.z);
					}
					break;
				
				case 'hidden':
					if (data !== undefined) {
						if ($ige.isClient) {
							if (data === 'true') {
								this.hide();
							} else {
								this.show();
							}
						}
					} else {
						return String(this.isHidden());
					}
					break;
				
				case 'mount':
					if (data !== undefined) {
						if ($ige.isClient) {
							if (data) {
								newParent = $ige.engine.$(data);
								
								if (newParent) {
									this.mount(newParent);
								}
							} else {
								// Unmount
								this.unMount();
							}
						}
					} else {
						parent = this.parent();
						
						if (parent) {
							return this.parent().id();
						} else {
							return '';
						}
					}
					break;
				
				case 'origin':
					if (data !== undefined) {
						if ($ige.isClient) {
							geom = data.split(',');
							this.origin(parseFloat(geom[0]), parseFloat(geom[1]), parseFloat(geom[2]));
						}
					} else {
						return String(this._origin.x + ',' + this._origin.y + ',' + this._origin.z);
					}
					break;
	
				case 'props':
					if (data !== undefined) {
						if ($ige.isClient) {
							props = JSON.parse(data);
	
							// Update properties that have been sent through
							for (i in props) {
								if (props.hasOwnProperty(i)) {
									changed = false;
									if (props.hasOwnProperty(i)) {
										if (this._streamProperty[i] !== props[i]) {
											//console.log('Updated stream property ' + i + ' to', props[i]);
											changed = true;
										}
										this._streamProperty[i] = props[i];
										
										this.emit('streamPropChange', [i, props[i]]);
									}
								}
							}
						}
					} else {
						stream = $ige.engine.network.stream;
						newData = {};
	
						for (i in this._streamProperty) {
							if (this._streamProperty.hasOwnProperty(i)) {
								if ((stream._streamPropertyChange && stream._streamPropertyChange[this._id] && stream._streamPropertyChange[this._id][i]) || bypassChangeDetection) {
									newData[i] = this._streamProperty[i];
								}
							}
						}
	
						return JSON.stringify(newData);
					}
					break;
			}
		},
	
		/* CEXCLUDE */
		/**
		 * Gets / sets the stream mode that the stream system will use when
		 * handling pushing data updates to connected clients.
		 * @param {Number=} val A value representing the stream mode.
		 * @example #Set the entity to disable streaming
		 *     entity.streamMode(0);
		 * @example #Set the entity to automatic streaming
		 *     entity.streamMode(1);
		 * @example #Set the entity to manual (advanced mode) streaming
		 *     entity.streamMode(2);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		streamMode: function (val) {
			if (val !== undefined) {
				if ($ige.isServer) {
					this._streamMode = val;
				}
				return this;
			}
	
			return this._streamMode;
		},
	
		/**
		 * Gets / sets the stream control callback function that will be called
		 * each time the entity tick method is called and stream-able data is
		 * updated.
		 * @param {Function=} method The stream control method.
		 * @example #Set the entity's stream control method to control when this entity is streamed and when it is not
		 *     entity.streamControl(function (clientId) {
		 *         // Let's use an example where we only want this entity to stream
		 *         // to one particular client with the id 4039589434
		 *         if (clientId === '4039589434') {
		 *             // Returning true tells the network stream to send data
		 *             // about this entity to the client
		 *             return true;
		 *         } else {
		 *             // Returning false tells the network stream NOT to send
		 *             // data about this entity to the client
		 *             return false;
		 *         }
		 *     });
		 *
		 * Further reading: [Controlling Streaming](http://www.isogenicengine.com/documentation/isogenic-game-engine/versions/1-1-0/manual/networking-multiplayer/realtime-network-streaming/stream-modes-and-controlling-streaming/)
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		streamControl: function (method) {
			if (method !== undefined) {
				this._streamControl = method;
				return this;
			}
	
			return this._streamControl;
		},
	
		/**
		 * Gets / sets the stream sync interval. This value
		 * is in milliseconds and cannot be lower than 16. It will
		 * determine how often data from this entity is added to the
		 * stream queue.
		 * @param {Number=} val Number of milliseconds between adding
		 * stream data for this entity to the stream queue.
		 * @param {String=} sectionId Optional id of the stream data
		 * section you want to set the interval for. If omitted the
		 * interval will be applied to all sections.
		 * @example #Set the entity's stream update (sync) interval to 1 second because this entity's data is not highly important to the simulation so save some bandwidth!
		 *     entity.streamSyncInterval(1000);
		 * @example #Set the entity's stream update (sync) interval to 16 milliseconds because this entity's data is very important to the simulation so send as often as possible!
		 *     entity.streamSyncInterval(16);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		streamSyncInterval: function (val, sectionId) {
			if (val !== undefined) {
				if (!sectionId) {
					if (val < 16) {
						delete this._streamSyncInterval;
					} else {
						this._streamSyncDelta = 0;
						this._streamSyncInterval = val;
					}
				} else {
					this._streamSyncSectionInterval = this._streamSyncSectionInterval || {};
					this._streamSyncSectionDelta = this._streamSyncSectionDelta || {};
					if (val < 16) {
						delete this._streamSyncSectionInterval[sectionId];
					} else {
						this._streamSyncSectionDelta[sectionId] = 0;
						this._streamSyncSectionInterval[sectionId] = val;
					}
				}
				return this;
			}
	
			return this._streamSyncInterval;
		},
	
		/**
		 * Gets / sets the precision by which floating-point values will
		 * be encoded and sent when packaged into stream data.
		 * @param {Number=} val The number of decimal places to preserve.
		 * @example #Set the float precision to 2
		 *     // This will mean that any data using floating-point values
		 *     // that gets sent across the network stream will be rounded
		 *     // to 2 decimal places. This helps save bandwidth by not
		 *     // having to send the entire number since precision above
		 *     // 2 decimal places is usually not that important to the
		 *     // simulation.
		 *     entity.streamFloatPrecision(2);
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		streamFloatPrecision: function (val) {
			if (val !== undefined) {
				this._streamFloatPrecision = val;
	
				var i, floatRemove = '\\.';
	
				// Update the floatRemove regular expression pattern
				for (i = 0; i < this._streamFloatPrecision; i++) {
					floatRemove += '0';
				}
	
				// Add the trailing comma
				floatRemove += ',';
	
				// Create the new regexp
				this._floatRemoveRegExp = new RegExp(floatRemove, 'g');
	
				return this;
			}
	
			return this._streamFloatPrecision;
		},
	
		/**
		 * Queues stream data for this entity to be sent to the
		 * specified client id or array of client ids.
		 * @param {Array} clientId An array of string IDs of each
		 * client to send the stream data to.
		 * @return {IgeEntity} "this".
		 */
		streamSync: function (clientId) {
			if (this._streamMode === 1) {
				// Check if we have a stream sync interval
				if (this._streamSyncInterval) {
					this._streamSyncDelta += $time._tickDelta;
	
					if (this._streamSyncDelta < this._streamSyncInterval) {
						// The stream sync interval is still higher than
						// the stream sync delta so exit without calling the
						// stream sync method
						return this;
					} else {
						// We've reached the delta we want so zero it now
						// ready for the next loop
						this._streamSyncDelta = 0;
					}
				}
	
				// Grab an array of connected clients from the network
				// system
				var recipientArr = [],
					clientArr = $ige.engine.network.clients(this._streamRoomId),
					i;
				
				for (i in clientArr) {
					if (clientArr.hasOwnProperty(i)) {
						// Check for a stream control method
						if (this._streamControl) {
							// Call the callback method and if it returns true,
							// send the stream data to this client
							if (this._streamControl.apply(this, [i, this._streamRoomId])) {
								recipientArr.push(i);
							}
						} else {
							// No control method so process for this client
							recipientArr.push(i);
						}
					}
				}
	
				this._streamSync(recipientArr);
				return this;
			}
	
			if (this._streamMode === 2) {
				// Stream mode is advanced
				this._streamSync(clientId, this._streamRoomId);
	
				return this;
			}
	
			return this;
		},
	
		/**
		 * Override this method if your entity should send data through to
		 * the client when it is being created on the client for the first
		 * time through the network stream. The data will be provided as the
		 * first argument in the constructor call to the entity class so
		 * you should expect to receive it as per this example:
		 * @example #Using and Receiving Stream Create Data
		 *     var MyNewClass = IgeEntity.extend({
		 *         classId: 'MyNewClass',
		 *
		 *         // Define the init with the parameter to receive the
		 *         // data you return in the streamCreateData() method
		 *         init: function (myCreateData) {
		 *             this._myData = myCreateData;
		 *         },
		 *
		 *         streamCreateData: function () {
		 *             return this._myData;
		 *         }
		 *     });
		 *
		 * Valid return values must not include circular references!
		 */
		streamCreateData: function () {},
	
		/**
		 * Gets / sets the stream emit created flag. If set to true this entity
		 * emit a "streamCreated" event when it is created by the stream, but
		 * after the id and initial transform are set.
		 * @param val
		 * @returns {*}
		 */
		streamEmitCreated: function (val) {
			if (val !== undefined) {
				this._streamEmitCreated = val;
				return this;
			}
			
			return this._streamEmitCreated;
		},
		
		/**
		 * Asks the stream system to queue the stream data to the specified
		 * client id or array of ids.
		 * @param {Array} recipientArr The array of ids of the client(s) to
		 * queue stream data for. The stream data being queued
		 * is returned by a call to this._streamData().
		 * @param {String} streamRoomId The id of the room the entity belongs
		 * in (can be undefined or null if no room assigned).
		 * @private
		 */
		_streamSync: function (recipientArr, streamRoomId) {
			var arrCount = recipientArr.length,
				arrIndex,
				clientId,
				data,
				stream = $ige.engine.network.stream,
				thisId = this.id(),
				filteredArr = [],
				createResult = true; // We set this to true by default
	
			// Loop the recipient array
			for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
				clientId = recipientArr[arrIndex];
	
				// Check if the client has already received a create
				// command for this entity
				stream._streamClientCreated[thisId] = stream._streamClientCreated[thisId] || {};
				if (!stream._streamClientCreated[thisId][clientId]) {
					createResult = this.streamCreate(clientId);
				}
	
				// Make sure that if we had to create the entity for
				// this client that the create worked before bothering
				// to waste bandwidth on stream updates
				if (createResult) {
					// Get the stream data
					data = this._streamData();
	
					// Is the data different from the last data we sent
					// this client?
					stream._streamClientData[thisId] = stream._streamClientData[thisId] || {};
					
					if (stream._streamClientData[thisId][clientId] !== data) {
						filteredArr.push(clientId);
					}
				}
			}
			
			if (filteredArr.length) {
				stream.queue(thisId, data, filteredArr);
			}
		},
	
		/**
		 * Forces the stream to push this entity's full stream data on the
		 * next stream sync regardless of what clients have received in the
		 * past. This should only be used when required rather than every
		 * tick as it will reduce the overall efficiency of the stream if
		 * used every tick.
		 * @returns {*}
		 */
		streamForceUpdate: function () {
			if ($ige.isServer) {
				var thisId = this.id();
				
				// Invalidate the stream client data lookup to ensure
				// the latest data will be pushed on the next stream sync
				if ($ige.engine.network && $ige.engine.network.stream && $ige.engine.network.stream._streamClientData && $ige.engine.network.stream._streamClientData[thisId]) {
					$ige.engine.network.stream._streamClientData[thisId] = {};
				}
			}
			
			return this;
		},
	
		/**
		 * Issues a create entity command to the passed client id
		 * or array of ids. If no id is passed it will issue the
		 * command to all connected clients. If using streamMode(1)
		 * this method is called automatically.
		 * @param {*} clientId The id or array of ids to send
		 * the command to.
		 * @example #Send a create command for this entity to all clients
		 *     entity.streamCreate();
		 * @example #Send a create command for this entity to an array of client ids
		 *     entity.streamCreate(['43245325', '326755464', '436743453']);
		 * @example #Send a create command for this entity to a single client id
		 *     entity.streamCreate('43245325');
		 * @return {Boolean}
		 */
		streamCreate: function (clientId) {
			if (this._parent) {
				var thisId = this.id(),
					arr,
					i;
	
				// Send the client an entity create command first
				$ige.engine.network.send('_igeStreamCreate', [
					this.classId(),
					thisId,
					this._parent.id(),
					this.streamSectionData('transform'),
					this.streamCreateData()
				], clientId);
				
				$ige.engine.network.stream._streamClientCreated[thisId] = $ige.engine.network.stream._streamClientCreated[thisId] || {};
	
				if (clientId) {
					// Mark the client as having received a create
					// command for this entity
					$ige.engine.network.stream._streamClientCreated[thisId][clientId] = true;
				} else {
					// Mark all clients as having received this create
					arr = $ige.engine.network.clients();
	
					for (i in arr) {
						if (arr.hasOwnProperty(i)) {
							$ige.engine.network.stream._streamClientCreated[thisId][i] = true;
						}
					}
				}
	
				return true;
			}
	
			return false;
		},
	
		/**
		 * Issues a destroy entity command to the passed client id
		 * or array of ids. If no id is passed it will issue the
		 * command to all connected clients. If using streamMode(1)
		 * this method is called automatically.
		 * @param {*} clientId The id or array of ids to send
		 * the command to.
		 * @example #Send a destroy command for this entity to all clients
		 *     entity.streamDestroy();
		 * @example #Send a destroy command for this entity to an array of client ids
		 *     entity.streamDestroy(['43245325', '326755464', '436743453']);
		 * @example #Send a destroy command for this entity to a single client id
		 *     entity.streamDestroy('43245325');
		 * @return {Boolean}
		 */
		streamDestroy: function (clientId) {
			var thisId = this.id(),
				arr,
				i;
	
			// Send clients the stream destroy command for this entity
			$ige.engine.network.send('_igeStreamDestroy', [$time._currentTime, thisId], clientId);
			
			$ige.engine.network.stream._streamClientCreated[thisId] = $ige.engine.network.stream._streamClientCreated[thisId] || {};
			$ige.engine.network.stream._streamClientData[thisId] = $ige.engine.network.stream._streamClientData[thisId] || {};
	
			if (clientId) {
				// Mark the client as having received a destroy
				// command for this entity
				$ige.engine.network.stream._streamClientCreated[thisId][clientId] = false;
				$ige.engine.network.stream._streamClientData[thisId][clientId] = undefined;
			} else {
				// Mark all clients as having received this destroy
				arr = $ige.engine.network.clients();
	
				for (i in arr) {
					if (arr.hasOwnProperty(i)) {
						$ige.engine.network.stream._streamClientCreated[thisId] = {};
					}
				}
			}
			
			return true;
		},
	
		/**
		 * Generates and returns the current stream data for this entity. The
		 * data will usually include only properties that have changed since
		 * the last time the stream data was generated. The returned data is
		 * a string that has been compressed in various ways to reduce network
		 * overhead during transmission.
		 * @return {String} The string representation of the stream data for
		 * this entity.
		 * @private
		 */
		_streamData: function () {
			// Check if we already have a cached version of the streamData
			if (this._streamDataCache) {
				return this._streamDataCache;
			}
			
			// Let's generate our stream data
			var streamData = '',
				sectionDataString = '',
				sectionArr = this._streamSections,
				sectionCount = sectionArr.length,
				sectionData,
				sectionIndex,
				sectionId;

			// Add the entity id
			streamData += this.id();

			// Only send further data if the entity is still "alive"
			if (this._alive) {
				// Now loop the data sections array and compile the rest of the
				// data string from the data section return data
				for (sectionIndex = 0; sectionIndex < sectionCount; sectionIndex++) {
					sectionData = '';
					sectionId = sectionArr[sectionIndex];
					
					// Stream section sync intervals allow individual stream sections
					// to be streamed at different (usually longer) intervals than other
					// sections so you could for instance reduce the number of updates
					// a particular section sends out in a second because the data is
					// not that important compared to updated transformation data
					if (this._streamSyncSectionInterval && this._streamSyncSectionInterval[sectionId]) {
						// Check if the section interval has been reached
						this._streamSyncSectionDelta[sectionId] += $time._tickDelta;

						if (this._streamSyncSectionDelta[sectionId] >= this._streamSyncSectionInterval[sectionId]) {
							// Get the section data for this section id
							sectionData = this.streamSectionData(sectionId);

							// Reset the section delta
							this._streamSyncSectionDelta[sectionId] = 0;
						}
					} else {
						// Get the section data for this section id
						sectionData = this.streamSectionData(sectionId);
					}

					// Add the section start designator character. We do this
					// regardless of if there is actually any section data because
					// we want to be able to identify sections in a serial fashion
					// on receipt of the data string on the client
					sectionDataString += $ige.engine.network.stream._sectionDesignator;

					// Check if we were returned any data
					if (sectionData !== undefined) {
						// Add the data to the section string
						sectionDataString += sectionData;
					}
				}

				// Add any custom data to the stream string at this point
				if (sectionDataString) {
					streamData += sectionDataString;
				}

				// Remove any .00 from the string since we don't need that data
				// TODO: What about if a property is a string with something.00 and it should be kept?
				streamData = streamData.replace(this._floatRemoveRegExp, ',');
			}

			// Store the data in cache in case we are asked for it again this tick
			// the update() method of the IgeEntity class clears this every tick
			this._streamDataCache = streamData;
			
			return streamData;
		},
		/* CEXCLUDE */
	
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// INTERPOLATOR
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 * Calculates the current value based on the time along the
		 * value range.
		 * @param {Number} startValue The value that the interpolation started from.
		 * @param {Number} endValue The target value to be interpolated to.
		 * @param {Number} startTime The time the interpolation started.
		 * @param {Number} currentTime The current time.
		 * @param {Number} endTime The time the interpolation will end.
		 * @return {Number} The interpolated value.
		 */
		interpolateValue: function (startValue, endValue, startTime, currentTime, endTime) {
			var totalValue = endValue - startValue,
				dataDelta = endTime - startTime,
				offsetDelta = currentTime - startTime,
				deltaTime = offsetDelta / dataDelta;
	
			// Clamp the current time from 0 to 1
			if (deltaTime < 0) { deltaTime = 0; } else if (deltaTime > 1) { deltaTime = 1; }
	
			return (totalValue * deltaTime) + startValue;
		},
	
		/**
		 * Processes the time stream for the entity.
		 * @param {Number} renderTime The time that the time stream is
		 * targeting to render the entity at.
		 * @param {Number} maxLerp The maximum lerp before the value
		 * is assigned directly instead of being interpolated.
		 * @private
		 */
		_processInterpolate: function (renderTime, maxLerp) {
			// Set the maximum lerp to 200 if none is present
			if (!maxLerp) { maxLerp = 200; }
	
			var //maxLerpSquared = maxLerp * maxLerp,
				previousData,
				nextData,
				timeStream = this._timeStream,
				dataDelta,
				offsetDelta,
				currentTime,
				previousTransform,
				nextTransform,
				currentTransform = [],
				i = 1;
	
			// Find the point in the time stream that is
			// closest to the render time and assign the
			// previous and next data points
			while (timeStream[i]) {
				if (timeStream[i][0] > renderTime) {
					// We have previous and next data points from the
					// time stream so store them
					previousData = timeStream[i - 1];
					nextData = timeStream[i];
					break;
				}
				i++;
			}
	
			// Check if we have some data to use
			if (!nextData && !previousData) {
				// No in-time data was found, check for lagging data
				if (timeStream.length > 2) {
					if (timeStream[timeStream.length - 1][0] < renderTime) {
						// Lagging data is available, use that
						previousData = timeStream[timeStream.length - 2];
						nextData = timeStream[timeStream.length - 1];
						timeStream.shift();
						
						/**
						 * Fires when the entity interpolates against old data, usually
						 * the result of slow processing on the client or too much data
						 * being sent from the server.
						 * @event IgeEntity#interpolationLag
						 */
						this.emit('interpolationLag');
					}
				}
			} else {
				// We have some new data so clear the old data
				timeStream.splice(0, i - 1);
			}
	
			// If we have data to use
			if (nextData && previousData) {
				// Check if the previous data has a timestamp and if not,
				// use the next data's timestamp
				if (isNaN(previousData[0])) { previousData[0] = nextData[0]; }
	
				// Store the data so outside systems can access them
				this._timeStreamPreviousData = previousData;
				this._timeStreamNextData = nextData;
	
				// Calculate the delta times
				dataDelta = nextData[0] - previousData[0];
				offsetDelta = renderTime - previousData[0];
	
				this._timeStreamDataDelta = Math.floor(dataDelta);
				this._timeStreamOffsetDelta = Math.floor(offsetDelta);
	
				// Calculate the current time between the two data points
				currentTime = offsetDelta / dataDelta;
	
				this._timeStreamCurrentInterpolateTime = currentTime;
	
				// Clamp the current time from 0 to 1
				//if (currentTime < 0) { currentTime = 0.0; } else if (currentTime > 1) { currentTime = 1.0; }
	
				// Set variables up to store the previous and next data
				previousTransform = previousData[1];
				nextTransform = nextData[1];
	
				// Translate
				currentTransform[0] = this.interpolateValue(previousTransform[0], nextTransform[0], previousData[0], renderTime, nextData[0]);
				currentTransform[1] = this.interpolateValue(previousTransform[1], nextTransform[1], previousData[0], renderTime, nextData[0]);
				currentTransform[2] = this.interpolateValue(previousTransform[2], nextTransform[2], previousData[0], renderTime, nextData[0]);
				// Scale
				currentTransform[3] = this.interpolateValue(previousTransform[3], nextTransform[3], previousData[0], renderTime, nextData[0]);
				currentTransform[4] = this.interpolateValue(previousTransform[4], nextTransform[4], previousData[0], renderTime, nextData[0]);
				currentTransform[5] = this.interpolateValue(previousTransform[5], nextTransform[5], previousData[0], renderTime, nextData[0]);
				// Rotate
				currentTransform[6] = this.interpolateValue(previousTransform[6], nextTransform[6], previousData[0], renderTime, nextData[0]);
				currentTransform[7] = this.interpolateValue(previousTransform[7], nextTransform[7], previousData[0], renderTime, nextData[0]);
				currentTransform[8] = this.interpolateValue(previousTransform[8], nextTransform[8], previousData[0], renderTime, nextData[0]);
	
				this.translateTo(parseFloat(currentTransform[0]), parseFloat(currentTransform[1]), parseFloat(currentTransform[2]));
				this.scaleTo(parseFloat(currentTransform[3]), parseFloat(currentTransform[4]), parseFloat(currentTransform[5]));
				this.rotateTo(parseFloat(currentTransform[6]), parseFloat(currentTransform[7]), parseFloat(currentTransform[8]));
	
				/*// Calculate the squared distance between the previous point and next point
				 dist = this.distanceSquared(previousTransform.x, previousTransform.y, nextTransform.x, nextTransform.y);
	
				 // Check that the distance is not higher than the maximum lerp and if higher,
				 // set the current time to 1 to snap to the next position immediately
				 if (dist > maxLerpSquared) { currentTime = 1; }
	
				 // Interpolate the entity position by multiplying the Delta times T, and adding the previous position
				 currentPosition = {};
				 currentPosition.x = ( (nextTransform.x - previousTransform.x) * currentTime ) + previousTransform.x;
				 currentPosition.y = ( (nextTransform.y - previousTransform.y) * currentTime ) + previousTransform.y;
	
				 // Now actually transform the entity
				 this.translate(entity, currentPosition.x, currentPosition.y);*/
	
				// Record the last time we updated the entity so we can disregard any updates
				// that arrive and are before this timestamp (not applicable in TCP but will
				// apply if we ever get UDP in websockets)
				this._lastUpdate = new Date().getTime();
			}
		},
		
		_highlightToGlobalCompositeOperation: function (val) {
			if (val) {
				if (val === true) {
					return 'lighter';
				}

				return val;
			}
		}
	});
	
	return IgeEntity;
});
},{"irrelon-appcore":125}],60:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeEventingClass', function (IgeClass) {
	/**
	 * Creates a new class with the capability to emit events.
	 */
	var IgeEventingClass = IgeClass.extend({
		classId: 'IgeEventingClass',
		
		/**
		 * Add an event listener method for an event.
		 * @param {String || Array} eventName The name of the event to listen for (string), or an array of events to listen for.
		 * @param {Function} call The method to call when the event listener is triggered.
		 * @param {Object=} context The context in which the call to the listening method will be made (sets the 'this' variable in the method to the object passed as this parameter).
		 * @param {Boolean=} oneShot If set, will instruct the listener to only listen to the event being fired once and will not fire again.
		 * @param {Boolean=} sendEventName If set, will instruct the emitter to send the event name as the argument instead of any emitted arguments.
		 * @return {Object} The event listener object. Hold this value if you later want to turn off the event listener.
		 * @example #Add an Event Listener
		 *     // Register event lister and store in "evt"
		 *     var evt = myEntity.on('mouseDown', function () { console.log('down'); });
		 * @example #Listen for Event Data
		 *     // Set a listener to listen for the data (multiple values emitted
		 *     // from an event are passed as function arguments)
		 *     myEntity.on('hello', function (arg1, arg2) {
	 	 *         console.log(arg1, arg2);
	 	 *     }
		 *
		 *     // Emit the event named "hello"
		 *     myEntity.emit('hello', ['data1', 'data2']);
		 *
		 *     // The console output is:
		 *     //    data1, data2
		 */
		on: function (eventName, call, context, oneShot, sendEventName) {
			var self = this,
				newListener,
				addListener,
				existingIndex,
				elArr,
				multiEvent,
				eventIndex,
				eventData,
				eventObj,
				multiEventName;
			
			// Check that we have an event listener object
			this._eventListeners = this._eventListeners || {};
			
			if (typeof call === 'function') {
				if (typeof eventName === 'string') {
					// Compose the new listener
					newListener = {
						call: call,
						context: context,
						oneShot: oneShot,
						sendEventName: sendEventName
					};
					
					elArr = this._eventListeners[eventName] = this._eventListeners[eventName] || [];
					
					// Check if we already have this listener in the list
					addListener = true;
					
					// TO-DO - Could this do with using indexOf? Would that work? Would be faster?
					existingIndex = elArr.indexOf(newListener);
					if (existingIndex > -1) {
						addListener = false;
					}
					
					// Add this new listener
					if (addListener) {
						elArr.push(newListener);
					}
					
					return newListener;
				} else {
					// The eventName is an array of names, creating a group of events
					// that must be fired to fire this event callback
					if (eventName.length) {
						// Loop the event array
						multiEvent = [];
						multiEvent[0] = 0; // This will hold our event count total
						multiEvent[1] = 0; // This will hold our number of events fired
						
						// Define the multi event callback
						multiEvent[3] = function (firedEventName) {
							multiEvent[1]++;
							
							if (multiEvent[0] === multiEvent[1]) {
								// All the multi-event events have fired
								// so fire the callback
								call.apply(context || self);
							}
						};
						
						for (eventIndex in eventName) {
							if (eventName.hasOwnProperty(eventIndex)) {
								eventData = eventName[eventIndex];
								eventObj = eventData[0];
								multiEventName = eventData[1];
								
								// Increment the event listening count total
								multiEvent[0]++;
								
								// Register each event against the event object with a callback
								eventObj.on(multiEventName, multiEvent[3], null, true, true);
							}
						}
					}
				}
			} else {
				if (typeof(eventName) !== 'string') {
					eventName = '*Multi-Event*';
				}
				this.log('Cannot register event listener for event "' + eventName + '" because the passed callback is not a function!', 'error');
			}
		},
		
		/**
		 * Remove an event listener. If the _processing flag is true
		 * then the removal will be placed in the removals array to be
		 * processed after the event loop has completed in the emit()
		 * method.
		 * @param {Boolean} eventName The name of the event you originally registered to listen for.
		 * @param {Object} evtListener The event listener object to cancel. This object is the one
		 * returned when calling the on() method. It is NOT the method you passed as the second argument
		 * to the on() method.
		 * @param {Function} callback The callback method to call when the event listener has been
		 * successfully removed. If you attempt to remove a listener during the event firing loop
		 * then the listener will not immediately be removed but will be queued for removal before
		 * the next listener loop is fired. In this case you may like to be informed via callback
		 * when the listener has been fully removed in which case, provide a method for this argument.
		 *
		 * The callback will be passed a single boolean argument denoting if the removal was successful
		 * (true) or the listener did not exist to remove (false).
		 * @example #Switch off an Event Listener
		 *     // Register event lister and store in "evt"
		 *     var evt = myEntity.on('mouseDown', function () { console.log('down'); });
		 *
		 *     // Switch off event listener
		 *     myEntity.off('mouseDown', evt);
		 * @return {Boolean}
		 */
		off: function (eventName, evtListener, callback) {
			if (this._eventListeners) {
				if (!this._eventListeners._processing) {
					if (this._eventListeners[eventName]) {
						// Find this listener in the list
						var evtListIndex = this._eventListeners[eventName].indexOf(evtListener);
						if (evtListIndex > -1) {
							// Remove the listener from the event listener list
							this._eventListeners[eventName].splice(evtListIndex, 1);
							if (callback) {
								callback(true);
							}
							return true;
						} else {
							this.log('Failed to cancel event listener for event named "' + eventName + '" !', 'warning', evtListener);
						}
					} else {
						this.log('Failed to cancel event listener!');
					}
				} else {
					// Add the removal to a remove queue since we are processing
					// listeners at the moment and removing one would mess up the
					// loop!
					this._eventListeners._removeQueue = this._eventListeners._removeQueue || [];
					this._eventListeners._removeQueue.push([eventName, evtListener, callback]);
					
					return -1;
				}
			}
			
			if (callback) {
				callback(false);
			}
			return false;
		},
		
		/**
		 * Emit an event by name.
		 * @param {Object} eventName The name of the event to emit.
		 * @param {Object || Array} args The arguments to send to any listening methods.
		 * If you are sending multiple arguments, use an array containing each argument.
		 * @return {Number}
		 * @example #Emit an Event
		 *     // Emit the event named "hello"
		 *     myEntity.emit('hello');
		 * @example #Emit an Event With Data Object
		 *     // Emit the event named "hello"
		 *     myEntity.emit('hello', {moo: true});
		 * @example #Emit an Event With Multiple Data Values
		 *     // Emit the event named "hello"
		 *     myEntity.emit('hello', [{moo: true}, 'someString']);
		 * @example #Listen for Event Data
		 *     // Set a listener to listen for the data (multiple values emitted
		 *     // from an event are passed as function arguments)
		 *     myEntity.on('hello', function (arg1, arg2) {
	 	 *         console.log(arg1, arg2);
		 *     }
		 *
		 *     // Emit the event named "hello"
		 *     myEntity.emit('hello', ['data1', 'data2']);
		 *
		 *     // The console output is:
		 *     //    data1, data2
		 */
		emit: function (eventName, args) {
			if (this._eventListeners) {
				// Check if the event has any listeners
				if (this._eventListeners[eventName]) {
					
					// Fire the listeners for this event
					var eventCount = this._eventListeners[eventName].length,
						eventCount2 = this._eventListeners[eventName].length - 1,
						finalArgs, i, cancelFlag, eventIndex, tempEvt, retVal;
					
					// If there are some events, ensure that the args is ready to be used
					if (eventCount) {
						finalArgs = [];
						if (typeof(args) === 'object' && args !== null && args[0] !== null && args[0] !== undefined) {
							for (i in args) {
								if (args.hasOwnProperty(i)) {
									finalArgs[i] = args[i];
								}
							}
						} else {
							finalArgs = [args];
						}
						
						// Loop and emit!
						cancelFlag = false;
						
						this._eventListeners._processing = true;
						while (eventCount--) {
							eventIndex = eventCount2 - eventCount;
							tempEvt = this._eventListeners[eventName][eventIndex];
							
							
							// If the sendEventName flag is set, overwrite the arguments with the event name
							if (tempEvt.sendEventName) { finalArgs = [eventName]; }
							
							// Call the callback
							retVal = tempEvt.call.apply(tempEvt.context || this, finalArgs);
							
							// If the retVal === true then store the cancel flag and return to the emitting method
							if (retVal === true) {
								// The receiver method asked us to send a cancel request back to the emitter
								cancelFlag = true;
							}
							
							// Check if we should now cancel the event
							if (tempEvt.oneShot) {
								// The event has a oneShot flag so since we have fired the event,
								// lets cancel the listener now
								if (this.off(eventName, tempEvt) === true) {
									eventCount2--;
								}
							}
						}
						
						// Check that the array still exists because an event
						// could have triggered a method that destroyed our object
						// which would have deleted the array!
						if (this._eventListeners) {
							this._eventListeners._processing = false;
							
							// Now process any event removal
							this._processRemovals();
						}
						
						if (cancelFlag) {
							return 1;
						}
						
					}
					
				}
			}
		},
		
		/**
		 * Returns an object containing the current event listeners.
		 * @return {Object}
		 */
		eventList: function () {
			return this._eventListeners;
		},
		
		/**
		 * Loops the removals array and processes off() calls for
		 * each array item.
		 * @private
		 */
		_processRemovals: function () {
			if (this._eventListeners) {
				var remArr = this._eventListeners._removeQueue,
					arrCount,
					item,
					result;
				
				// If the removal array exists
				if (remArr) {
					// Get the number of items in the removal array
					arrCount = remArr.length;
					
					// Loop the array
					while (arrCount--) {
						item = remArr[arrCount];
						
						// Call the off() method for this item
						result = this.off(item[0], item[1]);
						
						// Check if there is a callback
						if (typeof remArr[2] === 'function') {
							// Call the callback with the removal result
							remArr[2](result);
						}
					}
				}
				
				// Remove the removal array
				delete this._eventListeners._removeQueue;
			}
		}
	});
	
	return IgeEventingClass;
});
},{"irrelon-appcore":125}],61:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFSM', function (IgeClass) {
	/**
	 * A simple finite state machine implementation.
	 */
	var IgeFSM = IgeClass.extend({
		classId: 'IgeFSM',
		
		init: function () {
			this._states = {};
			this._transitions = {};
			
			// Track states by name.
			this._initialStateName = '';
			this._currentStateName = '';
			this._previousStateName = '';
			
			this._debug = false;
		},
		
		/**
		 * Returns the name of the initial state.
		 * @returns {string}
		 */
		initialStateName: function () {
			return this._currentStateName;
		},
		
		/**
		 * Returns the name of the previous state.
		 * @returns {string}
		 */
		previousStateName: function () {
			return this._currentStateName;
		},
		
		/**
		 * Returns the name of the current state.
		 * @returns {string}
		 */
		currentStateName: function () {
			return this._currentStateName;
		},
		
		/**
		 * Gets / sets the debug flag. If set to true will enable console logging
		 * of state changes / events.
		 * @param {Boolean=} val Set to true to enable.
		 * @returns {*}
		 */
		debug: function (val) {
			if (val !== undefined) {
				this._debug = val;
				return this;
			}
			
			return this._debug;
		},
		
		/**
		 * Defines a state with a name and a state definition.
		 * @param {String} name The name of the state to define.
		 * @param {Object} definition The state definition object.
		 * @example #Define a state
		 *     var fsm = new IgeFSM();
		 *
		 *     // Define an "idle" state
		 *     fsm.defineState('idle', {
	 *         enter: function (data, completeCallback) {
	 *             console.log('entered idle state');
	 *             completeCallback();
	 *         },
	 *         exit: function (data, completeCallback) {
	 *             console.log('exited idle state');
	 *             completeCallback();
	 *         }
	 *     });
		 * @returns {IgeFSM}
		 */
		defineState: function (name, definition) {
			this._states[name] = definition;
			
			if (!this._initialStateName) {
				this._initialStateName = name;
			}
			
			return this;
		},
		
		/**
		 * Defines a transition between two states.
		 * @param {String} fromState The state name the transition is from.
		 * @param {String} toState The state name the transition is to.
		 * @param {Function} transitionCheck A method to call just before this transition
		 * between the two specified states is executed, that will call the callback method
		 * passed to it in the second parameter and include either true to allow the
		 * transition to continue, or false to cancel it in the first parameter.
		 * @example #Define a state transition
		 *     var fsm = new IgeFSM();
		 *
		 *     // Define an "idle" state
		 *     fsm.defineState('idle', {
	 *         enter: function (data, completeCallback) {
	 *             console.log('entered idle state');
	 *             completeCallback();
	 *         },
	 *         exit: function (data, completeCallback) {
	 *             console.log('exited idle state');
	 *             completeCallback();
	 *         }
	 *     });
		 *
		 *     // Define a "moving" state
		 *     fsm.defineState('moving', {
	 *         enter: function (data, completeCallback) {
	 *             console.log('entered moving state');
	 *             completeCallback();
	 *         },
	 *         exit: function (data, completeCallback) {
	 *             console.log('exited moving state');
	 *             completeCallback();
	 *         }
	 *     });
		 *
		 *     // Define a transition between the two methods
		 *     fsm.defineTransition('idle', 'moving', function (data, callback) {
	 *         // Check some data we were passed
	 *         if (data === 'ok') {
	 *             // Callback the listener and tell them there was no error
	 *             // (first argument is an err flag, set to false for no error)
	 *             callback(false);
	 *         } else {
	 *             // Callback and say there was an error by passing anything other
	 *             // than false in the first argument
	 *             callback('Some error string, or true or any data');
	 *         }
	 *     });
		 *
		 *     // Now change states and cause it to fail
		 *     fsm.enterState('moving', 'notOk', function (err, data) {
	 *         if (!err) {
	 *             // There was no error, the state changed successfully
	 *             console.log('State changed!', fsm.currentStateName());
	 *         } else {
	 *             // There was an error, the state did not change
	 *             console.log('State did NOT change!', fsm.currentStateName());
	 *         }
	 *     });
		 *
		 *     // Now change states and pass "ok" in the data to make it proceed
		 *     fsm.enterState('moving', 'ok', function (err, data) {
	 *         if (!err) {
	 *             // There was no error, the state changed successfully
	 *             console.log('State changed!', fsm.currentStateName());
	 *         } else {
	 *             // There was an error, the state did not change
	 *             console.log('State did NOT change!', fsm.currentStateName());
	 *         }
	 *     });
		 * @returns {*}
		 */
		defineTransition: function (fromState, toState, transitionCheck) {
			if (fromState && toState && transitionCheck) {
				if (!this._states[fromState]) {
					this.log('fromState "' + fromState + '" specified is not defined as a state!', 'error');
				}
				
				if (!this._states[toState]) {
					this.log('toState "' + toState + '" specified is not defined as a state!', 'error');
				}
				
				this._transitions[fromState] = this._transitions[fromState] || {};
				this._transitions[fromState][toState] = transitionCheck;
				
				return this;
			}
			
			return false;
		},
		
		/**
		 * After defining your states, call this with the state name and the initial
		 * state of the FSM will be set.
		 * @param {String} stateName The state to set as the initial state.
		 * @param {*=} data Any data you wish to pass the state's "enter" method.
		 * @param {Function=} callback An optional callback method that will be called
		 * once the state has been entered successfully, or if there was an error.
		 */
		initialState: function (stateName, data, callback) {
			var newStateObj = this.getState(stateName);
			
			this._currentStateName = stateName;
			
			if (this._debug) { this.log('Entering initial state: ' + stateName); }
			
			if (newStateObj.enter) {
				newStateObj.enter.apply(newStateObj, [data, function (enterErr, enterData) {
					if (callback) { callback(enterErr, enterData); }
				}]);
			}
		},
		
		/**
		 * Gets the state definition object for the specified state name.
		 * @param {String} stateName The name of the state who's definition object should
		 * be looked up and returned.
		 * @returns {Object} The state definition object or undefined if no state exists
		 * with that name.
		 */
		getState: function (stateName) {
			return this._states[stateName];
		},
		
		/**
		 * Tell the FSM to enter the state specified.
		 * @param {String} newStateName The new state to enter.
		 * @param {*} data Any data to pass to the exit and enter methods.
		 * @param {Function=} callback The optional callback method to call on completion.
		 */
		enterState: function (newStateName, data, callback) {
			var self = this;
			
			if (self._transitions[self._currentStateName] && self._transitions[self._currentStateName][newStateName]) {
				// There is a transition check method, call it to see if we can change states
				self._transitions[self._currentStateName][newStateName](data, function (err) {
					if (!err) {
						// State change allowed
						self._transitionStates(self._currentStateName, newStateName, data, callback);
					} else {
						// State change not allowed or error
						if (callback ) { callback(err); }
						
						this.log('Cannot transition from "' + self._currentStateName + '" to "' + newStateName + '" states.', 'warning');
					}
				});
			} else {
				// No transition check method exists, continue to change states
				self._transitionStates(self._currentStateName, newStateName, data, callback);
			}
		},
		
		/**
		 * Tell the FSM to exit the current state and enter the previous state.
		 * @param {Function=} callback Optional callback method once exiting the state
		 * has been executed.
		 */
		exitState: function (callback) {
			this.enterState(this._previousStateName, null, callback);
		},
		
		/**
		 * Handles changing states from one to another by checking for transitions and
		 * handling callbacks.
		 * @param {String} oldStateName The name of the state we are transitioning from.
		 * @param {String} newStateName The name of the state we are transitioning to.
		 * @param {*=} data Optional data to pass to the exit and enter methods of each state.
		 * @param {Function=} callback Optional callback method to execute once the transition
		 * has been completed.
		 * @private
		 */
		_transitionStates: function (oldStateName, newStateName, data, callback) {
			var self = this,
				currentStateObj = self.getState(self._currentStateName),
				newStateObj = self.getState(newStateName);
			
			if (currentStateObj && newStateObj) {
				if (self._debug) { self.log('Exiting state: ' + self._currentStateName); }
				if (currentStateObj.exit) {
					currentStateObj.exit.apply(currentStateObj, [data, function (exitStateErr, exitStateData) {
						self._previousStateName = self._currentStateName;
						self._currentStateName = newStateName;
						
						if (self._debug) { self.log('Entering state: ' + newStateName); }
						if (newStateObj.enter) {
							newStateObj.enter.apply(newStateObj, [data, function (enterStateErr, enterStateData) {
								if (callback) { callback(enterStateErr, data); }
							}]);
						}
					}]);
				}
			} else {
				if (callback) { callback('Cannot change states from "' + self._currentStateName + '" to "' + newStateName + '" states.'); }
				self.log('Cannot change states from "' + self._currentStateName + '" to "' + newStateName + '" states.', 'warning');
			}
		}
	});
	
	return IgeFSM;
});
},{"irrelon-appcore":125}],62:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters', function () {
	// See the ige/engine/filters folder for the individual filter source
	var IgeFilters = {};
	
	if (typeof(window) !== 'undefined') {
		// Create a temporary canvas for the filter system to use
		IgeFilters.tmpCanvas = document.createElement('canvas');
		IgeFilters.tmpCtx = IgeFilters.tmpCanvas.getContext('2d');
	}
	
	return IgeFilters;
});
},{"irrelon-appcore":125}],63:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFontEntity', function (IgeUiEntity, IgeTexture, IgeFontSmartTexture) {
	/**
	 * Creates a new font entity. A font entity will use a font sheet
	 * (IgeFontSheet) or native font and render text.
	 */
	var IgeFontEntity = IgeUiEntity.extend({
		classId: 'IgeFontEntity',
		
		init: function () {
			IgeUiEntity.prototype.init.call(this);
			
			this._renderText = undefined;
			this._text = undefined;
			this._textAlignX = 1;
			this._textAlignY = 1;
			this._textLineSpacing = 0;
			this._nativeMode = false;
			
			// Enable caching by default for font entities!
			this.cache(true);
		},
		
		/**
		 * Extends the IgeUiEntity.width() method and if the value being
		 * set is different from the current width value then the font's
		 * cache is invalidated so it gets redrawn.
		 * @param val
		 * @param lockAspect
		 * @param modifier
		 * @param noUpdate
		 * @returns {*}
		 */
		width: function (val, lockAspect, modifier, noUpdate) {
			if (val !== undefined) {
				if (this._bounds2d.x !== val) {
					this.clearCache();
				}
			}
			
			var retVal = IgeUiEntity.prototype.width.call(this, val, lockAspect, modifier, noUpdate);
			
			if (this._autoWrap) {
				this._applyAutoWrap();
			}
			
			return retVal;
		},
		
		/**
		 * Extends the IgeUiEntity.height() method and if the value being
		 * set is different from the current height value then the font's
		 * cache is invalidated so it gets redrawn.
		 * @param val
		 * @param lockAspect
		 * @param modifier
		 * @param noUpdate
		 * @returns {*|number}
		 */
		height: function (val, lockAspect, modifier, noUpdate) {
			if (val !== undefined) {
				if (this._bounds2d.y !== val) {
					this.clearCache();
				}
			}
			
			return IgeUiEntity.prototype.height.call(this, val, lockAspect, modifier, noUpdate);
		},
		
		/**
		 * Sets the text to render for this font entity. This sets both
		 * the private properties "_text" and "_renderText". If auto-wrapping
		 * has been enabled then the "_text" remains equal to whatever
		 * text you pass into this method but "_renderText" becomes the
		 * line-broken text that the auto-wrapper method creates. When the
		 * entity renders it's text string it ALWAYS renders from "_renderText"
		 * and not the value of "_text". Effectively this means that "_text"
		 * contains the unaltered version of your original text and
		 * "_renderText" will be either the same as "_text" if auto-wrapping
		 * is disable or a wrapped version otherwise.
		 * @param {String} text The text string to render.
		 * @returns {*}
		 */
		text: function (text) {
			if (text !== undefined) {
				var wasDifferent = false;
				
				// Ensure we have a string
				text = String(text);
				
				if (this._text !== text) {
					this.clearCache();
					wasDifferent = true;
				}
				
				this._text = text;
				
				if (this._autoWrap && wasDifferent) {
					this._applyAutoWrap();
				} else {
					this._renderText = text;
				}
				
				return this;
			}
			
			return this._text;
		},
		
		/**
		 * Allows you to bind the text output of this font entity to match
		 * the value of an object's property so that when it is updated the
		 * text will automatically update on this entity. Useful for score,
		 * position etc output where data is stored in an object and changes
		 * frequently.
		 * @param {Object} obj The object to read the property from.
		 * @param {String} propName The name of the property to read value from.
		 * @param {String} preText Text to place before the output.
		 * @param {String} postText Text to place after the output.
		 * @returns {*}
		 */
		bindData: function (obj, propName, preText, postText) {
			if (obj !== undefined && propName !== undefined) {
				this._bindDataObject = obj;
				this._bindDataProperty = propName;
				this._bindDataPreText = preText || '';
				this._bindDataPostText = postText || '';
			}
			
			return this;
		},
		
		/**
		 * Gets / sets the current horizontal text alignment. Accepts
		 * a value of 0, 1 or 2 (left, centre, right) respectively.
		 * @param {Number=} val
		 * @returns {*}
		 */
		textAlignX: function (val) {
			if (val !== undefined) {
				if (this._textAlignX !== val) {
					this.clearCache();
				}
				this._textAlignX = val;
				return this;
			}
			return this._textAlignX;
		},
		
		/**
		 * Gets / sets the current vertical text alignment. Accepts
		 * a value of 0, 1 or 2 (top, middle, bottom) respectively.
		 * @param {Number=} val
		 * @returns {*}
		 */
		textAlignY: function (val) {
			if (val !== undefined) {
				if (this._textAlignY !== val) {
					this.clearCache();
				}
				this._textAlignY = val;
				return this;
			}
			return this._textAlignY;
		},
		
		/**
		 * Gets / sets the amount of spacing between the lines of text being
		 * rendered. Accepts negative values as well as positive ones.
		 * @param {Number=} val
		 * @returns {*}
		 */
		textLineSpacing: function (val) {
			if (val !== undefined) {
				if (this._textLineSpacing !== val) {
					this.clearCache();
				}
				this._textLineSpacing = val;
				return this;
			}
			return this._textLineSpacing;
		},
		
		/**
		 * Gets / sets the string hex or rgba value of the colour
		 * to use as an overlay when rending this entity's texture.
		 * @param {String=} val The colour value as hex e.g. '#ff0000'
		 * or as rgba e.g. 'rbga(255, 0, 0, 0.5)'. To remove an overlay
		 * colour simply passed an empty string.
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		colorOverlay: function (val) {
			if (val !== undefined) {
				if (this._colorOverlay !== val) {
					this.clearCache();
				}
				this._colorOverlay = val;
				return this;
			}
			
			return this._colorOverlay;
		},
		
		/**
		 * A proxy for colorOverlay().
		 */
		color: function (val) {
			return this.colorOverlay(val);
		},
		
		/**
		 * Clears the texture cache for this entity's text string.
		 */
		clearCache: function () {
			if (this._cache) {
				this.cacheDirty(true);
			}
			
			if (this._texture && this._texture._caching && this._texture._cacheText[this._renderText]) {
				delete this._texture._cacheText[this._renderText];
			}
		},
		
		/**
		 * When using native font rendering (canvasContext.fillText())
		 * this sets the font and size as per the canvasContext.font
		 * string specification.
		 * @param {String=} val The font style string.
		 * @return {*} "this" when arguments are passed to allow method
		 * chaining or the current value if no arguments are specified.
		 */
		nativeFont: function (val) {
			if (val !== undefined) {
				// Check if this font is different from the current
				// assigned font
				if (this._nativeFont !== val) {
					// The fonts are different, clear existing cache
					this.clearCache();
				}
				this._nativeFont = val;
				
				// Assign the native font smart texture
				var tex = new IgeTexture(IgeFontSmartTexture);
				this.texture(tex);
				
				// Set the flag indicating we are using a native font
				this._nativeMode = true;
				
				return this;
			}
			
			return this._nativeFont;
		},
		
		/**
		 * Gets / sets the text stroke size that applies when using
		 * a native font for text rendering.
		 * @param {Number=} val The size of the text stroke.
		 * @return {*}
		 */
		nativeStroke: function (val) {
			if (val !== undefined) {
				if (this._nativeStroke !== val) {
					this.clearCache();
				}
				this._nativeStroke = val;
				return this;
			}
			
			return this._nativeStroke;
		},
		
		/**
		 * Gets / sets the text stroke color that applies when using
		 * a native font for text rendering.
		 * @param {Number=} val The color of the text stroke.
		 * @return {*}
		 */
		nativeStrokeColor: function (val) {
			if (val !== undefined) {
				if (this._nativeStrokeColor !== val) {
					this.clearCache();
				}
				this._nativeStrokeColor = val;
				return this;
			}
			
			return this._nativeStrokeColor;
		},
		
		/**
		 * Gets / sets the auto-wrapping mode. If set to true then the
		 * text this font entity renders will be automatically line-broken
		 * when a line reaches the width of the entity.
		 * @param val
		 * @returns {*}
		 */
		autoWrap: function (val) {
			if (val !== undefined) {
				this._autoWrap = val;
				
				// Execute an auto-wrap modification of the text
				if (this._text) {
					this._applyAutoWrap();
					this.clearCache();
				}
				return this;
			}
			
			return this._autoWrap;
		},
		
		/**
		 * Automatically detects where line-breaks need to occur in the text
		 * assigned to the entity and adds them.
		 * @private
		 */
		_applyAutoWrap: function () {
			if (this._text) {
				// Un-wrap the text so it is all on one line
				var oneLineText = this._text.replace(/\n/g, ' '),
					words,
					wordIndex,
					textArray = [],
					currentTextLine = '',
					lineWidth;
				
				// Break the text into words
				words = oneLineText.split(' ');
				
				// There are multiple words - loop the words
				for (wordIndex = 0; wordIndex < words.length; wordIndex++) {
					if (currentTextLine) {
						currentTextLine += ' ';
					}
					currentTextLine += words[wordIndex];
					
					// Check the width and if greater than the width of the entity,
					// add a line break before the word
					lineWidth = this.measureTextWidth(currentTextLine);
					
					if (lineWidth >= this._bounds2d.x) {
						// Start a new line
						currentTextLine = words[wordIndex];
						
						// Add a line break
						textArray.push('\n' + words[wordIndex]);
					} else {
						textArray.push(words[wordIndex]);
					}
					
				}
				
				this._renderText = textArray.join(' ');
			}
		},
		
		/**
		 * Will measure and return the width in pixels of a line or multiple
		 * lines of text. If no text parameter is passed, will use the current
		 * text assigned to the font entity.
		 * @param {String=} text Optional text to measure, used existing entity
		 * text value if none is provided.
		 * @returns {Number} The width of the text in pixels.
		 */
		measureTextWidth: function (text) {
			text = text || this._text;
			
			// Both IgeFontSheet and the IgeFontSmartTexture have a method
			// called measureTextWidth() so we can just asks the current
			// texture for the width :)
			if (this._texture._mode === 0) {
				return this._texture.measureTextWidth(text);
			} else {
				return this._texture.script.measureTextWidth(text, this);
			}
		},
		
		tick: function (ctx) {
			// Check for an auto-progress update
			if (this._bindDataObject && this._bindDataProperty) {
				if (this._bindDataObject._alive === false) {
					// The object we have bind data from has been
					// destroyed so release our reference to it!
					delete this._bindDataObject;
				} else {
					this.text(this._bindDataPreText + this._bindDataObject[this._bindDataProperty] + this._bindDataPostText);
				}
			}
			
			IgeUiEntity.prototype.tick.call(this, ctx);
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object's properties via
		 * chained commands. This method will only check for
		 * properties that are directly related to this class.
		 * Other properties are handled by their own class method.
		 * @return {String}
		 */
		_stringify: function () {
			// Get the properties for all the super-classes
			var str = IgeUiEntity.prototype._stringify.call(this), i;
			
			// Loop properties and add property assignment code to string
			for (i in this) {
				if (this.hasOwnProperty(i) && this[i] !== undefined) {
					switch (i) {
						case '_text':
							str += ".text(" + this.text() + ")";
							break;
						case '_textAlignX':
							str += ".textAlignX(" + this.textAlignX() + ")";
							break;
						case '_textAlignY':
							str += ".textAlignY(" + this.textAlignY() + ")";
							break;
						case '_textLineSpacing':
							str += ".textLineSpacing(" + this.textLineSpacing() + ")";
							break;
					}
				}
			}
			
			return str;
		}
	});
	
	return IgeFontEntity;
});
},{"irrelon-appcore":125}],64:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFontSheet', function ($time, IgeTexture) {
	/* TODO: URGENT - Make this alignment stuff work inside the bounds of the entity it is attached to
	 * so that bottom-right aligns to the lower-right point of the bounding box of the entity
	 * whilst maintaining the current text-alignment as well
	 * */
	
	/**
	 * Creates a new font sheet. A font sheet is an image that contains
	 * letters and numbers rendered to specifications. It allows you to
	 * use and render text fonts without the font actually existing on
	 * the target system that the engine is running in.
	 */
	var IgeFontSheet = IgeTexture.extend({
		classId: 'IgeFontSheet',
		
		init: function (url) {
			IgeTexture.prototype.init.call(this, url);
			
			if (arguments[1]) {
				this.log('Font sheets no longer accept a caching limit value. All font output is now cached by default via the actual font entity - fontEntity.cache(true);', 'warning');
			}
			
			// Set the _noDimensions flag which tells any entity
			// that assigns this texture that the texture has an
			// unknown width/height so it should not get it's
			// dimension data from the texture
			this._noDimensions = true;
			
			// Set a listener for when the texture loads
			this.on('loaded', function () {
				if (this.image) {
					// Store the cell sheet image
					this._sheetImage = this.image;
					
					// Get the font sheet data header
					this._fontData = this.decodeHeader();
					
					// Cache access to looped data
					this._charCodeMap = this._fontData.characters.charCodes;
					this._charPosMap = this._fontData.characters.charPosition;
					this._measuredWidthMap = this._fontData.characters.measuredWidth;
					this._pixelWidthMap = this._fontData.characters.pixelWidth;
					
					if (this._fontData) {
						var header = this._fontData.font;
						this.log('Loaded font sheet for font: ' + header.fontName + ' @ ' + header.fontSize + header.fontSizeUnit + ' in ' + header.fontColor);
					} else {
						this.log('Could not load data header for font sheet: ' + this.image.src, 'error');
					}
				}
			});
		},
		
		decodeHeader: function () {
			// Create a temporary canvas
			var canvas = document.createElement('canvas'),
				ctx = canvas.getContext('2d');
			
			// Set canvas width to match font sheet image and
			// height to 1 as we have 1 line of header data
			canvas.width = this.image.width;
			canvas.height = 1;
			
			// Draw the font sheet to the canvas
			ctx.drawImage(this.image, 0, 0);
			
			// Decode the font sheet pixel-encoded data
			return this._decode(canvas, 0, 0, this.image.width);
		},
		
		_decode: function (canvas, x, y, maxX) {
			var ctx = canvas.getContext('2d'),
				imageData = ctx.getImageData(x, y, maxX, canvas.height).data,
				run = true,
				quadCode,
				i = 0,
				jsonString = '';
			
			while (run) {
				quadCode = String(imageData[i]) + ' ' + String(imageData[i + 1]) + ' ' + String(imageData[i + 2]);
				if (quadCode === '3 2 1') {
					// We have scanned the terminal code
					// so exit the loop
					run = false;
					return JSON.parse(jsonString);
				} else {
					jsonString += String.fromCharCode(imageData[i]) + String.fromCharCode(imageData[i + 1]) + String.fromCharCode(imageData[i + 2]);
				}
				i += 4;
				
				if (i > imageData.length) {
					run = false;
					console.log('Image JSON Decode Error!');
				}
			}
		},
		
		lineHeightModifier: function (val) {
			if (typeof(val) !== 'undefined') {
				this._lineHeightModifier = val;
			}
		},
		
		/**
		 * Returns the width in pixels of the text passed in the
		 * argument.
		 * @param {String} text The text to measure.
		 * @returns {number}
		 */
		measureTextWidth: function (text) {
			if (this._loaded) {
				var characterIndex,
					charCodeMap = this._charCodeMap,
					measuredWidthMap = this._measuredWidthMap,
					charIndex,
					lineArr = [],
					lineIndex,
					measuredWidth,
					maxWidth = 0;
				
				// Handle multi-line text
				if (text.indexOf('\n') > -1) {
					// Split each line into an array item
					lineArr = text.split('\n');
				} else {
					// Store the text as a single line
					lineArr.push(text);
				}
				
				for (lineIndex = 0; lineIndex < lineArr.length; lineIndex++) {
					// Calculate the total width of the line of text
					measuredWidth = 0;
					for (characterIndex = 0; characterIndex < lineArr[lineIndex].length; characterIndex++) {
						charIndex = charCodeMap[lineArr[lineIndex].charCodeAt(characterIndex)];
						measuredWidth += measuredWidthMap[charIndex] || 0;
					}
					
					if (measuredWidth > maxWidth) {
						maxWidth = measuredWidth;
					}
				}
				
				// Store the width of this line so we can align it correctly
				return measuredWidth;
			}
			
			return -1;
		},
		
		render: function (ctx, entity) {
			if (entity._renderText && this._loaded) {
				var _ctx = ctx,
					text = entity._renderText,
					lineText,
					lineArr = [],
					lineIndex,
					characterIndex,
					charCodeMap = this._charCodeMap,
					charPosMap = this._charPosMap,
					measuredWidthMap = this._measuredWidthMap,
					pixelWidthMap = this._pixelWidthMap,
					renderX = 0,
					renderY = 0,
					renderStartX = 0,
					renderStartY = 0,
					masterX = 0,
					masterY = 0,
					lineWidth = [],
					lineHeight = (this._sizeY - 2),
					singleLineWidth = 0,
					totalWidth = 0,
					totalHeight,
					charIndex;
				
				// Handle multi-line text
				if (text.indexOf('\n') > -1) {
					// Split each line into an array item
					lineArr = text.split('\n');
				} else {
					// Store the text as a single line
					lineArr.push(text);
				}
				
				totalHeight = (lineHeight * lineArr.length);
				
				// TODO: Y-based alignment doesn't work at the moment. Fix it!
				// Handle text alignment y
				switch (entity._textAlignY) {
					case 0: // Align top
						renderStartY = -((lineHeight * (lineArr.length)) / 2) - (entity._textLineSpacing * ((lineArr.length - 1) / 2));//0;
						break;
					
					case 1: // Align middle
						renderStartY = -((lineHeight * (lineArr.length)) / 2) - (entity._textLineSpacing * ((lineArr.length - 1) / 2));
						break;
					
					case 2: // Align bottom
						renderStartY = -((lineHeight * (lineArr.length)) / 2) - (entity._textLineSpacing * ((lineArr.length - 1) / 2));//-((lineHeight) * (lineArr.length)) - (entity._textLineSpacing * (lineArr.length - 1));
						break;
				}
				
				// Calculate the total text width of each line
				for (lineIndex = 0; lineIndex < lineArr.length; lineIndex++) {
					lineText = lineArr[lineIndex];
					for (characterIndex = 0; characterIndex < lineText.length; characterIndex++) {
						charIndex = charCodeMap[lineText.charCodeAt(characterIndex)];
						singleLineWidth += measuredWidthMap[charIndex] || 0;
					}
					
					// Store the width of this line so we can align it correctly
					lineWidth[lineIndex] = singleLineWidth;
					
					if (singleLineWidth > totalWidth) {
						totalWidth = singleLineWidth;
					}
					
					singleLineWidth = 0;
				}
				
				// Handle text cached alignment x
				switch (entity._textAlignX) {
					case 0: // Align left
						renderStartX = -entity._bounds2d.x2;
						break;
					
					case 1: // Align center
						renderStartX = -totalWidth / 2;
						break;
					
					case 2: // Align right
						renderStartX = entity._bounds2d.x2 - totalWidth;
						break;
				}
				
				/*_ctx.strokeStyle = '#ff0000';
				 _ctx.strokeRect(renderStartX, renderStartY, totalWidth, totalHeight);*/
				
				for (lineIndex = 0; lineIndex < lineArr.length; lineIndex++) {
					lineText = lineArr[lineIndex];
					renderY = (lineHeight * lineIndex) + (entity._textLineSpacing * (lineIndex));
					
					// Handle text alignment x
					switch (entity._textAlignX) {
						case 0: // Align left
							renderX = -entity._bounds2d.x2;
							break;
						
						case 1: // Align center
							renderX = -lineWidth[lineIndex] / 2;
							break;
						
						case 2: // Align right
							renderX = entity._bounds2d.x2 - lineWidth[lineIndex];
							break;
					}
					
					for (characterIndex = 0; characterIndex < lineText.length; characterIndex++) {
						charIndex = charCodeMap[lineText.charCodeAt(characterIndex)];
						
						_ctx.drawImage(
							this.image,
							charPosMap[charIndex], // texture x
							2, // texture y
							pixelWidthMap[charIndex], // texture width
							this._sizeY - 2, // texture height
							Math.floor(masterX + renderX), // render x TODO: Performance - Cache these?
							Math.floor(masterY + renderStartY + renderY), // render y
							pixelWidthMap[charIndex], // render width
							(this._sizeY - 2) // render height
						);
						
						// Check if we should overlay with a colour
						if (entity._colorOverlay) {
							_ctx.save();
							// Set the composite operation and draw the colour over the top
							_ctx.globalCompositeOperation = 'source-atop';
							
							_ctx.fillStyle = entity._colorOverlay;
							_ctx.fillRect(
								Math.floor(masterX + renderX), // render x TODO: Performance - Cache these?
								Math.floor(masterY + renderStartY + renderY), // render y
								pixelWidthMap[charIndex], // render width
								(this._sizeY - 2) // render height
							);
							_ctx.restore();
						}
						
						renderX += measuredWidthMap[charIndex] || 0;
						
						$time._drawCount++;
					}
					
					renderX = 0;
				}
			}
		},
		
		destroy: function () {
			this.image = null;
			this.script = null;
		}
	});
	
	return IgeFontSheet;
});
},{"irrelon-appcore":125}],65:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeInterval', function ($ige, $time, IgeEventingClass) {
	/**
	 * Provides an alternative to setInterval() which works based on the engine's internal
	 * time system allowing intervals to fire correctly, taking into account pausing the
	 * game and differences in rendering speed etc.
	 */
	var IgeInterval = IgeEventingClass.extend({
		classId: 'IgeInterval',
		
		/**
		 * Creates a new timer that will call the method every given number of
		 * milliseconds specified by the interval parameter.
		 * @param {Function} method The method to call each interval.
		 * @param {Number} interval The number of milliseconds between each interval.
		 * @example #Create a timer that will call a method every 1 second in engine time
		 *     var myInterval = new IgeInterval(function () {
	 *     		console.log('interval fired');
	 *     }, 1000);
		 */
		init: function (method, interval) {
			this._method = method;
			this._interval = interval;
			this._time = 0;
			this._started = $time._currentTime;
			
			// Attach ourselves to the time system
			$ige.engine.time.addTimer(this);
		},
		
		/**
		 * Adds time to the timer's internal clock.
		 * @param {Number} time The time in milliseconds to add to the timer's internal clock.
		 * @returns {*}
		 */
		addTime: function (time) {
			this._time += time;
			return this;
		},
		
		/**
		 * Cancels the timer stopping all future method calls.
		 * @example #Cancel an interval timer
		 *     var myInterval = new IgeInterval(function () {
	 *     		console.log('interval fired');
	 *     }, 1000);
		 *
		 *     myInterval.cancel();
		 * @returns {*}
		 */
		cancel: function () {
			$ige.engine.time.removeTimer(this);
			return this;
		},
		
		/**
		 * Checks for a timer event to see if we should call the timer method. This is
		 * called automatically by the IgeTimeComponent class and does not need to be
		 * called manually.
		 * @returns {*}
		 */
		update: function () {
			if (this._time > this._interval) {
				// Fire an interval
				this._method($time._currentTime);
				this._time -= this._interval;
			}
			
			return this;
		}
	});
	
	return IgeInterval;
});
},{"irrelon-appcore":125}],66:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeMap2d', function (IgeClass) {
	/**
	 * Creates a new map that has two dimensions (x and y) to it's data.
	 */
	var IgeMap2d = IgeClass.extend({
		classId: 'IgeMap2d',
		
		init: function (data) {
			this._mapData = data || [];
		},
		
		/**
		 * Gets / sets a value on the specified map tile co-ordinates.
		 * @param {Number} x
		 * @param {Number} y
		 * @param {*=} val The data to set on the map tile co-ordinate.
		 * @return {*}
		 */
		tileData: function (x, y, val) {
			if (x !== undefined && y !== undefined) {
				if (val !== undefined) {
					// Assign a value
					this._mapData[y] = this._mapData[y] || [];
					this._mapData[y][x] = val;
					return this;
				} else {
					// No assignment so see if we have data to return
					if (this._mapData[y]) {
						return this._mapData[y][x];
					}
				}
			}
			
			// Either no x, y was specified or there was
			// no data at the x, y so return undefined
			return undefined;
		},
		
		/**
		 * Clears any data set at the specified map tile co-ordinates.
		 * @param x
		 * @param y
		 * @return {Boolean} True if data was cleared or false if no data existed.
		 */
		clearData: function (x, y) {
			if (x !== undefined && y !== undefined) {
				if (this._mapData[y] !== undefined) {
					delete this._mapData[y][x];
					return true;
				}
			}
			
			return false;
		},
		
		/**
		 * Checks if the tile area passed has any data stored in it. If
		 * so, returns true, otherwise false.
		 * @param x
		 * @param y
		 * @param width
		 * @param height
		 */
		collision: function (x, y, width, height) {
			var xi, yi;
			
			if (width === undefined) { width = 1; }
			if (height === undefined) { height = 1; }
			
			if (x !== undefined && y !== undefined) {
				for (yi = 0; yi < height; yi++) {
					for (xi = 0; xi < width; xi++) {
						if (this.tileData(x + xi, y + yi)) {
							return true;
						}
					}
				}
			}
			
			return false;
		},
		
		/**
		 * Checks if the tile area passed has data stored in it that matches
		 * the passed data. If so, returns true, otherwise false.
		 * @param x
		 * @param y
		 * @param width
		 * @param height
		 * @param data
		 */
		collisionWith: function (x, y, width, height, data) {
			var xi, yi;
			
			if (width === undefined) { width = 1; }
			if (height === undefined) { height = 1; }
			
			if (x !== undefined && y !== undefined) {
				for (yi = 0; yi < height; yi++) {
					for (xi = 0; xi < width; xi++) {
						if (this.tileData(x + xi, y + yi) === data) {
							return true;
						}
					}
				}
			}
			
			return false;
		},
		
		/**
		 * Checks if the tile area passed has data stored in it that matches
		 * the passed data and does not collide with any other stored tile
		 * data. If so, returns true, otherwise false.
		 * @param x
		 * @param y
		 * @param width
		 * @param height
		 * @param data
		 */
		collisionWithOnly: function (x, y, width, height, data) {
			var xi, yi,
				tileData,
				withData = false;
			
			if (width === undefined) { width = 1; }
			if (height === undefined) { height = 1; }
			
			if (x !== undefined && y !== undefined) {
				for (yi = 0; yi < height; yi++) {
					for (xi = 0; xi < width; xi++) {
						tileData = this.tileData(x + xi, y + yi);
						if (tileData) {
							if (this.tileData(x + xi, y + yi) === data) {
								withData = true;
							} else {
								return false;
							}
						}
					}
				}
			}
			
			return withData;
		},
		
		/**
		 * Gets / sets the map's tile data.
		 * @param {Array} val The map data array.
		 * @param {Integer} startX The start x co-ordinate of the data.
		 * @param {Integer} startY The start y co-ordinate of the data.
		 * @return {*}
		 */
		mapData: function (val, startX, startY) {
			if (val !== undefined) {
				if (!startX && !startY) {
					this._mapData = val;
				} else {
					// Loop the map data and apply based on the start positions
					var x, y;
					
					for (y in val) {
						for (x in val[y]) {
							this._mapData[startY + parseInt(y)][startX + parseInt(x)] = val[y][x];
						}
					}
				}
				return this;
			}
			
			return this._mapData;
		},
		
		sortedMapDataAsArray: function () {
			var data = this.mapData(),
				finalData = {};
			
			var x, y, xArr, yArr, i, k;
			
			yArr = this._sortKeys(data);
			
			for (i = 0; i < yArr.length; i++) {
				y = yArr[i];
				xArr = this._sortKeys(data[y]);
				
				finalData[y] = finalData[y] || {};
				
				for (k = 0; k < xArr.length; k++) {
					x = xArr[k];
					finalData[y][x] = data[y][x];
				}
			}
			
			return finalData;
		},
		
		_sortKeys: function (obj) {
			var arr = [];
			
			for (var i in obj) {
				arr.push(i);
			}
			
			arr.sort();
			return arr;
		},
		
		/**
		 * Returns a string of the map's data in JSON format.
		 * @return {String}
		 */
		mapDataString: function () {
			return JSON.stringify(this.mapData());
		},
		
		/**
		 * Inserts map data into the map at the given co-ordinates. Please note this
		 * is not used for setting a tile's value. This is used to add large sections
		 * of map data at the specified co-ordinates. To set an individual tile value,
		 * please use tile(x, y, val).
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Array} val The map data array.
		 */
		//TODO: Write this function's internals!
		insertMapData: function (x, y, val) {
			// Loop the data and fill the map data with it
		},
		
		/**
		 * Rotates map data either -90 degrees (anti-clockwise), 90 degrees (clockwise) or
		 * 180 degrees. Useful when you want to define one section of a map and then re-use
		 * it in slightly different layouts.
		 * @param {Array} val The map data array to rotate.
		 * @param {Number} mode Either -90, 90 or 180 to denote the type of rotation to perform.
		 */
		//TODO: Write this function's internals!
		rotateData: function (val, mode) {
			switch (mode) {
				case -90:
					// Rotate the data
					break;
				
				case 180:
					break;
				
				case 90:
				default:
					break;
			}
		},
		
		translateDataBy: function (transX, transY) {
			var yArr = this.mapData(),
				newArr = [],
				x, y,
				xArr,
				i, k;
			
			for (y in yArr) {
				if (yArr.hasOwnProperty(y)) {
					i = parseInt(y, 10);
					xArr = yArr[i];
					
					newArr[i + transY] = newArr[i + transY] || {};
					
					for (x in xArr) {
						if (xArr.hasOwnProperty(x)) {
							k = parseInt(x, 10);
							newArr[i + transY][k + transX] = yArr[y][x];
						}
					}
				}
			}
			
			this.mapData(newArr, 0, 0);
		}
	});
	
	return IgeMap2d;
});
},{"irrelon-appcore":125}],67:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeMapStack2d', function (IgeClass) {
	/**
	 * Creates a new map that has two dimensions (x and y) to it's data
	 * and allows multiple items to be stored or "stacked" on a single
	 * x, y map position.
	 */
	var IgeMapStack2d = IgeClass.extend({
		classId: 'IgeMapStack2d',
		
		init: function (data) {
			this._mapData = data || [];
		},
		
		/**
		 * Gets / sets the data stored at the specified map tile co-ordinates. If data already
		 * exists at the specified co-ordinates, it is replaced with the passed data.
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Array=} val The array of data items to set at the specified co-ordinates.
		 * @return {*} This or an array of data items at the specified co-ordinates.
		 */
		tileData: function (x, y, val) {
			if (x !== undefined && y !== undefined) {
				if (val !== undefined) {
					// Assign a value
					this._mapData[y] = this._mapData[y] || [];
					this._mapData[y][x] = [];
					this._mapData[y][x].push(val);
					return this;
				} else {
					// No assignment so see if we have data to return
					if (this._mapData[y] !== undefined) {
						return this._mapData[y][x];
					}
				}
			}
			
			// Either no x, y was specified or there was
			// no data at the x, y so return undefined
			return undefined;
		},
		
		/**
		 * Gets the data stored at the specified co-ordinates and index.
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} index
		 * @return {*} The current data stored at the specified point or undefined if no data exists.
		 */
		tileDataAtIndex: function (x, y, index) {
			if (this._mapData[y] && this._mapData[y][x]) {
				return this._mapData[y][x][index];
			}
			
			return undefined;
		},
		
		/**
		 * Adds a data item to the specified map tile co-ordinates.
		 * @param {Number} x
		 * @param {Number} y
		 * @param {*} val The data to add.
		 * @return {*} This on success or false on failure.
		 */
		push: function (x, y, val) {
			if (val !== undefined) {
				this._mapData[y] = this._mapData[y] || [];
				this._mapData[y][x] = this._mapData[y][x] || [];
				this._mapData[y][x].push(val);
				return this;
			}
			
			return false;
		},
		
		/**
		 * Removes a data item from the specified map tile co-ordinates.
		 * @param {Number} x
		 * @param {Number} y
		 * @param {*} val The data to remove.
		 * @return {*} This on success or false on failure.
		 */
		pull: function (x, y, val) {
			if (this._mapData[y] && this._mapData[y][x]) {
				this._mapData[y][x].pull(val);
				return this;
			}
			
			return false;
		},
		
		/**
		 * Checks if the tile area passed has any data stored in it. If
		 * so, returns true, otherwise false.
		 * @param x
		 * @param y
		 * @param width
		 * @param height
		 */
		collision: function (x, y, width, height) {
			var xi, yi;
			
			if (width === undefined) { width = 1; }
			if (height === undefined) { height = 1; }
			
			if (x !== undefined && y !== undefined) {
				for (yi = 0; yi < height; yi++) {
					for (xi = 0; xi < width; xi++) {
						if (this._mapData[y + yi] && this._mapData[y + yi][x + xi] && this._mapData[y + yi][x + xi].length) {
							return true;
						}
					}
				}
			}
			
			return false;
		},
		
		/**
		 * Clears any data set at the specified map tile co-ordinates.
		 * @param x
		 * @param y
		 * @return {Boolean} True if data was cleared or false if no data existed.
		 */
		clearData: function (x, y) {
			if (x !== undefined && y !== undefined) {
				if (this._mapData[y] !== undefined) {
					delete this._mapData[y][x];
					return true;
				}
			}
			
			return false;
		},
		
		/**
		 * Gets / sets the map's tile data.
		 * @param {Array} val The map data array.
		 * @return {*}
		 */
		mapData: function (val) {
			if (val !== undefined) {
				this._mapData = val;
				return this;
			}
			
			return this._mapData;
		}
	});
	
	return IgeMapStack2d;
});
},{"irrelon-appcore":125}],68:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeMatrix2d', function (IgePoint3d) {
// TODO: Clean up the variable declarations in this file so they all run on the same var call at the top of the method.
	/**
	 * Creates a new transformation matrix.
	 */
	var IgeMatrix2d = function () {
		this.matrix = [
			1.0, 0.0, 0.0,
			0.0, 1.0, 0.0,
			0.0, 0.0, 1.0
		];
		
		this._rotateOrigin = new IgePoint3d(0, 0, 0);
		this._scaleOrigin = new IgePoint3d(0, 0, 0);
	};
	
	IgeMatrix2d.prototype = {
		matrix: null,
		
		/**
		 * Transform a point by this matrix. The parameter point will be modified with the transformation values.
		 * @param {IgePoint3d} point
		 * @return {IgePoint3d} The passed point.
		 */
		transformCoord: function (point, obj) {
			var x = point.x,
				y = point.y,
				tm = this.matrix;
			
			point.x = x * tm[0] + y * tm[1] + tm[2];
			point.y = x * tm[3] + y * tm[4] + tm[5];
			
			/* DEXCLUDE */
			if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
				obj.log('The matrix operation produced a NaN value!', 'error');
			}
			/* DEXCLUDE */
			
			return point;
		},
		
		/**
		 * Transform a point by this matrix in inverse. The parameter point will be modified with the transformation values.
		 * @param {IgePoint3d} point.
		 * @return {IgePoint3d} The passed point.
		 */
		transformCoordInverse: function (point, obj) {
			var x = point.x,
				y = point.y,
				tm = this.matrix;
			
			point.x = x * tm[0] - y * tm[1] + tm[2];
			point.y = x * tm[3] + y * tm[4] - tm[5];
			
			/* DEXCLUDE */
			if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
				obj.log('The matrix operation produced a NaN value!', 'error');
			}
			/* DEXCLUDE */
			
			return point;
		},
		
		transform: function (points, obj) {
			var pointIndex,
				pointCount = points.length;
			
			for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
				this.transformCoord(points[pointIndex], obj);
			}
			
			return points;
		},
		
		/**
		 * Create a new rotation matrix and set it up for the specified angle in radians.
		 * @param {Number} angle
		 * @return {IgeMatrix2d} A new matrix object.
		 */
		_newRotate: function (angle) {
			var m = new IgeMatrix2d();
			m.rotateTo(angle);
			return m;
		},
		
		rotateBy: function (angle) {
			var m = new IgeMatrix2d();
			
			m.translateBy(this._rotateOrigin.x, this._rotateOrigin.y);
			m.rotateTo(angle);
			m.translateBy(-this._rotateOrigin.x, -this._rotateOrigin.y);
			
			this.multiply(m);
			
			return this;
		},
		
		rotateTo: function (angle) {
			var tm = this.matrix,
				c = Math.cos(angle),
				s = Math.sin(angle);
			
			tm[0] = c;
			tm[1] = -s;
			tm[3] = s;
			tm[4] = c;
			
			/* DEXCLUDE */
			if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
				console.log('The matrix operation produced a NaN value!', 'error');
			}
			/* DEXCLUDE */
			
			return this;
		},
		
		/**
		 * Gets the rotation from the matrix and returns it in
		 * radians.
		 * @return {Number}
		 */
		rotationRadians: function () {
			return Math.asin(this.matrix[3]);
		},
		
		/**
		 * Gets the rotation from the matrix and returns it in
		 * degrees.
		 * @return {Number}
		 */
		rotationDegrees: function () {
			return Math.degrees(Math.acos(this.matrix[0]));
		},
		
		/**
		 * Create a scale matrix.
		 * @param {Number} x X scale magnitude.
		 * @param {Number} y Y scale magnitude.
		 *
		 * @return {IgeMatrix2d} a matrix object.
		 *
		 * @static
		 */
		_newScale: function (x, y) {
			var m = new IgeMatrix2d();
			
			m.matrix[0] = x;
			m.matrix[4] = y;
			
			return m;
		},
		
		scaleBy: function (x, y) {
			var m = new IgeMatrix2d();
			
			m.matrix[0] = x;
			m.matrix[4] = y;
			
			this.multiply(m);
			
			return this;
		},
		
		scaleTo: function (x, y) {
			var tm = this.matrix;
			//this.identity();
			tm[0] = x;
			tm[4] = y;
			
			/* DEXCLUDE */
			if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
				this.log('The matrix operation produced a NaN value!', 'error');
			}
			/* DEXCLUDE */
			
			return this;
		},
		
		/**
		 * Create a translation matrix.
		 * @param {Number} x X translation magnitude.
		 * @param {Number} y Y translation magnitude.
		 * @return {IgeMatrix2d} A new matrix object.
		 */
		_newTranslate: function (x, y) {
			var m = new IgeMatrix2d();
			
			m.matrix[2] = x;
			m.matrix[5] = y;
			
			return m;
		},
		
		translateBy: function (x, y) {
			var m = new IgeMatrix2d();
			
			m.matrix[2] = x;
			m.matrix[5] = y;
			
			this.multiply(m);
			
			return this;
		},
		
		/**
		 * Sets this matrix as a translation matrix.
		 * @param x
		 * @param y
		 */
		translateTo: function (x, y) {
			var tm = this.matrix;
			
			tm[2] = x;
			tm[5] = y;
			
			/* DEXCLUDE */
			if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
				this.log('The matrix operation produced a NaN value!', 'error');
			}
			/* DEXCLUDE */
			
			return this;
		},
		
		/**
		 * Copy into this matrix the given matrix values.
		 * @param {IgeMatrix2d} matrix
		 * @return {Object} "this".
		 */
		copy: function (matrix) {
			matrix = matrix.matrix;
			
			var tmatrix = this.matrix;
			tmatrix[0] = matrix[0];
			tmatrix[1] = matrix[1];
			tmatrix[2] = matrix[2];
			tmatrix[3] = matrix[3];
			tmatrix[4] = matrix[4];
			tmatrix[5] = matrix[5];
			tmatrix[6] = matrix[6];
			tmatrix[7] = matrix[7];
			tmatrix[8] = matrix[8];
			
			return this;
		},
		
		compare: function (matrix) {
			var thisMatrix = this.matrix,
				thatMatrix = matrix.matrix;
			
			for (var i = 0; i < 9; i++) {
				if (thisMatrix[i] !== thatMatrix[i]) {
					return false;
				}
			}
			
			return true;
		},
		
		/**
		 * Set this matrix to the identity matrix.
		 * @return {Object} "this".
		 */
		identity: function () {
			
			var m = this.matrix;
			m[0] = 1.0;
			m[1] = 0.0;
			m[2] = 0.0;
			
			m[3] = 0.0;
			m[4] = 1.0;
			m[5] = 0.0;
			
			m[6] = 0.0;
			m[7] = 0.0;
			m[8] = 1.0;
			
			return this;
		},
		
		/**
		 * Multiply this matrix by a given matrix.
		 * @param {IgeMatrix2d} m The IgeMatrix2d to multiply the
		 * current matrix by.
		 * @return {Object} "this".
		 */
		multiply: function (m) {
			var tm = this.matrix,
				mm = m.matrix,
				
				tm0 = tm[0],
				tm1 = tm[1],
				tm2 = tm[2],
				tm3 = tm[3],
				tm4 = tm[4],
				tm5 = tm[5],
				tm6 = tm[6],
				tm7 = tm[7],
				tm8 = tm[8],
				
				mm0 = mm[0],
				mm1 = mm[1],
				mm2 = mm[2],
				mm3 = mm[3],
				mm4 = mm[4],
				mm5 = mm[5],
				mm6 = mm[6],
				mm7 = mm[7],
				mm8 = mm[8];
			
			tm[0] = tm0 * mm0 + tm1 * mm3 + tm2 * mm6;
			tm[1] = tm0 * mm1 + tm1 * mm4 + tm2 * mm7;
			tm[2] = tm0 * mm2 + tm1 * mm5 + tm2 * mm8;
			tm[3] = tm3 * mm0 + tm4 * mm3 + tm5 * mm6;
			tm[4] = tm3 * mm1 + tm4 * mm4 + tm5 * mm7;
			tm[5] = tm3 * mm2 + tm4 * mm5 + tm5 * mm8;
			tm[6] = tm6 * mm0 + tm7 * mm3 + tm8 * mm6;
			tm[7] = tm6 * mm1 + tm7 * mm4 + tm8 * mm7;
			tm[8] = tm6 * mm2 + tm7 * mm5 + tm8 * mm8;
			
			return this;
		},
		
		/**
		 * Premultiply this matrix by a given matrix.
		 * @param {IgeMatrix2d} m The IgeMatrix2d to premultiply the
		 * current matrix by.
		 * @return {Object} "this".
		 */
		premultiply: function (m) {
			
			var m00 = m.matrix[0] * this.matrix[0] + m.matrix[1] * this.matrix[3] + m.matrix[2] * this.matrix[6];
			var m01 = m.matrix[0] * this.matrix[1] + m.matrix[1] * this.matrix[4] + m.matrix[2] * this.matrix[7];
			var m02 = m.matrix[0] * this.matrix[2] + m.matrix[1] * this.matrix[5] + m.matrix[2] * this.matrix[8];
			
			var m10 = m.matrix[3] * this.matrix[0] + m.matrix[4] * this.matrix[3] + m.matrix[5] * this.matrix[6];
			var m11 = m.matrix[3] * this.matrix[1] + m.matrix[4] * this.matrix[4] + m.matrix[5] * this.matrix[7];
			var m12 = m.matrix[3] * this.matrix[2] + m.matrix[4] * this.matrix[5] + m.matrix[5] * this.matrix[8];
			
			var m20 = m.matrix[6] * this.matrix[0] + m.matrix[7] * this.matrix[3] + m.matrix[8] * this.matrix[6];
			var m21 = m.matrix[6] * this.matrix[1] + m.matrix[7] * this.matrix[4] + m.matrix[8] * this.matrix[7];
			var m22 = m.matrix[6] * this.matrix[2] + m.matrix[7] * this.matrix[5] + m.matrix[8] * this.matrix[8];
			
			this.matrix[0] = m00;
			this.matrix[1] = m01;
			this.matrix[2] = m02;
			
			this.matrix[3] = m10;
			this.matrix[4] = m11;
			this.matrix[5] = m12;
			
			this.matrix[6] = m20;
			this.matrix[7] = m21;
			this.matrix[8] = m22;
			
			return this;
		},
		
		/**
		 * Creates a new inverse matrix from this matrix.
		 * @return {IgeMatrix2d} An inverse matrix.
		 */
		getInverse: function () {
			var tm = this.matrix;
			
			var m00 = tm[0],
				m01 = tm[1],
				m02 = tm[2],
				m10 = tm[3],
				m11 = tm[4],
				m12 = tm[5],
				m20 = tm[6],
				m21 = tm[7],
				m22 = tm[8],
				
				newMatrix = new IgeMatrix2d(),
				determinant = m00 * (m11 * m22 - m21 * m12) - m10 * (m01 * m22 - m21 * m02) + m20 * (m01 * m12 - m11 * m02);
			
			if (determinant === 0) {
				return null;
			}
			
			var m = newMatrix.matrix;
			
			m[0] = m11 * m22 - m12 * m21;
			m[1] = m02 * m21 - m01 * m22;
			m[2] = m01 * m12 - m02 * m11;
			
			m[3] = m12 * m20 - m10 * m22;
			m[4] = m00 * m22 - m02 * m20;
			m[5] = m02 * m10 - m00 * m12;
			
			m[6] = m10 * m21 - m11 * m20;
			m[7] = m01 * m20 - m00 * m21;
			m[8] = m00 * m11 - m01 * m10;
			
			newMatrix.multiplyScalar(1 / determinant);
			
			return newMatrix;
		},
		
		/**
		 * Multiply this matrix by a scalar.
		 * @param scalar {number} Scalar value.
		 * @return this
		 */
		multiplyScalar: function (scalar) {
			var i;
			
			for (i = 0; i < 9; i++) {
				this.matrix[i] *= scalar;
			}
			
			return this;
		},
		
		/**
		 * Transforms the passed rendering context by the current matrix
		 * data using the setTransform() method so that the matrix data
		 * is set non-cumulative with the previous matrix data.
		 * @param {CanvasRenderingContext2d} ctx The rendering context to
		 * set the transform matrix for.
		 */
		transformRenderingContextSet: function (ctx) {
			var m = this.matrix;
			ctx.setTransform(m[0], m[3], m[1], m[4], m[2], m[5]);
			return this;
		},
		
		/**
		 * Transforms the passed rendering context by the current matrix
		 * data using the transform() method so that the matrix data
		 * is set cumulative with the previous matrix data.
		 * @param {CanvasRenderingContext2d} ctx The rendering context to
		 * set the transform matrix for.
		 */
		transformRenderingContext: function (ctx) {
			var m = this.matrix;
			ctx.transform(m[0], m[3], m[1], m[4], m[2], m[5]);
			return this;
		}
	};
	
	return IgeMatrix2d;
});
},{"irrelon-appcore":125}],69:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeObject', function ($ige, igeBase, IgeEventingClass) {
	/**
	 * Creates a new object.
	 */
	var IgeObject = IgeEventingClass.extend({
		classId: 'IgeObject',
		
		init: function () {
			this._newBorn = true;
			this._alive = true;
			this._mode = 0;
			this._mountMode = 0;
			this._parent = null;
			this._children = [];
			this._layer = 0;
			this._depth = 0;
			this._depthSortMode = 0;
			this._timeStream = [];
			this._inView = true;
			this._managed = 1;
			
			this._specialProp = [
				'_id',
				'_parent',
				'_children'
			];
		},
		
		/**
		 * Determines if the object is alive or not. The alive
		 * value is automatically set to false when the object's
		 * destroy() method is called. Useful for checking if
		 * an object that you are holding a reference to has been
		 * destroyed.
		 * @param {Boolean=} val The value to set the alive flag
		 * to.
		 * @example #Get the alive flag value
		 *     var entity = new IgeEntity();
		 *     console.log(entity.alive());
		 * @example #Set the alive flag value
		 *     var entity = new IgeEntity();
		 *     entity.alive(true);
		 * @return {*}
		 */
		alive: function (val) {
			if (val !== undefined) {
				this._alive = val;
				return this;
			}
			
			return this._alive;
		},
		
		/**
		 * Gets / set the managed mode from 0 to 2. 0 = off, 1 = static, 2 = dynamic.
		 *
		 * @param {Number=} val Set to 0 to switch off managed mode, 1 to set to static
		 * managed mode or 2 to dynamic managed mode. When in a managed mode and when
		 * the parent of this entity has an entity manager component enabled, the entity
		 * will be checked to see if it is inside the visible area of a viewport. If it
		 * is deemed not to be in a visible area (via it's AABB non-intersection with
		 * viewport view area) then it will either be un-mounted from the parent (mode 1)
		 * or marked as no longer in view (mode 2). Mode 2 in view = false will cause the
		 * entity to no longer be depth-sorted or rendered but will still have it's
		 * update() method called each frame allowing logic processing to occur as normal.
		 * The default managed mode is 1.
		 * @returns {*}
		 */
		managed: function (val) {
			if (val !== undefined) {
				this._managed = val;
				return this;
			}
			
			return this._managed;
		},
		
		/**
		 * Gets / sets the current object id. If no id is currently assigned and no
		 * id is passed to the method, it will automatically generate and assign a
		 * new id as a 16 character hexadecimal value typed as a string.
		 * @param {String=} id
		 * @example #Get the id of an entity
		 *     var entity = new IgeEntity();
		 *     console.log(entity.id());
		 * @example #Set the id of an entity
		 *     var entity = new IgeEntity();
		 *     entity.id('myNewId');
		 * @example #Set the id of an entity via chaining
		 *     var entity = new IgeEntity()
		 *         .id('myNewId');
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		id: function (id) {
			if (id !== undefined) {
				// Check if we're changing the id
				if (id !== this._id) {
					// Check if this ID already exists in the object register
					if ($ige.engine._register[id]) {
						// Already an object with this ID!
						if ($ige.engine._register[id] !== this) {
							this.log('Cannot set ID of object to "' + id + '" because that ID is already in use by another object!', 'error');
						}
					} else {
						// Check if we already have an id assigned
						if (this._id && $ige.engine._register[this._id]) {
							// Unregister the old ID before setting this new one
							$ige.engine.unRegister(this);
						}
						
						this._id = id;
						
						// Now register this object with the object register
						$ige.engine.register(this);
						
						return this;
					}
				} else {
					// The same ID we already have is being applied,
					// ignore the request and return
					return this;
				}
			}
			
			if (!this._id) {
				// The item has no id so generate one automatically
				this._id = $ige.engine.newIdHex();
				$ige.engine.register(this);
			}
			
			return this._id;
		},
		
		/**
		 * Gets / sets the arbitrary category name that the object belongs to.
		 * @param {String=} val
		 * @example #Get the category of an entity
		 *     var entity = new IgeEntity();
		 *     console.log(entity.category());
		 * @example #Set the category of an entity
		 *     var entity = new IgeEntity();
		 *     entity.category('myNewCategory');
		 * @example #Set the category of an entity via chaining
		 *     var entity = new IgeEntity()
		 *         .category('myNewCategory');
		 * @example #Get all the entities belonging to a category
		 *     var entityArray = $ige.engine.$$('categoryName');
		 * @example #Remove the category of an entity
		 *     // Set category to some name
		 *     var entity = new IgeEntity()
		 *         .category('myCategory');
		 *
		 *     // Will output "myCategory"
		 *     console.log(entity.category());
		 *
		 *     // Now remove the category
		 *     entity.category('');
		 *
		 *     // Will return ""
		 *     console.log(entity.category());
		 * @return {*}
		 */
		category: function (val) {
			if (val !== undefined) {
				// Check if we already have a category
				if (this._category) {
					// Check if the category being assigned is different from
					// the current one
					if (this._category !== val) {
						// The category is different so remove this object
						// from the current category association
						$ige.engine.categoryUnRegister(this);
					}
				}
				
				this._category = val;
				
				// Check the category is not a blank string
				if (val) {
					// Now register this object with the category it has been assigned
					$ige.engine.categoryRegister(this);
				}
				return this;
			}
			
			return this._category;
		},
		
		/**
		 * DEPRECIATED - Use category() instead. A warning method to
		 * help developers move to the new groups system.
		 */
		group: function () {
			this.log('The group() method has been renamed to category(). Please update your code.', 'error');
		},
		
		/**
		 * Adds this entity to a group or groups passed as
		 * arguments.
		 * @param {*} groupName A group or array of group names
		 * to add the entity to.
		 * @example #Add entity to a single group
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1');
		 * @example #Add entity to multiple groups
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g2', 'g3');
		 * @example #Add entity to multiple groups via an array
		 *     var entity = new IgeEntity();
		 *     entity.addGroup(['g1', 'g2', 'g3']);
		 * @example #Add entity to multiple groups via multiple arrays
		 *     var entity = new IgeEntity();
		 *     entity.addGroup(['g1', 'g2', 'g3'], ['g4', 'g5']);
		 * @return {*}
		 */
		addGroup: function () {
			var arrCount = arguments.length,
				groupName,
				groupItemCount;
			
			while (arrCount--) {
				groupName = arguments[arrCount];
				
				// Check if the argument is an array
				if (groupName instanceof Array) {
					groupItemCount = groupName.length;
					
					// Add each group of the array to the entity
					while (groupItemCount--) {
						if (!this._groups || this._groups.indexOf(groupName[groupItemCount]) === -1) {
							this._groups = this._groups || [];
							this._groups.push(groupName[groupItemCount]);
							
							// Now register this object with the group it has been assigned
							$ige.engine.groupRegister(this, groupName[groupItemCount]);
						}
					}
				} else {
					if (!this._groups || this._groups.indexOf(groupName) === -1) {
						this._groups = this._groups || [];
						this._groups.push(groupName);
						
						// Now register this object with the group it has been assigned
						$ige.engine.groupRegister(this, groupName);
					}
				}
			}
			
			return this;
		},
		
		/**
		 * Checks if the entity is in the group or array of group
		 * names passed.
		 * @param {*} groupName A group name or array of names.
		 * @param {Boolean=} matchAllGroups If set to true, will cause
		 * the method to check if the entity is in ALL the groups,
		 * otherwise the method will check if the entity is in ANY group.
		 * @example #Check if the entity is in a group
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g2');
		 *
		 *     // Will output true since entity is part of g1 group
		 *     console.log(entity.inGroup('g1', false);
		 *
		 *     // Will output false since entity is not part of g3 group
		 *     console.log(entity.inGroup('g3', false);
		 * @example #Check if the entity is in an array of groups using ANY and ALL options
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g2');
		 *
		 *     // Will output true since entity is part of g1 group
		 *     console.log(entity.inGroup(['g1, 'g3'], false);
		 *
		 *     // Will output false since entity is not part of g3 group
		 *     console.log(entity.inGroup(['g1, 'g3'], true);
		 * @return {Boolean}
		 */
		inGroup: function (groupName, matchAllGroups) {
			if (groupName) {
				if (matchAllGroups) {
					return this.inAllGroups(groupName);
				} else {
					return this.inAnyGroup(groupName);
				}
			}
			
			return false;
		},
		
		/**
		 * Checks if the entity is in the specified group or
		 * array of groups. If multiple group names are passed,
		 * as an array the method will only return true if the
		 * entity is in ALL the passed groups.
		 * @param {*} groupName The name of the group or array
		 * if group names to check if this entity is a member of.
		 * @example #Check if entity belongs to all of the passed groups
		 *     // Add a couple of groups
		 *     var entity = new IgeEntity();
		 *     entity.addGroup(['g1', 'g2']);
		 *
		 *     // This will output "false" (entity is not part of g3)
		 *     console.log(entity.inAllGroups(['g1', 'g3']));
		 *
		 *     // This will output "true"
		 *     console.log(entity.inAllGroups('g1'));
		 *
		 *     // This will output "true"
		 *     console.log(entity.inAllGroups(['g1', 'g2']));
		 * @return {Boolean}
		 */
		inAllGroups: function (groupName) {
			var arrItem, arrCount;
			
			if (groupName instanceof Array) {
				arrCount = groupName.length;
				
				while (arrCount--) {
					arrItem = groupName[arrCount];
					
					if (arrItem) {
						if (!this._groups || this._groups.indexOf(arrItem) === -1) {
							return false;
						}
					}
				}
			} else {
				return !(!this._groups || this._groups.indexOf(groupName) === -1);
			}
			
			return true;
		},
		
		/**
		 * Checks if the entity is in the specified group or
		 * array of group names. If multiple group names are passed
		 * as an array, the method will return true if the entity
		 * is in ANY of the the passed groups.
		 * @param {*} groupName The name of the group or array of
		 * group names to check if this entity is a member of.
		 * @example #Check if entity belongs to any of the passed groups
		 *     // Add a couple of groups
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g2');
		 *
		 *     // This will output "false"
		 *     console.log(entity.inAnyGroup('g3'));
		 *
		 *     // This will output "true"
		 *     console.log(entity.inAnyGroup(['g3', 'g1']));
		 * @return {Boolean}
		 */
		inAnyGroup: function (groupName) {
			var arrItem, arrCount;
			
			if (groupName instanceof Array) {
				arrCount = groupName.length;
				
				while (arrCount--) {
					arrItem = groupName[arrCount];
					
					if (arrItem) {
						if (this._groups && this._groups.indexOf(arrItem) > -1) {
							return true;
						}
					}
				}
			} else {
				return (this._groups && this._groups.indexOf(groupName) > -1);
			}
			
			return false;
		},
		
		/**
		 * Gets an array of all groups this entity belongs to.
		 * @example #Get array of groups entity belongs to
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g2');
		 *
		 *     // This will output "['g1', 'g2']"
		 *     console.log(entity.groups());
		 * @return {*}
		 */
		groups: function () {
			return this._groups || [];
		},
		
		/**
		 * Gets the number of groups this entity belongs to.
		 * @example #Get number of groups entity belongs to
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g2');
		 *
		 *     // This will output "2"
		 *     console.log(entity.groupCount());
		 * @return {Number}
		 */
		groupCount: function () {
			return this._groups ? this._groups.length : 0;
		},
		
		/**
		 * Removes the entity from the group or groups passed. This
		 * method accepts multiple arguments and will remove the entity
		 * from all groups passed as arguments.
		 * @param {*} groupName The name of the group or array of group
		 * names to remove this entity as a member of.
		 * @example #Remove entity from single group
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g2');
		 *
		 *     // This will output "['g1', 'g2']"
		 *     console.log(entity.groups());
		 *
		 *     // Remove entity from a single group
		 *     entity.removeGroup('g1');
		 *
		 *     // This will output "['g2']"
		 *     console.log(entity.groups());
		 * @example #Remove entity from multiple groups
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g3', 'g2');
		 *
		 *     // This will output "['g1', 'g3', 'g2']"
		 *     console.log(entity.groups());
		 *
		 *     // Remove entity from multiple groups
		 *     entity.removeGroup('g1', 'g3');
		 *
		 *     // This will output "['g2']"
		 *     console.log(entity.groups());
		 * @example #Remove entity from multiple groups via an array
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g3', 'g2');
		 *
		 *     // This will output "['g1', 'g3', 'g2']"
		 *     console.log(entity.groups());
		 *
		 *     // Remove entity from multiple groups
		 *     entity.removeGroup(['g1', 'g3']);
		 *
		 *     // This will output "['g2']"
		 *     console.log(entity.groups());
		 * @example #Remove entity from multiple groups via multiple arrays
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7');
		 *
		 *     // This will output "['g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7']"
		 *     console.log(entity.groups());
		 *
		 *     // Remove entity from multiple groups
		 *     entity.removeGroup(['g1', 'g3'], ['g5', 'g6', 'g7']);
		 *
		 *     // This will output "['g2', 'g4']"
		 *     console.log(entity.groups());
		 * @return {*}
		 */
		removeGroup: function () {
			if (this._groups) {
				var arrCount = arguments.length,
					groupName,
					groupNameCount;
				
				while (arrCount--) {
					groupName = arguments[arrCount];
					
					if (groupName instanceof Array) {
						groupNameCount = groupName.length;
						
						while (groupNameCount--) {
							this._groups.pull(groupName[groupNameCount]);
							
							// Now un-register this object with the group it has been assigned
							$ige.engine.groupUnRegister(this, groupName[groupNameCount]);
						}
					} else {
						this._groups.pull(groupName);
						
						// Now un-register this object with the group it has been assigned
						$ige.engine.groupUnRegister(this, groupName);
					}
				}
			}
			
			return this;
		},
		
		/**
		 * Removes the entity from all groups it is a member of.
		 * @example #Remove entity from all groups
		 *     var entity = new IgeEntity();
		 *     entity.addGroup('g1', 'g3', 'g2');
		 *
		 *     // This will output "['g1', 'g3', 'g2']"
		 *     console.log(entity.groups());
		 *
		 *     // Remove all the groups
		 *     entity.removeAllGroups();
		 *
		 *     // This will output "[]"
		 *     console.log(entity.groups());
		 * @return {*}
		 */
		removeAllGroups: function () {
			if (this._groups) {
				// Loop through all groups and un-register one at a time
				var arr = this._groups,
					arrCount = arr.length;
				
				while (arrCount--) {
					$ige.engine.groupUnRegister(this, arr[arrCount]);
				}
				
				delete this._groups;
			}
			return this;
		},
		
		/**
		 * Adds a behaviour to the object's active behaviour list.
		 * @param {String} id
		 * @param {Function} behaviour
		 * @param {Boolean=} duringTick If true, will execute the behaviour
		 * during the tick() method instead of the update() method.
		 * @example #Add a behaviour with the id "myBehaviour"
		 *     var entity = new IgeEntity();
		 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
		 *
		 *     // Now since each update we are setting _somePropertyOfTheEntity
		 *     // to equal "moo" we can console log the property and get
		 *     // the value as "moo"
		 *     console.log(entity._somePropertyOfTheEntity);
		 * @return {*} Returns this on success or false on failure.
		 */
		addBehaviour: function (id, behaviour, duringTick) {
			if (typeof(id) === 'string') {
				if (typeof(behaviour) === 'function') {
					if (duringTick) {
						this._tickBehaviours = this._tickBehaviours || [];
						this._tickBehaviours.push({
							id:id,
							method: behaviour
						});
					} else {
						this._updateBehaviours = this._updateBehaviours || [];
						this._updateBehaviours.push({
							id:id,
							method: behaviour
						});
					}
					
					return this;
				} else {
					this.log('The behaviour you passed is not a function! The second parameter of the call must be a function!', 'error');
				}
			} else {
				this.log('Cannot add behaviour to object because the specified behaviour id is not a string. You must provide two parameters with the addBehaviour() call, an id:String and a behaviour:Function. Adding a behaviour with an id allows you to remove it by it\'s id at a later stage!', 'error');
			}
			
			return false;
		},
		
		/**
		 * Removes a behaviour to the object's active behaviour list by it's id.
		 * @param {String} id
		 * @param {Boolean=} duringTick If true will look to remove the behaviour
		 * from the tick method rather than the update method.
		 * @example #Remove a behaviour with the id "myBehaviour"
		 *     var entity = new IgeEntity();
		 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
		 *
		 *     // Now remove the "myBehaviour" behaviour
		 *     entity.removeBehaviour('myBehaviour');
		 * @return {*} Returns this on success or false on failure.
		 */
		removeBehaviour: function (id, duringTick) {
			if (id !== undefined) {
				var arr,
					arrCount;
				
				if (duringTick) {
					arr = this._tickBehaviours;
				} else {
					arr = this._updateBehaviours;
				}
				
				// Find the behaviour
				if (arr) {
					arrCount = arr.length;
					
					while (arrCount--) {
						if (arr[arrCount].id === id) {
							// Remove the item from the array
							arr.splice(arrCount, 1);
							return this;
						}
					}
				}
			}
			
			return false;
		},
		
		/**
		 * Checks if the object has the specified behaviour already added to it.
		 * @param {String} id
		 * @param {Boolean=} duringTick If true will look to remove the behaviour
		 * from the tick method rather than the update method.
		 * @example #Check for a behaviour with the id "myBehaviour"
		 *     var entity = new IgeEntity();
		 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
		 *
		 *     // Now check for the "myBehaviour" behaviour
		 *     console.log(entity.hasBehaviour('myBehaviour')); // Will log "true"
		 * @return {*} Returns this on success or false on failure.
		 */
		hasBehaviour: function (id, duringTick) {
			if (id !== undefined) {
				var arr,
					arrCount;
				
				if (duringTick) {
					arr = this._tickBehaviours;
				} else {
					arr = this._updateBehaviours;
				}
				
				// Find the behaviour
				if (arr) {
					arrCount = arr.length;
					
					while (arrCount--) {
						if (arr[arrCount].id === id) {
							return true;
						}
					}
				}
			}
			
			return false;
		},
		
		/**
		 * Gets / sets the boolean flag determining if this object should have
		 * it's bounds drawn when the bounds for all objects are being drawn.
		 * In order for bounds to be drawn the viewport the object is being drawn
		 * to must also have draw bounds enabled.
		 * @param {Boolean} val
		 * @example #Enable draw bounds
		 *     var entity = new IgeEntity();
		 *     entity.drawBounds(true);
		 * @example #Disable draw bounds
		 *     var entity = new IgeEntity();
		 *     entity.drawBounds(false);
		 * @example #Get the current flag value
		 *     console.log(entity.drawBounds());
		 * @return {*}
		 */
		drawBounds: function (val) {
			if (val !== undefined) {
				this._drawBounds = val;
				return this;
			}
			
			return this._drawBounds;
		},
		
		/**
		 * Gets / sets the boolean flag determining if this object should have
		 * it's bounds data drawn when the bounds for all objects are being drawn.
		 * Bounds data includes the object ID and it's current depth etc.
		 * @param {Boolean} val
		 * @example #Enable draw bounds data
		 *     var entity = new IgeEntity();
		 *     entity.drawBoundsData(true);
		 * @example #Disable draw bounds data
		 *     var entity = new IgeEntity();
		 *     entity.drawBoundsData(false);
		 * @example #Get the current flag value
		 *     console.log(entity.drawBoundsData());
		 * @return {*}
		 */
		drawBoundsData: function (val) {
			if (val !== undefined) {
				this._drawBoundsData = val;
				return this;
			}
			
			return this._drawBoundsData;
		},
		
		/**
		 * Gets / sets the boolean flag determining if this object should have
		 * it's mouse position drawn, usually for debug purposes.
		 * @param {Boolean=} val
		 * @example #Enable draw mouse position data
		 *     var entity = new IgeEntity();
		 *     entity.drawMouse(true);
		 * @example #Disable draw mouse position data
		 *     var entity = new IgeEntity();
		 *     entity.drawMouse(false);
		 * @example #Get the current flag value
		 *     console.log(entity.drawMouse());
		 * @return {*}
		 */
		drawMouse: function (val) {
			if (val !== undefined) {
				this._drawMouse = val;
				return this;
			}
			
			return this._drawMouse;
		},
		
		/**
		 * Gets / sets the boolean flag determining if this object should have
		 * it's extra mouse data drawn for debug purposes. For instance, on tilemaps
		 * (IgeTileMap2d) instances, when enabled you will see the tile x and y
		 * co-ordinates currently being hoverered over by the mouse.
		 * @param {Boolean=} val
		 * @example #Enable draw mouse data
		 *     var entity = new IgeEntity();
		 *     entity.drawMouseData(true);
		 * @example #Disable draw mouse data
		 *     var entity = new IgeEntity();
		 *     entity.drawMouseData(false);
		 * @example #Get the current flag value
		 *     console.log(entity.drawMouseData());
		 * @return {*}
		 */
		drawMouseData: function (val) {
			if (val !== undefined) {
				this._drawMouseData = val;
				return this;
			}
			
			return this._drawMouseData;
		},
		
		/**
		 * Finds a child entity that matches the id mounted to this
		 * or any other child entity down the scenegraph chain. Will
		 * only return an object if the entity found has this entity
		 * as an ancestor (parent or parent of parent etc).
		 * @param {String} id The id of the entity to find.
		 * @returns {*} The entity or undefined.
		 */
		$: function (id) {
			var obj = $ige.engine.$(id);
			
			if (obj._parent === this) {
				// We found a child and it's parent is this object so return it
				return obj;
			} else {
				// Scan up the object's parent chain to see if this object is
				// an ancestor at some point
				var ancestor = obj.parent(this.id());
				
				if (ancestor) {
					return obj;
				} else {
					return undefined;
				}
			}
		},
		
		/**
		 * Finds all child entities of this or any child of this entity
		 * down the scenegraph who's category matches the category name
		 * passed.
		 * @param {String} categoryName The category name to scan for.
		 * @returns {Array}
		 */
		$$: function (categoryName) {
			var objArr = $ige.engine.$$(categoryName),
				arrCount = objArr.length,
				obj,
				finalArr = [],
				thisId = this.id();
			
			// Scan all objects that have the specified category
			// and see if we are it's parent or an ancestor
			while (arrCount--) {
				obj = objArr[arrCount];
				if (obj._parent === this || obj.parent(thisId)) {
					finalArr.push(obj);
				}
			}
			
			return finalArr;
		},
		
		/**
		 * Returns the object's parent object (the object that
		 * it is mounted to).
		 * @param {String=} id Optional, if present will scan up
		 * the parent chain until a parent with the matching id is
		 * found. If none is found, returns undefined.
		 * @example #Get the object parent
		 *     // Create a couple of entities and give them ids
		 *     var entity1 = new IgeEntity().id('entity1'),
		 *         entity2 = new IgeEntity().id('entity2');
		 *
		 *     // Mount entity2 to entity1
		 *     entity2.mount(entity1);
		 *
		 *     // Get the parent of entity2 (which is entity1)
		 *     var parent = entity2.parent();
		 *
		 *     // Log the parent's id (will output "entity1")
		 *     console.log(parent.id());
		 * @return {*}
		 */
		parent: function (id) {
			if (!id) {
				return this._parent;
			}
			
			if (this._parent) {
				if (this._parent.id() === id) {
					return this._parent;
				} else {
					return this._parent.parent(id);
				}
			}
			
			return undefined;
		},
		
		/**
		 * Returns the object's children as an array of objects.
		 * @example #Get the child objects array
		 *     // Create a couple of entities and give them ids
		 *     var entity1 = new IgeEntity().id('entity1'),
		 *         entity2 = new IgeEntity().id('entity2');
		 *
		 *     // Mount entity2 to entity1
		 *     entity2.mount(entity1);
		 *
		 *     // Get the chilren array entity1
		 *     var childArray = entity1.children();
		 *
		 *     // Log the child array contents (will contain entity2)
		 *     console.log(childArray);
		 * @return {Array} The array of child objects.
		 */
		children: function () {
			return this._children;
		},
		
		/**
		 * Mounts this object to the passed object in the scenegraph.
		 * @param {IgeObject} obj
		 * @example #Mount an entity to another entity
		 *     // Create a couple of entities and give them ids
		 *     var entity1 = new IgeEntity().id('entity1'),
		 *         entity2 = new IgeEntity().id('entity2');
		 *
		 *     // Mount entity2 to entity1
		 *     entity2.mount(entity1);
		 * @return {*} Returns this on success or false on failure.
		 */
		mount: function (obj) {
			if (obj) {
				if (obj === this) {
					this.log('Cannot mount an object to itself!', 'error');
					return this;
				}
				
				if (obj._children) {
					// Check that the engine will allow us to register this object
					this.id(); // Generates a new id if none is currently set, and registers it on the object register!
					
					if (this._parent) {
						if (this._parent === obj) {
							// We are already mounted to the parent!
							return this;
						} else {
							// We are already mounted to a different parent
							this.unMount();
						}
					}
					
					this._parent = obj;
					
					// Check if we need to set the ignore camera flag
					if (!this._ignoreCamera && this._parent._ignoreCamera) {
						this._ignoreCamera = this._parent._ignoreCamera;
						
						/*if (this.ignoreCameraComposite) {
						 this.ignoreCameraComposite(this._parent._ignoreCamera);
						 }*/
					}
					
					// Make sure we keep the child's room id in sync with it's parent
					if (this._parent._streamRoomId) {
						this._streamRoomId = this._parent._streamRoomId;
					}
					
					obj._children.push(this);
					this._parent._childMounted(this);
					
					if (obj.updateTransform) {
						obj.updateTransform();
						obj.aabb(true);
					}
					
					if (obj._compositeCache) {
						this._compositeParent = true;
					} else {
						delete this._compositeParent;
					}
					
					this._mounted(this._parent);
					
					this.emit('mounted', this._parent);
					
					return this;
				} else {
					// The object has no _children array!
					this.log('Cannot mount object because it has no _children array! If you are mounting to a custom class, ensure that you have called the prototype.init() method of your super-class during the init of your custom class.', 'warning');
					return false;
				}
			} else {
				this.log('Cannot mount non-existent object!', 'error');
			}
		},
		
		/**
		 * Unmounts this object from it's parent object in the scenegraph.
		 * @example #Unmount an entity from another entity
		 *     // Create a couple of entities and give them ids
		 *     var entity1 = new IgeEntity().id('entity1'),
		 *         entity2 = new IgeEntity().id('entity2');
		 *
		 *     // Mount entity2 to entity1
		 *     entity2.mount(entity1);
		 *
		 *     // Now unmount entity2 from entity1
		 *     entity2.unMount();
		 * @return {*} Returns this on success or false on failure.
		 */
		unMount: function () {
			if (this._parent) {
				var childArr = this._parent._children,
					index = childArr.indexOf(this),
					oldParent = this._parent;
				
				if (index > -1) {
					// Found this in the parent._children array so remove it
					childArr.splice(index, 1);
					
					this._parent._childUnMounted(this);
					this._parent = null;
					
					this._unMounted(oldParent);
					
					return this;
				} else {
					// Cannot find this in the parent._children array
					return false;
				}
			} else {
				return false;
			}
		},
		
		/**
		 * Determines if the object has a parent up the scenegraph whose
		 * id matches the one passed. Will traverse each parent object
		 * checking if the id matches. This information will be cached when
		 * first called and can be refreshed by setting the "fresh" parameter
		 * to true.
		 * @param {String} parentId The id of the parent to check for.
		 * @param {Boolean=} fresh If true will force a full check instead of
		 * using the cached value from an earlier check.
		 */
		hasParent: function (parentId, fresh) {
			var bool = false;
			
			// Check for a cached value
			if (!fresh && this._hasParent && this._hasParent[parentId] !== undefined) {
				return this._hasParent[parentId];
			}
			
			if (this._parent) {
				if (this._parent.id() === parentId) {
					bool = true;
				} else {
					bool = this._parent.hasParent(parentId, fresh);
				}
			}
			
			this._hasParent = this._hasParent || {};
			this._hasParent[parentId] = bool;
			
			return bool;
		},
		
		/**
		 * Clones the object and all it's children and returns a new object.
		 */
		clone: function (options) {
			// Make sure we have an options object
			if (options === undefined) { options = {}; }
			
			// Set some default option values
			if (options.id === undefined) { options.id = false; }
			if (options.mount === undefined) { options.mount = false; }
			if (options.transform === undefined) { options.transform = true; }
			
			// Loop all children and clone them, then return cloned version of ourselves
			var newObject = eval(this.stringify(options));
			
			return newObject;
		},
		
		/**
		 * Gets / sets the positioning mode of the entity.
		 * @param {Number=} val 0 = 2d, 1 = isometric
		 * @example #Set the positioning mode to 2d
		 *     var entity = new IgeEntity()
		 *         .mode(0);
		 * @example #Set the positioning mode to isometric
		 *     var entity = new IgeEntity()
		 *         .mode(1);
		 * @return {*}
		 */
		mode: function (val) {
			if (val !== undefined) {
				this._mode = val;
				return this;
			}
			
			return this._mode;
		},
		
		/**
		 * Gets / sets if this object should be positioned isometrically
		 * or in 2d.
		 * @param {Boolean} val Set to true to position this object in
		 * isometric space or false to position it in 2d space.
		 * @example #Set the positioning mode to isometric
		 *     var entity = new IgeEntity()
		 *         .isometric(true);
		 * @example #Set the positioning mode to 2d
		 *     var entity = new IgeEntity()
		 *         .isometric(false);
		 * @return {*}
		 */
		isometric: function (val) {
			if (val === true) {
				this._mode = 1;
				return this;
			}
			
			if (val === false) {
				this._mode = 0;
				return this;
			}
			
			return this._mode === 1;
		},
		
		/**
		 * Gets / sets if objects mounted to this object should be positioned
		 * and depth-sorted in an isometric fashion or a 2d fashion.
		 * @param {Boolean=} val Set to true to enabled isometric positioning
		 * and depth sorting of objects mounted to this object, or false to
		 * enable 2d positioning and depth-sorting of objects mounted to this
		 * object.
		 * @example #Set children to be positioned and depth sorted in 2d
		 *     var entity = new IgeEntity()
		 *         .isometricMounts(false);
		 * @example #Set children to be positioned and depth sorted in isometric
		 *     var entity = new IgeEntity()
		 *         .isometricMounts(true);
		 * @return {*}
		 */
		isometricMounts: function (val) {
			if (val === true) {
				this._mountMode = 1;
				return this;
			}
			
			if (val === false) {
				this._mountMode = 0;
				return this;
			}
			
			return this._mountMode === 1;
		},
		
		/**
		 * Gets / sets the indestructible flag. If set to true, the object will
		 * not be destroyed even if a call to the destroy() method is made.
		 * @param {Number=} val
		 * @example #Set an entity to indestructible
		 *     var entity = new IgeEntity()
		 *         .indestructible(true);
		 * @example #Set an entity to destructible
		 *     var entity = new IgeEntity()
		 *         .indestructible(false);
		 * @example #Get an entity's indestructible flag value
		 *     var entity = new IgeEntity()
		 *     console.log(entity.indestructible());
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		indestructible: function (val) {
			if (typeof(val) !== 'undefined') {
				this._indestructible = val;
				return this;
			}
			
			return this._indestructible;
		},
		
		/**
		 * Gets / sets the current entity layer. This affects how the entity is depth-sorted
		 * against other entities of the same parent. Please note that entities are first sorted
		 * by their layer and then by their depth, and only entities of the same layer will be
		 * sorted against each other by their depth values.
		 * @param {Number=} val
		 * @example #Set an entity's layer to 22
		 *     var entity = new IgeEntity()
		 *         .layer(22);
		 * @example #Get an entity's layer value
		 *     var entity = new IgeEntity()
		 *     console.log(entity.layer());
		 * @example #How layers and depths are handled together
		 *     var entity1 = new IgeEntity(),
		 *         entity2 = new IgeEntity(),
		 *         entity3 = new IgeEntity();
		 *
		 *     // Set entity1 to at layer zero and depth 100
		 *     entity1.layer(0)
		 *         .depth(100);
		 *
		 *     // Set entity2 and 3 to be at layer 1
		 *     entity2.layer(1);
		 *     entity3.layer(1);
		 *
		 *     // Set entity3 to have a higher depth than entity2
		 *     entity2.depth(0);
		 *     entity3.depth(1);
		 *
		 *     // The engine sorts first based on layer from lowest to highest
		 *     // and then within each layer, by depth from lowest to highest.
		 *     // This means that entity1 will be drawn before entity 2 and 3
		 *     // because even though it's depth is higher, it is not on the same
		 *     // layer as entity 2 and 3.
		 *
		 *     // Based on the layers and depths we have assigned, here
		 *     // is how the engine will sort the draw order of the entities
		 *     // entity1
		 *     // entity2
		 *     // entity3
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		layer: function (val) {
			if (val !== undefined) {
				this._layer = val;
				return this;
			}
			
			return this._layer;
		},
		
		/**
		 * Gets / sets the current render depth of the object (higher depths
		 * are drawn over lower depths). Please note that entities are first sorted
		 * by their layer and then by their depth, and only entities of the same layer will be
		 * sorted against each other by their depth values.
		 * @param {Number=} val
		 * @example #Set an entity's depth to 1
		 *     var entity = new IgeEntity()
		 *         .depth(1);
		 * @example #Get an entity's depth value
		 *     var entity = new IgeEntity()
		 *     console.log(entity.depth());
		 * @example #How layers and depths are handled together
		 *     var entity1 = new IgeEntity(),
		 *         entity2 = new IgeEntity(),
		 *         entity3 = new IgeEntity();
		 *
		 *     // Set entity1 to at layer zero and depth 100
		 *     entity1.layer(0)
		 *         .depth(100);
		 *
		 *     // Set entity2 and 3 to be at layer 1
		 *     entity2.layer(1);
		 *     entity3.layer(1);
		 *
		 *     // Set entity3 to have a higher depth than entity2
		 *     entity2.depth(0);
		 *     entity3.depth(1);
		 *
		 *     // The engine sorts first based on layer from lowest to highest
		 *     // and then within each layer, by depth from lowest to highest.
		 *     // This means that entity1 will be drawn before entity 2 and 3
		 *     // because even though it's depth is higher, it is not on the same
		 *     // layer as entity 2 and 3.
		 *
		 *     // Based on the layers and depths we have assigned, here
		 *     // is how the engine will sort the draw order of the entities
		 *     // entity1
		 *     // entity2
		 *     // entity3
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		depth: function (val) {
			if (val !== undefined) {
				this._depth = val;
				return this;
			}
			
			return this._depth;
		},
		
		/**
		 * Loops through all child objects of this object and destroys them
		 * by calling each child's destroy() method then clears the object's
		 * internal _children array.
		 */
		destroyChildren: function () {
			var arr = this._children,
				arrCount;
			
			if (arr) {
				arrCount = arr.length;
				
				while (arrCount--) {
					arr[arrCount].destroy();
				}
			}
			
			this._children = [];
			
			return this;
		},
		
		/**
		 * Removes all references to any behaviour methods that were added to
		 * this object.
		 */
		destroyBehaviours: function () {
			delete this._updateBehaviours;
			delete this._tickBehaviours;
		},
		
		/**
		 * Loops through all components added to this object and calls their
		 * destroy() method, then removes any references to the components.
		 * @return {*}
		 */
		destroyComponents: function () {
			var arr = this._components,
				arrCount;
			
			if (arr) {
				arrCount = arr.length;
				
				while (arrCount--) {
					if (arr[arrCount].destroy) {
						arr[arrCount].destroy();
					}
				}
			}
			
			delete this._components;
			
			return this;
		},
		
		/**
		 * Gets / sets the depth sort mode that is used when
		 * depth sorting this object's children against each other. This
		 * mode only applies if this object's mount mode is isometric,
		 * as set by calling isometricMounts(true). If the mount mode is
		 * 2d, the depth sorter will use a very fast 2d depth sort that
		 * does not use 3d bounds at all.
		 * @param {Number=} val The mode to use when depth sorting
		 * this object's children, given as an integer value.
		 * @example #Turn off all depth sorting for this object's children
		 *     entity.depthSortMode(-1);
		 * @example #Use 3d bounds when sorting this object's children
		 *     entity.depthSortMode(0);
		 * @example #Use 3d bounds optimised for mostly cube-shaped bounds when sorting this object's children
		 *     entity.depthSortMode(1);
		 * @example #Use 3d bounds optimised for all cube-shaped bounds when sorting this object's children
		 *     entity.depthSortMode(2);
		 * @return {*}
		 */
		depthSortMode: function (val) {
			if (val !== undefined) {
				this._depthSortMode = val;
				return this;
			}
			
			return this._depthSortMode;
		},
		
		/**
		 * Sorts the _children array by the layer and then depth of each object.
		 */
		depthSortChildren: function () {
			if (this._depthSortMode !== -1) {
				// TODO: Optimise this method, it is not especially efficient at the moment!
				var arr = this._children,
					arrCount,
					sortObj,
					i, j;
				
				if (arr) {
					arrCount = arr.length;
					
					// See if we can bug-out early
					if (arrCount > 1) {
						// Check if the mount mode is isometric
						if (this._mountMode === 1) {
							// Check the depth sort mode
							if (this._depthSortMode === 0) { // Slowest, uses 3d bounds
								// Calculate depths from 3d bounds
								sortObj = {
									adj: [],
									c: [],
									p: [],
									order: [],
									order_ind: arrCount - 1
								};
								
								for (i = 0; i < arrCount; ++i) {
									sortObj.c[i] = 0;
									sortObj.p[i] = -1;
									
									for (j = i + 1; j < arrCount; ++j) {
										sortObj.adj[i] = sortObj.adj[i] || [];
										sortObj.adj[j] = sortObj.adj[j] || [];
										
										if (arr[i]._inView && arr[j]._inView && arr[i]._projectionOverlap && arr[j]._projectionOverlap) {
											if (arr[i]._projectionOverlap(arr[j])) {
												if (arr[i].isBehind(arr[j])) {
													sortObj.adj[j].push(i);
												} else {
													sortObj.adj[i].push(j);
												}
											}
										}
									}
								}
								
								for (i = 0; i < arrCount; ++i) {
									if (sortObj.c[i] === 0) {
										this._depthSortVisit(i, sortObj);
									}
								}
								
								for (i = 0; i < sortObj.order.length; i++) {
									arr[sortObj.order[i]].depth(i);
								}
								
								this._children.sort(function (a, b) {
									var layerIndex = b._layer - a._layer;
									
									if (layerIndex === 0) {
										// On same layer so sort by depth
										return b._depth - a._depth;
									} else {
										// Not on same layer so sort by layer
										return layerIndex;
									}
								});
							}
							
							if (this._depthSortMode === 1) { // Medium speed, optimised for almost-cube shaped 3d bounds
								// Now sort the entities by depth
								this._children.sort(function (a, b) {
									var layerIndex = b._layer - a._layer;
									
									if (layerIndex === 0) {
										// On same layer so sort by depth
										//if (a._projectionOverlap(b)) {
										if (a.isBehind(b)) {
											return -1;
										} else {
											return 1;
										}
										//}
									} else {
										// Not on same layer so sort by layer
										return layerIndex;
									}
								});
							}
							
							if (this._depthSortMode === 2) { // Fastest, optimised for cube-shaped 3d bounds
								while (arrCount--) {
									sortObj = arr[arrCount];
									j = sortObj._translate;
									
									if (j) {
										sortObj._depth = j.x + j.y + j.z;
									}
								}
								
								// Now sort the entities by depth
								this._children.sort(function (a, b) {
									var layerIndex = b._layer - a._layer;
									
									if (layerIndex === 0) {
										// On same layer so sort by depth
										return b._depth - a._depth;
									} else {
										// Not on same layer so sort by layer
										return layerIndex;
									}
								});
							}
						} else { // 2d mode
							// Now sort the entities by depth
							this._children.sort(function (a, b) {
								var layerIndex = b._layer - a._layer;
								
								if (layerIndex === 0) {
									// On same layer so sort by depth
									return b._depth - a._depth;
								} else {
									// Not on same layer so sort by layer
									return layerIndex;
								}
							});
						}
					}
				}
			}
		},
		
		/**
		 * Gets / sets the view checking flag that if set to true
		 * will ask the engine to check during each tick if this
		 * object is actually "on screen" or not, and bypass it
		 * if it is not. The default is this flag set to false.
		 * @param {Boolean=} val The boolean flag value.
		 * @return {*}
		 */
		viewChecking: function (val) {
			if (val !== undefined) {
				this._viewChecking = val;
				return this;
			}
			
			return this._viewChecking;
		},
		
		/**
		 * ALPHA CODE DO NOT USE YET.
		 * When view checking is enabled, this method is called to
		 * determine if this object is within the bounds of an active
		 * viewport, essentially determining if the object is
		 * "on screen" or not.
		 */
		viewCheckChildren: function () {
			if ($ige._currentViewport) {
				var arr = this._children,
					arrCount = arr.length,
					vpViewArea = $ige._currentViewport.viewArea(),
					item;
				
				while (arrCount--) {
					item = arr[arrCount];
					
					if (item._alwaysInView) {
						item._inView = true;
					} else {
						if (item.aabb) {
							// Check the entity to see if its bounds are "inside" the
							// viewport's visible area
							if (vpViewArea.intersects(item.aabb(true))) {
								// The entity is inside the viewport visible area
								item._inView = true;
							} else {
								item._inView = false;
							}
						} else {
							item._inView = false;
						}
					}
				}
			}
			
			return this;
		},
		
		update: function (ctx, tickDelta) {
			// Check that we are alive before processing further
			if (this._alive) {
				if (this._newBorn) { this._newBorn = false; }
				var arr = this._children,
					arrCount,
					ts, td;
				
				if (arr) {
					arrCount = arr.length;
					
					// Depth sort all child objects
					if (arrCount && !$ige.engine._headless) {
						if (igeBase.igeConfig.debug._timing) {
							if (!$ige.engine._timeSpentLastTick[this.id()]) {
								$ige.engine._timeSpentLastTick[this.id()] = {};
							}
							
							ts = new Date().getTime();
							this.depthSortChildren();
							td = new Date().getTime() - ts;
							$ige.engine._timeSpentLastTick[this.id()].depthSortChildren = td;
						} else {
							this.depthSortChildren();
						}
					}
					
					// Loop our children and call their update methods
					if (igeBase.igeConfig.debug._timing) {
						while (arrCount--) {
							ts = new Date().getTime();
							arr[arrCount].update(ctx, tickDelta);
							td = new Date().getTime() - ts;
							if (arr[arrCount]) {
								if (!$ige.engine._timeSpentInTick[arr[arrCount].id()]) {
									$ige.engine._timeSpentInTick[arr[arrCount].id()] = 0;
								}
								
								if (!$ige.engine._timeSpentLastTick[arr[arrCount].id()]) {
									$ige.engine._timeSpentLastTick[arr[arrCount].id()] = {};
								}
								
								$ige.engine._timeSpentInTick[arr[arrCount].id()] += td;
								$ige.engine._timeSpentLastTick[arr[arrCount].id()].tick = td;
							}
						}
					} else {
						while (arrCount--) {
							arr[arrCount].update(ctx, tickDelta);
						}
					}
				}
			}
		},
		
		/**
		 * Processes the actions required each render frame.
		 */
		tick: function (ctx) {
			// Check that we are alive before processing further
			if (this._alive) {
				var arr = this._children,
					arrCount,
					ts, td;
				
				if (this._viewChecking) {
					// Set the in-scene flag for each child based on
					// the current viewport
					this.viewCheckChildren();
				}
				
				// Loop the child objects of this object
				if (arr) {
					arrCount = arr.length;
					
					// Loop our children and call their tick methods
					if (igeBase.igeConfig.debug._timing) {
						while (arrCount--) {
							if (!arr[arrCount]) {
								this.log('Object _children is undefined for index ' + arrCount + ' and _id: ' + this._id, 'error');
								continue;
							}
							
							if (!arr[arrCount]._newBorn) {
								ctx.save();
								ts = new Date().getTime();
								arr[arrCount].tick(ctx);
								td = new Date().getTime() - ts;
								if (arr[arrCount]) {
									if (!$ige.engine._timeSpentInTick[arr[arrCount].id()]) {
										$ige.engine._timeSpentInTick[arr[arrCount].id()] = 0;
									}
									
									if (!$ige.engine._timeSpentLastTick[arr[arrCount].id()]) {
										$ige.engine._timeSpentLastTick[arr[arrCount].id()] = {};
									}
									
									$ige.engine._timeSpentInTick[arr[arrCount].id()] += td;
									$ige.engine._timeSpentLastTick[arr[arrCount].id()].tick = td;
								}
								ctx.restore();
							}
						}
					} else {
						while (arrCount--) {
							if (!arr[arrCount]) {
								this.log('Object _children is undefined for index ' + arrCount + ' and _id: ' + this._id, 'error');
								continue;
							}
							
							if (!arr[arrCount]._newBorn) {
								ctx.save();
								arr[arrCount].tick(ctx);
								ctx.restore();
							}
						}
					}
				}
			}
		},
		
		_depthSortVisit: function (u, sortObj) {
			var arr = sortObj.adj[u],
				arrCount = arr.length,
				i, v;
			
			sortObj.c[u] = 1;
			
			for (i = 0; i < arrCount; ++i) {
				v = arr[i];
				
				if (sortObj.c[v] === 0) {
					sortObj.p[v] = u;
					this._depthSortVisit(v, sortObj);
				}
			}
			
			sortObj.c[u] = 2;
			sortObj.order[sortObj.order_ind] = u;
			--sortObj.order_ind;
		},
		
		/**
		 * Handles screen resize events. Calls the _resizeEvent method of
		 * every child object mounted to this object.
		 * @param event
		 * @private
		 */
		_resizeEvent: function (event) {
			var arr = this._children,
				arrCount;
			
			if (arr) {
				arrCount = arr.length;
				
				while (arrCount--) {
					arr[arrCount]._resizeEvent(event);
				}
			}
			
			
		},
		
		/**
		 * Calls each behaviour method for the object.
		 * @private
		 */
		_processUpdateBehaviours: function (ctx, tickDelta) {
			var arr = this._updateBehaviours,
				arrCount;
			
			if (arr) {
				arrCount = arr.length;
				while (arrCount--) {
					arr[arrCount].method.apply(this, arguments);
				}
			}
		},
		
		/**
		 * Calls each behaviour method for the object.
		 * @private
		 */
		_processTickBehaviours: function (ctx) {
			var arr = this._tickBehaviours,
				arrCount;
			
			if (arr) {
				arrCount = arr.length;
				while (arrCount--) {
					arr[arrCount].method.apply(this, arguments);
				}
			}
		},
		
		/**
		 * Called when a child object is mounted to this object.
		 * @param obj
		 * @private
		 */
		_childMounted: function (obj) {
			this._resizeEvent(null);
		},
		
		/**
		 * Called when a child object is un-mounted to this object.
		 * @param obj
		 * @private
		 */
		_childUnMounted: function (obj) {},
		
		/**
		 * Called when this object is mounted to another object.
		 * @param obj
		 * @private
		 */
		_mounted: function (obj) {
			
		},
		
		/**
		 * Called when this object is un-mounted from it's parent.
		 * @param obj
		 * @private
		 */
		_unMounted: function (obj) {
			
		},
		
		/**
		 * Destroys the object and all it's child objects, removing them from the
		 * scenegraph and from memory.
		 */
		destroy: function () {
			// Remove ourselves from any parent
			this.unMount();
			
			// Remove any children
			if (this._children) {
				this.destroyChildren();
			}
			
			// Remove any components
			this.destroyComponents();
			
			// Remove any behaviours
			this.destroyBehaviours();
			
			// Remove the object from the lookup system
			$ige.engine.unRegister(this);
			$ige.engine.categoryUnRegister(this);
			$ige.engine.groupUnRegister(this);
			
			// Set a flag in case a reference to this object
			// has been held somewhere, shows that the object
			// should no longer be interacted with
			this._alive = false;
			
			// Remove the event listeners array in case any
			// object references still exist there
			delete this._eventListeners;
			
			return this;
		},
		
		objSave: function () {
			return {igeClass: this.classId(), data: this._objSaveReassign(this, [])};
		},
		
		objLoad: function (obj) {
			this._objLoadReassign(this, obj.data);
		},
		
		saveSpecialProp: function (obj, i) {
			switch (i) {
				case '_id':
					if (obj._id) {
						return {_id: obj._id};
					}
					break;
				
				case '_parent':
					if (obj._parent) {
						return {_parent: obj._parent.id()};
					}
					break;
				
				case '_children':
					if (obj._children.length) {
						var childIndex,
							child,
							arr = [];
						
						for (childIndex = 0; childIndex < obj._children.length; childIndex++) {
							child = obj._children[childIndex];
							arr.push(child.objSave());
						}
						
						return {_children: arr};
					}
					break;
			}
			
			return undefined;
		},
		
		loadSpecialProp: function (obj, i) {
			switch (i) {
				case '_id':
					return {_id: obj[i]};
				
				case '_parent':
					return {_parent: obj[i]};
				
				case '_children':
					return {_children: obj[i]};
			}
			return undefined;
		},
		
		loadGraph: function (obj) {
			if (obj.igeClass && obj.data) {
				// Create a new class instance
				var classInstance = $ige.engine.newClassInstance(obj.igeClass),
					newId,
					childArr,
					childIndex,
					parentId;
				
				classInstance.objLoad(obj);
				
				if (classInstance._parent) {
					// Record the id and delete it
					parentId = classInstance._parent;
					delete classInstance._parent;
				}
				
				// Process item id
				if (classInstance._id) {
					newId = classInstance._id;
					delete classInstance._id;
					
					classInstance.id(newId);
				}
				
				// Check for children and process them if exists
				if (classInstance._children && classInstance._children.length) {
					childArr = classInstance._children;
					classInstance._children = [];
					
					for (childIndex = 0; childIndex < childArr.length; childIndex++) {
						classInstance.loadGraph(childArr[childIndex]);
					}
				}
				
				// Now mount the instance if it has a parent
				classInstance.mount(this);
			}
		},
		
		_objSaveReassign: function (obj, ref) {
			var copyObj,
				specialKeys = this._specialProp,
				refIndex,
				specProp,
				specPropKey,
				i;
			
			if (typeof(obj) === 'object' && !(obj instanceof Array)) {
				copyObj = {};
				
				for (i in obj) {
					if (obj.hasOwnProperty(i)) {
						if (typeof(obj[i]) === 'object') {
							if (specialKeys.indexOf(i) === -1) {
								// Check if the ref already exists
								refIndex = ref.indexOf(obj[i]);
								
								if (refIndex > -1) {
									copyObj[i] = '{ref:' + refIndex + '}';
									this.log('Possible circular reference for property ' + i);
								} else {
									ref.push(obj[i]);
									copyObj[i] = this._objSaveReassign(obj[i], ref);
								}
							} else {
								// This is a special property that needs handling via
								// it's own method to return an appropriate data value
								// so check if there is a method for it
								specProp = this.saveSpecialProp(obj, i);
								
								if (specProp) {
									if (typeof(specProp) === 'object' && !(specProp instanceof Array)) {
										// Process the returned object properties
										for (specPropKey in specProp) {
											if (specProp.hasOwnProperty(specPropKey)) {
												// Copy the special property data to the key in
												// our return object
												copyObj[specPropKey] = specProp[specPropKey];
											}
										}
									} else {
										copyObj[i] = specProp;
									}
								}
							}
						} else {
							copyObj[i] = obj[i];
						}
					}
				}
				
				return copyObj;
			} else {
				return obj;
			}
		},
		
		_objLoadReassign: function (obj, newProps) {
			var specialKeys = this._specialProp,
				specProp,
				specPropKey,
				i;
			
			for (i in newProps) {
				if (newProps.hasOwnProperty(i)) {
					if (specialKeys.indexOf(i) === -1) {
						if (typeof(newProps[i]) === 'object' && obj[i]) {
							this._objLoadReassign(obj[i], newProps[i]);
						} else {
							// Assign the property value directly
							obj[i] = newProps[i];
						}
					} else {
						// This is a special property that needs handling via
						// it's own method to return an appropriate data value
						// so check if there is a method for it
						specProp = this.loadSpecialProp(newProps, i);
						
						if (specProp) {
							if (typeof(specProp) === 'object' && !(specProp instanceof Array)) {
								// Process the returned object properties
								for (specPropKey in specProp) {
									if (specProp.hasOwnProperty(specPropKey)) {
										// Copy the special property data to the key in
										// our return object
										obj[specPropKey] = specProp[specPropKey];
									}
								}
							} else {
								obj[i] = specProp;
							}
						}
					}
				}
			}
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object.
		 * @return {String}
		 */
		stringify: function (options) {
			// TODO : Use the advanced serialiser system from ForerunnerDB
			// Make sure we have an options object
			if (options === undefined) { options = {}; }
			
			var str = "new " + this.classId() + "()";
			
			// Every object has an ID, assign that first
			if (options.id !== false) {
				str += ".id('" + this.id() + "')";
			}
			
			// Now check if there is a parent and mount that
			if (options.mount !== false && this.parent()) {
				str += ".mount($ige.engine.$('" + this.parent().id() + "'))";
			}
			
			// Now get all other properties
			str += this._stringify(options);
			
			return str;
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object's properties via
		 * chained commands. This method will only check for
		 * properties that are directly related to this class.
		 * Other properties are handled by their own class method.
		 * @return {String}
		 */
		_stringify: function (options) {
			// Make sure we have an options object
			if (options === undefined) { options = {}; }
			
			var str = '', i;
			
			// Loop properties and add property assignment code to string
			for (i in this) {
				if (this.hasOwnProperty(i) && this[i] !== undefined) {
					switch (i) {
						case '_category':
							str += ".category(" + this.category() + ")";
							break;
						case '_drawBounds':
							str += ".drawBounds(" + this.drawBounds() + ")";
							break;
						case '_drawBoundsData':
							str += ".drawBoundsData(" + this.drawBoundsData() + ")";
							break;
						case '_drawMouse':
							str += ".drawMouse(" + this.drawMouse() + ")";
							break;
						case '_mode':
							str += ".mode(" + this.mode() + ")";
							break;
						case '_isometricMounts':
							str += ".isometricMounts(" + this.isometricMounts() + ")";
							break;
						case '_indestructible':
							str += ".indestructible(" + this.indestructible() + ")";
							break;
						case '_layer':
							str += ".layer(" + this.layer() + ")";
							break;
						case '_depth':
							str += ".depth(" + this.depth() + ")";
							break;
					}
				}
			}
			
			return str;
		}
	});
	
	return IgeObject;
});

},{"irrelon-appcore":125}],70:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeParticle', function (IgeEntity, IgeVelocityComponent) {
	var IgeParticle = IgeEntity.extend({
		classId: 'IgeParticle',
		
		init: function (emitter) {
			this._emitter = emitter;
			IgeEntity.prototype.init.call(this);
			
			// Setup the particle default values
			this.addComponent(IgeVelocityComponent);
		},
		
		destroy: function () {
			// Remove ourselves from the emitter
			if (this._emitter !== undefined) {
				this._emitter._particles.pull(this);
			}
			IgeEntity.prototype.destroy.call(this);
		}
	});
	
	return IgeParticle;
});
},{"irrelon-appcore":125}],71:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeParticleEmitter', function ($time, IgeUiEntity, IgeTween) {
	/**
	 * Creates a new particle emitter.
	 */
	var IgeParticleEmitter = IgeUiEntity.extend({
		classId: 'IgeParticleEmitter',
		IgeParticleEmitter: true,
		
		init: function () {
			// IgeBody.init()
			IgeUiEntity.prototype.init.call(this);
			
			// Set some defaults
			this._currentDelta = 0;
			this._started = false;
			this._particles = [];
			
			this.applyDepthToParticles(true);
			this.applyLayerToParticles(true);
			this.quantityTimespan(1000);
			this.quantityBase(10);
			this.quantityVariance(0, 0);
			this.translateBaseX(0);
			this.translateBaseY(0);
			this.translateBaseZ(0);
			this.translateVarianceX(0, 0);
			this.translateVarianceY(0, 0);
			this.translateVarianceZ(0, 0);
			this.rotateBase(0);
			this.rotateVariance(0, 0);
			this.deathRotateBase(0);
			this.deathRotateVariance(0, 0);
			this.scaleBaseX(1);
			this.scaleBaseY(1);
			this.scaleBaseZ(1);
			this.scaleVarianceX(0, 0);
			this.scaleVarianceY(0, 0);
			this.scaleVarianceZ(0, 0);
			this.scaleLockAspect(false);
			this.deathScaleBaseX(0);
			this.deathScaleBaseY(0);
			this.deathScaleBaseZ(0);
			this.deathScaleVarianceX(0, 0);
			this.deathScaleVarianceY(0, 0);
			this.deathScaleVarianceZ(0, 0);
			this.deathScaleLockAspect(false);
			this.opacityBase(1);
			this.opacityVariance(0, 0);
			this.deathOpacityBase(1);
			this.deathOpacityVariance(0, 0);
			this.lifeBase(1000);
			this.lifeVariance(0, 0);
		},
		
		/**
		 * Sets the class that all particles emitted from this
		 * emitter will be created from.
		 * @param {IgeEntity} obj
		 * @return {*}
		 */
		particle: function (obj) {
			this._particle = obj;
			return this;
		},
		
		particleMountTarget: function (obj) {
			this._particleMountTarget = obj;
			return this;
		},
		
		applyDepthToParticles: function (val) {
			this._applyDepthToParticles = val;
			return this;
		},
		
		applyLayerToParticles: function (val) {
			this._applyLayerToParticles = val;
			return this;
		},
		
		quantityTimespan: function (val) {
			this._quantityTimespan = val;
			return this;
		},
		
		quantityBase: function (val) {
			this._quantityBase = val;
			return this;
		},
		
		quantityVariance: function (a, b) {
			this._quantityVariance = [a, b];
			return this;
		},
		
		quantityMax: function (val) {
			this._quantityMax = val;
			this._quantityProduced = 0;
			return this;
		},
		
		translateBaseX: function (val) {
			this._translateBaseX = val;
			return this;
		},
		
		translateBaseY: function (val) {
			this._translateBaseY = val;
			return this;
		},
		
		translateBaseZ: function (val) {
			this._translateBaseZ = val;
			return this;
		},
		
		translateVarianceX: function (a, b) {
			this._translateVarianceX = [a, b];
			return this;
		},
		
		translateVarianceY: function (a, b) {
			this._translateVarianceY = [a, b];
			return this;
		},
		
		translateVarianceZ: function (a, b) {
			this._translateVarianceZ = [a, b];
			return this;
		},
		
		rotateBase: function (val) {
			this._rotateBase = val;
			return this;
		},
		
		rotateVariance: function (a, b) {
			this._rotateVariance = [a, b];
			return this;
		},
		
		deathRotateBase: function (val) {
			this._deathRotateBase = val;
			return this;
		},
		
		deathRotateVariance: function (a, b) {
			this._deathRotateVariance = [a, b];
			return this;
		},
		
		scaleBaseX: function (val) {
			this._scaleBaseX = val;
			return this;
		},
		
		scaleBaseY: function (val) {
			this._scaleBaseY = val;
			return this;
		},
		
		scaleBaseZ: function (val) {
			this._scaleBaseZ = val;
			return this;
		},
		
		scaleVarianceX: function (a, b) {
			this._scaleVarianceX = [a, b];
			return this;
		},
		
		scaleVarianceY: function (a, b) {
			this._scaleVarianceY = [a, b];
			return this;
		},
		
		scaleVarianceZ: function (a, b) {
			this._scaleVarianceZ = [a, b];
			return this;
		},
		
		scaleLockAspect: function (val) {
			this._scaleLockAspect = val;
			return this;
		},
		
		deathScaleBaseX: function (val) {
			this._deathScaleBaseX = val;
			return this;
		},
		
		deathScaleBaseY: function (val) {
			this._deathScaleBaseY = val;
			return this;
		},
		
		deathScaleBaseZ: function (val) {
			this._deathScaleBaseZ = val;
			return this;
		},
		
		deathScaleVarianceX: function (a, b) {
			this._deathScaleVarianceX = [a, b];
			return this;
		},
		
		deathScaleVarianceY: function (a, b) {
			this._deathScaleVarianceY = [a, b];
			return this;
		},
		
		deathScaleVarianceZ: function (a, b) {
			this._deathScaleVarianceZ = [a, b];
			return this;
		},
		
		deathScaleLockAspect: function (val) {
			this._deathScaleLockAspect = val;
			return this;
		},
		
		opacityBase: function (val) {
			this._opacityBase = val;
			return this;
		},
		
		opacityVariance: function (a, b) {
			this._opacityVariance = [a, b];
			return this;
		},
		
		deathOpacityBase: function (val) {
			this._deathOpacityBase = val;
			return this;
		},
		
		deathOpacityVariance: function (a, b) {
			this._deathOpacityVariance = [a, b];
			return this;
		},
		
		lifeBase: function (val) {
			this._lifeBase = val;
			return this;
		},
		
		lifeVariance: function (a, b) {
			this._lifeVariance = [a, b];
			return this;
		},
		
		/**
		 * Sets the base velocity vector of each emitted particle and optionally
		 * the min and max vectors that are used to randomize the resulting particle
		 * velocity vector.
		 * @param baseVector
		 * @param minVector
		 * @param maxVector
		 */
		velocityVector: function (baseVector, minVector, maxVector) {
			this._velocityVector = {
				base: baseVector,
				min: minVector,
				max: maxVector
			};
			
			return this;
		},
		
		linearForceVector: function (baseVector, minVector, maxVector) {
			this._linearForceVector = {
				base: baseVector,
				min: minVector,
				max: maxVector
			};
			
			return this;
		},
		
		/**
		 * Starts the particle emitter which will begin spawning
		 * particle entities based upon the emitter's current settings.
		 * @return {*}
		 */
		start: function () {
			if (this._particle) {
				// Update the transform matrix before starting
				// otherwise some particles might read the old
				// matrix values if the start method was chained!
				this.updateTransform();
				
				this._quantityTimespan = this._quantityTimespan !== undefined ? this._quantityTimespan : 1000;
				this._maxParticles = this.baseAndVarianceValue(this._quantityBase, this._quantityVariance, true);
				this._particlesPerTimeVector = this._quantityTimespan / this._maxParticles; // 1 Particle every x milliseconds (x stored in this._particlesPerTimeVector)
				this._currentDelta = 0;
				
				// Set the emitter started flag
				this._quantityProduced = 0;
				this._started = true;
			} else {
				this.log('Cannot start particle emitter because no particle class was specified with a call to particle()', 'error');
			}
			
			return this;
		},
		
		updateSettings: function () {
			this._maxParticles = this.baseAndVarianceValue(this._quantityBase, this._quantityVariance, true);
			this._particlesPerTimeVector = this._quantityTimespan / this._maxParticles; // 1 Particle every x milliseconds (x stored in this._particlesPerTimeVector)
		},
		
		/**
		 * Stops the particle emitter. The current particles will
		 * continue to process until they reach their natural lifespan.
		 * @return {*}
		 */
		stop: function () {
			this._started = false;
			return this;
		},
		
		/**
		 * Stops the particle emitter. The current particles will be
		 * destroyed immediately.
		 * @return {*}
		 */
		stopAndKill: function () {
			this._started = false;
			
			// Loop the particles array and destroy all the particles
			var arr = this._particles,
				arrCount = arr.length;
			
			while (arrCount--) {
				arr[arrCount].destroy();
			}
			
			// Remove all references to the particles by
			// re-initialising the particles array
			this._particles = [];
			
			return this;
		},
		
		/**
		 * Takes a base value and a variance range and returns a random
		 * value between the range, added to the base.
		 * @param {Number} base The base value.
		 * @param {Array} variance An array containing the two values of
		 * the variance range.
		 * @param {Boolean} floorIt If set to true, will cause the returned
		 * value to be passed through Math.floor().
		 * @return {Number} Returns the final value based upon the base
		 * value and variance range.
		 */
		baseAndVarianceValue: function (base, variance, floorIt) {
			base = base || 0;
			variance = variance || [0, 0];
			var variant = 0;
			
			if (floorIt) {
				variant = Math.floor(variance[0] + Math.random() * (variance[1] - variance[0]));
			} else {
				variant = (variance[0] + Math.random() * (variance[1] - variance[0]));
			}
			
			return base + variant;
		},
		
		vectorFromBaseMinMax: function (vectorData) {
			if (vectorData.min && vectorData.max) {
				var base = vectorData.base,
					min = vectorData.min,
					max = vectorData.max,
					newVector = {};
				
				newVector.x = base.x + (min.x + Math.random() * (max.x - min.x));
				newVector.y = base.y + (min.y + Math.random() * (max.y - min.y));
				newVector.z = base.z + (min.z + Math.random() * (max.z - min.z));
				
				return newVector;
			} else {
				// There was no variance data so return the base vector
				return vectorData.base;
			}
		},
		
		/**
		 * Creates and maintains the particles that this emitter is
		 * responsible for spawning and controlling.
		 * @param ctx
		 */
		tick: function (ctx) {
			this._currentDelta += $time._tickDelta;
			
			// Check if the emitter is mounted to anything and started, if not
			// then don't bother creating particles!
			if (this._parent && this._started) {
				if (!this._quantityMax || this._quantityProduced < this._quantityMax) {
					var particleCount,
						translateX,
						translateY,
						translateZ,
						//vectorAngle,
						//vectorPower,
						velocityVector,
						newVecX, newVecY,
						rotX, rotY,
						cosRot, sinRot,
						scaleX,
						scaleY,
						scaleZ,
						rotate,
						opacity,
						life,
						//linearForceAngle,
						//linearForcePower,
						linearForceVector,
						deathScaleX,
						deathScaleY,
						deathScaleZ,
						deathRotate,
						deathOpacity,
						tempParticle,
						tweens,
						scaleProps,
						i;
					
					if (this._currentDelta > this._quantityTimespan) {
						this._currentDelta = this._quantityTimespan;
					}
					
					if (this._currentDelta >= this._particlesPerTimeVector) {
						particleCount = ((this._currentDelta / this._particlesPerTimeVector)|0); // Bitwise floor
						this._currentDelta -= (this._particlesPerTimeVector * particleCount);
						
						// Loop the particle array and if no particle exists,
						// create one to fill the space. Basically this keeps
						// the emitters creating new particles until it is
						// stopped.
						if (particleCount) {
							while (particleCount--) {
								if (this._quantityMax) {
									this._quantityProduced ++;
									
									// If the number of particles produced is equal to or greater
									// than the max we should produce then exit the loop
									if (this._quantityProduced >= this._quantityMax) {
										this.stop();
										break;
									}
								}
								
								// Create the initial particle values based on
								// the emitter options values
								
								// Generate the particle's initial translate values
								translateX = this.baseAndVarianceValue(this._translateBaseX, this._translateVarianceX, true);
								translateY = this.baseAndVarianceValue(this._translateBaseY, this._translateVarianceY, true);
								translateZ = this.baseAndVarianceValue(this._translateBaseZ, this._translateVarianceZ, true);
								
								//translateX += this._worldMatrix.matrix[2];
								//translateY += this._worldMatrix.matrix[5];
								
								if (this._velocityVector) {
									// Generate the particle's initial vector angle and power
									velocityVector = this.vectorFromBaseMinMax(this._velocityVector);
									
									// Rotate the vector's point to match the current emitter rotation
									rotX = velocityVector.x;
									rotY = velocityVector.y;
									cosRot = this._worldMatrix.matrix[0]; //Math.cos(this._rotate.z);
									sinRot = this._worldMatrix.matrix[3]; //Math.sin(this._rotate.z);
									newVecX = rotX * cosRot - rotY * sinRot;
									newVecY = rotY * cosRot + rotX * sinRot;
									
									// Assign the rotated vector back again
									velocityVector.x = newVecX;
									velocityVector.y = newVecY;
								}
								
								//vectorAngle = this.baseAndVarianceValue(this._vectorAngleBase, this._vectorAngleVariance, true);
								//vectorPower = this.baseAndVarianceValue(this._vectorPowerBase, this._vectorPowerVariance, false);
								
								// Generate the particle's initial scale
								scaleX = this.baseAndVarianceValue(this._scaleBaseX, this._scaleVarianceX, false);
								scaleZ = scaleY = scaleX;
								if (!this._scaleLockAspect) {
									scaleY = this.baseAndVarianceValue(this._scaleBaseY, this._scaleVarianceY, false);
									scaleZ = this.baseAndVarianceValue(this._scaleBaseZ, this._scaleVarianceZ, false);
								}
								
								// Generate the particle's initial rotation
								rotate = this.baseAndVarianceValue(this._rotateBase, this._rotateVariance, true);
								
								// Generate the particle's initial opacity
								opacity = this.baseAndVarianceValue(this._opacityBase, this._opacityVariance, false);
								
								// Generate the particle's initial lifespan
								life = this.baseAndVarianceValue(this._lifeBase, this._lifeVariance, true);
								
								// Generate the particle's linear force vector angle and power
								if (this._linearForceVector) {
									linearForceVector = this.vectorFromBaseMinMax(this._linearForceVector);
									
									// Rotate the vector's point to match the current emitter rotation
									rotX = linearForceVector.x;
									rotY = linearForceVector.y;
									cosRot = this._worldMatrix.matrix[0]; //Math.cos(this._rotate.z);
									sinRot = this._worldMatrix.matrix[3]; //Math.sin(this._rotate.z);
									newVecX = rotX * cosRot - rotY * sinRot;
									newVecY = rotY * cosRot + rotX * sinRot;
									
									// Assign the rotated vector back again
									linearForceVector.x = newVecX;
									linearForceVector.y = newVecY;
								}
								
								//linearForceAngle = this.baseAndVarianceValue(this._linearForceAngleBase, this._linearForceAngleVariance);
								//linearForcePower = this.baseAndVarianceValue(this._linearForcePowerBase, this._linearForcePowerVariance, false);
								
								// Generate the particle's death scale
								if (typeof(this._deathScaleBaseX) !== 'undefined') {
									deathScaleX = this.baseAndVarianceValue(
										this._deathScaleBaseX,
										this._deathScaleVarianceX,
										false
									);
								}
								if (typeof(this._deathScaleBaseY) !== 'undefined' && !this._deathScaleLockAspect) {
									deathScaleY = this.baseAndVarianceValue(
										this._deathScaleBaseY,
										this._deathScaleVarianceY,
										false
									);
								}
								if (typeof(this._deathScaleBaseZ) !== 'undefined' && !this._deathScaleLockAspect) {
									deathScaleZ = this.baseAndVarianceValue(
										this._deathScaleBaseZ,
										this._deathScaleVarianceZ,
										false
									);
								}
								if (this._deathScaleLockAspect) {
									deathScaleZ = deathScaleY = deathScaleX;
								}
								
								// Generate the particle's death rotation
								if (typeof(this._deathRotateBase) !== 'undefined') {
									deathRotate = this.baseAndVarianceValue(
										this._deathRotateBase,
										this._deathRotateVariance,
										true
									);
								}
								
								// Generate the particle's death opacity
								if (typeof(this._deathOpacityBase) !== 'undefined') {
									deathOpacity = this.baseAndVarianceValue(
										this._deathOpacityBase,
										this._deathOpacityVariance,
										false
									);
								}
								
								// Create the particle entity
								tempParticle = new this._particle(this);
								
								// Add the current transform of the emitter to the final
								// particle transforms
								if (this._ignoreCamera) {
									translateX += this._translate.x;
									translateY += this._translate.y;
								} else {
									translateX += this._worldMatrix.matrix[2];
									translateY += this._worldMatrix.matrix[5];
								}
								translateZ += this._translate.z;
								
								scaleX *= this._scale.x;
								scaleY *= this._scale.y;
								scaleZ *= this._scale.z;
								
								deathScaleX *= this._scale.x;
								deathScaleY *= this._scale.y;
								deathScaleZ *= this._scale.z;
								
								// Apply all the transforms (don't do this in the initial
								// entity definition because some components may already
								// have initialised due to the particle template
								tempParticle.translateTo(translateX, translateY, translateZ);
								tempParticle.rotateTo(0, 0, Math.radians(rotate));
								tempParticle.scaleTo(scaleX, scaleY, scaleZ);
								tempParticle.opacity(opacity);
								
								if (this._applyDepthToParticles) { tempParticle.depth(this._depth); }
								if (this._applyLayerToParticles) { tempParticle.layer(this._layer); }
								
								if (typeof(velocityVector) === 'object') {
									tempParticle.velocity.vector3(velocityVector, false);
								}
								
								if (typeof(linearForceVector) === 'object') {
									tempParticle.velocity.linearForceVector3(linearForceVector, false);
								}
								
								tweens = [];
								if (typeof(deathRotate) !== 'undefined') {
									tweens.push(new IgeTween()
										.targetObj(tempParticle._rotate)
										.properties({z: Math.radians(deathRotate)})
										.duration(life));
								}
								if (typeof(deathOpacity) !== 'undefined') {
									tweens.push(new IgeTween()
										.targetObj(tempParticle)
										.properties({_opacity: deathOpacity})
										.duration(life));
								}
								
								scaleProps = {};
								if (typeof(deathScaleX) !== 'undefined') {
									scaleProps.x = deathScaleX;
								}
								if (typeof(deathScaleY) !== 'undefined') {
									scaleProps.y = deathScaleY;
								}
								if (typeof(deathScaleZ) !== 'undefined') {
									scaleProps.z = deathScaleZ;
								}
								
								if (scaleProps.x || scaleProps.y || scaleProps.z) {
									tweens.push(new IgeTween()
										.targetObj(tempParticle._scale)
										.properties(scaleProps)
										.duration(life));
								}
								
								if (typeof(life) === 'number') {
									tempParticle.lifeSpan(life);
								}
								
								// Add the particle to this emitter's particle array
								this._particles.push(tempParticle);
								
								// Add the particle to the scene
								tempParticle.mount(this._particleMountTarget || this._parent);
								
								// Start the relevant tweens
								for (i = 0; i < tweens.length; i++) {
									tweens[i].start();
								}
							}
						}
					}
				}
			}
			
			IgeUiEntity.prototype.tick.call(this, ctx);
		},
		
		/**
		 * Returns an array of the current particle entities that this
		 * emitter has spawned.
		 * @return {Array} The array of particle entities the emitter spawned.
		 */
		particles: function () {
			return this._particles;
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object's properties via
		 * chained commands. This method will only check for
		 * properties that are directly related to this class.
		 * Other properties are handled by their own class method.
		 * @return {String}
		 */
		_stringify: function () {
			// Get the properties for all the super-classes
			var str = IgeUiEntity.prototype._stringify.call(this), i;
			return str;
			
			// TODO: WRITE THIS FOR THIS CLASS - EPIC AMOUNT OF WORK HERE
			// Loop properties and add property assignment code to string
			for (i in this) {
				if (this.hasOwnProperty(i) && this[i] !== undefined) {
					switch (i) {
						case '':
							str += ".text(" + this.text() + ")";
							break;
					}
				}
			}
			
			return str;
		}
	});
	
	return IgeParticleEmitter;
});
},{"irrelon-appcore":125}],72:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgePathFinder', function (IgeEventingClass, IgePathNode) {
	/**
	 * Creates a new path using the A* path-finding algorithm.
	 */
	var IgePathFinder = IgeEventingClass.extend({
		classId: 'IgePathFinder',
		
		init: function() {
			this._neighbourLimit = 1000;
			this._squareCost = 10;
			this._diagonalCost = 10;
		},
		
		/**
		 * Gets / sets the cost of movement over a square (left,
		 * right, up, down) adjacent tile.
		 * @param {Number=} val
		 * @return {*}
		 */
		squareCost: function (val) {
			if (val !== undefined) {
				this._squareCost = val;
				return this;
			}
			
			return this._squareCost;
		},
		
		/**
		 * Gets / sets the cost of movement over a diagonal (nw,
		 * ne, sw, se) adjacent tile.
		 * @param {Number=} val
		 * @return {*}
		 */
		diagonalCost: function (val) {
			if (val !== undefined) {
				this._diagonalCost = val;
				return this;
			}
			
			return this._diagonalCost;
		},
		
		/**
		 * Gets / sets the limit on the number of neighbour nodes
		 * that the path-finder will analyse before reaching it's
		 * target tile. On large maps this limit should be increased
		 * to allow pathing where many neighbours need to be
		 * considered.
		 * @param val
		 * @return {*}
		 */
		neighbourLimit: function (val) {
			if (val !== undefined) {
				this._neighbourLimit = val;
				return this;
			}
			
			return this._neighbourLimit;
		},
		
		aStar: function () {
			this.log('The "IgePathFinder.aStar" method has been renamed to "generate". Please update your code.', 'error');
		},
		
		/**
		 * Uses the A* algorithm to generate path data between two points.
		 * @param {IgeCollisionMap2d} tileMap The tile map to use when generating the path.
		 * @param {IgePoint3d} startPoint The point on the map to start path-finding from.
		 * @param {IgePoint3d} endPoint The point on the map to try to path-find to.
		 * @param {Function} comparisonCallback The callback function that will decide if each tile that is being considered for use in the path is allowed or not based on the tile map's data stored for that tile which is passed to this method as the first parameter. Must return a boolean value.
		 * @param {Boolean} allowSquare Whether to allow neighboring tiles along a square axis. Defaults to true if undefined.
		 * @param {Boolean} allowDiagonal Whether to allow neighboring tiles along a diagonal axis. Defaults to false if undefined.
		 * @param {Boolean=} allowInvalidDestination If the path finder cannot path to the destination tile, if this is true the closest path will be returned instead.
		 * @return {Array} An array of objects each containing an x, y co-ordinate that describes the path from the starting point to the end point in order.
		 */
		generate: function (tileMap, startPoint, endPoint, comparisonCallback, allowSquare, allowDiagonal, allowInvalidDestination) {
			var openList = [],
				closedList = [],
				listHash = {},
				startNode,
				lowestFScoringIndex,
				openCount,
				currentNode,
				pathPoint,
				finalPath,
				neighbourList,
				neighbourCount,
				neighbourNode,
				endPointCheckTile,
				tileMapData,
				existingNode,
				lowestHNode;
			
			// Set some defaults
			if (allowSquare === undefined) { allowSquare = true; }
			if (allowDiagonal === undefined) { allowDiagonal = false; }
			
			// Check that the end point on the map is actually allowed to be pathed to!
			tileMapData = tileMap.map._mapData;
			endPointCheckTile = tileMapData[endPoint.y] && tileMapData[endPoint.y][endPoint.x] ? tileMapData[endPoint.y][endPoint.x] : null;
			if (!allowInvalidDestination && !comparisonCallback(endPointCheckTile, endPoint.x, endPoint.y)) {
				// There is no path to the end point because the end point
				// is not allowed to be pathed to!
				this.emit('noPathFound');
				//this.log('Cannot path to destination because the destination tile is not pathable!');
				return [];
			}
			
			// Starting point to open list
			startNode = new IgePathNode(startPoint.x, startPoint.y, 0, 0, this._heuristic(startPoint.x, startPoint.y, endPoint.x, endPoint.y, 10));
			startNode.link = 1;
			openList.push(startNode);
			listHash[startNode.hash] = startNode;
			startNode.listType = 1;
			
			lowestHNode = startNode;
			
			// Loop as long as there are more points to process in our open list
			while (openList.length) {
				// Check for some major error
				if (openList.length > this._neighbourLimit) {
					//this.log('Path finder error, open list nodes exceeded ' + this._neighbourLimit + '!', 'warning');
					this.emit('exceededLimit');
					break;
				}
				
				// Grab the lowest f scoring node from the open list
				// to process next
				lowestFScoringIndex = 0;
				openCount = openList.length;
				
				while (openCount--) {
					if(openList[openCount].f < openList[lowestFScoringIndex].f) { lowestFScoringIndex = openCount; }
				}
				
				currentNode = openList[lowestFScoringIndex];
				
				// Check if the current node is the end point
				if (currentNode.x === endPoint.x && currentNode.y === endPoint.y) {
					// We have reached the end point
					pathPoint = currentNode;
					finalPath = [];
					
					while(pathPoint.link) {
						finalPath.push(pathPoint);
						pathPoint = pathPoint.link;
					}
					
					this.emit('pathFound', finalPath);
					
					return finalPath.reverse();
				} else {
					// Remove the current node from the open list
					openList.splice(lowestFScoringIndex, 1);
					
					// Add the current node to the closed list
					closedList.push(currentNode);
					currentNode.listType = -1;
					
					// Get the current node's neighbors
					neighbourList = this._getNeighbours(currentNode, endPoint, tileMap, comparisonCallback, allowSquare, allowDiagonal);
					neighbourCount = neighbourList.length;
					
					// Loop the neighbours and add each one to the open list
					while (neighbourCount--) {
						neighbourNode = neighbourList[neighbourCount];
						existingNode = listHash[neighbourNode.hash];
						
						// Check that the neighbour is not on the closed list
						if (!existingNode || existingNode.listType !== -1) {
							// The neighbour is not on the closed list so
							// check if it is already on the open list
							if (existingNode && existingNode.listType === 1) {
								// The neighbour is already on the open list
								// so check if our new path is a better score
								if (existingNode.g > neighbourNode.g) {
									// Pathing from the current node through this neighbour
									// costs less that any way we've calculated before
									existingNode.link = neighbourNode.link;
									existingNode.g = neighbourNode.g;
									existingNode.f = neighbourNode.f;
								}
							} else {
								// Add the neighbour to the open list
								openList.push(neighbourNode);
								listHash[neighbourNode.hash] = neighbourNode;
								neighbourNode.listType = 1;
								existingNode = neighbourNode;
							}
						}
						
						// Check if this neighbour node has the lowest
						// h value (distance from target) and store it
						if (!lowestHNode || existingNode.h < lowestHNode.h) {
							lowestHNode = existingNode;
						}
					}
				}
				
			}
			
			if (!allowInvalidDestination || (allowInvalidDestination && !lowestHNode)) {
				// Could not find a path, return an empty array!
				//this.log('Could not find a path to destination!');
				this.emit('noPathFound');
				return [];
			} else {
				// We couldn't path to the destination so return
				// the closest detected end point
				pathPoint = lowestHNode;
				finalPath = [];
				
				while(pathPoint.link) {
					finalPath.push(pathPoint);
					pathPoint = pathPoint.link;
				}
				
				// Reverse the final path so it is from
				// start to finish
				finalPath = finalPath.reverse();
				
				this.emit('pathFound', finalPath);
				return finalPath;
			}
		},
		
		/**
		 * Get all the neighbors of a node for the A* algorithm.
		 * @param {IgePathNode} currentNode The current node along the path to evaluate neighbors for.
		 * @param {IgePathNode} endPoint The end point of the path.
		 * @param {IgeCollisionMap2d} tileMap The tile map to use when evaluating neighbours.
		 * @param {Function} comparisonCallback The callback function that will decide if the tile data at the neighbouring node is to be used or not. Must return a boolean value.
		 * @param {Boolean} allowSquare Whether to allow neighboring tiles along a square axis.
		 * @param {Boolean} allowDiagonal Whether to allow neighboring tiles along a diagonal axis.
		 * @return {Array} An array containing nodes describing the neighbouring tiles of the current node.
		 * @private
		 */
		_getNeighbours: function (currentNode, endPoint, tileMap, comparisonCallback, allowSquare, allowDiagonal) {
			var list = [],
				x = currentNode.x,
				y = currentNode.y,
				newX = 0,
				newY = 0,
				newNode,
				mapData = tileMap.map._mapData,
				currentNodeData = mapData[y] && mapData[y][x] ? mapData[y][x] : undefined,
				tileData;
			
			if (allowSquare) {
				newX = x - 1; newY = y;
				tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
				if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
					newNode = new IgePathNode(newX, newY, currentNode.g, this._squareCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._squareCost), currentNode, 'W');
					list.push(newNode);
				}
				
				newX = x + 1; newY = y;
				tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
				if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
					newNode = new IgePathNode(newX, newY, currentNode.g, this._squareCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._squareCost), currentNode, 'E');
					list.push(newNode);
				}
				
				newX = x; newY = y - 1;
				tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
				if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
					newNode = new IgePathNode(newX, newY, currentNode.g, this._squareCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._squareCost), currentNode, 'N');
					list.push(newNode);
				}
				
				newX = x; newY = y + 1;
				tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
				if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
					newNode = new IgePathNode(newX, newY, currentNode.g, this._squareCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._squareCost), currentNode, 'S');
					list.push(newNode);
				}
				
			}
			
			if (allowDiagonal) {
				newX = x - 1; newY = y - 1;
				tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
				if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
					newNode = new IgePathNode(newX, newY, currentNode.g, this._diagonalCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._diagonalCost), currentNode, 'NW');
					list.push(newNode);
				}
				
				newX = x + 1; newY = y - 1;
				tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
				if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
					newNode = new IgePathNode(newX, newY, currentNode.g, this._diagonalCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._diagonalCost), currentNode, 'NE');
					list.push(newNode);
				}
				
				newX = x - 1; newY = y + 1;
				tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
				if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
					newNode = new IgePathNode(newX, newY, currentNode.g, this._diagonalCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._diagonalCost), currentNode, 'SW');
					list.push(newNode);
				}
				
				newX = x + 1; newY = y + 1;
				tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
				if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
					newNode = new IgePathNode(newX, newY, currentNode.g, this._diagonalCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._diagonalCost), currentNode, 'SE');
					list.push(newNode);
				}
			}
			
			return list;
		},
		
		/**
		 * The heuristic to calculate the rough cost of pathing from the
		 * x1, y1 to x2, y2.
		 * @param {Number} x1 The first x co-ordinate.
		 * @param {Number} y1 The first y co-ordinate.
		 * @param {Number} x2 The second x co-ordinate.
		 * @param {Number} y2 The second y co-ordinate.
		 * @param {Number} moveCost The cost multiplier to multiply by.
		 * @return {Number} Returns the heuristic cost between the co-ordinates specified.
		 * @private
		 */
		_heuristic: function (x1, y1, x2, y2, moveCost) {
			return moveCost * (Math.abs(x1 - x2) + Math.abs(y1 - y2));
		},
		
		as: function (map, fromNode, toNode) {
			var openList = [];
			
			// Add start point to open list
			openList.push(fromNode);
		}
	});
	
	return IgePathFinder;
});
},{"irrelon-appcore":125}],73:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgePathNode', function (IgePoint3d) {
	/**
	 * Creates a new path node for use with the IgePathFinder class.
	 */
	var IgePathNode = IgePoint3d.extend({
		classId: 'IgePathNode',
		
		/**
		 * @constructor
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} g
		 * @param {Number} moveCost
		 * @param {Number} h
		 * @param {Object} parent
		 * @param {String} direction
		 */
		init: function(x, y, g, moveCost, h, parent, direction) {
			this.z = 0; // Compat with IgePoint3d
			
			this.x = x;
			this.y = y;
			this.g = g + moveCost; // Cost of moving from the start point along the path to this node (parentNode.g + moveCost)
			this.h = h; // Rough distance to target node
			this.moveCost = moveCost;
			this.f = g + h; // Result of g + h
			this.link = parent;
			this.hash = x + ',' + y;
			this.listType = 0;
			this.direction = direction;
			this.mode = 0;
		},
		
		/**
		 * Gets / sets the path node mode. The mode determines if the co-ordinates
		 * will be in tile or absolute co-ordinates.
		 * @param {Number=} val 0 = tile based, 1 = absolute based.
		 * @return {*}
		 */
		mode: function (val) {
			if (val !== undefined) {
				this.mode = val;
				return this;
			}
			
			return this.mode;
		}
	});
	
	return IgePathNode;
});
},{"irrelon-appcore":125}],74:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgePoint2d', function (IgeClass) {
	/**
	 * Creates a new 2d point (x, y).
	 */
	var IgePoint2d = IgeClass.extend({
		classId: 'IgePoint2d',
		
		init: function (x, y, floor) {
			// Set values to the passed parameters or
			// zero if they are undefined
			// Commented for increase performance over stability checks
			/*if (x === undefined) { debugger; }
			 if (y === undefined) { debugger; }*/
			this.x = x = x !== undefined ? x : 0;
			this.y = y = y !== undefined ? y : 0;
			
			this._floor = floor !== undefined;
			
			if (this._floor) {
				this.x2 = Math.floor(x / 2);
				this.y2 = Math.floor(y / 2);
			} else {
				this.x2 = x / 2;
				this.y2 = y / 2;
			}
			
			return this;
		},
		
		/**
		 * Gets / sets the floor mode of this point. If set to true the point's
		 * data will be mathematically floored when they are assigned.
		 * @param val
		 * @return {*}
		 */
		floor: function (val) {
			if (val !== undefined) {
				this._floor = val;
				return this;
			}
			
			return this._floor;
		},
		
		/**
		 * Compares this point's x, y data with the passed point and returns
		 * true if they are the same and false if any is different.
		 * @param {IgePoint2d} point The point to compare data with.
		 * @return {Boolean}
		 */
		compare: function (point) {
			return point && this.x === point.x && this.y === point.y;
		},
		
		/**
		 * Copies the x, y data from the passed point and overwrites this
		 * point's data with those values.
		 * @param {IgePoint2d} point The point to copy values from.
		 * @returns {*}
		 */
		copy: function (point) {
			this.x = point.x;
			this.y = point.y;
			this.z = point.z;
			
			return this;
		},
		
		/**
		 * Converts the point's x, y to an isometric x, y 2d co-ordinate
		 * and returns an object whose x, y values are the result.
		 * @return {Object}
		 */
		toIso: function () {
			var sx = this.x - this.y,
				sy = (this.x + this.y) * 0.5;
			
			return {x: sx, y: sy};
		},
		
		/**
		 * Converts this point's x, y data into isometric co-ordinate space
		 * and overwrites the previous x, y values with the result.
		 * @return {*}
		 */
		thisToIso: function () {
			var val = this.toIso();
			this.x = val.x;
			this.y = val.y;
			
			return this;
		},
		
		/**
		 * Converts this point's x, y data into 2d co-ordinate space
		 * and returns an object whose x, y values are the result.
		 * @return {Object}
		 */
		to2d: function () {
			var sx = this.y + this.x / 2,
				sy = this.y - this.x / 2;
			
			return {x: sx, y: sy};
		},
		
		/**
		 * Converts this point's x, y data into 2d co-ordinate space
		 * and overwrites the previous x, y values with the result.
		 * @return {*}
		 */
		thisTo2d: function () {
			var val = this.to2d();
			this.x = val.x;
			this.y = val.y;
			
			return this;
		},
		
		/**
		 * Adds this point's data by the x, y, values specified
		 * and returns a new IgePoint2d whose values are the result.
		 * @param point
		 * @return {*}
		 */
		addPoint: function (point) {
			return new IgePoint2d(this.x + point.x, this.y + point.y);
		},
		
		/**
		 * Adds this point's data by the x, y values specified and
		 * overwrites the previous x, y values with the result.
		 * @param point
		 * @return {*}
		 */
		thisAddPoint: function (point) {
			this.x += point.x;
			this.y += point.y;
			
			return this;
		},
		
		/**
		 * Minuses this point's data by the x, y values specified
		 * and returns a new IgePoint2d whose values are the result.
		 * @param point
		 * @return {*}
		 */
		minusPoint: function (point) {
			return new IgePoint2d(this.x - point.x, this.y - point.y);
		},
		
		/**
		 * Minuses this point's data by the x, y values specified and
		 * overwrites the previous x, y values with the result.
		 * @param point
		 * @return {*}
		 */
		thisMinusPoint: function (point) {
			this.x -= point.x;
			this.y -= point.y;
			
			return this;
		},
		
		/**
		 * Multiplies this point's data by the x, y values specified
		 * and returns a new IgePoint2d whose values are the result.
		 * @param x
		 * @param y
		 * @return {*}
		 */
		multiply: function (x, y) {
			return new IgePoint2d(this.x * x, this.y * y);
		},
		
		/**
		 * Multiplies this point's data by the point specified
		 * and returns a new IgePoint2d whose values are the result.
		 * @param {IgePoint2d} point
		 * @return {*}
		 */
		multiplyPoint: function (point) {
			return new IgePoint2d(this.x * point.x, this.y * point.y);
		},
		
		/**
		 * Multiplies this point's data by the x, y values specified and
		 * overwrites the previous x, y values with the result.
		 * @param x
		 * @param y
		 * @param z
		 * @return {*}
		 */
		thisMultiply: function (x, y) {
			this.x *= x;
			this.y *= y;
			
			return this;
		},
		
		/**
		 * Divides this point's data by the x, y values specified
		 * and returns a new IgePoint2d whose values are the result.
		 * @param x
		 * @param y
		 * @return {*}
		 */
		divide: function (x, y) {
			return new IgePoint2d(this.x / x, this.y / y);
		},
		
		/**
		 * Divides this point's data by the point specified
		 * and returns a new IgePoint2d whose values are the result.
		 * @param {IgePoint2d} point
		 * @return {*}
		 */
		dividePoint: function (point) {
			var newX = this.x,
				newY = this.y;
			
			if (point.x) { newX = this.x / point.x; }
			if (point.y) { newY = this.y / point.y; }
			
			return new IgePoint2d(newX, newY);
		},
		
		/**
		 * Divides this point's data by the x, y values specified and
		 * overwrites the previous x, y values with the result.
		 * @param x
		 * @param y
		 * @return {*}
		 */
		thisDivide: function (x, y) {
			this.x /= x;
			this.y /= y;
			
			return this;
		},
		
		/**
		 * Returns a clone of this IgePoint2d's data as a new instance.
		 * @return {*}
		 */
		clone: function () {
			return new IgePoint2d(this.x, this.y);
		},
		
		/**
		 * Interpolates the x, y values of this point towards the endPoint's
		 * x, y values based on the passed time variables and returns a new
		 * IgePoint2d whose values are the result.
		 * @param endPoint
		 * @param startTime
		 * @param currentTime
		 * @param endTime
		 * @return {*}
		 */
		interpolate: function (endPoint, startTime, currentTime, endTime) {
			var totalX = endPoint.x - this.x,
				totalY = endPoint.y - this.y,
				totalTime = endTime - startTime,
				deltaTime = totalTime - (currentTime - startTime),
				timeRatio = deltaTime / totalTime;
			
			return new IgePoint2d(endPoint.x - (totalX * timeRatio), endPoint.y - (totalY * timeRatio));
		},
		
		/**
		 * Rotates the point by the given radians.
		 * @param {Number} radians Radians to rotate by.
		 * @return {IgePoint2d} A new point with the rotated x, y.
		 */
		rotate: function (radians) {
			var s = Math.sin(radians),
				c = Math.cos(radians),
				x = c * this.x - s * this.y,
				y = s * this.x - c * this.y;
			
			return new IgePoint2d(x, y);
		},
		
		/**
		 * Rotates the point by the given radians and updates this point
		 * to the new x, y values.
		 * @param {Number} radians Radians to rotate by.
		 * @return {IgePoint2d} This point.
		 */
		thisRotate: function (radians) {
			var s = Math.sin(radians),
				c = Math.cos(radians),
				x = this.x,
				y = this.y;
			
			this.x = c * x - s * y;
			this.y = s * x - c * y;
			
			return this;
		},
		
		/**
		 * Returns a string representation of the point's x, y
		 * converting floating point values into fixed using the
		 * passed precision parameter. If no precision is specified
		 * then the precision defaults to 2.
		 * @param {Number=} precision
		 * @return {String}
		 */
		toString: function (precision) {
			if (precision === undefined) { precision = 2; }
			return this.x.toFixed(precision) + ',' + this.y.toFixed(precision);
		}
	});
	
	return IgePoint2d;
});
},{"irrelon-appcore":125}],75:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgePoint3d', function (IgeClass) {
	/**
	 * Creates a new 3d point (x, y, z).
	 */
	var IgePoint3d = IgeClass.extend({
		classId: 'IgePoint3d',
		
		init: function (x, y, z, floor) {
			// Set values to the passed parameters or
			// zero if they are undefined
			// Commented for increase performance over stability checks
			/*if (x === undefined) { debugger; }
			 if (y === undefined) { debugger; }
			 if (z === undefined) { debugger; }*/
			this.x = x = x !== undefined ? x : 0;
			this.y = y = y !== undefined ? y : 0;
			this.z = z = z !== undefined ? z : 0;
			
			this._floor = floor !== undefined;
			
			if (this._floor) {
				this.x2 = Math.floor(x / 2);
				this.y2 = Math.floor(y / 2);
				this.z2 = Math.floor(z / 2);
			} else {
				this.x2 = x / 2;
				this.y2 = y / 2;
				this.z2 = z / 2;
			}
			
			return this;
		},
		
		/**
		 * Gets / sets the floor mode of this point. If set to true the point's
		 * data will be mathematically floored when they are assigned.
		 * @param val
		 * @return {*}
		 */
		floor: function (val) {
			if (val !== undefined) {
				this._floor = val;
				return this;
			}
			
			return this._floor;
		},
		
		/**
		 * Compares this point's x, y, z data with the passed point and returns
		 * true if they are the same and false if any is different.
		 * @param {IgePoint3d} point The point to compare data with.
		 * @return {Boolean}
		 */
		compare: function (point) {
			return point && this.x === point.x && this.y === point.y && this.z === point.z;
		},
		
		/**
		 * Copies the x, y, z data from the passed point and overwrites this
		 * point's data with those values.
		 * @param {IgePoint3d} point The point to copy values from.
		 * @returns {*}
		 */
		copy: function (point) {
			this.x = point.x;
			this.y = point.y;
			this.z = point.z;
			
			return this;
		},
		
		/**
		 * Converts the point's x, y, z to an isometric x, y 2d co-ordinate
		 * and returns an object whose x, y values are the result.
		 * @return {Object}
		 */
		toIso: function () {
			var sx = this.x - this.y,
				sy = (-this.z) * 1.2247 + (this.x + this.y) * 0.5;
			
			return {x: sx, y: sy};
		},
		
		/**
		 * Converts this point's x, y, z data into isometric co-ordinate space
		 * and overwrites the previous x, y, z values with the result.
		 * @return {*}
		 */
		thisToIso: function () {
			var val = this.toIso();
			this.x = val.x;
			this.y = val.y;
			
			return this;
		},
		
		/**
		 * Converts this point's x, y, z data into 2d co-ordinate space
		 * and returns an object whose x, y values are the result.
		 * @return {Object}
		 */
		to2d: function () {
			var sx = this.y + this.x / 2,
				sy = this.y - this.x / 2;
			
			return {x: sx, y: sy};
		},
		
		/**
		 * Converts this point's x, y, z data into 2d co-ordinate space
		 * and overwrites the previous x, y, z values with the result.
		 * @return {*}
		 */
		thisTo2d: function () {
			var val = this.to2d();
			this.x = val.x;
			this.y = val.y;
			this.z = 0;
			
			return this;
		},
		
		/**
		 * Adds this point's data by the x, y, z, values specified
		 * and returns a new IgePoint3d whose values are the result.
		 * @param point
		 * @return {*}
		 */
		addPoint: function (point) {
			return new IgePoint3d(this.x + point.x, this.y + point.y, this.z + point.z);
		},
		
		/**
		 * Adds this point's data by the x, y, z values specified and
		 * overwrites the previous x, y, z values with the result.
		 * @param point
		 * @return {*}
		 */
		thisAddPoint: function (point) {
			this.x += point.x;
			this.y += point.y;
			this.z += point.z;
			
			return this;
		},
		
		/**
		 * Minuses this point's data by the x, y, z, values specified
		 * and returns a new IgePoint3d whose values are the result.
		 * @param point
		 * @return {*}
		 */
		minusPoint: function (point) {
			return new IgePoint3d(this.x - point.x, this.y - point.y, this.z - point.z);
		},
		
		/**
		 * Minuses this point's data by the x, y, z values specified and
		 * overwrites the previous x, y, z values with the result.
		 * @param point
		 * @return {*}
		 */
		thisMinusPoint: function (point) {
			this.x -= point.x;
			this.y -= point.y;
			this.z -= point.z;
			
			return this;
		},
		
		/**
		 * Multiplies this point's data by the x, y, z, values specified
		 * and returns a new IgePoint3d whose values are the result.
		 * @param x
		 * @param y
		 * @param z
		 * @return {*}
		 */
		multiply: function (x, y, z) {
			return new IgePoint3d(this.x * x, this.y * y, this.z * z);
		},
		
		/**
		 * Multiplies this point's data by the point specified
		 * and returns a new IgePoint3d whose values are the result.
		 * @param {IgePoint3d} point
		 * @return {*}
		 */
		multiplyPoint: function (point) {
			return new IgePoint3d(this.x * point.x, this.y * point.y, this.z * point.z);
		},
		
		/**
		 * Multiplies this point's data by the x, y, z values specified and
		 * overwrites the previous x, y, z values with the result.
		 * @param x
		 * @param y
		 * @param z
		 * @return {*}
		 */
		thisMultiply: function (x, y, z) {
			this.x *= x;
			this.y *= y;
			this.z *= z;
			
			return this;
		},
		
		/**
		 * Divides this point's data by the x, y, z, values specified
		 * and returns a new IgePoint3d whose values are the result.
		 * @param x
		 * @param y
		 * @param z
		 * @return {*}
		 */
		divide: function (x, y, z) {
			return new IgePoint3d(this.x / x, this.y / y, this.z / z);
		},
		
		/**
		 * Divides this point's data by the point specified
		 * and returns a new IgePoint3d whose values are the result.
		 * @param {IgePoint3d} point
		 * @return {*}
		 */
		dividePoint: function (point) {
			var newX = this.x,
				newY = this.y,
				newZ = this.z;
			
			if (point.x) { newX = this.x / point.x; }
			if (point.y) { newY = this.y / point.y; }
			if (point.z) { newZ = this.z / point.z; }
			
			return new IgePoint3d(newX, newY, newZ);
		},
		
		/**
		 * Divides this point's data by the x, y, z values specified and
		 * overwrites the previous x, y, z values with the result.
		 * @param x
		 * @param y
		 * @param z
		 * @return {*}
		 */
		thisDivide: function (x, y, z) {
			this.x /= x;
			this.y /= y;
			this.z /= z;
			
			return this;
		},
		
		/**
		 * Returns a clone of this IgePoint3d's data as a new instance.
		 * @return {*}
		 */
		clone: function () {
			return new IgePoint3d(this.x, this.y, this.z);
		},
		
		/**
		 * Interpolates the x, y, z values of this point towards the endPoint's
		 * x, y, z values based on the passed time variables and returns a new
		 * IgePoint3d whose values are the result.
		 * @param endPoint
		 * @param startTime
		 * @param currentTime
		 * @param endTime
		 * @return {*}
		 */
		interpolate: function (endPoint, startTime, currentTime, endTime) {
			var totalX = endPoint.x - this.x,
				totalY = endPoint.y - this.y,
				totalZ = endPoint.z - this.z,
				totalTime = endTime - startTime,
				deltaTime = totalTime - (currentTime - startTime),
				timeRatio = deltaTime / totalTime;
			
			return new IgePoint3d(endPoint.x - (totalX * timeRatio), endPoint.y - (totalY * timeRatio), endPoint.z - (totalZ * timeRatio));
		},
		
		/**
		 * Rotates the point by the given radians.
		 * @param {Number} radians Radians to rotate by.
		 * @return {IgePoint3d} A new point with the rotated x, y.
		 */
		rotate: function (radians) {
			var s = Math.sin(radians),
				c = Math.cos(radians),
				x = c * this.x - s * this.y,
				y = s * this.x - c * this.y;
			
			return new IgePoint3d(x, y, this.z);
		},
		
		/**
		 * Rotates the point by the given radians and updates this point
		 * to the new x, y values.
		 * @param {Number} radians Radians to rotate by.
		 * @return {IgePoint3d} This point.
		 */
		thisRotate: function (radians) {
			var s = Math.sin(radians),
				c = Math.cos(radians),
				x = this.x,
				y = this.y;
			
			this.x = c * x - s * y;
			this.y = s * x - c * y;
			
			return this;
		},
		
		/**
		 * Returns a string representation of the point's x, y, z
		 * converting floating point values into fixed using the
		 * passed precision parameter. If no precision is specified
		 * then the precision defaults to 2.
		 * @param {Number=} precision
		 * @return {String}
		 */
		toString: function (precision) {
			if (precision === undefined) { precision = 2; }
			return this.x.toFixed(precision) + ',' + this.y.toFixed(precision) + ',' + this.z.toFixed(precision);
		}
	});
	
	return IgePoint3d;
});
},{"irrelon-appcore":125}],76:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgePoly2d', function (IgeClass, IgePoint2d, IgeRect) {
	/**
	 * Creates a new 2d polygon made up of IgePoint2d instances.
	 */
	var IgePoly2d = IgeClass.extend({
		classId: 'IgePoly2d',
		
		init: function () {
			this._poly = [];
			this._scale = new IgePoint2d(1, 1);
		},
		
		scale: function (x, y) {
			if (x !== undefined && y !== undefined) {
				this._scale.x = x;
				this._scale.y = y;
				
				return this;
			}
			
			return this._scale;
		},
		
		/**
		 * Multiplies the points of the polygon by the supplied factor.
		 * @param {Number} factor The multiplication factor.
		 * @return {*}
		 */
		multiply: function (factor) {
			if (factor !== undefined) {
				var polyPoints = this._poly,
					pointCount = polyPoints.length,
					pointIndex;
				
				for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
					polyPoints[pointIndex].x *= factor;
					polyPoints[pointIndex].y *= factor;
				}
			}
			
			return this;
		},
		
		/**
		 * Divides the points of the polygon by the supplied value.
		 * @param {Number} value The divide value.
		 * @return {*}
		 */
		divide: function (value) {
			if (value !== undefined) {
				var polyPoints = this._poly,
					pointCount = polyPoints.length,
					pointIndex;
				
				for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
					polyPoints[pointIndex].x /= value;
					polyPoints[pointIndex].y /= value;
				}
			}
			
			return this;
		},
		
		/**
		 * Adds a point to the polygon relative to the polygon center at 0, 0.
		 * @param x
		 * @param y
		 */
		addPoint: function (x, y) {
			this._poly.push(new IgePoint2d(x, y));
			return this;
		},
		
		/**
		 * Returns the length of the poly array.
		 * @return {Number}
		 */
		length: function () {
			return this._poly.length;
		},
		
		/**
		 * Check if a point is inside this polygon.
		 * @param {IgePoint2d} point
		 * @return {Boolean}
		 */
		pointInPoly: function (point) {
			var polyPoints = this._poly,
				pointCount = polyPoints.length,
				pointIndex,
				oldPointIndex = pointCount - 1,
				c = 0;
			
			for (pointIndex = 0; pointIndex < pointCount; oldPointIndex = pointIndex++) {
				if (((polyPoints[pointIndex].y > point.y) !== (polyPoints[oldPointIndex].y > point.y)) &&
					(point.x < (polyPoints[oldPointIndex].x - polyPoints[pointIndex].x) *
					(point.y - polyPoints[pointIndex].y) / (polyPoints[oldPointIndex].y - polyPoints[pointIndex].y) +
					polyPoints[pointIndex].x)) {
					c = !c;
				}
			}
			
			return Boolean(c);
		},
		
		/**
		 * Check if the passed x and y are inside this polygon.
		 * @param {Number} x
		 * @param {Number} y
		 * @return {Boolean}
		 */
		xyInside: function (x, y) {
			var polyPoints = this._poly,
				pointCount = polyPoints.length,
				pointIndex,
				oldPointIndex = pointCount - 1,
				c = 0;
			
			for (pointIndex = 0; pointIndex < pointCount; oldPointIndex = pointIndex++) {
				if (((polyPoints[pointIndex].y > y) !== (polyPoints[oldPointIndex].y > y)) &&
					(x < (polyPoints[oldPointIndex].x - polyPoints[pointIndex].x) *
					(y - polyPoints[pointIndex].y) / (polyPoints[oldPointIndex].y - polyPoints[pointIndex].y) +
					polyPoints[pointIndex].x)) {
					c = !c;
				}
			}
			
			return Boolean(c);
		},
		
		aabb: function () {
			var minX,
				minY,
				maxX,
				maxY,
				xArr = [],
				yArr = [],
				arr = this._poly,
				arrIndex,
				arrCount = arr.length;
			
			for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
				xArr.push(arr[arrIndex].x);
				yArr.push(arr[arrIndex].y);
			}
			
			// Get the extents of the newly transformed poly
			minX = Math.min.apply(Math, xArr);
			minY = Math.min.apply(Math, yArr);
			maxX = Math.max.apply(Math, xArr);
			maxY = Math.max.apply(Math, yArr);
			
			return new IgeRect(minX, minY, maxX - minX, maxY - minY);
		},
		
		/**
		 * Returns a copy of this IgePoly2d object that is
		 * it's own version, separate from the original.
		 * @return {IgePoly2d}
		 */
		clone: function () {
			var newPoly = new IgePoly2d(),
				arr = this._poly,
				arrCount = arr.length,
				i;
			
			for (i = 0; i < arrCount; i++) {
				newPoly.addPoint(arr[i].x, arr[i].y);
			}
			
			newPoly.scale(this._scale.x, this._scale.y);
			
			return newPoly;
		},
		
		/**
		 * Determines if the polygon is clockwise or not.
		 * @return {Boolean} A boolean true if clockwise or false
		 * if not.
		 */
		clockWiseTriangle: function () {
			// Loop the polygon points and determine if they are counter-clockwise
			var arr = this._poly,
				val,
				p1, p2, p3;
			
			p1 = arr[0];
			p2 = arr[1];
			p3 = arr[2];
			
			val = (p1.x * p2.y) + (p2.x * p3.y) + (p3.x * p1.y) - (p2.y * p3.x) - (p3.y * p1.x) - (p1.y * p2.x);
			
			return val > 0;
		},
		
		makeClockWiseTriangle: function () {
			// If our data is already clockwise exit
			if (!this.clockWiseTriangle()) {
				var p1 = this._poly[1],
					p2 = this._poly[2];
				
				this._poly[2] = p1;
				this._poly[1] = p2;
			}
		},
		
		triangulate: function () {
			// Get the indices of each new triangle
			var poly = this._poly,
				triangles = [],
				indices = this.triangulationIndices(),
				i,
				point1,
				point2,
				point3,
				newPoly;
			
			// Generate new polygons from the index data
			for (i = 0; i < indices.length; i += 3) {
				point1 = poly[indices[i]];
				point2 = poly[indices[i + 1]];
				point3 = poly[indices[i + 2]];
				newPoly = new IgePoly2d();
				
				newPoly.addPoint(point1.x, point1.y);
				newPoly.addPoint(point2.x, point2.y);
				newPoly.addPoint(point3.x, point3.y);
				
				// Check the new poly and make sure it's clockwise
				newPoly.makeClockWiseTriangle();
				triangles.push(newPoly);
			}
			
			return triangles;
		},
		
		triangulationIndices: function () {
			var indices = [],
				n = this._poly.length,
				v = [],
				V = [],
				nv,
				count,
				m,
				u,
				w,
				a,
				b,
				c,
				s,
				t;
			
			if (n < 3) { return indices; }
			
			if (this._area() > 0) {
				for (v = 0; v < n; v++) {
					V[v] = v;
				}
			} else {
				for (v = 0; v < n; v++) {
					V[v] = (n - 1) - v;
				}
			}
			
			nv = n;
			count = 2 * nv;
			m = 0;
			
			for (v = nv - 1; nv > 2; ) {
				if ((count--) <= 0) {
					return indices;
				}
				
				u = v;
				if (nv <= u) {
					u = 0;
				}
				
				v = u + 1;
				
				if (nv <= v) {
					v = 0;
				}
				
				w = v + 1;
				
				if (nv <= w) {
					w = 0;
				}
				
				if (this._snip(u, v, w, nv, V)) {
					a = V[u];
					b = V[v];
					c = V[w];
					indices.push(a);
					indices.push(b);
					indices.push(c);
					m++;
					s = v;
					
					for (t = v + 1; t < nv; t++) {
						V[s] = V[t];
						s++;
					}
					
					nv--;
					count = 2 * nv;
				}
			}
			
			indices.reverse();
			return indices;
		},
		
		_area: function () {
			var n = this._poly.length,
				a = 0.0,
				q = 0,
				p,
				pval,
				qval;
			
			for (p = n - 1; q < n; p = q++) {
				pval = this._poly[p];
				qval = this._poly[q];
				a += pval.x * qval.y - qval.x * pval.y;
			}
			
			return (a * 0.5);
		},
		
		_snip: function (u, v, w, n, V) {
			var p,
				A = this._poly[V[u]],
				B = this._poly[V[v]],
				C = this._poly[V[w]],
				P;
			
			// Replaced Math.Epsilon with 0.00001
			if (0.00001 > (((B.x - A.x) * (C.y - A.y)) - ((B.y - A.y) * (C.x - A.x)))) {
				return false;
			}
			
			for (p = 0; p < n; p++) {
				if ((p === u) || (p === v) || (p === w)) {
					continue;
				}
				
				P = this._poly[V[p]];
				if (this._insideTriangle(A, B, C, P)) {
					return false;
				}
			}
			
			return true;
		},
		
		_insideTriangle: function (A, B, C, P) {
			var ax,
				ay,
				bx,
				by,
				cx,
				cy,
				apx,
				apy,
				bpx,
				bpy,
				cpx,
				cpy,
				cCROSSap,
				bCROSScp,
				aCROSSbp;
			
			ax = C.x - B.x; ay = C.y - B.y;
			bx = A.x - C.x; by = A.y - C.y;
			cx = B.x - A.x; cy = B.y - A.y;
			apx = P.x - A.x; apy = P.y - A.y;
			bpx = P.x - B.x; bpy = P.y - B.y;
			cpx = P.x - C.x; cpy = P.y - C.y;
			
			aCROSSbp = ax * bpy - ay * bpx;
			cCROSSap = cx * apy - cy * apx;
			bCROSScp = bx * cpy - by * cpx;
			
			return ((aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0));
		},
		
		/**
		 * Draws the polygon bounding lines to the passed context.
		 * @param {CanvasRenderingContext2D} ctx
		 */
		render: function (ctx, fill) {
			var polyPoints = this._poly,
				pointCount = polyPoints.length,
				scaleX = this._scale.x,
				scaleY = this._scale.y,
				i;
			
			ctx.beginPath();
			ctx.moveTo(polyPoints[0].x * scaleX, polyPoints[0].y * scaleY);
			for (i = 1; i < pointCount; i++) {
				ctx.lineTo(polyPoints[i].x * scaleX, polyPoints[i].y * scaleY);
			}
			ctx.lineTo(polyPoints[0].x * scaleX, polyPoints[0].y * scaleY);
			if (fill) { ctx.fill(); }
			ctx.stroke();
			
			return this;
		}
	});
	
	return IgePoly2d;
});
},{"irrelon-appcore":125}],77:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeQuest', function (IgeEventingClass) {
	var IgeQuest = IgeEventingClass.extend({
		classId: 'IgeQuest',
		
		init: function (questDefinition, completeCallback) {
			this._linear = false;
			this._items = [];
			
			this._itemCount = 0;
			this._eventCount = 0;
			this._itemCompleteCount = 0;
			this._eventCompleteCount = 0;
			
			this._started = false;
			this._isComplete = false;
			
			if (questDefinition !== undefined) {
				this.items(questDefinition);
			}
			
			if (completeCallback !== undefined) {
				this._completeCallback = completeCallback;
			}
		},
		
		/**
		 * Gets / sets the callback method that will fire when
		 * the quest has been completed.
		 * @param callback
		 * @return {*}
		 */
		complete: function (callback) {
			if (callback !== undefined) {
				this._completeCallback = callback;
				return this;
			}
			
			return this._completeCallback;
		},
		
		/**
		 * Gets / sets the flag that determines if the quest
		 * has been completed successfully or not.
		 * @param val
		 * @return {*}
		 */
		isComplete: function (val) {
			if (val !== undefined) {
				this._isComplete = val;
				return this;
			}
			
			return this._isComplete;
		},
		
		/**
		 * Gets / sets the flag that determines if the quest items
		 * need to be completed in order (true) or if they can be
		 * completed in any order (false). Default is false.
		 * @param val
		 * @return {*}
		 */
		linear: function (val) {
			if (val !== undefined) {
				this._linear = val;
				return this;
			}
			
			return this._linear;
		},
		
		/**
		 * Gets / sets the items array containing the quest item
		 * definition objects.
		 * @param val
		 * @return {*}
		 */
		items: function (val) {
			if (val !== undefined) {
				this._items = val;
				
				// Set the event and item counts
				var arr = this._items,
					arrCount = arr.length,
					i,
					eventCount = 0;
				
				for (i = 0; i < arrCount; i++) {
					eventCount += arr[i].count;
				}
				
				this._eventCount = eventCount;
				this._itemCount = arrCount;
				
				return this;
			}
			
			return this._items;
		},
		
		/**
		 * Returns the number of quest items this quest has.
		 * @return {Number}
		 */
		itemCount: function () {
			return this._itemCount;
		},
		
		/**
		 * Returns the sum of all event counts for every item
		 * in the quest giving an overall number of events that
		 * need to fire in order for the quest to be completed.
		 * @return {Number}
		 */
		eventCount: function () {
			return this._eventCount;
		},
		
		/**
		 * Returns the number of events that have been completed.
		 * @return {Number}
		 */
		eventCompleteCount: function () {
			return this._eventCompleteCount;
		},
		
		/**
		 * Returns the number of items that have been completed.
		 * @return {Number}
		 */
		itemCompleteCount: function () {
			return this._itemCompleteCount;
		},
		
		/**
		 * Returns the percentage representation of the quest's
		 * overall completion based on number of overall events and
		 * number of events that have been completed.
		 * @return {Number} A number from zero to one-hundred.
		 */
		percentComplete: function () {
			return Math.floor((100 / this._eventCount) * this._eventCompleteCount);
		},
		
		/**
		 * Starts the quest by setting up the quest event
		 * listeners.
		 */
		start: function () {
			if (!this._started) {
				var arr = this._items,
					arrCount = arr.length,
					i;
				
				// Mark the quest as started
				this._started = true;
				
				// Check if we have a linear quest or a non-linear one
				if (!this._linear) {
					// The quest is non-linear so activate all the item listeners now...
					// Loop the quest items array
					for (i = 0; i < arrCount; i++) {
						// Setup the listener for this item
						this._setupItemListener(arr[i]);
					}
				} else {
					// The quest is linear so only activate the first listener for now...
					this._setupItemListener(arr[0]);
				}
				
				this.emit('started');
			} else {
				// Quest already started!
				this.log('Cannot start quest because it has already been started!', 'warning');
				this.emit('alreadyStarted');
			}
			
			return this;
		},
		
		/**
		 * Stops the quest and sets all the event listeners to
		 * ignore events until the quest is restarted.
		 */
		stop: function () {
			if (this._started) {
				this._started = false;
				this.emit('stopped');
			} else {
				this.log('Cannot stop quest because it has not been started yet!', 'warning');
				this.emit('notStarted');
			}
			
			return this;
		},
		
		/**
		 * Resets the quest and item internals back to their
		 * original values and cancels all current event listeners.
		 */
		reset: function () {
			var arr = this._items,
				arrCount = arr.length,
				i, item;
			
			for (i = 0; i < arrCount; i++) {
				item = arr[i];
				
				// Reset all the item internals
				item._complete = false;
				item._eventCount = 0;
				
				// Cancel the event listener
				if (item._listener) {
					item.emitter.off(item.eventName, item._listener);
				}
				
				// Clear the reference holding the item listener
				delete item._listener;
			}
			
			// Reset quest internals
			this._eventCompleteCount = 0;
			this._itemCompleteCount = 0;
			this._isComplete = false;
			
			this.emit('reset');
			
			return this;
		},
		
		/**
		 * Sets up a quest item's event listener.
		 * @param item
		 * @private
		 */
		_setupItemListener: function (item) {
			var self = this;
			
			// Check for an existing listener
			if (!item._listener) {
				// Set the item's internal event count to zero
				// (number of times the event has fired)
				item._eventCount = 0;
				item._complete = false;
				
				// Create the event listener
				item._listener = item.emitter.on(item.eventName, function () {
					// Check if the quest is currently started
					if (self._started) {
						// If the item has an event evaluator method...
						if (item.eventEvaluate) {
							// Check if the event's data evaluated to true
							if (item.eventEvaluate.apply(self, arguments)) {
								// The evaluator returned true so complete the event
								self._eventComplete(item);
							}
						} else {
							self._eventComplete(item);
						}
					}
				});
			}
		},
		
		/**
		 * Handles when an event has been fired for a quest item.
		 * @param item
		 * @private
		 */
		_eventComplete: function (item) {
			// Increment the internal event count
			item._eventCount++;
			
			// Increment the quest's internal event count
			this._eventCompleteCount++;
			
			// Fire the callback to the game logic
			if (item.eventCallback) {
				item.eventCallback.apply(this, item);
			}
			
			// Emit the event complete event
			this.emit('eventComplete', item);
			
			// Check if we've reached our designated event count
			if (item._eventCount === item.count) {
				this._itemComplete(item);
			}
		},
		
		/**
		 * Handles when an item's events have all been fired.
		 * @param item
		 * @private
		 */
		_itemComplete: function (item) {
			var itemIndex,
				arr = this._items;
			
			// Mark the item as complete
			item._complete = true;
			
			// Cancel the listener
			item.emitter.off(item.eventName, item._listener);
			delete item._listener;
			
			// Increment the quest's item complete count
			this._itemCompleteCount++;
			
			// Fire the item's itemCallback to the game logic
			if (item.itemCallback) {
				item.itemCallback.apply(this, item);
			}
			
			// Emit the item complete event
			this.emit('itemComplete', item);
			
			// Tell the quest to check it's internals
			this._update();
			
			// Check if the quest is linear
			if (this._started && this._linear && this._itemCompleteCount < this.itemCount()) {
				// Advance the listener to the next item
				itemIndex = arr.indexOf(item);
				this._setupItemListener(arr[itemIndex + 1]);
				
				// Emit the nextItem event (linear quests only)
				this.emit('nextItem', arr[itemIndex + 1]);
			}
		},
		
		/**
		 * Called when a quest item has been completed to determine
		 * if the quest should continue or if it has also been
		 * completed.
		 * @private
		 */
		_update: function () {
			// Check if all our items are complete
			if (this._itemCompleteCount === this.itemCount()) {
				// Mark the quest as complete
				this._isComplete = true;
				
				// Fire the quest completed callback
				this._completeCallback.apply(this);
				
				// Emit the quest complete event
				this.emit('complete');
				
				// Stop the quest
				this.stop();
				
				// Reset the quest (kills current event listeners)
				this.reset();
			}
		}
	});
	
	return IgeQuest;
});
},{"irrelon-appcore":125}],78:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeRect', function (IgeClass) {
	/**
	 * Creates a new rectangle (x, y, width, height).
	 */
	var IgeRect = IgeClass.extend({
		classId: 'IgeRect',
		
		init: function (x, y, width, height) {
			// Set values to the passed parameters or
			// zero if they are undefined
			this.x = x = x !== undefined ? x : 0;
			this.y = y = y !== undefined ? y : 0;
			this.width = width = width !== undefined ? width : 0;
			this.height = height = height !== undefined ? height : 0;
			
			this.x2 = this.x / 2;
			this.y2 = this.y / 2;
			
			return this;
		},
		
		/**
		 * Combines the extents of the passed IgeRect with this rect
		 * to create a new rect whose bounds encapsulate both rects.
		 * @param {IgeRect} rect The rect to combine with this one.
		 * @return {IgeRect} The new rect encapsulating both rects.
		 */
		combineRect: function (rect) {
			var thisRectMaxX = this.x + this.width,
				thisRectMaxY = this.y + this.height,
				thatRectMaxX = rect.x + rect.width,
				thatRectMaxY = rect.y + rect.height,
				
				x = Math.min(this.x, rect.x),
				y = Math.min(this.y, rect.y),
				width = Math.max(thisRectMaxX - this.x, thatRectMaxX - this.x),
				height = Math.max(thisRectMaxY - this.y, thatRectMaxY - this.y);
			
			return new IgeRect(x, y, width, height);
		},
		
		/**
		 * Combines the extents of the passed IgeRect with this rect
		 * and replaces this rect with one whose bounds encapsulate
		 * both rects.
		 * @param {IgeRect} rect The rect to combine with this one.
		 */
		thisCombineRect: function (rect) {
			var thisRectMaxX = this.x + this.width,
				thisRectMaxY = this.y + this.height,
				thatRectMaxX = rect.x + rect.width,
				thatRectMaxY = rect.y + rect.height;
			
			this.x = Math.min(this.x, rect.x);
			this.y = Math.min(this.y, rect.y);
			
			this.width = Math.max(thisRectMaxX - this.x, thatRectMaxX - this.x);
			this.height = Math.max(thisRectMaxY - this.y, thatRectMaxY - this.y);
		},
		
		minusPoint: function (point) {
			return new IgeRect(this.x - point.x, this.y - point.y, this.width, this.height);
		},
		
		/**
		 * Compares this rect's dimensions with the passed rect and returns
		 * true if they are the same and false if any is different.
		 * @param {IgeRect} rect
		 * @return {Boolean}
		 */
		compare: function (rect) {
			return rect && this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;
		},
		
		/**
		 * Returns boolean indicating if the passed x, y is
		 * inside the rectangle.
		 * @param x
		 * @param y
		 * @return {Boolean}
		 */
		xyInside: function (x, y) {
			return x >= this.x && y > this.y && x <= this.x + this.width && y <= this.y + this.height;
		},
		
		/**
		 * Returns boolean indicating if the passed point is
		 * inside the rectangle.
		 * @param {IgePoint3d} point
		 * @return {Boolean}
		 */
		pointInside: function (point) {
			return point.x >= this.x && point.y > this.y && point.x <= this.x + this.width && point.y <= this.y + this.height;
		},
		
		/**
		 * Returns boolean indicating if the passed IgeRect is
		 * intersecting the rectangle.
		 * @param {IgeRect} rect
		 * @return {Boolean}
		 */
		rectIntersect: function (rect) {
			this.log('rectIntersect has been renamed to "intersects". Please update your code. rectIntersect will be removed in a later version of IGE.', 'warning');
			return this.intersects(rect);
		},
		
		/**
		 * Returns boolean indicating if the passed IgeRect is
		 * intersecting the rectangle.
		 * @param {IgeRect} rect
		 * @return {Boolean}
		 */
		intersects: function (rect) {
			if (rect) {
				var sX1 = this.x,
					sY1 = this.y,
					sW = this.width,
					sH = this.height,
					
					dX1 = rect.x,
					dY1 = rect.y,
					dW = rect.width,
					dH = rect.height,
					
					sX2 = sX1 + sW,
					sY2 = sY1 + sH,
					dX2 = dX1 + dW,
					dY2 = dY1 + dH;
				
				if (sX1 < dX2 && sX2 > dX1 && sY1 < dY2 && sY2 > dY1) {
					return true;
				}
			}
			
			return false;
		},
		
		/**
		 * Multiplies this rect's data by the values specified
		 * and returns a new IgeRect whose values are the result.
		 * @param x1
		 * @param y1
		 * @param x2
		 * @param y2
		 * @return {*}
		 */
		multiply: function (x1, y1, x2, y2) {
			return new IgeRect(this.x * x1, this.y * y1, this.width * x2, this.height * y2);
		},
		
		/**
		 * Multiplies this rects's data by the values specified and
		 * overwrites the previous values with the result.
		 * @param x1
		 * @param y1
		 * @param x2
		 * @param y2
		 * @return {*}
		 */
		thisMultiply: function (x1, y1, x2, y2) {
			this.x *= x1;
			this.y *= y1;
			this.width *= x2;
			this.height *= y2;
			
			return this;
		},
		
		/**
		 * Returns a clone of this object that is not a reference
		 * but retains the same values.
		 * @return {IgeRect}
		 */
		clone: function () {
			return new IgeRect(this.x, this.y, this.width, this.height);
		},
		
		/**
		 * Returns a string representation of the rect's x, y, width,
		 * height, converting floating point values into fixed using the
		 * passed precision parameter. If no precision is specified
		 * then the precision defaults to 2.
		 * @param {Number=} precision
		 * @return {String}
		 */
		toString: function (precision) {
			if (precision === undefined) { precision = 2; }
			return this.x.toFixed(precision) + ',' + this.y.toFixed(precision) + ',' + this.width.toFixed(precision) + ',' + this.height.toFixed(precision);
		},
		
		/**
		 * Draws the polygon bounding lines to the passed context.
		 * @param {CanvasRenderingContext2D} ctx
		 */
		render: function (ctx, fill) {
			ctx.rect(this.x, this.y, this.width, this.height);
			if (fill) { ctx.fill(); }
			ctx.stroke();
			
			return this;
		}
	});
	
	return IgeRect;
});
},{"irrelon-appcore":125}],79:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeScene2d', function ($ige, IgeEntity) {
	/**
	 * Creates a new 2d scene.
	 */
	var IgeScene2d = IgeEntity.extend({
		classId: 'IgeScene2d',
		
		init: function () {
			this._mouseAlwaysInside = true;
			this._alwaysInView = true;
			IgeEntity.prototype.init.call(this);
			
			this._shouldRender = true;
			this._autoSize = true;
			
			// Set the geometry of the scene to the main canvas
			// width / height - used when positioning UI elements
			this._bounds2d.x = $ige.engine._bounds2d.x;
			this._bounds2d.y = $ige.engine._bounds2d.y;
			
			this.streamSections(['transform', 'ignoreCamera']);
		},
		
		/**
		 * Gets / sets the stream room id. If set, any streaming entities that
		 * are mounted to this scene will only sync with clients that have been
		 * assigned to this room id.
		 *
		 * @param {String} id The id of the room.
		 * @returns {*}
		 */
		streamRoomId: function (id) {
			if (id !== undefined) {
				this._streamRoomId = id;
				return this;
			}
			
			return this._streamRoomId;
		},
		
		/**
		 * Overrides the default entity stream sections to also stream important
		 * data about scenes to the client.
		 * @param sectionId
		 * @param data
		 * @returns {*}
		 */
		streamSectionData: function (sectionId, data) {
			switch (sectionId) {
				case 'ignoreCamera':
					if (data !== undefined) {
						// Setter
						if (data === 'false') {
							this.ignoreCamera(false);
						} else {
							this.ignoreCamera(true);
						}
					} else {
						// Getter
						return String(this._ignoreCamera);
					}
					break;
				
				default:
					IgeEntity.prototype.streamSectionData.call(this, sectionId, data);
					break;
			}
		},
		
		/**
		 * Gets / sets the auto-size property. If set to true, the scene will
		 * automatically resize to the engine's canvas geometry.
		 * @param {Boolean=} val If true, will autosize the scene to match the
		 * main canvas geometry. This is enabled by default and is unlikely to
		 * help you if you switch it off.
		 * @return {*}
		 */
		autoSize: function (val) {
			if (typeof(val) !== 'undefined') {
				this._autoSize = val;
				return this;
			}
			
			return this._autoSize;
		},
		
		/**
		 * Gets / sets the _shouldRender property. If set to true, the scene's child
		 * object's tick methods will be called.
		 * @param {Boolean} val If set to false, no child entities will be rendered.
		 * @return {Boolean}
		 */
		shouldRender: function (val) {
			if (val !== undefined) {
				this._shouldRender = val;
				return this;
			}
			
			return this._shouldRender;
		},
		
		/**
		 * Gets / sets the flag that determines if the scene will ignore camera
		 * transform values allowing the scene to remain static on screen
		 * regardless of the camera transform.
		 * @param {Boolean=} val True to ignore, false to not ignore.
		 * @return {*}
		 */
		ignoreCamera: function (val) {
			if (val !== undefined) {
				this._ignoreCamera = val;
				return this;
			}
			
			return this._ignoreCamera;
		},
		
		update: function (ctx, tickDelta) {
			if (this._ignoreCamera) {
				// Translate the scene so it is always center of the camera
				var cam = $ige._currentCamera;
				this.translateTo(cam._translate.x, cam._translate.y, cam._translate.z);
				this.scaleTo(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);
				this.rotateTo(-cam._rotate.x, -cam._rotate.y, -cam._rotate.z);
				//this._localMatrix.multiply($ige._currentCamera._worldMatrix.getInverse());
			}
			
			IgeEntity.prototype.update.call(this, ctx, tickDelta);
		},
		
		/**
		 * Processes the actions required each render frame.
		 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
		 */
		tick: function (ctx) {
			if (this._shouldRender) {
				IgeEntity.prototype.tick.call(this, ctx);
			}
		},
		
		/**
		 * Handles screen resize events.
		 * @param event
		 * @private
		 */
		_resizeEvent: function (event) {
			// Set width / height of scene to match main ige (SCENES ARE ALWAYS THE FULL IGE SIZE!!)
			if (this._autoSize) {
				this._bounds2d = $ige.engine._bounds2d.clone();
			}
			
			// Resize any children
			var arr = this._children,
				arrCount = arr.length;
			
			while (arrCount--) {
				arr[arrCount]._resizeEvent(event);
			}
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object's properties via
		 * chained commands. This method will only check for
		 * properties that are directly related to this class.
		 * Other properties are handled by their own class method.
		 * @return {String}
		 */
		_stringify: function () {
			// Get the properties for all the super-classes
			var str = IgeEntity.prototype._stringify.call(this), i;
			
			// Loop properties and add property assignment code to string
			for (i in this) {
				if (this.hasOwnProperty(i) && this[i] !== undefined) {
					switch (i) {
						case '_shouldRender':
							str += ".shouldRender(" + this.shouldRender() + ")";
							break;
						case '_autoSize':
							str += ".autoSize(" + this.autoSize() + ")";
							break;
					}
				}
			}
			
			return str;
		}
	});
	
	return IgeScene2d;
});
},{"irrelon-appcore":125}],80:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeSceneGraph', function (IgeClass) {
	var IgeSceneGraph = IgeClass.extend({
		classId: 'IgeSceneGraph',
		interfaceImplements: [
			'addGraph',
			'removeGraph'
		],
		
		/**
		 * Called when loading the graph data via $ige.engine.addGraph().
		 * @param {Object=} options The options that were passed with the call
		 * to $ige.engine.addGraph().
		 */
		addGraph: function (options) {
			
		},
		
		/**
		 * The method called when the graph items are to be removed from the
		 * active graph.
		 */
		removeGraph: function () {
			
		}
	});
	
	return IgeSceneGraph;
});
},{"irrelon-appcore":125}],81:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeSpriteSheet', function (IgeTexture) {
	/**
	 * Creates a new sprite sheet that cuts an image up into
	 * arbitrary sections.
	 */
	var IgeSpriteSheet = IgeTexture.extend({
		classId: 'IgeSpriteSheet',
		IgeSpriteSheet: true,
		
		init: function (url, cells) {
			this._spriteCells = cells;
			
			IgeTexture.prototype.init.call(this, url);
		},
		
		_textureLoaded: function () {
			if (this.image) {
				// Store the cell sheet image
				this._sheetImage = this.image;
				var i, cells = this._spriteCells;
				
				if (!cells) {
					// Try to automatically determine cells
					this.log('No cell data provided for sprite sheet, attempting to automatically detect sprite bounds...');
					cells = this.detectCells(this._sheetImage);
				}
				
				// Cells in the sheets always start at index
				// 1 so move all the cells one forward
				for (i = 0; i < cells.length; i++) {
					this._cells[i + 1] = cells[i];
					
					if (this._checkModulus) {
						// Check cell for division by 2 modulus warnings
						if (cells[i][2] % 2) {
							this.log('This texture\'s cell definition defines a cell width is not divisible by 2 which can cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning', cells[i]);
						}
						
						if (cells[i][3] % 2) {
							this.log('This texture\'s cell definition defines a cell height is not divisible by 2 which can cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning', cells[i]);
						}
					}
				}
			} else {
				// Unable to create cells from non-image texture
				// TODO: Low-priority - Support cell sheets from smart-textures
				this.log('Cannot create cell-sheet because texture has not loaded an image!', 'error');
			}
			
			IgeTexture.prototype._textureLoaded.call(this);
		},
		
		/**
		 * Uses the sprite sheet image pixel data to detect distinct sprite
		 * bounds.
		 * @param img
		 * @return {Array} An array of cell bounds.
		 */
		detectCells: function (img) {
			// Create a temp canvas
			var canvas = document.createElement('canvas'),
				ctx = canvas.getContext('2d'),
				pixels,
				x, y,
				newRect,
				spriteRects = [];
			
			canvas.width = img.width;
			canvas.height = img.height;
			
			// Draw the sheet to the canvas
			ctx.drawImage(img, 0, 0);
			
			// Read the pixel data
			pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
			
			// Loop the pixels and find non-transparent one
			for (y = 0; y < canvas.height; y++) {
				for (x = 0; x < canvas.width; x++) {
					// Check if the pixel is not transparent
					if (!pixels.isTransparent(x, y)) {
						// We found a non-transparent pixel so
						// is it in a rect we have already defined?
						if (!this._pixelInRects(spriteRects, x, y)) {
							// The pixel is not already in a rect,
							// so determine the bounding rect for
							// the new sprite whose pixel we've found
							newRect = this._determineRect(pixels, x, y);
							
							if (newRect) {
								spriteRects.push(newRect);
							} else {
								this.log('Cannot automatically determine sprite bounds!', 'warning');
								return [];
							}
						}
					}
				}
			}
			
			return spriteRects;
		},
		
		_pixelInRects: function (rects, x, y) {
			var rectIndex,
				rectCount = rects.length,
				rect;
			
			for (rectIndex = 0; rectIndex < rectCount; rectIndex++) {
				rect = rects[rectIndex];
				
				// Check if the x, y is inside this rect
				if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
					// The x, y is inside this rect
					return true;
				}
			}
			
			return false;
		},
		
		_determineRect: function (pixels, x, y) {
			var pixArr = [{x: x, y: y}],
				rect = {x: x, y: y, width: 1, height: 1},
				currentPixel;
			
			while (pixArr.length) {
				// De-queue front item
				currentPixel = pixArr.shift();
				
				// Expand rect to include pixel position
				if (currentPixel.x > rect.x + rect.width) {
					rect.width = currentPixel.x - rect.x + 1;
				}
				
				if (currentPixel.y > rect.y + rect.height) {
					rect.height = currentPixel.y - rect.y + 1;
				}
				
				if (currentPixel.x < rect.x) {
					rect.width += rect.x - currentPixel.x;
					rect.x = currentPixel.x;
				}
				
				if (currentPixel.y < rect.y) {
					rect.height += rect.y - currentPixel.y;
					rect.y = currentPixel.y;
				}
				
				// Check surrounding pixels
				if (!pixels.isTransparent(currentPixel.x - 1, currentPixel.y - 1)) {
					// Mark pixel so we dont use it again
					pixels.makeTransparent(currentPixel.x - 1, currentPixel.y - 1);
					
					// Add pixel position to queue
					pixArr.push({x: currentPixel.x - 1, y: currentPixel.y - 1});
				}
				
				if (!pixels.isTransparent(currentPixel.x, currentPixel.y - 1)) {
					// Mark pixel so we dont use it again
					pixels.makeTransparent(currentPixel.x, currentPixel.y - 1);
					
					// Add pixel position to queue
					pixArr.push({x: currentPixel.x, y: currentPixel.y - 1});
				}
				
				if (!pixels.isTransparent(currentPixel.x + 1, currentPixel.y - 1)) {
					// Mark pixel so we dont use it again
					pixels.makeTransparent(currentPixel.x + 1, currentPixel.y - 1);
					
					// Add pixel position to queue
					pixArr.push({x: currentPixel.x + 1, y: currentPixel.y - 1});
				}
				
				if (!pixels.isTransparent(currentPixel.x - 1, currentPixel.y)) {
					// Mark pixel so we dont use it again
					pixels.makeTransparent(currentPixel.x - 1, currentPixel.y);
					
					// Add pixel position to queue
					pixArr.push({x: currentPixel.x - 1, y: currentPixel.y});
				}
				
				if (!pixels.isTransparent(currentPixel.x + 1, currentPixel.y)) {
					// Mark pixel so we dont use it again
					pixels.makeTransparent(currentPixel.x + 1, currentPixel.y);
					
					// Add pixel position to queue
					pixArr.push({x: currentPixel.x + 1, y: currentPixel.y});
				}
				
				if (!pixels.isTransparent(currentPixel.x - 1, currentPixel.y + 1)) {
					// Mark pixel so we dont use it again
					pixels.makeTransparent(currentPixel.x - 1, currentPixel.y + 1);
					
					// Add pixel position to queue
					pixArr.push({x: currentPixel.x - 1, y: currentPixel.y + 1});
				}
				
				if (!pixels.isTransparent(currentPixel.x, currentPixel.y + 1)) {
					// Mark pixel so we dont use it again
					pixels.makeTransparent(currentPixel.x, currentPixel.y + 1);
					
					// Add pixel position to queue
					pixArr.push({x: currentPixel.x, y: currentPixel.y + 1});
				}
				
				if (!pixels.isTransparent(currentPixel.x + 1, currentPixel.y + 1)) {
					// Mark pixel so we dont use it again
					pixels.makeTransparent(currentPixel.x + 1, currentPixel.y + 1);
					
					// Add pixel position to queue
					pixArr.push({x: currentPixel.x + 1, y: currentPixel.y + 1});
				}
			}
			
			return [rect.x, rect.y, rect.width, rect.height];
		},
		
		/**
		 * Returns the total number of cells in the cell sheet.
		 * @return {Number}
		 */
		cellCount: function () {
			return this._cells.length;
		},
		
		/**
		 * Returns the cell index that the passed cell id corresponds
		 * to.
		 * @param {String} id
		 * @return {Number} The cell index that the cell id corresponds
		 * to or -1 if a corresponding index could not be found.
		 */
		cellIdToIndex: function (id) {
			var cells = this._cells,
				i;
			for (i = 1; i < cells.length; i++) {
				if (cells[i][4] === id) {
					// Found the cell id so return the index
					return i;
				}
			}
			
			return -1;
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object.
		 * @return {String}
		 */
		stringify: function () {
			var str = "new " + this.classId() + "('" + this.url() + "', " + this._cells.toString() + ")";
			
			// Every object has an ID, assign that first
			// IDs are automatically generated from texture urls
			//str += ".id('" + this.id() + "');";
			
			return str;
		}
	});
	
	return IgeSpriteSheet;
});
},{"irrelon-appcore":125}],82:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('igeState', function (Emitter) {
	var IgeState = function () {
		this._state = 0;
	};
	
	IgeState.prototype.start = function () {
		
	};
	
	IgeState.prototype.stop = function () {
		
	};
});
},{"irrelon-appcore":125}],83:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTexture', function ($ige, $textures, $time, IgeEventingClass) {
	/**
	 * Creates a new texture.
	 */
	var IgeTexture = IgeEventingClass.extend({
		classId: 'IgeTexture',
		IgeTexture: true,
	
		/**
		 * Constructor for a new IgeTexture.
		 * @param {String, Object} urlOrObject Either a string URL that
		 * points to the path of the image or script you wish to use as
		 * the texture image, or an object containing a smart texture.
		 * @return {*}
		 */
		init: function (urlOrObject) {
			this._loaded = false;
			
			/* CEXCLUDE */
			// If on a server, error
			if ($ige.isServer) {
				this.log('Cannot create a texture on the server. Textures are only client-side objects. Please alter your code so that you don\'t try to load a texture on the server-side using something like an if statement around your texture laoding such as "if ($ige.isClient) {}".', 'error');
				return this;
			}
			/* CEXCLUDE */
	
			// Create an array that is used to store cell dimensions
			this._cells = [];
			this._smoothing = $textures._globalSmoothing;
			
			// Instantiate filter lists for filter combinations
			this._applyFilters = [];
			this._applyFiltersData = [];
			this._preFilters = [];
			this._preFiltersData = [];
	
			var type = typeof(urlOrObject);
	
			if (type === 'string') {
				// Load the texture URL
				if (urlOrObject) {
					this.url(urlOrObject);
				}
			}
	
			if (type === 'object') {
				// Assign the texture script object
				this.assignSmartTextureImage(urlOrObject);
			}
		},
	
		/**
		 * Gets / sets the current object id. If no id is currently assigned and no
		 * id is passed to the method, it will automatically generate and assign a
		 * new id as a 16 character hexadecimal value typed as a string.
		 * @param {String=} id
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		id: function (id) {
			if (id !== undefined) {
				// Check if this ID already exists in the object register
				if ($ige.engine._register[id]) {
					if ($ige.engine._register[id] === this) {
						// We are already registered as this id
						return this;
					}
					
					// Already an object with this ID!
					this.log('Cannot set ID of object to "' + id + '" because that ID is already in use by another object!', 'error');
				} else {
					// Check if we already have an id assigned
					if (this._id && $ige.engine._register[this._id]) {
						// Unregister the old ID before setting this new one
						$ige.engine.unRegister(this);
					}
	
					this._id = id;
	
					// Now register this object with the object register
					$ige.engine.register(this);
	
					return this;
				}
			}
	
			if (!this._id) {
				// The item has no id so generate one automatically
				if (this._url) {
					// Generate an ID from the URL string of the image
					// this texture is using. Useful for always reproducing
					// the same ID for the same texture :)
					this._id = $ige.engine.newIdFromString(this._url);
				} else {
					// We don't have a URL so generate a random ID
					this._id = $ige.engine.newIdHex();
				}
				$ige.engine.register(this);
			}
	
			return this._id;
		},
	
		/**
		 * Gets / sets the source file for this texture.
		 * @param {String=} url "The url used to load the file for this texture.
		 * @return {*}
		 */
		url: function (url) {
			if (url !== undefined) {
				this._url = url;
	
				if (url.substr(url.length - 2, 2) === 'js') {
					// This is a script-based texture, load the script
					this._loadScript(url);
				} else {
					// This is an image-based texture, load the image
					this._loadImage(url);
				}
	
				return this;
			}
	
			return this._url;
		},
	
		/**
		 * Loads an image into an img tag and sets an onload event
		 * to capture when the image has finished loading.
		 * @param {String} imageUrl The image url used to load the
		 * image data.
		 * @private
		 */
		_loadImage: function (imageUrl) {
			var image,
				self = this;
	
			if ($ige.isClient) {
				// Increment the texture load count
				$textures.textureLoadStart(imageUrl, this);
	
				// Check if the image url already exists in the image cache
				if (!$textures._textureImageStore[imageUrl]) {
					// Image not in cache, create the image object
					image = $textures._textureImageStore[imageUrl] = this.image = this._originalImage = new Image();
					image._igeTextures = image._igeTextures || [];
	
					// Add this texture to the textures that are using this image
					image._igeTextures.push(this);
	
					image.onload = function () {
						// Mark the image as loaded
						image._loaded = true;
	
						// Log success
						$ige.engine.log('Texture image (' + imageUrl + ') loaded successfully');
	
						/*if (image.width % 2) {
							self.log('The texture ' + imageUrl + ' width (' + image.width + ') is not divisible by 2 to a whole number! This can cause rendering artifacts. It can also cause performance issues on some GPUs. Please make sure your texture width is divisible by 2!', 'warning');
						}
	
						if (image.height % 2) {
							self.log('The texture ' + imageUrl + ' height (' + image.height + ') is not divisible by 2 to a whole number! This can cause rendering artifacts. It can also cause performance issues on some GPUs. Please make sure your texture height is divisible by 2!', 'warning');
						}*/
	
						// Loop textures that are using this image
						var arr = image._igeTextures,
							arrCount = arr.length, i,
							item;
	
						for (i = 0; i < arrCount; i++) {
							item = arr[i];
	
							item._mode = 0;
	
							item.sizeX(image.width);
							item.sizeY(image.height);
	
							item._cells[1] = [0, 0, item._sizeX, item._sizeY];
							
							// Mark texture as loaded
							item._textureLoaded();
						}
					};
	
					// Start the image loading by setting the source url
					image.src = imageUrl;
				} else {
					// Grab the cached image object
					image = this.image = this._originalImage = $textures._textureImageStore[imageUrl];
	
					// Add this texture to the textures that are using this image
					image._igeTextures.push(this);
	
					if (image._loaded) {
						// The cached image object is already loaded so
						// fire off the relevant events
						self._mode = 0;
	
						self.sizeX(image.width);
						self.sizeY(image.height);
	
						if (image.width % 2) {
							this.log('This texture\'s width is not divisible by 2 which will cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning');
						}
	
						if (image.height % 2) {
							this.log('This texture\'s height is not divisible by 2 which will cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning');
						}
	
						self._cells[1] = [0, 0, self._sizeX, self._sizeY];
						
						// Mark texture as loaded
						self._textureLoaded();
					}
				}
			}
		},
		
		_textureLoaded: function () {
			var self = this;
			
			// Set a timeout here so that when this event is emitted,
			// the code creating the texture is given a chance to
			// set a listener first, otherwise this will be emitted
			// but nothing will have time to register a listener!
			setTimeout(function () {
				self._loaded = true;
				self.emit('loaded');
	
				// Inform the engine that this image has loaded
				$textures.textureLoadEnd(self.image.src, self);
			}, 5);
		},
	
		/**
		 * Loads a render script into a script tag and sets an onload
		 * event to capture when the script has finished loading.
		 * @param {String} scriptUrl The script url used to load the
		 * script data.
		 * @private
		 */
		_loadScript: function (scriptUrl) {
			var self = this,
				scriptElem;
	
			$textures.textureLoadStart(scriptUrl, this);
	
			if ($ige.isClient) {
				scriptElem = document.createElement('script');
				scriptElem.onload = function(data) {
					self.log('Texture script "' + scriptUrl + '" loaded successfully');
					// Parse the JS with evil eval and store the result in the asset
					eval(data); // jshint ignore:line
	
					// Store the eval data (the "image" variable is declared
					// by the texture script and becomes available in this scope
					// because we evaluated it above)
					self._mode = 1;
					self.script = image;
	
					// Run the asset script init method
					if (typeof(image.init) === 'function') {
						image.init.apply(image, [self]);
					}
	
					//self.sizeX(image.width);
					//self.sizeY(image.height);
	
					self._loaded = true;
					self.emit('loaded');
					$textures.textureLoadEnd(scriptUrl, self);
				};
	
				scriptElem.addEventListener('error', function () {
					self.log('Error loading smart texture script file: ' + scriptUrl, 'error');
				}, true);
	
				scriptElem.src = scriptUrl;
				document.getElementsByTagName('head')[0].appendChild(scriptElem);
			}
		},
	
		/**
		 * Assigns a render script to the smart texture.
		 * @param {String} scriptObj The script object.
		 * @private
		 */
		assignSmartTextureImage: function (scriptObj) {
			var self = this;
			
			// Check the object has a render method
			if (typeof(scriptObj.render) === 'function') {
				//$texutes.textureLoadStart(scriptUrl, this);
		
				// Store the script data
				self._mode = 1;
				self.script = scriptObj;
		
				// Run the asset script init method
				if (typeof(scriptObj.init) === 'function') {
					scriptObj.init.apply(scriptObj, [self]);
				}
		
				//self.sizeX(image.width);
				//self.sizeY(image.height);
		
				self._loaded = true;
				self.emit('loaded');
				//$textures.textureLoadEnd(scriptUrl, self);
			} else {
				this.log('Cannot assign smart texture because it doesn\'t have a render() method!', 'error');
			}
		},
	
		/**
		 * Sets the image element that the IgeTexture will use when
		 * rendering. This is a special method not designed to be called
		 * directly by any game code and is used specifically when
		 * assigning an existing canvas element to an IgeTexture.
		 * @param {Image} imageElement The canvas / image to use as
		 * the image data for the IgeTexture.
		 * @private
		 */
		_setImage: function (imageElement) {
			var image;
	
			if ($ige.isClient) {
				// Create the image object
				image = this.image = this._originalImage = imageElement;
				image._igeTextures = image._igeTextures || [];
	
				// Mark the image as loaded
				image._loaded = true;
	
				this._mode = 0;
	
				this.sizeX(image.width);
				this.sizeY(image.height);
	
				this._cells[1] = [0, 0, this._sizeX, this._sizeY];
			}
		},
	
		/**
		 * Creates a new texture from a cell in the existing texture
		 * and returns the new texture.
		 * @param {Number, String} indexOrId The cell index or id to use.
		 * @return {*}
		 */
		textureFromCell: function (indexOrId) {
			var tex = new IgeTexture(),
				self = this;
	
			if (this._loaded) {
				this._textureFromCell(tex, indexOrId);
			} else {
				// The texture has not yet loaded, return the new texture and set a listener to handle
				// when this texture has loaded so we can assign the texture's image properly
				this.on('loaded', function () {
					self._textureFromCell(tex, indexOrId);
				});
			}
	
			return tex;
		},
	
		/**
		 * Called by textureFromCell() when the texture is ready
		 * to be processed. See textureFromCell() for description.
		 * @param {IgeTexture} tex The new texture to paint to.
		 * @param {Number, String} indexOrId The cell index or id
		 * to use.
		 * @private
		 */
		_textureFromCell: function (tex, indexOrId) {
			var index,
				cell,
				canvas,
				ctx;
	
			if (typeof(indexOrId) === 'string') {
				index = this.cellIdToIndex(indexOrId);
			} else {
				index = indexOrId;
			}
	
			if (this._cells[index]) {
				// Create a new IgeTexture, then draw the existing cell
				// to it's internal canvas
				cell = this._cells[index];
				canvas = document.createElement('canvas');
				ctx = canvas.getContext('2d');
	
				// Set smoothing mode
				// TODO: Does this cause a costly context change? If so maybe we set a global value to keep
				// TODO: track of the value and evaluate first before changing?
				if (!this._smoothing) {
					ctx.imageSmoothingEnabled = false;
					ctx.mozImageSmoothingEnabled = false;
				} else {
					ctx.imageSmoothingEnabled = true;
					ctx.mozImageSmoothingEnabled = true;
				}
	
				canvas.width = cell[2];
				canvas.height = cell[3];
	
				// Draw the cell to the canvas
				ctx.drawImage(
					this._originalImage,
					cell[0],
					cell[1],
					cell[2],
					cell[3],
					0,
					0,
					cell[2],
					cell[3]
				);
	
				// Set the new texture's image to the canvas
				tex._setImage(canvas);
				tex._loaded = true;
	
				// Fire the loaded event
				setTimeout(function () {
					tex.emit('loaded');
				}, 1);
			} else {
				this.log('Unable to create new texture from passed cell index (' + indexOrId + ') because the cell does not exist!', 'warning');
			}
		},
	
		/**
		 * Sets the _sizeX property.
		 * @param {Number} val
		 */
		sizeX: function (val) {
			this._sizeX = val;
		},
	
		/**
		 * Sets the _sizeY property.
		 * @param {Number} val
		 */
		sizeY: function (val) {
			this._sizeY = val;
		},
	
		/**
		 * Resizes the original texture image to a new size. This alters
		 * the image that the texture renders so all entities that use
		 * this texture will output the newly resized version of the image.
		 * @param {Number} x The new width.
		 * @param {Number} y The new height.
		 * @param {Boolean=} dontDraw If true the resized image will not be
		 * drawn to the texture canvas. Useful for just resizing the texture
		 * canvas and not the output image. Use in conjunction with the
		 * applyFilter() and preFilter() methods.
		 */
		resize: function (x, y, dontDraw) {
			if (this._originalImage) {
				if (this._loaded) {
					if (!this._textureCtx) {
						// Create a new canvas
						this._textureCanvas = document.createElement('canvas');
					}
	
					this._textureCanvas.width = x;
					this._textureCanvas.height = y;
					this._textureCtx = this._textureCanvas.getContext('2d');
	
					// Set smoothing mode
					if (!this._smoothing) {
						this._textureCtx.imageSmoothingEnabled = false;
						this._textureCtx.mozImageSmoothingEnabled = false;
					} else {
						this._textureCtx.imageSmoothingEnabled = true;
						this._textureCtx.mozImageSmoothingEnabled = true;
					}
	
					if (!dontDraw) {
						// Draw the original image to the new canvas
						// scaled as required
						this._textureCtx.drawImage(
							this._originalImage,
							0,
							0,
							this._originalImage.width,
							this._originalImage.height,
							0,
							0,
							x,
							y
						);
					}
	
					// Swap the current image for this new canvas
					this.image = this._textureCanvas;
				} else {
					this.log('Cannot resize texture because the texture image (' + this._url + ') has not loaded into memory yet!', 'error');
				}
			}
		},
	
		/**
		 * Resizes the original texture image to a new size based on percentage.
		 * This alters the image that the texture renders so all entities that use
		 * this texture will output the newly resized version of the image.
		 * @param {Number} x The new width.
		 * @param {Number} y The new height.
		 * @param {Boolean=} dontDraw If true the resized image will not be
		 * drawn to the texture canvas. Useful for just resizing the texture
		 * canvas and not the output image. Use in conjunction with the
		 * applyFilter() and preFilter() methods.
		 */
		resizeByPercent: function (x, y, dontDraw) {
			if (this._originalImage) {
				if (this._loaded) {
					// Calc final x/y values
					x = Math.floor((this.image.width / 100) * x);
					y = Math.floor((this.image.height / 100) * y);
	
					if (!this._textureCtx) {
						// Create a new canvas
						this._textureCanvas = document.createElement('canvas');
					}
	
					this._textureCanvas.width = x;
					this._textureCanvas.height = y;
					this._textureCtx = this._textureCanvas.getContext('2d');
	
					// Set smoothing mode
					if (!this._smoothing) {
						this._textureCtx.imageSmoothingEnabled = false;
						this._textureCtx.mozImageSmoothingEnabled = false;
					} else {
						this._textureCtx.imageSmoothingEnabled = true;
						this._textureCtx.mozImageSmoothingEnabled = true;
					}
	
					if (!dontDraw) {
						// Draw the original image to the new canvas
						// scaled as required
						this._textureCtx.drawImage(
							this._originalImage,
							0,
							0,
							this._originalImage.width,
							this._originalImage.height,
							0,
							0,
							x,
							y
						);
					}
	
					// Swap the current image for this new canvas
					this.image = this._textureCanvas;
				} else {
					this.log('Cannot resize texture because the texture image (' + this._url + ') has not loaded into memory yet!', 'error');
				}
			}
		},
	
		/**
		 * Sets the texture image back to the original image that the
		 * texture first loaded. Useful if you have applied filters
		 * or resized the image and now want to revert back to the
		 * original.
		 */
		restoreOriginal: function () {
			this.image = this._originalImage;
			delete this._textureCtx;
			delete this._textureCanvas;
			
			this.removeFilters();
		},
	
		smoothing: function (val) {
			if (val !== undefined) {
				this._smoothing = val;
				return this;
			}
	
			return this._smoothing;
		},
	
		/**
		 * Renders the texture image to the passed canvas context.
		 * @param {CanvasRenderingContext2d} ctx The canvas context to draw to.
		 * @param {IgeEntity} entity The entity that this texture is
		 * being drawn for.
		 */
		render: function (ctx, entity) {
			// Check that the cell is not set to null. If it is then
			// we don't render anything which effectively makes the
			// entity "blank"
			if (entity._cell !== null) {
				// TODO: Does this cause a costly context change? If so maybe we set a global value to keep
				// TODO: track of the value and evaluate first before changing?
				if (!this._smoothing) {
					// Added if here to try to mitigate above TODO
					if ($ige.engine._ctx.imageSmoothingEnabled) {
						$ige.engine._ctx.imageSmoothingEnabled = false;
						$ige.engine._ctx.mozImageSmoothingEnabled = false;
					}
				} else {
					if (!$ige.engine._ctx.imageSmoothingEnabled) {
						$ige.engine._ctx.imageSmoothingEnabled = true;
						$ige.engine._ctx.mozImageSmoothingEnabled = true;
					}
				}
	
				if (this._mode === 0) {
					// This texture is image-based
					var cell = this._cells[entity._cell],
						geom = entity._bounds2d,
						poly = entity._renderPos; // Render pos is calculated in the IgeEntity.aabb() method
	
					if (cell) {
						if (this._preFilters.length > 0 && this._textureCtx) {
							// Call the drawing of the original image
							this._textureCtx.clearRect(0, 0, this._textureCanvas.width, this._textureCanvas.height);
							this._textureCtx.drawImage(this._originalImage, 0, 0);
							
							var self = this;
							// Call the applyFilter and preFilter methods one by one
							this._applyFilters.forEach(function(method, index) {
								self._textureCtx.save();
								method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._applyFiltersData[index]);
								self._textureCtx.restore();
							});
							this._preFilters.forEach(function(method, index) {
								self._textureCtx.save();
								method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._preFiltersData[index]);
								self._textureCtx.restore();
							});
						}
	
						ctx.drawImage(
							this.image,
							cell[0], // texture x
							cell[1], // texture y
							cell[2], // texture width
							cell[3], // texture height
							poly.x, // render x
							poly.y, // render y
							geom.x, // render width
							geom.y // render height
						);
						
						$time._drawCount++;
					} else {
						this.log('Cannot render texture using cell ' + entity._cell + ' because the cell does not exist in the assigned texture!', 'error');
					}
				}
	
				if (this._mode === 1) {
					// This texture is script-based (a "smart texture")
					ctx.save();
						this.script.render(ctx, entity, this);
					ctx.restore();
					
					$time._drawCount++;
				}
			}
		},
		
		/**
		 * Removes a certain filter from the texture
		 * Useful if you want to keep resizings, etc.
		 */
		removeFilter: function(method) {
			var i;
			while ((i = this._preFilters.indexOf(method)) > -1) {
				this._preFilters[i] = undefined;
				this._preFiltersData[i] = undefined;
			}
			while ((i = this._applyFilters.indexOf(method)) > -1) {
				this._applyFilters[i] = undefined;
				this._applyFiltersData[i] = undefined;
			}
			this._preFilters = this._preFilters.clean();
			this._preFiltersData = this._preFiltersData.clean();
			this._applyFilters = this._applyFilters.clean();
			this._applyFiltersData = this._applyFiltersData.clean();
			
			this._rerenderFilters();
		},
		
		/**
		 * Removes all filters on the texture
		 * Useful if you want to keep resizings, etc.
		 */
		removeFilters: function() {
			this._applyFilters = [];
			this._applyFiltersData = [];
			this._preFilters = [];
			this._preFiltersData = [];
			
			this._rerenderFilters();
		},
		
		/**
		 * Rerenders image with filter list. Keeps sizings.
		 * Useful if you have no preFilters
		 */
		_rerenderFilters: function() {
			var self = this;
			
			if (!this._textureCanvas) { return; }
			
			// Rerender applyFilters from scratch:
			// Draw the basic image
			// resize it to the old boundaries
			this.resize(this._textureCanvas.width, this._textureCanvas.height, false);
			
			// Draw applyFilter layers upon it
			this._applyFilters.forEach(function(method, index) {
				self._textureCtx.save();
				method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._applyFiltersData[index]);
				self._textureCtx.restore();
			});
		},
	
		/**
		 * Gets / sets the pre-filter method that will be called before
		 * the texture is rendered and will allow you to modify the texture
		 * image before rendering each tick.
		 * @param method
		 * @return {*}
		 */
		preFilter: function (method, data) {
			if (method !== undefined) {
				if (this._originalImage) {
					if (!this._textureCtx) {
						// Create a new canvas
						this._textureCanvas = document.createElement('canvas');
	
						this._textureCanvas.width = this._originalImage.width;
						this._textureCanvas.height = this._originalImage.height;
						this._textureCtx = this._textureCanvas.getContext('2d');
	
						// Set smoothing mode
						if (!this._smoothing) {
							this._textureCtx.imageSmoothingEnabled = false;
							this._textureCtx.webkitImageSmoothingEnabled = false;
							this._textureCtx.mozImageSmoothingEnabled = false;
						} else {
							this._textureCtx.imageSmoothingEnabled = true;
							this._textureCtx.webkitImageSmoothingEnabled = true;
							this._textureCtx.mozImageSmoothingEnabled = true;
						}
					}
	
					// Swap the current image for this new canvas
					this.image = this._textureCanvas;
	
					// Save filter in active preFilter list
					this._preFilters[this._preFilters.length] = method;
					this._preFiltersData[this._preFiltersData.length] = !data ? {} : data;
				}
				return this;
			} else {
				this.log('Cannot use pre-filter, no filter method was passed!', 'warning');
			}
	
			return this._preFilters[this._preFilters.length - 1];
		},
	
		/**
		 * Applies a filter to the texture. The filter is a method that will
		 * take the canvas, context and originalImage parameters and then
		 * use context calls to alter / paint the context with the texture
		 * and any filter / adjustments that you want to apply.
		 * @param {Function} method
		 * @param {Object=} data
		 * @return {*}
		 */
		applyFilter: function (method, data) {
			if (this._loaded) {
				if (method !== undefined) {
					if (this._originalImage) {
						if (!this._textureCtx) {
							// Create a new canvas
							this._textureCanvas = document.createElement('canvas');
		
							this._textureCanvas.width = this._originalImage.width;
							this._textureCanvas.height = this._originalImage.height;
							this._textureCtx = this._textureCanvas.getContext('2d');
							
							// Draw the basic image
							this._textureCtx.clearRect(0, 0, this._textureCanvas.width, this._textureCanvas.height);
							this._textureCtx.drawImage(this._originalImage, 0, 0);
		
							// Set smoothing mode
							if (!this._smoothing) {
								this._textureCtx.imageSmoothingEnabled = false;
								this._textureCtx.webkitImageSmoothingEnabled = false;
								this._textureCtx.mozImageSmoothingEnabled = false;
							} else {
								this._textureCtx.imageSmoothingEnabled = true;
								this._textureCtx.webkitImageSmoothingEnabled = true;
								this._textureCtx.mozImageSmoothingEnabled = true;
							}
						}
		
						// Swap the current image for this new canvas
						this.image = this._textureCanvas;
		
						// Call the passed method
						if (this._preFilters.length <= 0) {
							this._textureCtx.save();
							method(this._textureCanvas, this._textureCtx, this._originalImage, this, data);
							this._textureCtx.restore();
						}
						
						// Save filter in active applyFiler list
						this._applyFilters[this._applyFilters.length] = method;
						this._applyFiltersData[this._applyFiltersData.length] = !data ? {} : data;
					}
				} else {
					this.log('Cannot apply filter, no filter method was passed!', 'warning');
				}
			} else {
				this.log('Cannot apply filter, the texture you are trying to apply the filter to has not yet loaded!', 'error');
			}
	
			return this;
		},
		
		/**
		 * Retrieves pixel data from x,y texture coordinate (starts from top-left).
		 * Important: If the texture has a cross-domain url, the image host must allow
		 * cross-origin resource sharing or a security error will be thrown.
		 * Reference: http://blog.chromium.org/2011/07/using-cross-domain-images-in-webgl-and.html
		 * @param  {Number} x
		 * @param  {Number} y
		 * @return {Array} [r,g,b,a] Pixel data.
		 */
		pixelData: function (x, y) {
			if (this._loaded) {
				if (this.image) {
					// Check if the texture is already using a canvas
					if (!this._textureCtx) {
						// Create a new canvas
						this._textureCanvas = document.createElement('canvas');
	
						this._textureCanvas.width = this.image.width;
						this._textureCanvas.height = this.image.height;
						this._textureCtx = this._textureCanvas.getContext('2d');
	
						// Set smoothing mode
						if (!this._smoothing) {
							this._textureCtx.imageSmoothingEnabled = false;
							this._textureCtx.webkitImageSmoothingEnabled = false;
							this._textureCtx.mozImageSmoothingEnabled = false;
						} else {
							this._textureCtx.imageSmoothingEnabled = true;
							this._textureCtx.webkitImageSmoothingEnabled = true;
							this._textureCtx.mozImageSmoothingEnabled = true;
						}
						
						// Draw the image to the canvas
						this._textureCtx.drawImage(this.image, 0, 0);
					} else {
						this._textureCtx = this._textureCtx;
					}
	
					return this._textureCtx.getImageData(x, y, 1, 1).data;
				}
			} else {
				this.log('Cannot read pixel data, the texture you are trying to read data from has not yet loaded!', 'error');
			}
	
			return this;
		},
	
		/**
		 * Creates a clone of the texture.
		 * @return {IgeTexture} A new, distinct texture with the same attributes
		 * as the one being cloned.
		 */
		clone: function () {
			return this.textureFromCell(1);
		},
	
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object.
		 * @return {String}
		 */
		stringify: function () {
			var str = "new " + this.classId() + "('" + this._url + "')";
	
			// Every object has an ID, assign that first
			// We've commented this because ids for textures are actually generated
			// from their asset so will ALWAYS produce the same ID as long as the asset
			// is the same path.
			//str += ".id('" + this.id() + "')";
	
			// Now get all other properties
			str += this._stringify();
	
			return str;
		},
		
		_stringify: function () {
			return '';
		},
	
		/**
		 * Destroys the item.
		 */
		destroy: function () {
			delete this._eventListeners;
	
			// Remove us from the image store reference array
			if (this.image && this.image._igeTextures) {
				this.image._igeTextures.pull(this);
			}
	
			// Remove the texture from the texture store
			$textures._arr.pull(this);
	
			delete this.image;
			delete this.script;
			delete this._textureCanvas;
			delete this._textureCtx;
	
			this._destroyed = true;
		}
	});
	
	return IgeTexture;
});
},{"irrelon-appcore":125}],84:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTextureAtlas', function ($ige, IgeTextureMap) {
	/**
	 * Texture maps provide a way to display textures across a tile map.
	 */
	var IgeTextureAtlas = IgeTextureMap.extend({
		classId: 'IgeTextureAtlas',
		
		init: function (tileWidth, tileHeight) {
			IgeTextureMap.prototype.init.call(this, tileWidth, tileHeight);
		},
		
		/**
		 * Get / set the data source that the atlas system will use
		 * to retrieve new map data when required.
		 * @param {String, Object} ds The url of the data source API
		 * endpoint or the actual map data object.
		 * @return {*}
		 */
		dataSource: function (ds) {
			if (ds !== undefined) {
				this._dataSource = ds;
				
				// Check the type of data source and set a flag so we don't
				// have to check it every time we read data
				switch (typeof(this._dataSource)) {
					case 'string':
						// The data source is a string so it must be a URL
						this._dataSourceType = 'url';
						break;
					
					case 'object':
						// The data source is an object so it must be map data
						this._dataSourceType = 'data';
						break;
				}
				
				return this;
			}
			
			return this._dataSource;
		},
		
		/**
		 * Gets / sets the extra data to load around the main texture map size to
		 * try to mitigate loading times on new data.
		 * @param {Number} x The number of pixels along the x axis to load.
		 * @param {Number} y The number of pixels along the y axis to load.
		 * @return {*}
		 */
		bufferZone: function (x, y) {
			if (x !== undefined && y !== undefined) {
				this._bufferZone = {x: x, y: y};
				return this;
			}
			
			return {x: this._bufferZone.x, y: this._bufferZone.y};
		}
	});
	
	return IgeTextureAtlas;
});
},{"irrelon-appcore":125}],85:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTextureMap', function ($ige, $time, $textures, IgeTileMap2d, IgeMap2d, IgePoint3d) {
	// TODO: Implement the _stringify() method for this class
	/**
	 * Texture maps provide a way to display textures / cells across a tile map.
	 */
	var IgeTextureMap = IgeTileMap2d.extend({
		classId: 'IgeTextureMap',
	
		init: function (tileWidth, tileHeight) {
			IgeTileMap2d.prototype.init.call(this, tileWidth, tileHeight);
			this.map = new IgeMap2d();
			this._textureList = [];
			this._renderCenter = new IgePoint3d(0, 0, 0);
			this._cacheDirty = true;
		},
	
		/**
		 * Gets / sets the auto sectioning mode. If enabled the texture map
		 * will render to off-screen canvases in sections denoted by the
		 * number passed. For instance if you pass 10, the canvas sections
		 * will be 10x10 tiles in size.
		 * @param {Number=} val The size in tiles of each section.
		 * @return {*}
		 */
		autoSection: function (val) {
			if (val !== undefined) {
				this._autoSection = val;
				return this;
			}
	
			return this._autoSection;
		},
	
		/**
		 * Gets / sets the draw sections flag. If true the texture map will
		 * output debug lines between each section of the map when using the
		 * auto section system.
		 * @param {Number=} val The boolean flag value.
		 * @return {*}
		 */
		drawSectionBounds: function (val) {
			if (val !== undefined) {
				this._drawSectionBounds = val;
				return this;
			}
	
			return this._drawSectionBounds;
		},
	
		/**
		 * Forces a cache redraw on the next tick.
		 */
		cacheForceFrame: function () {
			this._cacheDirty = true;
		},
	
		/**
		 * Takes another map and removes any data from this map where data already
		 * exists in the other.
		 * @param {IgeTileMap2d} entity The other map to read map data from.
		 * @return {*}
		 */
		negate: function (entity) {
			if (entity !== undefined) {
				var x, y,
					entityMapData = entity.map._mapData,
					thisMapData = this.map._mapData;
	
				for (y in entityMapData) {
					if (entityMapData.hasOwnProperty(y)) {
						for (x in entityMapData[y]) {
							if (entityMapData[y].hasOwnProperty(x)) {
								if (thisMapData[y] && thisMapData[y][x]) {
									// This map has data in the same place as the passed
									// entity's map so remove this map's data
									delete thisMapData[y][x];
								}
							}
						}
					}
				}
			}
	
			return this;
		},
	
		/**
		 * Adds a texture to the texture map's internal texture list so
		 * that it can be referenced via an index so that the texture map's
		 * data will be something like [[textureId, textureCell]]
		 * or a real world example: [[0, 1], [1, 1]].
		 * @param {IgeTexture} texture
		 * @return {Integer} The index of the texture you just added.
		 */
		addTexture: function (texture) {
			this._textureList.push(texture);
			if (!texture._loaded) {
				this._allTexturesLoaded = false;
			}
			return this._textureList.length - 1;
		},
	
		/**
		 * Checks the status of all the textures that have been added to
		 * this texture map and returns true if they are all loaded.
		 * @return {Boolean} True if all textures are loaded, false if
		 * not.
		 */
		allTexturesLoaded: function () {
			if (!this._allTexturesLoaded) {
				var arr = this._textureList,
					arrCount = arr.length;
	
				while (arrCount--) {
					if (!arr[arrCount]._loaded) {
						return false;
					}
				}
			}
	
			this._allTexturesLoaded = true;
			return true;
		},
	
		/**
		 * Sets the specified tile's texture index and cell that will be used
		 * when rendering the texture map.
		 * @param {Number} x The tile x co-ordinate.
		 * @param {Number} y The tile y co-ordinate.
		 * @param {Number} textureIndex The texture index.
		 * @param {Number} cell The cell index.
		 */
		paintTile: function (x, y, textureIndex, cell) {
			if (x !== undefined && y !== undefined && textureIndex !== undefined) {
				if (cell === undefined || cell < 1) {
					cell = 1; // Set the cell default to 1
				}
				this.map.tileData(x, y, [textureIndex, cell]);
			}
		},
	
		/**
		 * Clears any previous tile texture and cell data for the specified
		 * tile co-ordinates.
		 * @param {Number} x The tile x co-ordinate.
		 * @param {Number} y The tile y co-ordinate.
		 */
		clearTile: function (x, y) {
			this.map.clearData(x, y);
		},
	
		/**
		 * Reads the map data from a standard map object and fills the map
		 * with the data found.
		 * @param {Object} map The map data object.
		 */
		loadMap: function (map) {
			if (map.textures) {
				// Empty the existing array
				this._textureList = [];
	
				var tex = [], i,
					self = this;
	
				// Loop the texture list and create each texture object
				for (i = 0; i < map.textures.length; i++) {
					// Load each texture
					eval('tex[' + i + '] = ' + map.textures[i]);
					self.addTexture(tex[i]);
				}
	
				// Fill in the map data
				self.map.mapData(map.data);
			} else {
				// Just fill in the map data
				this.map.mapData(map.data);
			}
	
			return this;
		},
	
		/**
		 * Returns a map JSON string that can be saved to a data file and loaded
		 * with the loadMap() method.
		 * @return {Object} The map data object.
		 */
		saveMap: function () {
			// in URL format
			var textures = [], i,
				x, y,
				dataX = 0, dataY = 0,
				mapData = this.map._mapData;
	
			// Grab all the texture definitions
			for (i = 0; i < this._textureList.length; i++) {
				textures.push(this._textureList[i].stringify());
			}
	
			// Get the lowest x, y
			for (y in mapData) {
				if (mapData.hasOwnProperty(y)) {
					for (x in mapData[y]) {
						if (mapData[y].hasOwnProperty(x)) {
							if (x < dataX) {
								dataX = x;
							}
	
							if (y < dataY) {
								dataY = y;
							}
						}
					}
				}
			}
	
			return JSON.stringify({
				textures: textures,
				data: this.map.mapData(),
				dataXY: [dataX, dataY]
			});
		},
	
		/**
		 * Clears the tile data from the map effectively wiping it clean. All
		 * existing map data will be removed. The textures assigned to the texture
		 * map will not be affected.
		 * @returns {*}
		 */
		clearMap: function () {
			this.map.mapData([]);
			return this;
		},
	
		/**
		 * Clears tile data from the map and also removes any textures from the
		 * map that were previously assigned to it. This is useful for reverting
		 * the texture map to it's virgin state as if it had just been created.
		 * @returns {*}
		 */
		reset: function () {
			this.clearMap();
			this._textureList = [];
			
			return this;
		},
	
		/**
		 * Gets / sets the specified tile's texture index.
		 * @param {Number} x The tile x co-ordinate.
		 * @param {Number} y The tile y co-ordinate.
		 * @param {Number=} textureIndex The new texture index.
		 */
		tileTextureIndex: function (x, y, textureIndex) {
			if (x !== undefined && y !== undefined) {
				var obj = this.map.tileData(x, y);
				if (textureIndex !== undefined) {
					// Set the cell
					obj[0] = textureIndex;
				} else {
					return obj[0];
				}
			}
		},
	
		/**
		 * Gets / sets the specified tile's texture cell.
		 * @param {Number} x The tile x co-ordinate.
		 * @param {Number} y The tile y co-ordinate.
		 * @param {Number} cell The new cell index.
		 */
		tileTextureCell: function (x, y, cell) {
			if (x !== undefined && y !== undefined) {
				var obj = this.map.tileData(x, y);
				if (cell !== undefined) {
					// Set the cell
					obj[1] = cell;
				} else {
					return obj[1];
				}
			}
		},
	
		/**
		 * Converts data that is saved in the format [x][y] to the IGE standard
		 * of [y][x] and then returns the data.
		 * @param {Array} mapData The map data array.
		 * @return {Object} The new map data.
		 */
		convertHorizontalData: function (mapData) {
			var newData = [],
				x, y;
	
			for (x in mapData) {
				if (mapData.hasOwnProperty(x)) {
					for (y in mapData[x]) {
						if (mapData[x].hasOwnProperty(y)) {
							// Displace the data from the x axis to the y axis
							newData[y] = newData[y] || [];
							newData[y][x] = mapData[x][y];
						}
					}
				}
			}
	
			return newData;
		},
	
		/**
		 * Handles rendering the texture map during engine tick events.
		 * @param {CanvasRenderingContext2d} ctx
		 */
		tick: function (ctx) {
			// TODO: This is being called at the wrong time, drawing children before this parent! FIX THIS
			// Run the IgeTileMap2d tick method
			IgeTileMap2d.prototype.tick.call(this, ctx);
	
			// Draw each image that has been defined on the map
			var mapData = this.map._mapData,
				x, y,
				tx, ty,
				xInt, yInt,
				finalX, finalY,
				finalPoint,
				tileData, tileEntity = this._newTileEntity(), // TODO: This is wasteful, cache it?
				sectionX, sectionY,
				tempSectionX, tempSectionY,
				_ctx,
				regions, region, i;
	
			if (this._autoSection > 0) {
				if (this._cacheDirty) {
					// Check that all the textures we need to use are loaded
					if (this.allTexturesLoaded()) {
						// We have a dirty cache so render the section cache
						// data first
						// TODO: Shouldn't we be replacing these arrays with new ones to drop the old ones from memory?
						// TODO: Gonna do that now and see what the result is.
						this._sections = []; //this._sections || [];
						this._sectionCtx = []; //this._sectionCtx || [];
						// TODO: This isn't ideal because we are almost certainly dropping sections that are still relevant,
						// TODO: so we should scan and garbage collect I think, instead.
	
						// Loop the map data
						for (y in mapData) {
							if (mapData.hasOwnProperty(y)) {
								for (x in mapData[y]) {
									if (mapData[y].hasOwnProperty(x)) {
										xInt = parseInt(x);
										yInt = parseInt(y);
	
										// Calculate the tile's final resting position in absolute
										// co-ordinates so we can work out which section canvas to
										// paint the tile to
										if (this._mountMode === 0) {
											// We're rendering a 2d map
											finalX = xInt;
											finalY = yInt;
										}
	
										if (this._mountMode === 1) {
											// We're rendering an iso map
											// Convert the tile x, y to isometric
											tx = xInt * this._tileWidth;
											ty = yInt * this._tileHeight;
											finalX = (tx - ty) / this._tileWidth;
											finalY = ((tx + ty) * 0.5) / this._tileHeight;
										}
	
										// Grab the tile data to paint
										tileData = mapData[y][x];
	
										// Work out which section to paint to
										sectionX = Math.floor(finalX / this._autoSection);
										sectionY = Math.floor(finalY / this._autoSection);
										
										// Check if an off-screen canvas already exists for this section
										// and if not, create one
										this._ensureSectionExists(sectionX, sectionY);
										
										// Grab the drawing context for the section
										_ctx = this._sectionCtx[sectionX][sectionY];
	
										if (tileData) {
											regions = this._renderTile(
												_ctx,
												xInt,
												yInt,
												tileData,
												tileEntity,
												null,
												sectionX,
												sectionY
											);
	
											// Check if the tile overlapped another section
											if (regions) {
												// Loop the regions and re-render the tile on the
												// other sections that it overlaps
												for (i = 0; i < regions.length; i++) {
													region = regions[i];
	
													tempSectionX = sectionX;
													tempSectionY = sectionY;
	
													if (region.x) {
														tempSectionX += region.x;
													}
	
													if (region.y) {
														tempSectionY += region.y;
													}
	
													this._ensureSectionExists(tempSectionX, tempSectionY);
													_ctx = this._sectionCtx[tempSectionX][tempSectionY];
	
													this._sectionTileRegion = this._sectionTileRegion || [];
													this._sectionTileRegion[tempSectionX] = this._sectionTileRegion[tempSectionX] || [];
													this._sectionTileRegion[tempSectionX][tempSectionY] = this._sectionTileRegion[tempSectionX][tempSectionY] || [];
													this._sectionTileRegion[tempSectionX][tempSectionY][xInt] = this._sectionTileRegion[tempSectionX][tempSectionY][xInt] || [];
	
													if (!this._sectionTileRegion[tempSectionX][tempSectionY][xInt][yInt]) {
														this._sectionTileRegion[tempSectionX][tempSectionY][xInt][yInt] = true;
	
														this._renderTile(
															_ctx,
															xInt,
															yInt,
															tileData,
															tileEntity,
															null,
															tempSectionX,
															tempSectionY
														);
													}
												}
											}
										}
									}
								}
							}
						}
	
						// Set the cache to clean!
						this._cacheDirty = false;
	
						// Remove the temporary section tile painted data
						delete this._sectionTileRegion;
					}
				}
	
				this._drawSectionsToCtx(ctx);
			} else {
				// Check that all the textures we need to use are loaded
				if (this.allTexturesLoaded()) {
					// Render the whole map
					for (y in mapData) {
						if (mapData.hasOwnProperty(y)) {
							for (x in mapData[y]) {
								if (mapData[y].hasOwnProperty(x)) {
									// Grab the tile data to paint
									tileData = mapData[y][x];
		
									if (tileData) {
										this._renderTile(ctx, x, y, tileData, tileEntity);
									}
								}
							}
						}
					}
				}
			}
		},
	
		/**
		 * Private method, checks if the specified section currently exists in the cache
		 * and if not, creates it.
		 * @param {Number} sectionX The section's x co-ordinate.
		 * @param {Number} sectionY The section's y co-ordinate.
		 * @private
		 */
		_ensureSectionExists: function (sectionX, sectionY) {
			var sectionCtx;
	
			this._sections[sectionX] = this._sections[sectionX] || [];
			this._sectionCtx[sectionX] = this._sectionCtx[sectionX] || [];
	
			if (!this._sections[sectionX][sectionY]) {
				this._sections[sectionX][sectionY] = document.createElement('canvas');
				this._sections[sectionX][sectionY].width = (this._tileWidth * this._autoSection);
				this._sections[sectionX][sectionY].height = (this._tileHeight * this._autoSection);
	
				sectionCtx = this._sectionCtx[sectionX][sectionY] = this._sections[sectionX][sectionY].getContext('2d');
	
				// Ensure the canvas is using the correct image antialiasing mode
				if (!$textures._globalSmoothing) {
					sectionCtx.imageSmoothingEnabled = false;
					sectionCtx.mozImageSmoothingEnabled = false;
				} else {
					sectionCtx.imageSmoothingEnabled = true;
					sectionCtx.mozImageSmoothingEnabled = true;
				}
	
				// One-time translate the context
				sectionCtx.translate(this._tileWidth / 2, this._tileHeight / 2);
			}
		},
	
		/**
		 * Private method, draws cached image sections to the canvas context.
		 * @param {CanvasRenderingContext2d} ctx
		 * @private
		 */
		_drawSectionsToCtx: function (ctx) {
			var x, y, tileData,
				sectionRenderX, sectionRenderY,
				sectionAbsX, sectionAbsY,
				sectionWidth, sectionHeight,
				viewArea = $ige._currentViewport.viewArea();
	
			// Render the map sections
			//ctx.translate(-(this._tileWidth / 2), -(this._tileHeight / 2));
	
			sectionWidth = (this._tileWidth * this._autoSection);
			sectionHeight = (this._tileHeight * this._autoSection);
	
			for (x in this._sections) {
				if (this._sections.hasOwnProperty(x)) {
					for (y in this._sections[x]) {
						if (this._sections[x].hasOwnProperty(y)) {
							sectionRenderX = x * (this._tileWidth * this._autoSection);
							sectionRenderY = y * (this._tileHeight * this._autoSection);
							sectionAbsX = this._translate.x + sectionRenderX - $ige._currentCamera._translate.x;
							sectionAbsY = this._translate.y + sectionRenderY - $ige._currentCamera._translate.y;
	
							// Check if we are drawing isometrically and adjust
							if (this._mountMode === 1) {
								sectionAbsX -= (this._tileWidth / 2);
								sectionAbsY -= (this._tileHeight / 2);
							}
	
							// Check if the section is "on screen"
							if ((sectionAbsX + sectionWidth + (this._tileHeight / 2) >= -(viewArea.width / 2) && sectionAbsX - (this._tileWidth / 2) <= (viewArea.width / 2)) && (sectionAbsY + sectionHeight + (this._tileHeight / 2) >= -(viewArea.height / 2) && sectionAbsY <= (viewArea.height / 2))) {
								// Grab the canvas to paint
								tileData = this._sections[x][y];
	
								ctx.drawImage(
									tileData,
									0, 0,
									sectionWidth,
									sectionHeight,
									sectionRenderX,
									sectionRenderY,
									sectionWidth,
									sectionHeight
								);
								
								$time._drawCount++;
	
								if (this._drawSectionBounds) {
									// Draw a bounding rectangle around the section
									ctx.strokeStyle = '#ff00f6';
									ctx.strokeRect(
										x * (this._tileWidth * this._autoSection),
										y * (this._tileHeight * this._autoSection),
										(this._tileWidth * this._autoSection),
										(this._tileHeight * this._autoSection)
									);
								}
							}
						}
					}
				}
			}
		},
	
		/**
		 * Private method, renders a tile texture based on data from the texture map,
		 * to a cached section.
		 * @param {CanvasRenderingContext2d} ctx
		 * @param {Number} x The tile x co-ordinate.
		 * @param {Number} y The tile y co-ordinate.
		 * @param {Object} tileData The tile's texture and cell data.
		 * @param {Object} tileEntity The object that represents the tile.
		 * @param {IgeRect=} rect The rectangular area to limit drawing to.
		 * @param {Number} sectionX The x co-ordinate of the section to draw to.
		 * @param {Number} sectionY The y co-ordinate of the section to draw to.
		 * @return {*}
		 * @private
		 */
		_renderTile: function (ctx, x, y, tileData, tileEntity, rect, sectionX, sectionY) {
			// TODO: Handle scaling so tiles don't loose res on scaled cached sections
			var finalX, finalY, regions,
				xm1, xp1, ym1, yp1, regObj,
				xAdjust = this._mountMode === 1 ? this._tileWidth / 2 : 0,
				yAdjust = this._mountMode === 1 ? this._tileHeight / 2 : 0,
				tx, ty, sx, sy,
				texture;
			
			// Translate the canvas to the tile position
			if (this._mountMode === 0) {
				finalX = x * this._tileWidth;
				finalY = y * this._tileHeight;
			}
	
			if (this._mountMode === 1) {
				// Convert the tile x, y to isometric
				tx = x * this._tileWidth;
				ty = y * this._tileHeight;
				sx = tx - ty;
				sy = (tx + ty) * 0.5;
	
				finalX = sx - this._tileWidth / 2;
				finalY = sy;
			}
	
			if (sectionX !== undefined) {
				finalX -= sectionX * this._autoSection * this._tileWidth;
			}
			if (sectionY !== undefined) {
				finalY -= sectionY * this._autoSection * this._tileHeight;
			}
	
			// If we have a rectangle region we are limiting to...
			if (rect) {
				// Check the bounds first
				if (!rect.xyInside(finalX, finalY)) {
					// The point is not inside the bounds, return
					return;
				}
			}
	
			if (finalX - (xAdjust) < 0) {
				regions = regions || [];
				regions.push({x: -1});
				xm1 = true;
	
				regObj = regObj || {};
				regObj.x = -1;
			}
	
			if (finalX + (xAdjust) > (ctx.canvas.width - (this._tileWidth))) {
				regions = regions || [];
				regions.push({x: 1});
				xp1 = true;
	
				regObj = regObj || {};
				regObj.x = 1;
			}
	
			if (finalY - (0) < 0) {
				regions = regions || [];
				regions.push({y: -1});
				ym1 = true;
	
				regObj = regObj || {};
				regObj.y = -1;
			}
	
			if (finalY + (0) > (ctx.canvas.height - (this._tileHeight))) {
				regions = regions || [];
				regions.push({y: 1});
				yp1 = true;
	
				regObj = regObj || {};
				regObj.y = 1;
			}
	
			if (xm1 || ym1 || xp1 || yp1) {
				regions.push(regObj);
			}
	
			ctx.save();
			ctx.translate(finalX, finalY);
			
			// Set the correct texture data
			texture = this._textureList[tileData[0]];
			tileEntity._cell = tileData[1];
	
			// Paint the texture
			if (texture) {
				texture.render(ctx, tileEntity, $time._tickDelta);
			}
			ctx.restore();
	
			return regions;
		},
	
		/**
		 * Private method, creates an entity object that a texture can use to render
		 * itself. This is basically a dummy object that has the minimum amount of data
		 * in it that a texture requires to render such as geometry, texture
		 * cell and rendering position.
		 * @return {Object} The new tile entity object.
		 * @private
		 */
		_newTileEntity: function () {
			if (this._mountMode === 0) {
				return {
					_cell: 1,
					_bounds2d: {
						x: this._tileWidth,
						y: this._tileHeight
					},
					_renderPos: {
						x: -this._tileWidth / 2,
						y: -this._tileHeight / 2
					}
				};
			}
	
			if (this._mountMode === 1) {
				return {
					_cell: 1,
					_bounds2d: {
						x: this._tileWidth * 2,
						y: this._tileHeight
					},
					_renderPos: {
						x: -this._tileWidth,
						y: -this._tileHeight / 2
					}
				};
			}
		}
	});
	
	return IgeTextureMap;
});

},{"irrelon-appcore":125}],86:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTileMap2d', function ($ige, IgeEntity, IgeTexture, IgeTileMap2dSmartTexture, IgeMap2d, IgeMatrix2d, IgePoint2d, IgePoint3d, IgePoly2d, IgeRect) {
	/**
	 * Tile maps provide a way to align mounted child objects to a tile-based grid.
	 * NOTE: These are not to be confused with IgeTextureMap's which allow you to
	 * paint a bunch of tiles to a grid.
	 */
	var IgeTileMap2d = IgeEntity.extend({
		classId: 'IgeTileMap2d',
		IgeTileMap2d: true,
		
		init: function (tileWidth, tileHeight) {
			IgeEntity.prototype.init.call(this);
			
			tileWidth = tileWidth !== undefined ? tileWidth : 40;
			tileHeight = tileHeight !== undefined ? tileHeight : 40;
			
			var self = this;
			
			if (!$ige.isServer) {
				var tex = new IgeTexture(IgeTileMap2dSmartTexture);
				self.texture(tex);
			}
			
			self.map = new IgeMap2d();
			self._adjustmentMatrix = new IgeMatrix2d();
			
			self.tileWidth(tileWidth);
			self.tileHeight(tileHeight);
			self.gridSize(3, 3);
			
			self._drawGrid = 0;
			self._gridColor = '#ffffff';
		},
		
		/**
		 * Gets / sets the flag that determines if the tile map will paint the
		 * occupied tiles with an overlay colour so that it is easy to spot them.
		 * @param val
		 * @return {*}
		 */
		highlightOccupied: function (val) {
			if (val !== undefined) {
				this._highlightOccupied = val;
				return this;
			}
			
			return this._highlightOccupied;
		},
		
		highlightTileRect: function (val) {
			if (val !== undefined) {
				this._highlightTileRect = val;
				return this;
			}
			
			return this._highlightTileRect;
		},
		
		/**
		 * Gets / sets the map's tile width.
		 * @param {Number} val Tile width.
		 * @return {*}
		 */
		tileWidth: function (val) {
			if (val !== undefined) {
				this._tileWidth = val;
				if (this._gridSize && this._gridSize.x) {
					this.width(this._tileWidth * this._gridSize.x);
					this._updateAdjustmentMatrix();
				}
				
				return this;
			}
			
			return this._tileWidth;
		},
		
		/**
		 * Gets / sets the map's tile height.
		 * @param {Number} val Tile height.
		 * @return {*}
		 */
		tileHeight: function (val) {
			if (val !== undefined) {
				this._tileHeight = val;
				if (this._gridSize && this._gridSize.y) {
					this.height(this._tileHeight * this._gridSize.y);
					this._updateAdjustmentMatrix();
				}
				
				return this;
			}
			
			return this._tileHeight;
		},
		
		gridSize: function (x, y) {
			if (x !== undefined && y !== undefined) {
				this._gridSize = new IgePoint2d(x, y);
				
				// If in 2d mount mode
				if (this._mountMode === 0) {
					if (this._tileWidth) {
						this.width(this._tileWidth * this._gridSize.x);
					}
				}
				
				// If in isometric mount mode
				if (this._mountMode === 1) {
					if (this._tileWidth) {
						this.width((this._tileWidth * 2) * this._gridSize.x);
					}
				}
				
				if (this._tileHeight) {
					this.height(this._tileHeight * this._gridSize.y);
				}
				
				this._updateAdjustmentMatrix();
				
				return this;
			}
			
			return this._gridSize;
		},
		
		/**
		 * Gets / sets if the tile map should paint a grid to the context during
		 * the tick method.
		 * @param {Boolean=} val If true, will paint the grid on tick.
		 * @return {*}
		 */
		drawGrid: function (val)  {
			if (val !== undefined) {
				this._drawGrid = val;
				return this;
			}
			
			return this._drawGrid;
		},
		
		/**
		 * Gets / sets the color of the grid overlay. It accepts a string color
		 * definition with the same specifications as the canvas context strokeStyle
		 * property.
		 * @param {String=} val The color of the grid.
		 * @return {*}
		 */
		gridColor: function (val)  {
			if (val !== undefined) {
				this._gridColor = val;
				return this;
			}
			
			return this._gridColor;
		},
		
		/**
		 * Sets a tile or area as occupied by the passed obj parameter.
		 * Any previous occupy data on the specified tile or area will be
		 * overwritten.
		 * @param {Number} x X co-ordinate of the tile to un-occupy.
		 * @param {Number} y Y co-ordinate of the tile to un-occupy.
		 * @param {Number} width Number of tiles along the x-axis to occupy.
		 * @param {Number} height Number of tiles along the y-axis to occupy.
		 * @param {*} obj
		 * @return {*}
		 */
		occupyTile: function (x, y, width, height, obj) {
			var xi, yi;
			
			if (width === undefined) { width = 1; }
			if (height === undefined) { height = 1; }
			
			// Floor the values
			x = Math.floor(x);
			y = Math.floor(y);
			width = Math.floor(width);
			height = Math.floor(height);
			
			if (x !== undefined && y !== undefined) {
				for (xi = 0; xi < width; xi++) {
					for (yi = 0; yi < height; yi++) {
						this.map.tileData(x + xi, y + yi, obj);
					}
				}
				
				// Create an IgeRect to represent the tiles this
				// entity has just occupied
				if (obj._classId) {
					obj._occupiedRect = new IgeRect(x, y, width, height);
				}
			}
			return this;
		},
		
		/**
		 * Removes all data from the specified tile or area.
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number=} width
		 * @param {Number=} height
		 * @return {*}
		 */
		unOccupyTile: function (x, y, width, height) {
			var xi, yi, item;
			
			if (width === undefined) { width = 1; }
			if (height === undefined) { height = 1; }
			
			// Floor the values
			x = Math.floor(x);
			y = Math.floor(y);
			width = Math.floor(width);
			height = Math.floor(height);
			
			if (x !== undefined && y !== undefined) {
				for (xi = 0; xi < width; xi++) {
					for (yi = 0; yi < height; yi++) {
						item = this.map.tileData(x + xi, y + yi);
						if (item && item._occupiedRect) {
							delete item._occupiedRect;
						}
						this.map.clearData(x + xi, y + yi);
					}
				}
				
				
			}
			return this;
		},
		
		/**
		 * Returns true if the specified tile or tile area has
		 * an occupied status.
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number=} width
		 * @param {Number=} height
		 * @return {*}
		 */
		isTileOccupied: function (x, y, width, height) {
			if (width === undefined) { width = 1; }
			if (height === undefined) { height = 1; }
			
			return this.map.collision(x, y, width, height);
		},
		
		tileOccupiedBy: function (x, y) {
			return this.map.tileData(x, y);
		},
		
		/**
		 * Returns the tile co-ordinates of the tile that the point's world
		 * co-ordinates reside inside.
		 * @param {IgePoint3d} point
		 * @return {IgePoint3d} The tile co-ordinates as a point object.
		 */
		pointToTile: function (point) {
			// TODO: Could this do with some caching to check if the input values have changed and if not,
			// TODO: supply the same pre-calculated data if it already exists?
			var mx = point.x,
				my = point.y,
				dx, dy, tilePos;
			
			if (this._mountMode === 0) {
				// 2d
				dx = mx; //+ this._tileWidth / 2;
				dy = my; //+ this._tileHeight / 2;
				
				tilePos = new IgePoint3d(
					Math.floor(dx / this._tileWidth),
					Math.floor(dy / this._tileWidth),
					0
				);
			}
			
			if (this._mountMode === 1) {
				// iso
				dx = mx;
				dy = my;
				
				tilePos = new IgePoint3d(
					Math.floor(dx / this._tileWidth),
					Math.floor(dy / this._tileHeight),
					0
				);
			}
			
			return tilePos;
		},
		
		/**
		 * Returns the world co-ordinates of the tile the mouse is currently over.
		 * @return {IgePoint3d}
		 */
		mouseTilePoint: function () {
			var tilePos = this.mouseToTile()
				.thisMultiply(this._tileWidth, this._tileHeight, 1);
			
			tilePos.x += this._tileWidth / 2;
			tilePos.y += this._tileHeight / 2;
			
			return tilePos;
		},
		
		tileToPoint: function (x, y) {
			var point;
			
			if (this._mountMode === 0) {
				point = new IgePoint3d(x, y, 0)
					.thisMultiply(this._tileWidth, this._tileHeight, 1);
				
				point.x -= this._bounds2d.x2 - (this._tileWidth / 2);
				point.y -= this._bounds2d.y2 - (this._tileHeight / 2);
			}
			
			if (this._mountMode === 1) {
				point = new IgePoint3d(x * this._tileWidth + this._tileWidth / 2, y * this._tileHeight + this._tileHeight / 2, 0);
				point.x -= this._bounds2d.x2 / 2;
				point.y -= this._bounds2d.y2;
			}
			
			point.x2 = point.x / 2;
			point.y2 = point.y / 2;
			
			return point;
		},
		
		/**
		 * Returns the tile co-ordinates of the tile the mouse is currently over.
		 * @return {IgePoint3d}
		 */
		mouseToTile: function () {
			var tilePos;
			
			if (this._mountMode === 0) {
				tilePos = this.pointToTile(this.mousePos());
			} else {
				tilePos = this.pointToTile(this.mousePos().to2d());
			}
			
			return tilePos;
		},
		
		/**
		 * Scans the map data and returns an array of rectangle
		 * objects that encapsulate the map data into discrete
		 * rectangle areas.
		 * @param {Function=} callback Returns true or false for
		 * the passed map data determining if it should be included
		 * in a rectangle or not.
		 * @return {Array}
		 */
		scanRects: function (callback) {
			var x, y,
				rectArray = [],
				mapData = this.map._mapData.clone();
			
			// Loop the map data and scan for blocks that can
			// be converted into static box2d rectangle areas
			for (y in mapData) {
				if (mapData.hasOwnProperty(y)) {
					for (x in mapData[y]) {
						if (mapData[y].hasOwnProperty(x)) {
							if (mapData[y][x] && (!callback || (callback && callback(mapData[y][x], x, y)))) {
								rectArray.push(this._scanRects(mapData, parseInt(x, 10), parseInt(y, 10), callback));
							}
						}
					}
				}
			}
			
			return rectArray;
		},
		
		_scanRects: function (mapData, x, y, callback) {
			var rect = {
					x: x,
					y: y,
					width: 1,
					height: 1
				},
				nx = x + 1,
				ny = y + 1;
			
			// Clear the current x, y cell mapData
			mapData[y][x] = 0;
			
			while (mapData[y][nx] && (!callback || (callback && callback(mapData[y][nx], nx, y)))) {
				rect.width++;
				
				// Clear the mapData for this cell
				mapData[y][nx] = 0;
				
				// Next column
				nx++;
			}
			
			while (mapData[ny] && mapData[ny][x] && (!callback || (callback && callback(mapData[ny][x], x, ny)))) {
				// Check for mapData either side of the column width
				if ((mapData[ny][x - 1] && (!callback || (callback && callback(mapData[ny][x - 1], x - 1, ny)))) || (mapData[ny][x + rect.width] && (!callback || (callback && callback(mapData[ny][x + rect.width], x + rect.width, ny))))) {
					return rect;
				}
				
				// Loop the column's map data and check that there is
				// an intact column the same width as the starting column
				for (nx = x; nx < x + rect.width; nx++) {
					if (!mapData[ny][nx] || (callback && !callback(mapData[ny][nx], nx, ny))) {
						// This row has a different column width from the starting
						// column so return the rectangle as it stands
						return rect;
					}
				}
				
				// Mark the row as cleared
				for (nx = x; nx < x + rect.width; nx++) {
					mapData[ny][nx] = 0;
				}
				
				rect.height++;
				ny++;
			}
			
			return rect;
		},
		
		inGrid: function (x, y, width, height) {
			if (width === undefined) { width = 1; }
			if (height === undefined) { height = 1; }
			
			// Checks if the passed area is inside the tile map grid as defined by gridSize
			return x >= 0 && y >= 0 && x + width <= this._gridSize.x && y + height <= this._gridSize.y;
		},
		
		/**
		 * Gets / sets the mouse tile hover color used in conjunction with the
		 * drawMouse() method.
		 * @param {String=} val The hex or rbg string color definition e.g. #ff0099.
		 * @returns {*}
		 */
		hoverColor: function (val) {
			if (val !== undefined) {
				this._hoverColor = val;
				return this;
			}
			
			return this._hoverColor;
		},
		
		/**
		 * Loads map data from a saved map.
		 * @param {Object} map The map data object.
		 */
		loadMap: function (map) {
			// Just fill in the map data
			this.map.mapData(map.data, 0, 0);
			
			return this;
		},
		
		/**
		 * Returns a map JSON string that can be saved to a data file and loaded
		 * with the loadMap() method.
		 * @return {Object} The map data object.
		 */
		saveMap: function () {
			// in URL format
			var textures = [], i,
				x, y,
				dataX = 0, dataY = 0,
				mapData = this.map._mapData;
			
			// Get the lowest x, y
			for (y in mapData) {
				if (mapData.hasOwnProperty(y)) {
					for (x in mapData[y]) {
						if (mapData[y].hasOwnProperty(x)) {
							if (parseInt(x) < parseInt(dataX)) {
								dataX = parseInt(x);
							}
							
							if (parseInt(y) < parseInt(dataY)) {
								dataY = parseInt(y);
							}
						}
					}
				}
			}
			
			return JSON.stringify({
				data: this.map.sortedMapDataAsArray(),
				dataXY: [parseInt(dataX, 10), parseInt(dataY, 10)]
			});
		},
		
		isometricMounts: function (val) {
			if (val !== undefined) {
				IgeEntity.prototype.isometricMounts.call(this, val);
				
				// Re-call the methods that check iso mounts property
				this.tileWidth(this._tileWidth);
				this.tileHeight(this._tileHeight);
				this.gridSize(this._gridSize.x, this._gridSize.y);
				
				this._updateAdjustmentMatrix();
				return this;
			}
			
			return this._mountMode;
		},
		
		tileMapHitPolygon: function (mousePoint) {
			if (this._mountMode === 0) {
				return this.aabb();
			}
			
			if (this._mountMode === 1) {
				var aabb = this.aabb(),
					poly = new IgePoly2d();
				
				poly.addPoint(aabb.x + aabb.width / 2, aabb.y);
				poly.addPoint(aabb.x + aabb.width, aabb.y + aabb.height / 2);
				poly.addPoint(aabb.x + aabb.width / 2, (aabb.y + aabb.height) - 1);
				poly.addPoint(aabb.x - 1, (aabb.y + aabb.height / 2) - 1);
				
				return poly;
			}
		},
		
		_processTriggerHitTests: function () {
			// This method overrides the one in IgeEntity
			if (this._mouseEventsActive && $ige._currentViewport) {
				if (!this._mouseAlwaysInside) {
					var mouseTile = this.mouseToTile();
					if (mouseTile.x >= 0 && mouseTile.y >= 0 && mouseTile.x < this._gridSize.x && mouseTile.y < this._gridSize.y) {
						return true;
					} else {
						return false;
					}
				} else {
					return true;
				}
			}
			
			return false;
		},
		
		_updateAdjustmentMatrix: function () {
			if (this._bounds2d.x2 && this._bounds2d.y2 && this._tileWidth && this._tileHeight) {
				if (this._mountMode === 0) {
					this._adjustmentMatrix.translateTo(this._bounds2d.x2, this._bounds2d.y2);
				}
				
				if (this._mountMode === 1) {
					this._adjustmentMatrix.translateTo(0, this._bounds2d.y2);
				}
			}
		},
		
		_childMounted: function (obj) {
			// We can also re-use the tile size methods since
			// they alter the same properties on the calling
			// entity anyway.
			obj.tileWidth = obj.tileWidth || this.tileWidth;
			obj.tileHeight = obj.tileHeight || this.tileHeight;
			
			// Set default values
			obj._tileWidth = obj._tileWidth || 1;
			obj._tileHeight = obj._tileHeight || 1;
			
			IgeEntity.prototype._childMounted.call(this, obj);
		}
	});
	
	return IgeTileMap2d;
});
},{"irrelon-appcore":125}],87:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTimeout', function ($ige, $time, IgeInterval) {
	/**
	 * Provides an alternative to setTimeout() which works based on the engine's internal
	 * time system allowing timeouts to fire correctly, taking into account pausing the
	 * game and differences in rendering speed etc.
	 */
	var IgeTimeout = IgeInterval.extend({
		classId: 'IgeTimeout',
		
		/**
		 * Creates a new timeout that will call the passed method after the number of
		 * milliseconds specified by the timeout parameter has been reached.
		 * @param {Function} method The method to call on timeout.
		 * @param {Number} timeout The number of milliseconds before the timeout.
		 * @example #Create a timer that will call a method after 1 second of engine time
		 *     var myTimeout = new IgeTimeout(function () {
	 *     		console.log('interval fired');
	 *     }, 1000);
		 */
		init: function (method, timeout) {
			IgeInterval.prototype.init.call(this, method, timeout);
		},
		
		/**
		 * Cancels the timer, stops the timeout.
		 * @example #Cancel a timeout timer
		 *     var myTimeout = new IgeTimeout(function () {
	 *     		console.log('timeout fired');
	 *     }, 1000);
		 *
		 *     myTimeout.cancel();
		 * @returns {*}
		 */
		cancel: function () {
			return IgeInterval.prototype.cancel.call(this);
		},
		
		/**
		 * Resets the time and lets the timeout begin anew.
		 * @returns {*}
		 */
		reset: function() {
			this._time = 0;
			if ($ige.engine.time._timers.indexOf(this) == -1) {
				$ige.engine.time.addTimer(this);
			}
		},
		
		/**
		 * Checks for a timeout event to see if we should call the timeout method. This is
		 * called automatically by the IgeTimeComponent class and does not need to be
		 * called manually.
		 * @returns {*}
		 */
		update: function () {
			if (this._time > this._interval) {
				// Fire an interval
				this._method($time._currentTime);
				$ige.engine.time.removeTimer(this);
			}
			
			return this;
		}
	});
	
	return IgeTimeout;
});
},{"irrelon-appcore":125}],88:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeTween', function ($ige, $time, IgeClass) {
	/**
	 * Creates a new tween instance.
	 */
	var IgeTween = IgeClass.extend({
		classId: 'IgeTween',
		
		init: function (targetObj, propertyObj, durationMs, options) {
			// Create a new tween object and return it
			// so the user can decide when to start it
			this._targetObj = targetObj;
			this._steps = [];
			this._currentStep = -1;
			if (propertyObj !== undefined) {
				this.stepTo(propertyObj);
			}
			this._durationMs = durationMs !== undefined ? durationMs : 0;
			this._started = false;
			this._stepDirection = false;
			
			// Sort out the options
			if (options && options.easing) { this.easing(options.easing); } else { this.easing('none'); }
			if (options && options.startTime !== undefined) { this.startTime(options.startTime); }
			if (options && options.beforeTween !== undefined) { this.beforeTween(options.beforeTween); }
			if (options && options.afterTween !== undefined) { this.afterTween(options.afterTween); }
		},
		
		/**
		 * Sets the object in which the properties to tween exist.
		 * @param targetObj
		 * @return {*}
		 */
		targetObj: function (targetObj) {
			if (targetObj !== undefined) {
				this._targetObj = targetObj;
			}
			
			return this;
		},
		
		/**
		 * Sets the tween's target properties to tween to.
		 * @param propertyObj
		 * @return {*}
		 */
		properties: function (propertyObj) {
			if (propertyObj !== undefined) {
				// Reset any existing steps and add this new one
				this._steps = [];
				this._currentStep = -1;
				this.stepTo(propertyObj);
			}
			
			return this;
		},
		
		/**
		 * Gets / sets the repeat mode for the tween. If the mode
		 * is set to 1 the tween will repeat from the first step.
		 * If set to 2 the tween will reverse the order of the steps
		 * each time the repeat occurs. The count determines the
		 * number of times the tween will be repeated before stopping.
		 * Setting the count to -1 will make it repeat infinitely.
		 * @param val
		 * @param count
		 * @return {*}
		 */
		repeatMode: function (val, count) {
			if (val !== undefined) {
				this._repeatMode = val;
				this.repeatCount(count);
				return this;
			}
			
			return this._repeatMode;
		},
		
		/**
		 * Gets / sets the repeat count. The count determines the
		 * number of times the tween will be repeated before stopping.
		 * Setting the count to -1 will make it repeat infinitely.
		 * This setting is used in conjunction with the repeatMode()
		 * method. If you just set a repeat count and no mode then
		 * the tween will not repeat.
		 * @param val
		 * @return {*}
		 */
		repeatCount: function (val) {
			if (val !== undefined) {
				this._repeatCount = val;
				this._repeatedCount = 0;
				return this;
			}
			
			return this._repeatCount;
		},
		
		/**
		 * DEPRECIATED, Renamed to stepTo().
		 */
		step: function (propertyObj, durationMs, easing) {
			this.log('The step method has been renamed to stepTo(). Please update your code as the step() method will soon be removed.', 'warning');
			this.stepTo(propertyObj, durationMs, easing);
			return this;
		},
		
		/**
		 * Defines a step in a multi-stage tween. Uses the properties
		 * as destination value.
		 * @param {Object} propertyObj The properties to
		 * tween during this step.
		 * @param {Number=} durationMs The number of milliseconds
		 * to spend tweening this step, or if not provided uses
		 * the current tween durationMs setting.
		 * @param {String=} easing The name of the easing method
		 * to use during this step.
		 * @param {Boolean=} delta If true will set the step to use
		 * delta values instead of absolute values as the destination.
		 * @return {*}
		 */
		stepTo: function (propertyObj, durationMs, easing, delta) {
			if (propertyObj !== undefined) {
				// Check if we have already been given a standard
				// non-staged property
				this._steps.push({
					props: propertyObj,
					durationMs: durationMs,
					easing: easing,
					isDelta: delta
				});
			}
			
			return this;
		},
		
		/**
		 * Defines a step in a multi-stage tween. Uses the properties
		 * as deltas, not as destination values
		 * @param {Object} propertyObj The properties to
		 * tween during this step.
		 * @param {Number=} durationMs The number of milliseconds
		 * to spend tweening this step, or if not provided uses
		 * the current tween durationMs setting.
		 * @param {String=} easing The name of the easing method
		 * to use during this step.
		 * @return {*}
		 */
		stepBy: function (propertyObj, durationMs, easing) {
			this.stepTo(
				propertyObj,
				durationMs,
				easing,
				true
			);
			
			return this;
		},
		
		/**
		 * Sets the duration of the tween in milliseconds.
		 * @param durationMs
		 * @return {*}
		 */
		duration: function (durationMs) {
			if (durationMs !== undefined) {
				this._durationMs = durationMs;
			}
			
			return this;
		},
		
		/**
		 * Sets the method to be called just before the tween has started.
		 * @param callback
		 * @return {*}
		 */
		beforeTween: function (callback) {
			if (callback !== undefined) {
				this._beforeTween = callback;
			}
			
			return this;
		},
		
		/**
		 * Sets the method to be called just after the tween has ended.
		 * @param callback
		 * @return {*}
		 */
		afterTween: function (callback) {
			if (callback !== undefined) {
				this._afterTween = callback;
			}
			
			return this;
		},
		
		/**
		 * Sets the method to be called just before a tween step has
		 * started.
		 * @param callback
		 * @return {*}
		 */
		beforeStep: function (callback) {
			if (callback !== undefined) {
				this._beforeStep = callback;
			}
			
			return this;
		},
		
		/**
		 * Sets the method to be called just after a tween step has
		 * ended.
		 * @param callback
		 * @return {*}
		 */
		afterStep: function (callback) {
			if (callback !== undefined) {
				this._afterStep = callback;
			}
			
			return this;
		},
		
		/**
		 * Sets the method to be called just after a tween has changed
		 * the values of the target object every update tick.
		 * @param callback
		 * @return {*}
		 */
		afterChange: function (callback) {
			if (callback !== undefined) {
				this._afterChange = callback;
			}
			
			return this;
		},
		
		/**
		 * Returns the object that this tween is modifying.
		 * @return {*}
		 */
		targetObject: function () {
			return this._targetObj;
		},
		
		/**
		 * Sets the name of the easing method to use with the tween.
		 * @param methodName
		 * @return {*}
		 */
		easing: function (methodName) {
			if (methodName !== undefined) {
				if ($ige.engine.tween.easing[methodName]) {
					this._easing = methodName;
				} else {
					this.log('The easing method you have selected does not exist, please use a valid easing method. For a list of easing methods please inspect $ige.engine.tween.easing from your console.', 'error', $ige.engine.tween.easing);
				}
			}
			
			return this;
		},
		
		/**
		 * Sets the timestamp at which the tween should start.
		 * @param timeMs
		 * @return {*}
		 */
		startTime: function (timeMs) {
			if (timeMs !== undefined) {
				this._startTime = timeMs;
			}
			
			return this;
		},
		
		/**
		 * Starts the tweening operation.
		 * @param {Number=} timeMs If set, the tween will start this
		 * many milliseconds in the future.
		 */
		start: function (timeMs) {
			if (timeMs !== undefined) {
				this.startTime(timeMs + $time._currentTime);
			}
			
			$ige.engine.tween.start(this);
			
			// Add the tween to the target object's tween array
			this._targetObj._tweenArr = this._targetObj._tweenArr || [];
			this._targetObj._tweenArr.push(this);
			
			return this;
		},
		
		/**
		 * Stops the tweening operation.
		 */
		stop: function () {
			$ige.engine.tween.stop(this);
			if (this._targetObj._tweenArr) {
				this._targetObj._tweenArr.pull(this);
			}
			
			return this;
		},
		
		/**
		 * Starts all tweens registered to an object.
		 * @private
		 */
		startAll: function () {
			if (this._targetObj._tweenArr) {
				this._targetObj._tweenArr.eachReverse(function (tweenItem) {
					tweenItem.start();
				});
			}
			
			return this;
		},
		
		/**
		 * Stops all tweens registered to an object.
		 * @private
		 */
		stopAll: function () {
			if (this._targetObj._tweenArr) {
				this._targetObj._tweenArr.eachReverse(function (tweenItem) {
					tweenItem.stop();
				});
			}
			
			return this;
		}
	});
	
	return IgeTween;
});
},{"irrelon-appcore":125}],89:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiElement', function ($ige, IgeUiEntity) {
	/**
	 * Creates a new UI element. UI elements use more resources and CPU
	 * than standard IgeEntity instances but provide a rich set of extra
	 * positioning and styling methods as well as reacting to styles
	 * defined using the IgeUiManagerComponent.
	 */
	var IgeUiElement = IgeUiEntity.extend({
		classId: 'IgeUiElement',
		
		/**
		 * Constructor
		 */
		init: function () {
			var self = this;
			
			IgeUiEntity.prototype.init.call(this);
			$ige.engine.ui.registerElement(this);
			
			this._focused = false;
			this._allowHover = true;
			this._allowFocus = true;
			this._allowActive = true;
			
			var updateStyleFunc = function () {
				self._updateStyle();
			};
			
			this.on('mouseOver', function () {
				if (this._allowHover) {
					updateStyleFunc();
					$ige.engine.input.stopPropagation();
				} else {
					this._mouseStateOver = false;
				}
			});
			this.on('mouseOut', function () {
				if (this._allowHover) {
					updateStyleFunc();
					$ige.engine.input.stopPropagation();
				} else {
					this._mouseStateOver = false;
				}
			});
			this.on('mouseDown', function () {
				if (this._allowActive) {
					updateStyleFunc();
					$ige.engine.input.stopPropagation();
				} else {
					this._mouseStateDown = false;
				}
			});
			this.on('mouseUp', function () {
				if (this._allowFocus) {
					// Try to focus the entity
					if (!self.focus()) {
						updateStyleFunc();
					} else {
						$ige.engine.input.stopPropagation();
					}
				} else if (this._allowActive) {
					updateStyleFunc();
				}
			});
			
			// Enable mouse events on this entity by default
			this.mouseEventsActive(true);
		},
		
		allowHover: function (val) {
			if (val !== undefined) {
				this._allowHover = val;
				return this;
			}
			
			return this._allowHover;
		},
		
		allowFocus: function (val) {
			if (val !== undefined) {
				this._allowFocus = val;
				return this;
			}
			
			return this._allowFocus;
		},
		
		allowActive: function (val) {
			if (val !== undefined) {
				this._allowActive = val;
				return this;
			}
			
			return this._allowActive;
		},
		
		/**
		 * Gets / sets the applied style by name.
		 * @param {String=} name The style name to apply.
		 * @returns {*}
		 */
		styleClass: function (name) {
			if (name !== undefined) {
				// Add a period to the class name
				name = '.' + name;
				
				// Check for existing assigned style
				if (this._styleClass && this._styleClass !== name) {
					// Unregister this element from the style
					$ige.engine.ui.unRegisterElementStyle(this);
				}
				
				// Assign the new style
				this._styleClass = name;
				
				// Register the element for this style
				$ige.engine.ui.registerElementStyle(this);
				
				// Update the element style
				this._updateStyle();
				
				return this;
			}
			
			return this._styleClass;
		},
		
		_updateStyle: function () {
			// Apply styles in order of class, class:focus, class:hover, class:active,
			// id, id:focus, id:hover, id:active
			this._processStyle(this._classId);
			this._processStyle(this._styleClass);
			this._processStyle('#' + this._id);
			
			if (this._focused) {
				this._processStyle(this._classId, 'focus');
				this._processStyle(this._styleClass, 'focus');
				this._processStyle('#' + this._id, 'focus');
			}
			
			if (this._mouseStateOver) {
				this._processStyle(this._classId, 'hover');
				this._processStyle(this._styleClass, 'hover');
				this._processStyle('#' + this._id, 'hover');
			}
			
			if (this._mouseStateDown) {
				this._processStyle(this._classId, 'active');
				this._processStyle(this._styleClass, 'active');
				this._processStyle('#' + this._id, 'active');
			}
		},
		
		_processStyle: function (styleName, state) {
			if (styleName) {
				if (state) {
					styleName += ':' + state;
				}
				
				//this.log('Checking for styles with selector: ' + styleName);
				
				// Basic
				var styleData = $ige.engine.ui.style(styleName);
				if (styleData) {
					//this.log('Applying styles with selector "' + styleName + '"');
					this.applyStyle(styleData);
				}
			}
		},
		
		/**
		 * Apply styles from a style data object. Usually you don't want to
		 * call this method directly but rather assign a style by name using
		 * the style() method, however it is not illegal practise to apply
		 * here if you wish if you have not defined a style by name and simply
		 * wish to apply style data directly.
		 *
		 * Style property names must correspond to method names in the element
		 * class that the style is being applied to. You can see the default
		 * ui style methods available in the ./engine/extensions/IgeUi* files.
		 *
		 * In the example below showing padding, you can see how the data assigned
		 * is passed to the "padding()" method as arguments, which is the same
		 * as calling "padding(10, 10, 10, 10);".
		 *
		 * @example #Apply a background color
		 *     var elem = new IgeUiElement()
		 *         .applyStyle({
	 	 *             'backgroundColor': '#ffffff' // Set background color to white
	 	 *         });
		 *
		 * @example #Apply padding with multiple arguments
		 *     var elem = new IgeUiElement()
		 *         .applyStyle({
	  	 *             'padding': [10, 10, 10, 10] // Set padding using multiple values
	 	 *         });
		 *
		 * @param {Object} styleData The style object to apply. This object should
		 * contain key/value pairs where the key matches a method name and the value
		 * is the parameter to pass it.
		 */
		applyStyle: function (styleData) {
			var args;
			
			if (styleData !== undefined) {
				// Loop the style data and apply styles as required
				for (var i in styleData) {
					if (styleData.hasOwnProperty(i)) {
						// Check that the style method exists
						if (typeof(this[i]) === 'function') {
							// The method exists, call it with the arguments
							if (styleData[i] instanceof Array) {
								args = styleData[i];
							} else {
								args = [styleData[i]];
							}
							
							this[i].apply(this, args);
						}
					}
				}
			}
			
			return this;
		},
		
		/**
		 * Sets global UI focus to this element.
		 */
		focus: function () {
			if ($ige.engine.ui.focus(this)) {
				// Re-apply styles since the change
				this._updateStyle();
				return true;
			}
			
			return false;
		},
		
		blur: function () {
			if ($ige.engine.ui.blur(this)) {
				// Re-apply styles since the change
				this._updateStyle();
				return true;
			}
			
			return false;
		},
		
		focused: function () {
			return this._focused;
		},
		
		value: function (val) {
			if (val !== undefined) {
				this._value = val;
				return this;
			}
			
			return this._value;
		},
		
		_mounted: function () {
			this._updateStyle();
		},
		
		/**
		 * Destructor
		 */
		destroy: function () {
			$ige.engine.ui.unRegisterElement(this);
			IgeUiEntity.prototype.destroy.call(this);
		}
	});
	
	return IgeUiElement;
});
},{"irrelon-appcore":125}],90:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiEntity', function ($ige, IgeEntity, IgeUiStyleExtension, IgeUiPositionExtension) {
// TODO: Implement the _stringify() method for this class
	/**
	 * Creates a new UI entity. UI entities use more resources and CPU
	 * than standard IgeEntity instances so only use them if an IgeEntity
	 * won't do the job.
	 */
	var IgeUiEntity = IgeEntity.extend([
		{extension: IgeUiStyleExtension, overwrite: true},
		{extension: IgeUiPositionExtension, overwrite: true}
	], {
		classId: 'IgeUiEntity',
		
		init: function () {
			IgeEntity.prototype.init.call(this);
			
			// Set some defaults
			this._color = '#000000';
			this._borderLeftWidth = 0;
			this._borderTopWidth = 0;
			this._borderRightWidth = 0;
			this._borderBottomWidth = 0;
			this._borderTopLeftRadius = 0;
			this._borderTopRightRadius = 0;
			this._borderBottomRightRadius = 0;
			this._borderBottomLeftRadius = 0;
			this._backgroundPosition = {x: 0, y: 0};
			this._paddingLeft = 0;
			this._paddingTop = 0;
			this._paddingRight = 0;
			this._paddingBottom = 0;
		},
		
		disabled: function (val) {
			if (val !== undefined) {
				this._disabled = val;
				return this;
			}
			
			return this._disabled;
		},
		
		overflow: function (val) {
			if (val !== undefined) {
				this._overflow = val;
				return this;
			}
			
			return this._overflow;
		},
		
		_renderBackground: function (ctx) {
			var geom = this._bounds2d,
				left, top, width, height;
			
			if (this._backgroundColor || this._patternFill) {
				left = -(geom.x / 2) | 0;
				top = -(geom.y / 2) | 0;
				width = geom.x;
				height = geom.y;
				
				ctx.save();
				ctx.beginPath();
				
				// Check for early exit if we are rendering a rectangle
				if (!this._borderTopRightRadius && !this._borderBottomRightRadius && !this._borderBottomLeftRadius && !this._borderTopLeftRadius) {
					ctx.rect(left, top, width, height);
				} else {
					// Top border
					ctx.moveTo(left + this._borderTopLeftRadius, top);
					ctx.lineTo(left + width - this._borderTopRightRadius, top);
					
					if (this._borderTopRightRadius > 0) {
						// Top-right corner
						ctx.arcTo(
							left + width,
							top,
							left + width,
							top + this._borderTopRightRadius,
							this._borderTopRightRadius
						);
					}
					
					// Right border
					ctx.lineTo(
						left + width,
						top + height - this._borderBottomRightRadius
					);
					
					if (this._borderBottomRightRadius > 0) {
						// Bottom-right corner
						ctx.arcTo(
							left + width,
							top + height,
							left + width - this._borderBottomRightRadius,
							top + height, this._borderBottomRightRadius
						);
					}
					
					// Bottom border
					ctx.lineTo(
						left + this._borderBottomLeftRadius,
						top + height
					);
					
					if (this._borderBottomLeftRadius > 0) {
						// Bottom-left corner
						ctx.arcTo(
							left,
							top + height,
							left,
							top + height - this._borderBottomLeftRadius,
							this._borderBottomLeftRadius
						);
					}
					
					// Left border
					ctx.lineTo(
						left,
						top + this._borderTopLeftRadius
					);
					
					if (this._borderTopLeftRadius > 0) {
						// Top-left corner
						ctx.arcTo(
							left,
							top,
							left + this._borderTopLeftRadius,
							top, this._borderTopLeftRadius
						);
					}
					
					ctx.clip();
				}
				
				// If there is a background colour, paint it here
				if (this._backgroundColor) {
					ctx.fillStyle = this._backgroundColor;
					ctx.fill();
				}
				
				// If there is a background image, paint it here
				if (this._patternFill) {
					ctx.translate(
						-(width / 2 | 0) + this._backgroundPosition.x,
						-(height / 2 | 0) + this._backgroundPosition.y
					);
					
					ctx.fillStyle = this._patternFill;
					ctx.fill();
				}
				ctx.restore();
			}
		},
		
		_renderBorder: function (ctx) {
			var rad,
				geom = this._bounds2d,
				left = (-(geom.x2) | 0) + 0.5,
				top = (-(geom.y2) | 0) + 0.5,
				width = geom.x - 1,
				height = geom.y - 1;
			
			// Check for early exit if we are rendering a rectangle
			if (!this._borderTopRightRadius &&
				!this._borderBottomRightRadius &&
				!this._borderBottomLeftRadius &&
				!this._borderTopLeftRadius &&
				this._borderLeftWidth === this._borderWidth &&
				this._borderTopWidth === this._borderWidth &&
				this._borderRightWidth === this._borderWidth &&
				this._borderBottomWidth === this._borderWidth) {
				ctx.strokeStyle = this._borderColor;
				ctx.lineWidth = this._borderWidth;
				ctx.strokeRect(left, top, width, height);
			} else {
				rad = Math.PI / 180;
				
				ctx.beginPath();
				if (this._borderTopWidth) {
					// Top-left corner top-half
					ctx.strokeStyle = this._borderTopColor;
					ctx.lineWidth = this._borderTopWidth;
					
					if (this._borderTopLeftRadius > 0) {
						// Top-left corner top-half
						ctx.arc(left + this._borderTopLeftRadius, top + this._borderTopLeftRadius, this._borderTopLeftRadius, 225 * rad, 270 * rad);
					}
					
					// Top border
					ctx.moveTo(left + this._borderTopLeftRadius, top);
					ctx.lineTo(left + width - this._borderTopRightRadius, top);
					
					if (this._borderTopRightRadius > 0) {
						// Top-right corner top-half
						ctx.arc(left + width - this._borderTopRightRadius, top + this._borderTopRightRadius, this._borderTopRightRadius, -90 * rad, -44 * rad); // use -44 instead of -45 to fully connect with next piece
					}
				}
				
				if (!this._borderRightWidth || this._borderTopColor !== this._borderRightColor || this._borderTopWidth !== this._borderRightWidth) {
					ctx.stroke();
					ctx.beginPath();
				}
				
				if (this._borderRightWidth) {
					// Top-right corner bottom-half
					ctx.strokeStyle = this._borderRightColor;
					ctx.lineWidth = this._borderRightWidth;
					
					if (this._borderTopRightRadius > 0) {
						ctx.arc(left + width - this._borderTopRightRadius, top + this._borderTopRightRadius, this._borderTopRightRadius, -45 * rad, 0);
					}
					
					// Right border
					ctx.moveTo(left + width, top + this._borderTopRightRadius);
					ctx.lineTo(left + width, top + height - this._borderBottomRightRadius);
					
					if (this._borderBottomRightRadius > 0) {
						// Bottom-right corner top-half
						ctx.arc(left + width - this._borderBottomRightRadius, top + height - this._borderBottomRightRadius, this._borderTopRightRadius, 0, 46 * rad); // use 46 instead of 45 to fully connect with next piece
					}
				}
				
				if (!this._borderBottomWidth || this._borderRightColor !== this._borderBottomColor || this._borderRightWidth !== this._borderBottomWidth) {
					ctx.stroke();
					ctx.beginPath();
				}
				
				if (this._borderBottomWidth) {
					// Bottom-right corner bottom-half
					ctx.strokeStyle = this._borderBottomColor;
					ctx.lineWidth = this._borderBottomWidth;
					
					if (this._borderBottomRightRadius > 0) {
						ctx.arc(left + width - this._borderBottomRightRadius, top + height - this._borderBottomRightRadius, this._borderBottomRightRadius, 45 * rad, 90 * rad);
					}
					
					// Bottom border
					ctx.moveTo(left + width - this._borderBottomRightRadius, top + height);
					ctx.lineTo(left + this._borderBottomLeftRadius, top + height);
					
					if (this._borderBottomLeftRadius > 0) {
						// Bottom-left corner bottom-half
						ctx.arc(left + this._borderBottomLeftRadius, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius, 90 * rad, 136 * rad); // use 136 instead of 135 to fully connect with next piece
					}
				}
				
				if (!this._borderLeftWidth || this._borderBottomColor !== this._borderLeftColor || this._borderBottomWidth !== this._borderLeftWidth) {
					ctx.stroke();
					ctx.beginPath();
				}
				
				if (this._borderLeftWidth) {
					// Bottom-left corner top-half
					ctx.strokeStyle = this._borderLeftColor;
					ctx.lineWidth = this._borderLeftWidth;
					
					if (this._borderBottomLeftRadius > 0) {
						ctx.arc(left + this._borderBottomLeftRadius, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius, 135 * rad, 180 * rad);
					}
					
					// Left border
					ctx.moveTo(left, top + height - this._borderBottomLeftRadius);
					ctx.lineTo(left, top + this._borderTopLeftRadius);
					
					if (this._borderTopLeftRadius > 0) {
						// Top-left corner bottom-half
						ctx.arc(left + this._borderTopLeftRadius, top + this._borderTopLeftRadius, this._borderTopLeftRadius, 180 * rad, 226 * rad); // use 226 instead of 225 to fully connect with next piece
					}
				}
				ctx.stroke();
			}
		},
		
		cell: function (val) {
			var ret = IgeEntity.prototype.cell.call(this, val);
			
			if (ret === this && this._patternTexture) {
				this.backgroundImage(
					this._patternTexture,
					this._patternRepeat
				);
			}
			
			return ret;
		},
		
		mount: function (obj) {
			var ret = IgeEntity.prototype.mount.call(this, obj);
			
			if (this._parent) {
				// Now we're mounted update our ui calculations since we have a parent
				// to calculate from
				if (this._updateUiPosition) {
					this._updateUiPosition();
				}
				
				// Also update any children if we have any
				if (this._children.length) {
					this.updateUiChildren();
				}
				
				if (this._updateStyle) {
					this._updateStyle();
				}
				
			}
			
			return ret;
		},
		
		tick: function (ctx, dontTransform) {
			if (!this._hidden && this._inView && (!this._parent || (this._parent._inView)) && !this._streamJustCreated) {
				if (!dontTransform) {
					this._transformContext(ctx);
				}
				// TODO: Investigate caching expensive background and border calls
				//if (!this._cache || this._cacheDirty) {
				this._renderBackground(ctx);
				this._renderBorder(ctx);
				//}
				
				if (this._overflow === 'hidden') {
					// Limit drawing of child entities to within the bounds
					// of this one
					var geom = this._bounds2d,
						left = -(geom.x / 2) + this._paddingLeft | 0,
						top = -(geom.y / 2) + (this._paddingTop) | 0,
						width = geom.x + this._paddingRight,
						height = geom.y + this._paddingBottom;
					
					ctx.rect(left, top, width, height);
					//ctx.stroke();
					ctx.clip();
				}
				
				ctx.translate(this._paddingLeft, this._paddingTop);
				IgeEntity.prototype.tick.call(this, ctx, true);
			}
		},
		
		/**
		 * Handles screen resize events.
		 * @param event
		 * @private
		 */
		_resizeEvent: function (event) {
			if (this._updateUiPosition) {
				this._updateUiPosition();
			}
			
			if (this._updateStyle) {
				this._updateStyle();
			}
			
			IgeEntity.prototype._resizeEvent.call(this, event);
		}
	});
	
	return IgeUiEntity;
});
},{"irrelon-appcore":125}],91:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeViewport', function ($ige, IgeEntity, IgePoint3d, IgeCamera, IgeUiStyleExtension, IgeUiPositionExtension, IgeRect) {
	/**
	 * Creates a new viewport.
	 */
	var IgeViewport = IgeEntity.extend([
		{extension: IgeUiStyleExtension, overwrite: true},
		{extension: IgeUiPositionExtension, overwrite: true}
	], {
		classId: 'IgeViewport',
		IgeViewport: true,
		
		init: function (options) {
			var width, height;
			
			this._alwaysInView = true;
			IgeEntity.prototype.init.call(this);
			
			this._mouseAlwaysInside = true;
			this._mousePos = new IgePoint3d(0, 0, 0);
			this._overflow = '';
			this._clipping = true;
			this._bornTime = undefined;
			
			// Set default options if not specified
			// TODO: Is this required or even used?
			if (options) {
				width = options.width;
				height = options.height;
				
				if (options && options.scaleToWidth && options.scaleToHeight) {
					// Store the w/h we want to lock to
					this._lockDimension = new IgePoint3d(options.scaleToWidth, options.scaleToHeight, 0);
				}
			}
			
			// Setup default objects
			this._bounds2d = new IgePoint3d(width || $ige.engine._bounds2d.x, height || $ige.engine._bounds2d.y, 0);
			this.camera = new IgeCamera(this);
			this.camera._entity = this;
			//this._drawMouse = true;
		},
		
		/**
		 * Sets the minimum amount of world in pixels to display in width and height.
		 * When set, if the viewport's geometry is reduced below the minimum width or
		 * height, the viewport's camera is automatically scaled to ensure that the
		 * minimum area remains visible in the viewport.
		 * @param {Integer} width Width in pixels.
		 * @param {Integer} height Height in pixels.
		 * @returns {*}
		 */
		minimumVisibleArea: function (width, height) {
			// Store the w/h we want to lock to
			this._lockDimension = new IgePoint3d(width, height, 0);
			if ($ige.isClient) {
				this._resizeEvent({});
			}
			
			return this;
		},
		
		/**
		 * Gets / sets the auto-size property. If set to true, the viewport will
		 * automatically resize to fill the entire scene.
		 * @param val
		 * @return {*}
		 */
		autoSize: function (val) {
			if (typeof(val) !== 'undefined') {
				this._autoSize = val;
				return this;
			}
			
			return this._autoSize;
		},
		
		/**
		 * Gets / sets the scene that the viewport will render.
		 * @param {IgeScene2d} scene
		 * @return {*}
		 */
		scene: function (scene) {
			if (typeof(scene) !== 'undefined') {
				this._scene = scene;
				return this;
			}
			
			return this._scene;
		},
		
		/**
		 * Returns the viewport's mouse position.
		 * @return {IgePoint3d}
		 */
		mousePos: function () {
			// Viewport mouse position is calculated and assigned in the
			// IgeInputComponent class.
			return this._mousePos.clone();
		},
		
		mousePosWorld: function () {
			return this._transformPoint(this._mousePos.clone());
		},
		
		/**
		 * Gets the current rectangular area that the viewport is "looking at"
		 * in the world. The co-ordinates are in world space.
		 * @returns {IgeRect}
		 */
		viewArea: function () {
			var aabb = this.aabb(),
				camTrans = this.camera._translate,
				camScale = this.camera._scale,
				width = aabb.width * (1 / camScale.x),
				height = aabb.height * (1 / camScale.y);
			
			return new IgeRect(
				(camTrans.x - width / 2),
				(camTrans.y - height / 2),
				width,
				height
			);
		},
		
		/**
		 * Processes the updates before the render tick is called.
		 * @param ctx
		 */
		update: function (ctx, tickDelta) {
			// Check if we have a scene attached to this viewport
			if (this._scene) {
				// Store the viewport camera in the main ige so that
				// down the scenegraph we can choose to negate the camera
				// transform effects
				$ige._currentCamera = this.camera;
				$ige._currentViewport = this;
				
				this._scene._parent = this;
				
				this.camera.update(ctx, tickDelta);
				IgeEntity.prototype.update.call(this, ctx, tickDelta);
				
				if (this._scene.newFrame()) {
					this._scene.update(ctx, tickDelta);
				}
			}
		},
		
		/**
		 * Processes the actions required each render frame.
		 */
		tick: function (ctx, scene) {
			// Check if we have a scene attached to this viewport
			if (this._scene) {
				// Store the viewport camera in the main ige so that
				// down the scenegraph we can choose to negate the camera
				// transform effects
				$ige._currentCamera = this.camera;
				$ige._currentViewport = this;
				
				this._scene._parent = this;
				
				// Render our scene data
				//ctx.globalAlpha = ctx.globalAlpha * this._parent._opacity * this._opacity;
				IgeEntity.prototype.tick.call(this, ctx);
				
				// Translate to the top-left of the viewport
				ctx.translate(
					-(this._bounds2d.x * this._origin.x) | 0,
					-(this._bounds2d.y * this._origin.y) | 0
				);
				
				// Clear the rectangle area of the viewport
				ctx.clearRect(0, 0, this._bounds2d.x, this._bounds2d.y);
				
				// Clip the context so we only draw "inside" the viewport area
				if (this._clipping || this._borderColor) {
					ctx.beginPath();
					ctx.rect(0, 0, this._bounds2d.x / $ige.engine._scale.x, this._bounds2d.y / $ige.engine._scale.x);
					
					// Paint a border if required
					if (this._borderColor) {
						ctx.strokeStyle = this._borderColor;
						ctx.stroke();
					}
					
					if (this._clipping) {
						ctx.clip();
					}
				}
				
				// Translate back to the center of the viewport
				ctx.translate(((this._bounds2d.x / 2) | 0) + $ige.engine._translate.x, ((this._bounds2d.y / 2) | 0) + $ige.engine._translate.y);
				/*ctx.translate($ige.engine._translate.x, $ige.engine._translate.y);*/
				if ($ige.engine._scale.x !== 1 || $ige.engine._scale.y !== 1) {
					ctx.scale($ige.engine._scale.x, $ige.engine._scale.y);
				}
				
				// Transform the context to the center of the viewport
				// by processing the viewport's camera tick method
				this.camera.tick(ctx);
				
				// Draw the scene
				ctx.save();
				this._scene.tick(ctx);
				ctx.restore();
				
				// Check if we should draw guides
				if (this._drawGuides && ctx === $ige.engine._ctx) {
					ctx.save();
					ctx.translate(-this._translate.x, -this._translate.y);
					this.paintGuides(ctx);
					ctx.restore();
				}
				
				// Check if we should draw bounds on this viewport
				// (usually for debug purposes)
				if (this._drawBounds && ctx === $ige.engine._ctx) {
					// Traverse the scenegraph and draw axis-aligned
					// bounding boxes for every object
					ctx.save();
					ctx.translate(-this._translate.x, -this._translate.y);
					this.paintAabbs(ctx, this._scene, 0);
					ctx.restore();
				}
				
				// Check if we should draw the mouse position on this
				// viewport (usually for debug purposes)
				if (this._drawMouse && ctx === $ige.engine._ctx) {
					ctx.save();
					var mp = this.mousePos(),
						text,
						mx,
						my,
						textMeasurement;
					
					// Re-scale the context to ensure that output is always 1:1
					ctx.scale(1 / this.camera._scale.x, 1 / this.camera._scale.y);
					
					// Work out the re-scale mouse position
					mx = Math.floor(mp.x * this.camera._scale.x);
					my = Math.floor(mp.y * this.camera._scale.y);
					
					ctx.fillStyle = '#fc00ff';
					ctx.fillRect(mx - 5, my - 5, 10, 10);
					
					text = this.id() + ' X: ' + mx + ', Y: ' + my;
					textMeasurement = ctx.measureText(text);
					ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
					ctx.fillRect(Math.floor(mx - textMeasurement.width / 2 - 5), Math.floor(my - 25), Math.floor(textMeasurement.width + 10), 14);
					ctx.fillStyle = '#ffffff';
					ctx.fillText(text, mx - textMeasurement.width / 2, my - 15);
					ctx.restore();
				}
				
				if (this._drawViewArea) {
					ctx.save();
					var va = this.viewArea();
					ctx.rect(va.x, va.y, va.width, va.height);
					ctx.stroke();
					ctx.restore();
				}
			}
		},
		
		/**
		 * Returns the screen position of the viewport as an IgePoint3d where x is the
		 * "left" and y is the "top", useful for positioning HTML elements at the
		 * screen location of an IGE entity. The returned values indicate the center
		 * of the viewport on the screen.
		 *
		 * This method assumes that the top-left
		 * of the main canvas element is at 0, 0. If not you can adjust the values
		 * yourself to allow for offset.
		 * @example #Get the screen position of the entity
		 *     var screenPos = entity.screenPosition();
		 * @return {IgePoint3d} The screen position of the entity.
		 */
		screenPosition: function () {
			return new IgePoint3d(
				Math.floor(this._worldMatrix.matrix[2] + $ige.engine._bounds2d.x2),
				Math.floor(this._worldMatrix.matrix[5] + $ige.engine._bounds2d.y2),
				0
			);
		},
		
		drawViewArea: function (val) {
			if (val !== undefined) {
				this._drawViewArea = val;
				return this;
			}
			
			return this._drawViewArea;
		},
		
		drawBoundsLimitId: function (id) {
			if (id !== undefined) {
				this._drawBoundsLimitId = id;
				return this;
			}
			
			return this._drawBoundsLimitId;
		},
		
		drawBoundsLimitCategory: function (category) {
			if (category !== undefined) {
				this._drawBoundsLimitCategory = category;
				return this;
			}
			
			return this._drawBoundsLimitCategory;
		},
		
		drawCompositeBounds: function (val) {
			if (val !== undefined) {
				this._drawCompositeBounds = val;
				return this;
			}
			
			return this._drawCompositeBounds;
		},
		
		drawGuides: function (val) {
			if (val !== undefined) {
				this._drawGuides = val;
				return this;
			}
			
			return this._drawGuides;
		},
		
		paintGuides: function (ctx) {
			var geom = $ige.engine._bounds2d;
			
			// Check draw-guides setting
			if (this._drawGuides) {
				ctx.strokeStyle = '#ffffff';
				
				ctx.translate(0.5, 0.5);
				
				// Draw guide lines in the center
				ctx.beginPath();
				ctx.moveTo(0, -geom.y2);
				ctx.lineTo(0, geom.y);
				ctx.stroke();
				
				ctx.beginPath();
				ctx.moveTo(-geom.x2, 0);
				ctx.lineTo(geom.x, 0);
				ctx.stroke();
			}
		},
		
		/**
		 * Draws the bounding data for each entity in the scenegraph.
		 * @param ctx
		 * @param rootObject
		 * @param index
		 */
		paintAabbs: function (ctx, rootObject, index) {
			var arr = rootObject._children,
				arrCount,
				obj,
				aabb,
				aabbC,
				bounds3dPoly,
				ga,
				r3d,
				xl1, xl2, xl3, xl4, xl5, xl6,
				bf1, bf2, bf3, bf4,
				tf1, tf2, tf3, tf4;
			
			if (arr) {
				arrCount = arr.length;
				
				while (arrCount--) {
					obj = arr[arrCount];
					index++;
					
					if (obj._shouldRender !== false) {
						if (obj._classId !== 'IgeScene2d' && (!this._drawBoundsLimitId && !this._drawBoundsLimitCategory) || ((this._drawBoundsLimitId && (this._drawBoundsLimitId instanceof Array ? this._drawBoundsLimitId.indexOf(obj.id()) > -1 : this._drawBoundsLimitId === obj.id())) || (this._drawBoundsLimitCategory && this._drawBoundsLimitCategory === obj.category()))) {
							if (typeof(obj.aabb) === 'function') {
								// Grab the AABB and then draw it
								aabb = obj.aabb();
								
								if (this._drawCompositeBounds && obj._compositeCache) {
									aabbC = obj.compositeAabb();
									
									// Draw composite bounds
									ctx.strokeStyle = '#ff0000';
									ctx.strokeRect(aabbC.x, aabbC.y, aabbC.width, aabbC.height);
								}
								
								if (aabb) {
									if (obj._drawBounds || obj._drawBounds === undefined) {
										//if (!obj._parent || (obj._parent && obj._parent._mountMode !== 1)) {
										// Draw a rect around the bounds of the object transformed in world space
										/*ctx.save();
										 obj._worldMatrix.transformRenderingContext(ctx);
										 ctx.strokeStyle = '#9700ae';
										 ctx.strokeRect(-obj._bounds2d.x2, -obj._bounds2d.y2, obj._bounds2d.x, obj._bounds2d.y);
										 ctx.restore();*/
										
										// Draw individual bounds
										ctx.strokeStyle = '#00deff';
										ctx.strokeRect(aabb.x, aabb.y, aabb.width, aabb.height);
										//}
										
										// Check if the object is mounted to an isometric mount
										if (obj._parent && obj._parent._mountMode === 1) {
											bounds3dPoly = obj.bounds3dPolygon().aabb();
											ctx.save();
											ctx.strokeStyle = '#0068b8';
											ctx.strokeRect(bounds3dPoly.x, bounds3dPoly.y, bounds3dPoly.width, bounds3dPoly.height);
											ctx.restore();
											
											ctx.save();
											ctx.translate(
												bounds3dPoly.x + bounds3dPoly.width / 2,
												bounds3dPoly.y + bounds3dPoly.height / 2
											);
											//obj._transformContext(ctx);
											
											// Calculate the 3d bounds data
											r3d = obj._bounds3d;
											xl1 = new IgePoint3d(-(r3d.x / 2), 0, 0).toIso();
											xl2 = new IgePoint3d(+(r3d.x / 2), 0, 0).toIso();
											xl3 = new IgePoint3d(0, -(r3d.y / 2), 0).toIso();
											xl4 = new IgePoint3d(0, +(r3d.y / 2), 0).toIso();
											xl5 = new IgePoint3d(0, 0, -(r3d.z / 2)).toIso();
											xl6 = new IgePoint3d(0, 0, +(r3d.z / 2)).toIso();
											// Bottom face
											bf1 = new IgePoint3d(-(r3d.x / 2), -(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf2 = new IgePoint3d(+(r3d.x / 2), -(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf3 = new IgePoint3d(+(r3d.x / 2), +(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf4 = new IgePoint3d(-(r3d.x / 2), +(r3d.y / 2),  -(r3d.z / 2)).toIso();
											// Top face
											tf1 = new IgePoint3d(-(r3d.x / 2), -(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf2 = new IgePoint3d(+(r3d.x / 2), -(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf3 = new IgePoint3d(+(r3d.x / 2), +(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf4 = new IgePoint3d(-(r3d.x / 2), +(r3d.y / 2),  (r3d.z / 2)).toIso();
											
											ga = ctx.globalAlpha;
											
											// Axis lines
											ctx.globalAlpha = 1;
											ctx.strokeStyle = '#ff0000';
											ctx.beginPath();
											ctx.moveTo(xl1.x, xl1.y);
											ctx.lineTo(xl2.x, xl2.y);
											ctx.stroke();
											ctx.strokeStyle = '#00ff00';
											ctx.beginPath();
											ctx.moveTo(xl3.x, xl3.y);
											ctx.lineTo(xl4.x, xl4.y);
											ctx.stroke();
											ctx.strokeStyle = '#fffc00';
											ctx.beginPath();
											ctx.moveTo(xl5.x, xl5.y);
											ctx.lineTo(xl6.x, xl6.y);
											ctx.stroke();
											
											ctx.strokeStyle = '#a200ff';
											
											if (obj._highlight) {
												ctx.globalAlpha = 0.9;
											} else {
												ctx.globalAlpha = 0.6;
											}
											
											// Left face
											ctx.fillStyle = '#545454';
											ctx.beginPath();
											ctx.moveTo(bf3.x, bf3.y);
											ctx.lineTo(bf4.x, bf4.y);
											ctx.lineTo(tf4.x, tf4.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(bf3.x, bf3.y);
											ctx.fill();
											ctx.stroke();
											
											// Right face
											ctx.fillStyle = '#282828';
											ctx.beginPath();
											ctx.moveTo(bf3.x, bf3.y);
											ctx.lineTo(bf2.x, bf2.y);
											ctx.lineTo(tf2.x, tf2.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(bf3.x, bf3.y);
											ctx.fill();
											ctx.stroke();
											
											// Top face
											ctx.fillStyle = '#676767';
											ctx.beginPath();
											ctx.moveTo(tf1.x, tf1.y);
											ctx.lineTo(tf2.x, tf2.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(tf4.x, tf4.y);
											ctx.lineTo(tf1.x, tf1.y);
											ctx.fill();
											ctx.stroke();
											
											ctx.globalAlpha = ga;
											ctx.restore();
										}
									}
									
									if (this._drawBoundsData  && (obj._drawBounds || obj._drawBoundsData === undefined)) {
										ctx.globalAlpha = 1;
										ctx.fillStyle = '#f6ff00';
										ctx.fillText('ID: ' + obj.id() + ' ' + '(' + obj.classId() + ') ' + obj.layer() + ':' + obj.depth().toFixed(0), aabb.x + aabb.width + 3, aabb.y + 10);
										ctx.fillText('X: ' + obj._translate.x.toFixed(2) + ', ' + 'Y: ' + obj._translate.y.toFixed(2) + ', ' + 'Z: ' + obj._translate.z.toFixed(2), aabb.x + aabb.width + 3, aabb.y + 20);
										ctx.fillText('Num Children: ' + obj._children.length, aabb.x + aabb.width + 3, aabb.y + 40);
									}
								}
							}
						}
						
						this.paintAabbs(ctx, obj, index);
					}
				}
			}
		},
		
		/**
		 * Handles screen resize events.
		 * @param event
		 * @private
		 */
		_resizeEvent: function (event) {
			if (this._autoSize && this._parent) {
				this._bounds2d = this._parent._bounds2d.clone();
			}
			
			this._updateUiPosition();
			
			// Resize the scene
			if (this._scene) {
				this._scene._resizeEvent(event);
			}
			
			// Process locked dimension scaling
			if (this._lockDimension) {
				// Calculate the new camera scale
				var ratio = 1,
					tmpX,
					tmpY;
				
				if (this._bounds2d.x > this._lockDimension.x && this._bounds2d.y > this._lockDimension.y) {
					// Scale using lowest ratio
					tmpX = this._bounds2d.x / this._lockDimension.x;
					tmpY = this._bounds2d.y / this._lockDimension.y;
					
					ratio = tmpX < tmpY ? tmpX : tmpY;
				} else {
					if (this._bounds2d.x > this._lockDimension.x && this._bounds2d.y < this._lockDimension.y) {
						// Scale out to show height
						ratio = this._bounds2d.y / this._lockDimension.y;
					}
					
					if (this._bounds2d.x < this._lockDimension.x && this._bounds2d.y > this._lockDimension.y) {
						// Scale out to show width
						ratio = this._bounds2d.x / this._lockDimension.x;
					}
					
					if (this._bounds2d.x < this._lockDimension.x && this._bounds2d.y < this._lockDimension.y) {
						// Scale using lowest ratio
						tmpX = this._bounds2d.x / this._lockDimension.x;
						tmpY = this._bounds2d.y / this._lockDimension.y;
						
						ratio = tmpX < tmpY ? tmpX : tmpY;
					}
				}
				
				this.camera.scaleTo(ratio, ratio, ratio);
			}
		},
		
		/**
		 * Returns a string containing a code fragment that when
		 * evaluated will reproduce this object's properties via
		 * chained commands. This method will only check for
		 * properties that are directly related to this class.
		 * Other properties are handled by their own class method.
		 * @return {String}
		 */
		_stringify: function () {
			// Get the properties for all the super-classes
			var str = IgeEntity.prototype._stringify.call(this), i;
			
			// Loop properties and add property assignment code to string
			for (i in this) {
				if (this.hasOwnProperty(i) && this[i] !== undefined) {
					switch (i) {
						case '_autoSize':
							str += ".autoSize(" + this._autoSize + ")";
							break;
						case '_scene':
							str += ".scene($ige.engine.$('" + this.scene().id() + "'))";
							break;
					}
				}
			}
			
			return str;
		}
	});
	
	return IgeViewport;
});
},{"irrelon-appcore":125}],92:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiPositionExtension', function () {
	var IgeUiPositionExtension = {
		/**
		 * Gets / sets the entity's x position relative to the left of
		 * the canvas.
		 * @param {Number} px
		 * @param {Boolean=} noUpdate
		 * @return {Number}
		 */
		left: function (px, noUpdate) {
			if (px !== undefined) {
				if (px === null) {
					// Remove all data
					delete this._uiLeft;
					delete this._uiLeftPercent;
				} else {
					delete this._uiCenter;
					delete this._uiCenterPercent;
					
					if (typeof(px) === 'string') {
						// Store the percentage value
						this._uiLeftPercent = px;
						
						// Check if we are already mounted
						var parentWidth,
							val = parseInt(px, 10),
							newVal;
						
						if (this._parent) {
							// We have a parent, use it's geometry
							parentWidth = this._parent._bounds2d.x;
						} else {
							// We don't have a parent so use the main canvas
							// as a reference
							parentWidth = $ige.engine._bounds2d.x;
						}
						
						// Calculate real width from percentage
						newVal = (parentWidth / 100 * val) | 0;
						
						this._uiLeft = newVal;
					} else {
						// The value passed is not a percentage, directly assign it
						this._uiLeft = px;
						delete this._uiLeftPercent;
					}
				}
				
				if (!noUpdate) {
					this._updateUiPosition();
				}
				return this;
			}
			
			return this._uiLeft;
		},
		
		/**
		 * Gets / sets the entity's x position relative to the right of
		 * the canvas.
		 * @param {Number} px
		 * @param {Boolean=} noUpdate
		 * @return {Number}
		 */
		right: function (px, noUpdate) {
			if (px !== undefined) {
				if (px === null) {
					// Remove all data
					delete this._uiRight;
					delete this._uiRightPercent;
				} else {
					delete this._uiCenter;
					delete this._uiCenterPercent;
					
					if (typeof(px) === 'string') {
						// Store the percentage value
						this._uiRightPercent = px;
						
						// Check if we are already mounted
						var parentWidth,
							val = parseInt(px, 10),
							newVal;
						
						if (this._parent) {
							// We have a parent, use it's geometry
							parentWidth = this._parent._bounds2d.x;
						} else {
							// We don't have a parent so use the main canvas
							// as a reference
							parentWidth = $ige.engine._bounds2d.x;
						}
						
						// Calculate real width from percentage
						newVal = (parentWidth / 100 * val) | 0;
						
						this._uiRight = newVal;
					} else {
						// The value passed is not a percentage, directly assign it
						this._uiRight = px;
						delete this._uiRightPercent;
					}
				}
				
				if (!noUpdate) {
					this._updateUiPosition();
				}
				return this;
			}
			
			return this._uiRight;
		},
		
		/**
		 * Gets / sets the viewport's x position relative to the center of
		 * the entity parent.
		 * @param {Number} px
		 * @param {Boolean=} noUpdate
		 * @return {Number}
		 */
		center: function (px, noUpdate) {
			if (px !== undefined) {
				if (px === null) {
					// Remove all data
					delete this._uiCenter;
					delete this._uiCenterPercent;
				} else {
					delete this._uiLeft;
					delete this._uiLeftPercent;
					delete this._uiRight;
					delete this._uiRightPercent;
					
					if (typeof(px) === 'string') {
						// Store the percentage value
						this._uiCenterPercent = px;
						
						// Check if we are already mounted
						var parentWidth,
							val = parseInt(px, 10),
							newVal;
						
						if (this._parent) {
							// We have a parent, use it's geometry
							parentWidth = this._parent._bounds2d.x2;
						} else {
							// We don't have a parent so use the main canvas
							// as a reference
							parentWidth = $ige.engine._bounds2d.x2;
						}
						
						// Calculate real width from percentage
						newVal = (parentWidth / 100 * val) | 0;
						
						this._uiCenter = newVal;
					} else {
						// The value passed is not a percentage, directly assign it
						this._uiCenter = px;
						delete this._uiCenterPercent;
					}
				}
				
				if (!noUpdate) {
					this._updateUiPosition();
				}
				return this;
			}
			
			return this._uiCenter;
		},
		
		/**
		 * Gets / sets the entity's y position relative to the top of
		 * the canvas.
		 * @param {Number} px
		 * @param {Boolean=} noUpdate
		 * @return {Number}
		 */
		top: function (px, noUpdate) {
			if (px !== undefined) {
				if (px === null) {
					// Remove all data
					delete this._uiTop;
					delete this._uiTopPercent;
				} else {
					delete this._uiMiddle;
					delete this._uiMiddlePercent;
					
					if (typeof(px) === 'string') {
						// Store the percentage value
						this._uiTopPercent = px;
						
						// Check if we are already mounted
						var parentHeight,
							val = parseInt(px, 10),
							newVal;
						
						if (this._parent) {
							// We have a parent, use it's geometry
							parentHeight = this._parent._bounds2d.y;
						} else {
							// We don't have a parent so use the main canvas
							// as a reference
							parentHeight = $ige.engine._bounds2d.y;
						}
						
						// Calculate real width from percentage
						newVal = (parentHeight / 100 * val) | 0;
						
						this._uiTop = newVal;
					} else {
						// The value passed is not a percentage, directly assign it
						this._uiTop = px;
						delete this._uiTopPercent;
					}
				}
				
				if (!noUpdate) {
					this._updateUiPosition();
				}
				return this;
			}
			
			return this._uiTop;
		},
		
		/**
		 * Gets / sets the entity's y position relative to the bottom of
		 * the canvas.
		 * @param {Number} px
		 * @param {Boolean=} noUpdate
		 * @return {Number}
		 */
		bottom: function (px, noUpdate) {
			if (px !== undefined) {
				if (px === null) {
					// Remove all data
					delete this._uiBottom;
					delete this._uiBottomPercent;
				} else {
					delete this._uiMiddle;
					delete this._uiMiddlePercent;
					
					if (typeof(px) === 'string') {
						// Store the percentage value
						this._uiBottomPercent = px;
						
						// Check if we are already mounted
						var parentHeight,
							val = parseInt(px, 10),
							newVal;
						
						if (this._parent) {
							// We have a parent, use it's geometry
							parentHeight = this._parent._bounds2d.y;
						} else {
							// We don't have a parent so use the main canvas
							// as a reference
							parentHeight = $ige.engine._bounds2d.y;
						}
						
						// Calculate real width from percentage
						newVal = (parentHeight / 100 * val) | 0;
						
						this._uiBottom = newVal;
					} else {
						// The value passed is not a percentage, directly assign it
						this._uiBottom = px;
						delete this._uiBottomPercent;
					}
				}
				
				if (!noUpdate) {
					this._updateUiPosition();
				}
				return this;
			}
			
			return this._uiBottom;
		},
		
		/**
		 * Gets / sets the viewport's y position relative to the middle of
		 * the canvas.
		 * @param {Number} px
		 * @param {Boolean=} noUpdate
		 * @return {Number}
		 */
		middle: function (px, noUpdate) {
			if (px !== undefined) {
				if (px === null) {
					// Remove all data
					delete this._uiMiddle;
					delete this._uiMiddlePercent;
				} else {
					delete this._uiTop;
					delete this._uiTopPercent;
					delete this._uiBottom;
					delete this._uiBottomPercent;
					
					if (typeof(px) === 'string') {
						// Store the percentage value
						this._uiMiddlePercent = px;
						
						// Check if we are already mounted
						var parentWidth,
							val = parseInt(px, 10),
							newVal;
						
						if (this._parent) {
							// We have a parent, use it's geometry
							parentWidth = this._parent._bounds2d.y2;
						} else {
							// We don't have a parent so use the main canvas
							// as a reference
							parentWidth = $ige.engine._bounds2d.y2;
						}
						
						// Calculate real width from percentage
						newVal = (parentWidth / 100 * val) | 0;
						
						this._uiMiddle = newVal;
					} else {
						// The value passed is not a percentage, directly assign it
						this._uiMiddle = px;
						delete this._uiMiddlePercent;
					}
				}
				
				if (!noUpdate) {
					this._updateUiPosition();
				}
				return this;
			}
			
			return this._uiMiddle;
		},
		
		/**
		 * Gets / sets the geometry.x in pixels.
		 * @param {Number, String=} px Either the width in pixels or a percentage
		 * @param {Boolean=} lockAspect
		 * @param {Number=} modifier A value to add to the final width. Useful when
		 * you want to alter a percentage value by a certain number of pixels after
		 * it has been calculated.
		 * @param {Boolean=} noUpdate
		 * @return {*}
		 */
		width: function (px, lockAspect, modifier, noUpdate) {
			if (px !== undefined) {
				if (px === null) {
					// Remove all data
					delete this._uiWidth;
					this._bounds2d.x = 0;
					this._bounds2d.x2 = 0;
				} else {
					this._uiWidth = px;
					this._widthModifier = modifier !== undefined ? modifier : 0;
					
					if (typeof(px) === 'string') {
						if (this._parent) {
							// Percentage
							var parentWidth = this._parent._bounds2d.x,
								val = parseInt(px, 10),
								newVal,
								ratio;
							
							// Calculate real width from percentage
							newVal = (parentWidth / 100 * val) + this._widthModifier | 0;
							
							if (lockAspect) {
								// Calculate the height from the change in width
								ratio = newVal / this._bounds2d.x;
								this.height(this._bounds2d.y / ratio, false, 0, noUpdate);
							}
							
							this._bounds2d.x = newVal;
							this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
						} else {
							// We don't have a parent so use the main canvas
							// as a reference
							var parentWidth = $ige.engine._bounds2d.x,
								val = parseInt(px, 10);
							
							// Calculate real height from percentage
							this._bounds2d.x = (parentWidth / 100 * val) + this._widthModifier | 0;
							this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
						}
					} else {
						if (lockAspect) {
							// Calculate the height from the change in width
							var ratio = px / this._bounds2d.x;
							this.height(this._bounds2d.y * ratio, false, 0, noUpdate);
						}
						
						this._bounds2d.x = px;
						this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
					}
				}
				
				if (!noUpdate) {
					this._updateUiPosition();
				}
				return this;
			}
			
			return this._bounds2d.x;
		},
		
		/**
		 * Gets / sets the geometry.y in pixels.
		 * @param {Number=} px
		 * @param {Boolean=} lockAspect
		 * @param {Number=} modifier A value to add to the final height. Useful when
		 * you want to alter a percentage value by a certain number of pixels after
		 * it has been calculated.
		 * @param {Boolean=} noUpdate
		 * @return {*}
		 */
		height: function (px, lockAspect, modifier, noUpdate) {
			if (px !== undefined) {
				if (px === null) {
					// Remove all data
					delete this._uiHeight;
					this._bounds2d.y = 0;
					this._bounds2d.y2 = 0;
				} else {
					this._uiHeight = px;
					this._heightModifier = modifier !== undefined ? modifier : 0;
					
					if (typeof(px) === 'string') {
						if (this._parent) {
							// Percentage
							var parentHeight = this._parent._bounds2d.y,
								val = parseInt(px, 10),
								newVal,
								ratio;
							
							// Calculate real height from percentage
							// Calculate real width from percentage
							newVal = (parentHeight / 100 * val) + this._heightModifier | 0;
							
							if (lockAspect) {
								// Calculate the height from the change in width
								ratio = newVal / this._bounds2d.y;
								this.width(this._bounds2d.x / ratio, false, 0, noUpdate);
							}
							
							this._bounds2d.y = newVal;
							this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
						} else {
							// We don't have a parent so use the main canvas
							// as a reference
							var parentHeight = $ige.engine._bounds2d.y,
								val = parseInt(px, 10);
							
							// Calculate real height from percentage
							this._bounds2d.y = (parentHeight / 100 * val) + this._heightModifier | 0;
							this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
						}
					} else {
						if (lockAspect) {
							// Calculate the height from the change in width
							var ratio = px / this._bounds2d.y;
							this.width(this._bounds2d.x * ratio, false, 0, noUpdate);
						}
						
						this._bounds2d.y = px;
						this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
					}
				}
				
				if (!noUpdate) {
					this._updateUiPosition();
				}
				return this;
			}
			
			return this._bounds2d.y;
		},
		
		autoScaleX: function (val, lockAspect) {
			if (val !== undefined) {
				this._autoScaleX = val;
				this._autoScaleLockAspect = lockAspect;
				
				this._updateUiPosition();
				return this;
			}
			
			return this._autoScaleX;
		},
		
		autoScaleY: function (val, lockAspect) {
			if (val !== undefined) {
				this._autoScaleY = val;
				this._autoScaleLockAspect = lockAspect;
				
				this._updateUiPosition();
				return this;
			}
			
			return this._autoScaleY;
		},
		
		/**
		 * Updates the UI position of every child entity down the scenegraph
		 * for this UI entity.
		 * @return {*}
		 */
		updateUiChildren: function () {
			var arr = this._children,
				arrCount,
				arrItem;
			
			if (arr) {
				arrCount = arr.length;
				
				while (arrCount--) {
					arrItem = arr[arrCount];
					if (arrItem._updateUiPosition) {
						arrItem._updateUiPosition();
					}
					
					if (typeof(arrItem.updateUiChildren) === 'function') {
						arrItem.updateUiChildren();
					}
				}
			}
			
			return this;
		},
		
		/**
		 * Sets the correct translate x and y for the viewport's left, right
		 * top and bottom co-ordinates.
		 * @private
		 */
		_updateUiPosition: function () {
			if (this._parent) {
				var parentGeom = this._parent._bounds2d,
					geomScaled = this._bounds2d.multiplyPoint(this._scale),
					percent,
					newVal,
					ratio;
				
				/*if (this._ignoreCamera && $ige._currentCamera) {
				 // Handle cam ignore when calculating
				 parentGeom = parentGeom.dividePoint($ige._currentCamera._scale);
				 }*/
				
				if (this._autoScaleX) {
					// Get the percentage as an integer
					percent = parseInt(this._autoScaleX, 10);
					
					// Calculate new width from percentage
					newVal = (parentGeom.x / 100 * percent);
					
					// Calculate scale ratio
					ratio = newVal / this._bounds2d.x;
					
					// Set the new scale
					this._scale.x = ratio;
					
					if (this._autoScaleLockAspect) {
						this._scale.y = ratio;
					}
				}
				
				if (this._autoScaleY) {
					// Get the percentage as an integer
					percent = parseInt(this._autoScaleY, 10);
					
					// Calculate new height from percentage
					newVal = (parentGeom.y / 100 * percent);
					
					// Calculate scale ratio
					ratio = newVal / this._bounds2d.y;
					
					// Set the new scale
					this._scale.y = ratio;
					
					if (this._autoScaleLockAspect) {
						this._scale.x = ratio;
					}
				}
				
				if (this._uiWidth) {
					this.width(this._uiWidth, false, this._widthModifier, true);
				}
				if (this._uiHeight) {
					this.height(this._uiHeight, false, this._heightModifier, true);
				}
				
				if (this._uiCenterPercent) {
					this.center(this._uiCenterPercent, true);
				}
				if (this._uiMiddlePercent) {
					this.middle(this._uiMiddlePercent, true);
				}
				if (this._uiLeftPercent) {
					this.left(this._uiLeftPercent, true);
				}
				if (this._uiRightPercent) {
					this.right(this._uiRightPercent, true);
				}
				if (this._uiTopPercent) {
					this.top(this._uiTopPercent, true);
				}
				if (this._uiBottomPercent) {
					this.bottom(this._uiBottomPercent, true);
				}
				
				if (this._uiCenter !== undefined) {
					// The element is center-aligned
					this._translate.x = Math.floor(this._uiCenter);
				} else {
					// The element is not center-aligned, process left and right
					if (this._uiLeft !== undefined && this._uiRight !== undefined) {
						// Both left and right values are set, position left and assign width to reach right
						this.width((parentGeom.x) - this._uiLeft - this._uiRight, false, 0, true);
						
						// Update translation
						this._translate.x = Math.floor(this._uiLeft + geomScaled.x2 - (parentGeom.x2));
					} else {
						if (this._uiLeft !== undefined) {
							// Position left aligned
							this._translate.x = Math.floor(this._uiLeft + geomScaled.x2 - (parentGeom.x2));
						}
						
						if (this._uiRight !== undefined) {
							// Position right aligned
							this._translate.x = Math.floor(parentGeom.x2 - geomScaled.x2 - this._uiRight);
						}
					}
				}
				
				if (this._uiMiddle !== undefined) {
					// The element is middle-aligned
					this._translate.y = Math.floor(this._uiMiddle);
				} else {
					// The element is not middle-aligned, process top and bottom
					if (this._uiTop !== undefined && this._uiBottom !== undefined) {
						// Both top and bottom values are set, position top and assign height to reach bottom
						this.height((parentGeom.y) - this._uiTop - this._uiBottom, false, 0, true);
						
						// Update translation
						this._translate.y = Math.floor(this._uiTop + geomScaled.y2 - (parentGeom.y2));
					} else {
						if (this._uiTop !== undefined) {
							// Position top aligned
							this._translate.y = Math.floor(this._uiTop + geomScaled.y2 - (parentGeom.y2));
						}
						
						if (this._uiBottom !== undefined) {
							// Position bottom aligned
							this._translate.y = Math.floor(parentGeom.y2 - geomScaled.y2 - this._uiBottom);
						}
					}
				}
				
				this.emit('uiUpdate');
				
				this.cacheDirty(true);
			}
		}
	};
	
	return IgeUiPositionExtension;
});
},{"irrelon-appcore":125}],93:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiStyleExtension', function () {
	// TODO: Add "overflow" with automatic scroll-bars
	var IgeUiStyleExtension = {
		/**
		 * Gets / sets the color to use as the font color.
		 * @param {CSSColor, CanvasGradient, CanvasPattern=} color
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		color: function (color) {
			if (color !== undefined) {
				this._color = color;
				this.cacheDirty(true);
				return this;
			}
			
			return this._color;
		},
		
		/**
		 * Sets the current background texture and the repeatType
		 * to determine in which axis the image should be repeated.
		 * @param {IgeTexture=} texture
		 * @param {String=} repeatType Accepts "repeat", "repeat-x",
		 * "repeat-y" and "no-repeat".
		 * @return {*} Returns this if any parameter is specified or
		 * the current background image if no parameters are specified.
		 */
		backgroundImage: function (texture, repeatType) {
			if (texture && texture.image) {
				if (!repeatType) {
					repeatType = 'no-repeat';
				}
				
				// Store the repeatType
				this._patternRepeat = repeatType;
				
				// Store the texture
				this._patternTexture = texture;
				
				// Resize the image if required
				if (this._backgroundSize) {
					texture.resize(this._backgroundSize.x, this._backgroundSize.y);
					this._patternWidth = this._backgroundSize.x;
					this._patternHeight = this._backgroundSize.y;
				} else {
					this._patternWidth = texture.image.width;
					this._patternHeight = texture.image.height;
				}
				
				if (this._cell > 1) {
					// We are using a cell sheet, render the cell to a
					// temporary canvas and set that as the pattern image
					var canvas = document.createElement('canvas'),
						ctx = canvas.getContext('2d'),
						cellData = texture._cells[this._cell];
					
					canvas.width = cellData[2];
					canvas.height = cellData[3];
					
					ctx.drawImage(
						texture.image,
						cellData[0],
						cellData[1],
						cellData[2],
						cellData[3],
						0,
						0,
						cellData[2],
						cellData[3]
					);
					
					// Create the pattern from the texture cell
					this._patternFill = $ige.engine._ctx.createPattern(canvas, repeatType);
				} else {
					// Create the pattern from the texture
					this._patternFill = $ige.engine._ctx.createPattern(texture.image, repeatType);
				}
				
				texture.restoreOriginal();
				this.cacheDirty(true);
				return this;
			}
			
			return this._patternFill;
		},
		
		backgroundSize: function (x, y) {
			if (x !== undefined && y !== undefined) {
				
				if (typeof(x) === 'string' && x !== 'auto') {
					// Work out the actual size in pixels
					// from the percentage
					x = this._bounds2d.x / 100 * parseInt(x, 10);
				}
				
				if (typeof(y) === 'string' && y !== 'auto') {
					// Work out the actual size in pixels
					// from the percentage
					y = this._bounds2d.y / 100 * parseInt(y, 10);
				}
				
				if (x === 'auto' && y === 'auto') {
					this.log('Cannot set background x and y both to auto!', 'error');
					return this;
				} else if (x === 'auto') {
					if (this._patternTexture && this._patternTexture.image) {
						// find out y change and apply it to the x
						x = this._patternTexture.image.width * (y / this._patternTexture.image.height);
					} else {
						x = this._bounds2d.x * (y / this._bounds2d.y);
					}
				} else if (y === 'auto') {
					if (this._patternTexture && this._patternTexture.image) {
						// find out x change and apply it to the y
						y = this._patternTexture.image.height * (x / this._patternTexture.image.width);
					} else {
						y = this._bounds2d.y * (x / this._bounds2d.x);
					}
				}
				
				if (x !== 0 && y !== 0) {
					this._backgroundSize = {x: x, y: y};
					
					// Reset the background image
					if (this._patternTexture && this._patternRepeat) {
						this.backgroundImage(this._patternTexture, this._patternRepeat);
					}
					this.cacheDirty(true);
				} else {
					this.log('Cannot set background to zero-sized x or y!', 'error');
				}
				return this;
			}
			
			return this._backgroundSize;
		},
		
		/**
		 * Gets / sets the color to use as a background when
		 * rendering the UI element.
		 * @param {CSSColor, CanvasGradient, CanvasPattern=} color
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		backgroundColor: function (color) {
			if (color !== undefined) {
				this._backgroundColor = color;
				this.cacheDirty(true);
				return this;
			}
			
			return this._backgroundColor;
		},
		
		/**
		 * Gets / sets the position to start rendering the background image at.
		 * @param {Number=} x
		 * @param {Number=} y
		 * @return {*} Returns this when setting the value or the current value if none is specified.
		 */
		backgroundPosition: function (x, y) {
			if (x !== undefined && y !== undefined) {
				this._backgroundPosition = {x: x, y: y};
				this.cacheDirty(true);
				return this;
			}
			
			return this._backgroundPosition;
		},
		
		borderColor: function (color) {
			if (color !== undefined) {
				this._borderColor = color;
				this._borderLeftColor = color;
				this._borderTopColor = color;
				this._borderRightColor = color;
				this._borderBottomColor = color;
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderColor;
		},
		
		borderLeftColor: function (color) {
			if (color !== undefined) {
				this._borderLeftColor = color;
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderLeftColor;
		},
		
		borderTopColor: function (color) {
			if (color !== undefined) {
				this._borderTopColor = color;
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderTopColor;
		},
		
		borderRightColor: function (color) {
			if (color !== undefined) {
				this._borderRightColor = color;
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderRightColor;
		},
		
		borderBottomColor: function (color) {
			if (color !== undefined) {
				this._borderBottomColor = color;
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderBottomColor;
		},
		
		borderWidth: function (px) {
			if (px !== undefined) {
				this._borderWidth = px;
				this._borderLeftWidth = px;
				this._borderTopWidth = px;
				this._borderRightWidth = px;
				this._borderBottomWidth = px;
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderWidth;
		},
		
		borderLeftWidth: function (px) {
			if (px !== undefined) {
				this._borderLeftWidth = px;
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderLeftWidth;
		},
		
		borderTopWidth: function (px) {
			if (px !== undefined) {
				this._borderTopWidth = px;
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderTopWidth;
		},
		
		borderRightWidth: function (px) {
			if (px !== undefined) {
				this._borderRightWidth = px;
				
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderRightWidth;
		},
		
		borderBottomWidth: function (px) {
			if (px !== undefined) {
				this._borderBottomWidth = px;
				
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderBottomWidth;
		},
		
		borderRadius: function (px) {
			if (px !== undefined) {
				this._borderRadius = px;
				this._borderTopLeftRadius = px;
				this._borderTopRightRadius = px;
				this._borderBottomRightRadius = px;
				this._borderBottomLeftRadius = px;
				
				this.cacheDirty(true);
				return this;
			}
			
			return this._borderRadius;
		},
		
		padding: function (left, top, right, bottom) {
			this._paddingLeft = left;
			this._paddingTop = top;
			this._paddingRight = right;
			this._paddingBottom = bottom;
			
			this.cacheDirty(true);
			return this;
		},
		
		paddingLeft: function (px) {
			if (px !== undefined) {
				this._paddingLeft = px;
				
				this.cacheDirty(true);
				return this;
			}
			
			return this._paddingLeft;
		},
		
		paddingTop: function (px) {
			if (px !== undefined) {
				this._paddingTop = px;
				
				this.cacheDirty(true);
				return this;
			}
			
			return this._paddingTop;
		},
		
		paddingRight: function (px) {
			if (px !== undefined) {
				this._paddingRight = px;
				
				this.cacheDirty(true);
				return this;
			}
			
			return this._paddingRight;
		},
		
		paddingBottom: function (px) {
			if (px !== undefined) {
				this._paddingBottom = px;
				
				this.cacheDirty(true);
				return this;
			}
			
			return this._paddingBottom;
		}
	};
	
	return IgeUiStyleExtension;
});
},{"irrelon-appcore":125}],94:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.blur', function (IgeFilters) {
	IgeFilters.blur = function (canvas, ctx, originalImage, texture, data) {
		var strength = 1,
			loop,
			oneNinth = 1 / 9,
			pixelData;
		
		pixelData = ctx.getImageData(
			0,
			0,
			canvas.width,
			canvas.height
		);
		
		if (data && data.value) {
			strength = data.value;
		}
		
		for (loop = 0; loop < strength; loop++) {
			pixelData = IgeFilters._convolute(
				pixelData,
				[
					oneNinth, oneNinth, oneNinth,
					oneNinth, oneNinth, oneNinth,
					oneNinth, oneNinth, oneNinth
				]
			);
		}
		
		// Put the new pixel data
		ctx.putImageData(
			pixelData,
			0,
			0
		);
	};
});
},{"irrelon-appcore":125}],95:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.brighten', function (IgeFilters) {
	IgeFilters.brighten = function (canvas, ctx, originalImage, texture, data) {
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			IgeFilters._brighten(
				ctx.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				),
				texture,
				data
			),
			0,
			0
		);
	};
	
	IgeFilters._brighten = function (imageData, texture, data) {
		var arr,
			arrCount,
			i, adjustment = texture.data('IgeFilters.brighten.value') || data.value;
		
		arr = imageData.data;
		arrCount = arr.length;
		
		for (i = 0; i < arrCount; i += 4) {
			arr[i] += adjustment;
			arr[i + 1] += adjustment;
			arr[i + 2] += adjustment;
		}
		
		return imageData;
	};
});
},{"irrelon-appcore":125}],96:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.colorOverlay', function (IgeFilters) {
	IgeFilters.colorOverlay = function (canvas, ctx, originalImage, texture, data) {
		// Set the composite operation and draw the colour over the top
		ctx.globalCompositeOperation = 'source-atop';
		
		ctx.fillStyle = data.color;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	};
});
},{"irrelon-appcore":125}],97:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.createImageData', function (IgeFilters) {
	IgeFilters.createImageData = function (w, h) {
		return IgeFilters.tmpCtx.createImageData(w, h);
	};
	
	IgeFilters._convolute = function (pixels, weights, opaque) {
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);
		var src = pixels.data;
		var sw = pixels.width;
		var sh = pixels.height;
		// pad output by the convolution matrix
		var w = sw;
		var h = sh;
		var output = IgeFilters.createImageData(w, h);
		var dst = output.data;
		// go through the destination image pixels
		var alphaFac = opaque ? 1 : 0;
		for (var y = 0; y < h; y++) {
			for (var x = 0; x < w; x++) {
				var sy = y;
				var sx = x;
				var dstOff = (y * w + x) * 4;
				// calculate the weighed sum of the source image pixels that
				// fall under the convolution matrix
				var r = 0, g = 0, b = 0, a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = sy + cy - halfSide;
						var scx = sx + cx - halfSide;
						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
							var srcOff = (scy * sw + scx) * 4;
							var wt = weights[cy * side + cx];
							r += src[srcOff] * wt;
							g += src[srcOff + 1] * wt;
							b += src[srcOff + 2] * wt;
							a += src[srcOff + 3] * wt;
						}
					}
				}
				dst[dstOff] = r;
				dst[dstOff + 1] = g;
				dst[dstOff + 2] = b;
				dst[dstOff + 3] = a + alphaFac * (255 - a);
			}
		}
		return output;
	};
});
},{"irrelon-appcore":125}],98:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.edgeDetect', function (IgeFilters) {
	IgeFilters.edgeDetect = function (canvas, ctx, originalImage, texture, data) {
		if (!texture._filterImageDrawn || !data || !data.cumulative) {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.drawImage(originalImage, 0, 0);
			texture._filterImageDrawn = true;
		}
		
		var newData = IgeFilters._convolute(
			ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			),
			[
				-1,	-1,	-1,	-1,	-1,
				-1,	2,	2,	2,	-1,
				-1,	2,	0,	2,	-1,
				-1,	2,	2,	2,	-1,
				-1,	-1,	-1,	-1,	-1
			],
			true
			),
			arr = newData.data,
			arrCount = arr.length,
			i, r, g, b, v;
		
		for (i = 0; i < arrCount; i += 4) {
			r = arr[i];
			g = arr[i+1];
			b = arr[i+2];
			
			v = (r + g + b) / 3;
			v *= 1.1;
			
			v = v >= data.value ? 255 : 0;
			
			arr[i] = arr[i+1] = arr[i+2] = v;
		}
		
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			newData,
			0,
			0
		);
	};
});
},{"irrelon-appcore":125}],99:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.edgeEnhance', function (IgeFilters) {
	IgeFilters.edgeEnhance = function (canvas, ctx, originalImage, texture, data) {
		if (!texture._filterImageDrawn || !data || !data.cumulative) {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.drawImage(originalImage, 0, 0);
			texture._filterImageDrawn = true;
		}
		
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			IgeFilters._convolute(
				ctx.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				),
				[
					0, 0, 0,
					-1,  1, 0,
					0, 0, 0
				],
				true
			),
			0,
			0
		);
	};
});
},{"irrelon-appcore":125}],100:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.emboss', function (IgeFilters) {
	IgeFilters.emboss = function (canvas, ctx, originalImage, texture, data) {
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			IgeFilters._convolute(
				ctx.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				),
				[
					-2, -1, 0,
					-1,  1, 1,
					0, 1, 2
				]
			),
			0,
			0
		);
	};
});
},{"irrelon-appcore":125}],101:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.glowMask', function (IgeFilters) {
	IgeFilters.glowMask = function (canvas, ctx, originalImage, texture, data) {
		var oneNinth = 1 / 9,
			pixelData,
			tempCanvas,
			tempCtx,
			i;
		
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		
		if (data.blurPasses) {
			ctx.drawImage(data.glowMask.image, 0, 0);
			
			pixelData = ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			);
			
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			for (i = 0; i < data.blurPasses; i++) {
				pixelData = IgeFilters._convolute(
					pixelData,
					[
						oneNinth, oneNinth,  oneNinth,
						oneNinth, oneNinth,  oneNinth,
						oneNinth, oneNinth,  oneNinth
					],
					false
				);
			}
			
			tempCanvas = document.createElement("canvas");
			tempCtx = tempCanvas.getContext('2d');
			
			tempCanvas.width = canvas.width;
			tempCanvas.height = canvas.height;
			
			tempCtx.putImageData(pixelData, 0, 0);
		} else {
			tempCanvas = data.glowMask.image;
		}
		
		ctx.drawImage(originalImage, 0, 0);
		
		ctx.globalCompositeOperation = "lighter";
		
		for (i = 0; i < data.glowPasses; i++) {
			// Apply the filter and then put the new pixel data
			ctx.drawImage(tempCanvas, 0, 0);
		}
	};
});
},{"irrelon-appcore":125}],102:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.greyScale', function (IgeFilters) {
	IgeFilters.greyScale = function (canvas, ctx, originalImage, texture, data) {
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			IgeFilters._greyScale(
				ctx.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				)
			),
			0,
			0
		);
	};
	
	IgeFilters._greyScale = function (imageData) {
		var arr,
			arrCount,
			i, r, g, b, v;
		
		arr = imageData.data;
		arrCount = arr.length;
		
		for (i = 0; i < arrCount; i += 4) {
			// Extract pixel colour values
			r = arr[i];
			g = arr[i + 1];
			b = arr[i + 2];
			
			// CIE luminance for the RGB
			// The human eye is bad at seeing red and blue, so we de-emphasize them.
			v = 0.2126 * r + 0.7152 * g + 0.0722 * b;
			
			// Set the new pixel colour value
			arr[i] = arr[i + 1] = arr[i + 2] = v;
		}
		
		return imageData;
	};
});
},{"irrelon-appcore":125}],103:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.invert', function (IgeFilters) {
	IgeFilters.invert = function (canvas, ctx, originalImage, texture, data) {
		var w, h, canvasData, i;
		w = canvas.width;
		h = canvas.height;
		
		canvasData = ctx.getImageData(0, 0, w, h);
		
		for (i = 0; i < w * h * 4; i += 4)  {
			canvasData.data[i] = 255 - canvasData.data[i];
			canvasData.data[i+1] = 255 - canvasData.data[i+1];
			canvasData.data[i+2] = 255 - canvasData.data[i+2];
		}
		
		ctx.putImageData(canvasData, 0, 0);
	};
});
},{"irrelon-appcore":125}],104:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.outlineDetect', function (IgeFilters) {
	IgeFilters.outlineDetect = function (canvas, ctx, originalImage, texture, data) {
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			IgeFilters._convolute(
				ctx.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				),
				[
					0, 1, 0,
					1,  -4, 1,
					0, 1, 0
				]
			),
			0,
			0
		);
	};
});
},{"irrelon-appcore":125}],105:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.sharpen', function (IgeFilters) {
	IgeFilters.sharpen = function (canvas, ctx, originalImage, texture, data) {
		var strength = 1,
			loop;
		
		if (data && data.value) {
			strength = data.value;
		}
		
		for (loop = 0; loop < strength; loop++) {
			// Apply the filter and then put the new pixel data
			ctx.putImageData(
				IgeFilters._convolute(
					ctx.getImageData(
						0,
						0,
						canvas.width,
						canvas.height
					),
					[  0, -1,  0,
						-1,  5, -1,
						0, -1,  0 ]
				),
				0,
				0
			);
		}
	};
});
},{"irrelon-appcore":125}],106:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.sobel', function (IgeFilters) {
	IgeFilters.sobel = function (canvas, ctx, originalImage, texture, data) {
		var strength = 1,
			loop;
		
		if (data && data.value) {
			strength = data.value;
		}
		
		for (loop = 0; loop < strength; loop++) {
			// Apply the filter and then put the new pixel data
			ctx.putImageData(
				IgeFilters._convolute(
					ctx.getImageData(
						0,
						0,
						canvas.width,
						canvas.height
					),
					[
						-1, -1, 1,
						-2, 0, 2,
						-1, 1, 1
					],
					true
				),
				0,
				0
			);
		}
		
		//IgeFilters._invert(canvas, ctx);
	};
	
	IgeFilters._invert = function (canvas, ctx) {
		var w, h, canvasData, i;
		w = canvas.width;
		h = canvas.height;
		
		canvasData = ctx.getImageData(0, 0, w, h);
		
		for (i = 0; i < w * h * 4; i += 4) {
			canvasData.data[i] = 255 - canvasData.data[i];
			canvasData.data[i + 1] = 255 - canvasData.data[i + 1];
			canvasData.data[i + 2] = 255 - canvasData.data[i + 2];
		}
		
		ctx.putImageData(canvasData, 0, 0);
	};
});
},{"irrelon-appcore":125}],107:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeFilters.threshold', function (IgeFilters) {
	IgeFilters.threshold = function (canvas, ctx, originalImage, texture, data) {
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			IgeFilters._threshold(
				ctx.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				),
				texture,
				data
			),
			0,
			0
		);
	};
	
	IgeFilters._threshold = function (imageData, texture, data) {
		var arr,
			arrCount,
			i, r, g, b, v,
			threshold = texture.data('IgeFilters.threshold.value') || data.value;
		
		arr = imageData.data;
		arrCount = arr.length;
		
		for (i = 0; i < arrCount; i += 4) {
			r = arr[i];
			g = arr[i + 1];
			b = arr[i + 2];
			v = (0.2126 * r + 0.7152 * g + 0.0722 * b >= threshold) ? 255 : 0;
			arr[i] = arr[i + 1] = arr[i + 2] = v;
		}
		
		return imageData;
	};
});
},{"irrelon-appcore":125}],108:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeCuboid', function (IgeEntity, IgeTexture, IgeCuboidSmartTexture) {
	var IgeCuboid = IgeEntity.extend({
		classId: 'IgeCuboid',
		
		init: function () {
			IgeEntity.prototype.init.call(this);
			
			this.bounds3d(40, 40, 40);
			
			var tex = new IgeTexture(IgeCuboidSmartTexture);
			this.texture(tex);
		}
	});
	
	return IgeCuboid;
});
},{"irrelon-appcore":125}],109:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiAutoFlow', function (IgeUiElement) {
	var IgeUiAutoFlow = IgeUiElement.extend({
		classId: 'IgeUiAutoFlow',
		
		init: function () {
			IgeUiElement.prototype.init.call(this);
			
			this._currentHeight = 0;
		},
		
		tick: function (ctx) {
			// Loop children and re-position then
			var arr = this._children,
				arrCount = arr.length, i,
				item, itemY, currentY = 0;
			
			for (i = 0; i < arrCount; i++) {
				item = arr[i];
				itemY = item._bounds2d.y;
				
				item.top(currentY);
				
				currentY += itemY;
			}
			
			// Now do the super-class tick
			IgeUiElement.prototype.tick.call(this, ctx);
		}
	});
	
	return IgeUiAutoFlow;
});
},{"irrelon-appcore":125}],110:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiButton', function (IgeUiElement) {
	var IgeUiButton = IgeUiElement.extend({
		classId: 'IgeUiButton',
		
		init: function () {
			var self = this;
			
			IgeUiElement.prototype.init.call(this);
			
			this.on('mouseDown', function () {
				if (self._autoCell) {
					// React to the mouse events
					self.cell(this._cell + 1);
					self.cacheDirty(true);
				}
			});
			
			this.on('mouseUp', function () {
				if (self._autoCell) {
					// React to the mouse events
					self.cell(this._cell - 1);
					self.cacheDirty(true);
				}
			});
		},
		
		/**
		 * Gets / sets the auto cell flag. If true the button will automatically
		 * react to being clicked on and update the texture cell to +1 when mousedown
		 * and -1 when mouseup allowing you to define cell sheets of button graphics
		 * with the up-state on cell 1 and the down-state on cell 2.
		 * @param {Boolean=} val Either true or false.
		 * @returns {*}
		 */
		autoCell: function (val) {
			if (val !== undefined) {
				this._autoCell = val;
				
				if (val) {
					this.mouseEventsActive(true);
				}
				return this;
			}
			
			return this._autoCell;
		},
		
		/**
		 * Fires a mouse-down and a mouse-up event for the entity.
		 * @returns {*}
		 */
		click: function () {
			if (this._mouseDown) { this._mouseDown(); }
			if (this._mouseUp) { this._mouseUp(); }
			
			return this;
		},
		
		tick: function (ctx) {
			IgeUiElement.prototype.tick.call(this, ctx);
			
			// Now draw any ui overlays
			
			// Check for the old way to assign text to the button
			var uiData = this.data('ui');
			if (uiData) {
				// Draw text
				if (uiData['text']) {
					ctx.font = uiData['text'].font || "normal 12px Verdana";
					ctx.textAlign = uiData['text'].align || 'center';
					ctx.textBaseline = uiData['text'].baseline || 'middle';
					ctx.fillStyle = uiData['text'].color || '#ffffff';
					ctx.fillText(uiData['text'].value, 0, 0);
				}
			}
			
			// Check for the new way to assign text to the button
			if (this._value) {
				// Draw text
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillStyle = this._color;
				ctx.fillText(this._value, 0, 0);
			}
		}
	});
	
	return IgeUiButton;
});
},{"irrelon-appcore":125}],111:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiDropDown', function (IgeUiElement) {
	var IgeUiDropDown = IgeUiElement.extend({
		classId: 'IgeUiDropDown',
		
		init: function () {
			var self = this;
			
			IgeUiElement.prototype.init.call(this);
			
			// Define some default styles
			if (!$ige.engine.ui.style('.IgeUiDropDownOption')) {
				$ige.engine.ui.style('.IgeUiDropDownOption', {
					backgroundColor: null
				});
				
				$ige.engine.ui.style('.IgeUiDropDownOption:hover', {
					backgroundColor: '#00b4ff',
					color: '#ffffff'
				});
			}
			
			// Set defaults
			this.borderColor('#000000');
			this.borderWidth(1);
			this.backgroundColor('#ffffff');
			this.color('#000000');
			this.width(200);
			this.height(30);
			
			this._options = [];
			this._toggleState = false;
			
			this._label = new IgeUiLabel()
				.left(0)
				.right(30)
				.top(0)
				.bottom(0)
				.mount(this);
			
			this.on('mouseUp', function () {
				// Toggle the list drop-down
				self.toggle();
			});
		},
		
		options: function (ops) {
			if (ops !== undefined) {
				this._options = ops;
				
				// Loop the options and check for a selected one
				var arrCount = ops.length;
				
				while (arrCount--) {
					if (ops[arrCount].selected) {
						// Set this option as selected
						this.selectIndex(arrCount);
						return this;
					}
				}
				
				// No item selected, select the first option
				this.selectIndex(0);
				
				return this;
			}
			
			return this;
		},
		
		addOption: function (op) {
			if (op !== undefined) {
				this._options.push(op);
				
				if (op.selected) {
					// Set this option as selected
					this.selectIndex(this._options.length - 1);
					return this;
				}
				
				// No item selected, select the first option
				this.selectIndex(0);
				
				return this;
			}
			
			return this;
		},
		
		removeAllOptions: function () {
			this._options = [];
			this.value({
				text: '',
				value: ''
			});
		},
		
		blur: function () {
			IgeUiElement.prototype.blur.call(this);
			if (this._toggleState) {
				this.toggle();
			}
		},
		
		selectIndex: function (index) {
			if (this._options[index]) {
				this.value(this._options[index]);
				this.emit('change', this.value());
			}
		},
		
		value: function (val) {
			if (val !== undefined) {
				IgeUiElement.prototype.value.call(this, val);
				this._label.value(val.text);
				return this;
			}
			
			return this._value.value;
		},
		
		toggle: function () {
			this._toggleState = !this._toggleState;
			
			if (this._toggleState) {
				var self = this,
					optionContainer,
					mainTop = this._bounds2d.y + 5,
					mainHeight = this._options.length * 30,
					optionTop = 0,
					i;
				
				optionContainer =new IgeUiElement()
					.id(this._id + '_options')
					.backgroundColor(this._backgroundColor)
					.borderColor(this._borderColor)
					.borderWidth(this._borderWidth)
					.top(mainTop)
					.width(this._bounds2d.x)
					.height(mainHeight)
					.mount(this);
				
				for (i = 0; i < this._options.length; i++) {
					$ige.engine.ui.style('#' + this._id + '_options_' + i, {
						color: this._color
					});
					
					new IgeUiLabel()
						.id(this._id + '_options_' + i)
						.data('optionIndex', i)
						.styleClass('IgeUiDropDownOption')
						.value(this._options[i].text)
						.top((this._bounds2d.y * i) + 1)
						.left(1)
						.width(this._bounds2d.x - 2)
						.height(this._bounds2d.y - 2)
						.allowFocus(true)
						.allowActive(true)
						.allowHover(true)
						.mouseUp(function () {
							self.selectIndex(this.data('optionIndex'));
						})
						.mount(optionContainer);
				}
			} else {
				$ige.engine.$(this._id + '_options').destroy();
			}
		},
		
		tick: function (ctx) {
			IgeUiElement.prototype.tick.call(this, ctx);
			
			// Draw drop-down box
			ctx.fillStyle = '#cccccc';
			ctx.fillRect(Math.floor(this._bounds2d.x2) - 30, -this._bounds2d.y2 + 1, 30, this._bounds2d.y - 2);
			
			// Chevron
			ctx.strokeStyle = this._color;
			ctx.beginPath();
			ctx.moveTo(this._bounds2d.x2 - 18.5, -this._bounds2d.y2 + 14.5);
			ctx.lineTo(this._bounds2d.x2 - 14.5, 2.5);
			ctx.lineTo(this._bounds2d.x2 - 10.5, -this._bounds2d.y2 + 14.5);
			ctx.stroke();
			
			this._renderBorder(ctx);
		}
	});
	
	return IgeUiDropDown;
});
},{"irrelon-appcore":125}],112:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiGridPanel', function (IgeUiElement) {
	var IgeUiGridPanel = IgeUiElement.extend({
		classId: 'IgeUiGridPanel',
		
		init: function (cellWidth, cellHeight) {
			IgeUiElement.prototype.init.call(this);
			
			this._gridCellWidth = cellWidth || 32;
			this._gridCellHeight = cellHeight || 32;
		},
		
		_childMounted: function (obj) {
			IgeUiElement.prototype._childMounted.call(this, obj);
			
			var gridWidth = Math.floor(this._bounds2d.x / this._gridCellWidth),
				gridHeight = Math.floor(this._bounds2d.y / this._gridCellHeight),
				totalChildren = this._children.length - 1, positionX, positionY;
			
			// Position this child in the grid
			positionY = Math.floor(totalChildren / gridWidth);
			positionX = totalChildren - (gridWidth * positionY);
			
			obj.left(this._gridCellWidth * positionX)
				.top(this._gridCellHeight * positionY);
		}
	});
	
	return IgeUiGridPanel;
});
},{"irrelon-appcore":125}],113:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiInlineFlow', function (IgeUiElement) {
	var IgeUiInlineFlow = IgeUiElement.extend({
		classId: 'IgeUiInlineFlow',
		
		init: function () {
			IgeUiElement.prototype.init.call(this);
		},
		
		tick: function (ctx) {
			// Loop children and re-position them
			var arr = this._children,
				arrCount = arr.length, i,
				item, itemY, currentX = 0;
			
			for (i = 0; i < arrCount; i++) {
				item = arr[i];
				itemX = item._bounds2d.x;
				item.left(currentX);
				currentX += itemX;
			}
			
			// call the super-class tick
			IgeUiElement.prototype.tick.call(this, ctx);
		}
	});
	
	return IgeUiInlineFlow;
});
},{"irrelon-appcore":125}],114:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiLabel', function (IgeUiElement, IgeFontEntity) {
	/**
	 * Provides a UI label entity. Basic on-screen text label.
	 */
	var IgeUiLabel = IgeUiElement.extend({
		classId: 'IgeUiLabel',
		
		/**
		 * @constructor
		 */
		init: function () {
			IgeUiElement.prototype.init.call(this);
			
			this._value = '';
			this._fontEntity = new IgeFontEntity()
				.left(0)
				.middle(0)
				.textAlignX(0)
				.textAlignY(0)
				.textLineSpacing(10)
				.mount(this);
			
			// Set defaults
			this.font('10px Verdana');
			this.paddingLeft(5);
			this.allowActive(false);
			this.allowFocus(false);
			this.allowHover(false);
		},
		
		textAlignX: function () {
			this._fontEntity.textAlignX.apply(this._fontEntity, arguments);
			return this;
		},
		
		textAlignY: function () {
			this._fontEntity.textAlignY.apply(this._fontEntity, arguments);
			return this;
		},
		
		textLineSpacing: function () {
			this._fontEntity.textLineSpacing.apply(this._fontEntity, arguments);
			return this;
		},
		
		autoWrap: function () {
			this._fontEntity.autoWrap.apply(this._fontEntity, arguments);
			return this;
		},
		
		/**
		 * Extended method to auto-update the width of the child
		 * font entity automatically to fill the text box.
		 * @param px
		 * @param lockAspect
		 * @param modifier
		 * @param noUpdate
		 * @return {*}
		 */
		width: function (px, lockAspect, modifier, noUpdate) {
			var val;
			
			// Call the main super class method
			val = IgeUiElement.prototype.width.call(this, px, lockAspect, modifier, noUpdate);
			
			// Update the font entity width - 10px for margin
			this._fontEntity.width(px - 10, lockAspect, modifier, noUpdate);
			
			return val;
		},
		
		/**
		 * Extended method to auto-update the height of the child
		 * font entity automatically to fill the text box.
		 * @param px
		 * @param lockAspect
		 * @param modifier
		 * @param noUpdate
		 * @return {*}
		 */
		height: function (px, lockAspect, modifier, noUpdate) {
			var val;
			
			// Call the main super class method
			val = IgeUiElement.prototype.height.call(this, px, lockAspect, modifier, noUpdate);
			
			// Update the font entity height
			this._fontEntity.height(px, lockAspect, modifier, noUpdate);
			
			return val;
		},
		
		/**
		 * Gets / sets the text value of the input box.
		 * @param {String=} val The text value.
		 * @return {*}
		 */
		value: function (val) {
			if (val !== undefined) {
				if (this._value !== val) {
					this._value = val;
					
					if (!val && this._placeHolder) {
						// Assign placeholder text and color
						this._fontEntity.text(this._placeHolder);
						this._fontEntity.color(this._placeHolderColor);
					} else {
						// Set the text of the font entity to the value
						if (!this._mask) {
							// Assign text directly
							this._fontEntity.text(this._value);
						} else {
							// Assign a mask value instead
							this._fontEntity.text(new Array(this._value.length + 1).join(this._mask));
						}
						this._fontEntity.color(this._color);
					}
					
					this.emit('change', this._value);
				}
				return this;
			}
			
			return this._value;
		},
		
		/**
		 * Gets / sets the font sheet (texture) that the text box will
		 * use when rendering text inside the box.
		 * @param fontSheet
		 * @return {*}
		 */
		fontSheet: function (fontSheet) {
			if (fontSheet !== undefined) {
				this._fontSheet = fontSheet;
				
				// Set the font sheet as the texture for our font entity
				this._fontEntity.texture(this._fontSheet);
				return this;
			}
			
			return this._fontSheet;
		},
		
		font: function (val) {
			if (val !== undefined) {
				if (typeof(val) === 'string') {
					// Native font name
					return this.nativeFont(val);
				} else {
					// Font sheet
					return this.fontSheet(val);
				}
			}
			
			if (this._fontEntity._nativeMode) {
				// Return native font
				return this.nativeFont();
			} else {
				// Return font sheet
				return this.fontSheet();
			}
		},
		
		nativeFont: function (val) {
			if (val !== undefined) {
				this._fontEntity.nativeFont(val);
				return this;
			}
			
			return this._fontEntity.nativeFont();
		},
		
		nativeStroke: function (val) {
			if (val !== undefined) {
				this._fontEntity.nativeStroke(val);
				return this;
			}
			
			return this._fontEntity.nativeStroke();
		},
		
		nativeStrokeColor: function (val) {
			if (val !== undefined) {
				this._fontEntity.nativeStrokeColor(val);
				return this;
			}
			
			return this._fontEntity.nativeStrokeColor();
		},
		
		color: function (val) {
			if (val !== undefined) {
				this._color = val;
				
				if (!this._value && this._placeHolder && this._placeHolderColor) {
					this._fontEntity.color(this._placeHolderColor);
				} else {
					this._fontEntity.color(val);
				}
				return this;
			}
			
			return this._color;
		},
		
		_mounted: function () {
			// Check if we have a text value
			if (!this._value && this._placeHolder) {
				// Assign placeholder text and color
				this._fontEntity.text(this._placeHolder);
				this._fontEntity.color(this._placeHolderColor);
			}
			
			IgeUiElement.prototype._mounted.call(this);
		}
	});
	
	return IgeUiLabel;
});
},{"irrelon-appcore":125}],115:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiMenu', function (IgeUiElement, IgeUiMenuItem) {
	/**
	 * Provides a UI drop-down menu entity.
	 */
	var IgeUiMenu = IgeUiElement.extend({
		classId: 'IgeUiMenu',
		
		/**
		 * Gets / sets the menu definition.
		 * @param {Object=} val The menu definition object.
		 * @return {*}
		 */
		menuData: function (val) {
			if (val !== undefined) {
				this._menuData = val;
				
				// Remove all existing children from the menu
				this.destroyChildren();
				
				// Build the new menu
				this._buildMenu(this._menuData, this);
				return this;
			}
			
			return this._menuData;
		},
		
		menuMode: function (mode) {
			if (mode !== undefined) {
				this._menuMode = mode;
				return this;
			}
			
			return this._menuMode;
		},
		
		/**
		 * Gets / sets the font sheet (texture) that the text box will
		 * use when rendering text inside the box.
		 * @param fontSheet
		 * @return {*}
		 */
		fontSheet: function (fontSheet) {
			if (fontSheet !== undefined) {
				this._fontSheet = fontSheet;
				return this;
			}
			
			return this._fontSheet;
		},
		
		addItem: function (item) {
			if (item !== undefined) {
				
			}
		},
		
		_buildMenu: function (data, parent) {
			var arrCount = data.length, i,
				item, ent, left = 0, top = 0;
			
			for (i = 0; i < arrCount; i++) {
				item = data[i];
				
				if (this._menuMode) {
					top += this.height();
				}
				
				ent = new IgeUiMenuItem()
					.backgroundColor('#666666')
					.left(left)
					.middle(top)
					.height(this.height())
					.fontSheet(this._fontSheet)
					.menuData(item)
					.mount(parent);
				
				if (!this._menuMode) {
					left += item.width;
				}
			}
		}
	});
	
	return IgeUiMenu;
});

var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiMenuItem', function (IgeUiElement) {
	var IgeUiMenuItem = IgeUiElement.extend({
		classId: 'IgeUiMenuItem',
		
		menuData: function (menuData) {
			if (menuData !== undefined) {
				this._menuData = menuData;
				
				if (menuData.width) {
					this.width(menuData.width);
				}
				if (menuData.id) {
					this.id(menuData.id);
				}
				if (menuData.mouseUp) {
					this.mouseUp(menuData.mouseUp);
				}
				if (menuData.mouseOver) {
					this.mouseOver(menuData.mouseOver);
				}
				if (menuData.mouseOut) {
					this.mouseOut(menuData.mouseOut);
				}
				
				this._labelEntity = new IgeFontEntity()
					.id(this.id() + '_label')
					.texture(this._fontSheet)
					.left(5)
					.middle(0)
					.width(menuData.width)
					.height(this.height())
					.textAlignX(0)
					.textAlignY(1)
					.text(menuData.text)
					.mount(this);
				
				return this;
			}
			
			return this._menuData;
		},
		
		/**
		 * Gets / sets the font sheet (texture) that the menu item will
		 * use when rendering text.
		 * @param fontSheet
		 * @return {*}
		 */
		fontSheet: function (fontSheet) {
			if (fontSheet !== undefined) {
				this._fontSheet = fontSheet;
				return this;
			}
			
			return this._fontSheet;
		},
		
		/**
		 * Opens the menu item so it's child items are visible.
		 */
		open: function () {
			if (this._menuData.items) {
				this._childMenu = new IgeUiMenu()
					.id(this.id() + '_childMenu')
					.depth(this.depth() + 1)
					.fontSheet(this._fontSheet)
					.left(0)
					.top(this.height())
					.width(100)
					.height(30)
					.menuMode(1)
					.menuData(this._menuData.items)
					.mount(this);
			}
		},
		
		/**
		 * Closes the menu item so it's child items are hidden.
		 */
		close: function () {
			if (this._childMenu) {
				this._childMenu.destroy();
			}
		}
	});
	
	return IgeUiMenuItem;
});
},{"irrelon-appcore":125}],116:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiProgressBar', function (IgeUiElement) {
	// TODO: Document this class
	var IgeUiProgressBar = IgeUiElement.extend({
		classId: 'IgeUiProgressBar',
		
		init: function () {
			IgeUiElement.prototype.init.call(this);
			
			// Set some defaults
			this._min = 0;
			this._max = 100;
			this._progress = 0;
			this._barColor = '#fff600';
			this._barText = {
				pre: '',
				post: '',
				color: ''
			};
		},
		
		barBackColor: function (val) {
			if (val !== undefined) {
				this._barBackColor = val;
				return this;
			}
			
			return this._barBackColor;
		},
		
		barColor: function (val) {
			if (val !== undefined) {
				this._barColor = val;
				return this;
			}
			
			return this._barColor;
		},
		
		barBorderColor: function (val) {
			if (val !== undefined) {
				this._barBorderColor = val;
				return this;
			}
			
			return this._barBorderColor;
		},
		
		barText: function (pre, post, color, percent) {
			if (pre !== undefined && post !== undefined && color !== undefined) {
				this._barText = {
					pre: pre,
					post: post,
					color: color,
					percent: percent !== undefined ? percent : false
				};
				return this;
			}
			
			return this._barText;
		},
		
		min: function (val) {
			if (val !== undefined) {
				this._min = val;
				return this;
			}
			
			return this._min;
		},
		
		max: function (val) {
			if (val !== undefined) {
				this._max = val;
				return this;
			}
			
			return this._max;
		},
		
		progress: function (val) {
			if (val !== undefined) {
				if (val < this._min) {
					val = this._min;
				}
				
				if (val > this._max) {
					val = this._max;
				}
				
				this._progress = val;
				return this;
			}
			
			return this._progress;
		},
		
		bindData: function (obj, propName) {
			if (obj !== undefined && propName !== undefined) {
				// Set the object and property to automatically
				// track progress from
				this._bindDataObject = obj;
				this._bindDataProperty = propName;
			}
			
			return this;
		},
		
		render: function (ctx) {
			// Check for an auto-progress update
			if (this._bindDataObject && this._bindDataProperty) {
				if (this._bindDataObject._alive === false) {
					// The object we have bind data from has been
					// destroyed so release our reference to it!
					delete this._bindDataObject;
				} else {
					this.progress(parseInt(this._bindDataObject[this._bindDataProperty]));
				}
			}
			
			var min = this._min,
				max = this._max,
				progress = this._progress,
				interval = this._bounds2d.x / (max - min),
				barWidth = (progress - min) * interval,
				valText;
			
			// Check the value is not out of range
			if (progress > max) {
				progress = max;
			}
			
			if (progress < min) {
				progress = min;
			}
			
			// Draw bar fill
			if (this._barBackColor) {
				ctx.fillStyle = this._barBackColor;
				ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);
			}
			
			// Draw bar
			if (this._barColor) {
				ctx.fillStyle = this._barColor;
				ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, barWidth, this._bounds2d.y);
			}
			
			// Draw bar border
			if (this._barBorderColor) {
				ctx.strokeStyle = this._barBorderColor;
				ctx.strokeRect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);
			}
			
			// Draw bar text centered
			if (this._barText && (this._barText.pre || this._barText.post)) {
				if (this._barText.percent) {
					valText = String(Math.floor((100 / max) * progress));
				} else {
					valText = String(Math.floor(progress));
				}
				
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				
				ctx.fillStyle = this._barText.color;
				ctx.fillText(this._barText.pre + valText + this._barText.post, 0, 0);
			}
		},
		
		tick: function (ctx) {
			this._transformContext(ctx);
			this.render(ctx);
			IgeUiElement.prototype.tick.call(this, ctx, true);
		}
	});
	
	return IgeUiProgressBar;
});
},{"irrelon-appcore":125}],117:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiRadioButton', function (IgeUiButton) {
	var IgeUiRadioButton = IgeUiButton.extend({
		classId: 'IgeUiRadioButton',
		
		radioGroup: function (val) {
			if (val !== undefined) {
				this._uiRadioGroup = val;
				return this;
			}
			
			return this._uiRadioGroup;
		},
		
		select: function (val) {
			if (val !== undefined) {
				this._uiOnSelect = val;
				return this;
			}
			
			if (this._parent) {
				// Loop the parent object's children, find any
				// radio buttons that belong to this radio group
				// and then deselect them
				var arr = this._parent._children,
					arrCount = arr.length,
					item;
				
				while (arrCount--) {
					item = arr[arrCount];
					if (item !== this) {
						if (item._uiRadioGroup === this._uiRadioGroup) {
							// The item is part of the same radio group!
							if (item._uiSelected) {
								// The item is selected so un-select it!
								item._uiSelected = false;
								
								// Fire the item's onDeSelect method
								if (item._uiOnDeSelect) {
									item._uiOnDeSelect();
								}
							}
						}
					}
				}
			}
			
			// Now set this item as selected
			this._uiSelected = true;
			
			// Fire this item's onSelect method
			if (this._uiOnSelect) {
				this._uiOnSelect();
			}
			
			return this;
		},
		
		deSelect: function (val) {
			if (val !== undefined) {
				this._uiOnDeSelect = val;
				return this;
			}
			
			this._uiSelected = false;
			
			if (this._uiOnDeSelect) {
				this._uiOnDeSelect();
			}
			
			return this;
		}
	});
	
	return IgeUiRadioButton;
});
},{"irrelon-appcore":125}],118:[function(_dereq_,module,exports){

},{}],119:[function(_dereq_,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],120:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiTextBox', function (IgeUiElement) {
	/**
	 * Provides a UI text entry box. When provided with focus this UI entity will
	 * capture keyboard input and display it, similar in usage to the HTML input
	 * text element.
	 */
	//TODO: Make cursor a text entry cursor on hover
	var IgeUiTextBox = IgeUiElement.extend({
		classId: 'IgeUiTextBox',
	
		/**
		 * @constructor
		 */
		init: function () {
			IgeUiElement.prototype.init.call(this);
	
			var self = this;
	
			this._value = '';
			this._caretStart = 0;
			this._caretEnd = 0;
	
			this._fontEntity = new IgeFontEntity()
				.left(5)
				.middle(0)
				.textAlignX(0)
				.textAlignY(0)
				.mount(this);
			
			var blurFunc = function () {
				if (self._domElement) {
					self._domElement.parentNode.removeChild(self._domElement);
					delete self._domElement;
				}
			};
			
			var focusFunc = function () {
				$ige.engine.input.stopPropagation();
				blurFunc();
				
				var input,
					body,
					entScreenPos = self.screenPosition();
				
				input = document.createElement('input');
				input.setAttribute('type', 'text');
				
				// Position the infobox and set content
				input.style.position = 'absolute';
				input.style.top = (entScreenPos.y - self._bounds2d.y2) + 'px';
				input.style.left = (entScreenPos.x - self._bounds2d.x2) + 'px';
				input.style.width = self._bounds2d.x + 'px';
				input.style.zIndex = -1;
				input.style.opacity = '0';
				
				body = document.getElementsByTagName('body')[0];
				
				body.appendChild(input);
				input.focus();
				
				// Now add the existing text to the box
				input.setAttribute('value', self._value);
				
				// Set the caret position
				input.selectionStart = self._value.length;
				input.selectionEnd = self._value.length;
				
				self._caretStart = self._value.length;
				self._caretEnd = self._value.length;
				
				// Listen for events from the temp input element
				input.addEventListener('keyup', function (event) {
					self.value(this.value);
					
					if (event.keyCode === 13) {
						// Enter pressed
						self.emit('enter', self._value);
					}
				});
				
				input.addEventListener('keydown', function (event) {
					self.value(this.value);
				});
				
				input.addEventListener('mouseup', function (event) {
					self._caretStart = this.selectionStart;
					self._caretEnd = this.selectionEnd;
				});
				
				input.addEventListener('blur', function (event) {
					this.focus();
				});
				
				self._domElement = input;
			};
			
			// On focus, create a temp input element in the DOM and focus to it
			this.on('focus', focusFunc);
			this.on('mouseUp', focusFunc);
			this.on('mouseDown', function () { $ige.engine.input.stopPropagation(); });
			
			this.on('uiUpdate', function () {
				if (self._domElement) {
					// Update the transformation matrix
					self.updateTransform();
					
					var input = self._domElement,
						entScreenPos = self.screenPosition();
					
					// Reposition the dom element
					input.style.top = (entScreenPos.y - self._bounds2d.y2) + 'px';
					input.style.left = (entScreenPos.x - self._bounds2d.x2) + 'px';
				}
			});
			
			this.on('blur', blurFunc);
		},
	
		/**
		 * Extended method to auto-update the width of the child
		 * font entity automatically to fill the text box.
		 * @param px
		 * @param lockAspect
		 * @param modifier
		 * @param noUpdate
		 * @return {*}
		 */
		width: function (px, lockAspect, modifier, noUpdate) {
			var val;
	
			// Call the main super class method
			val = IgeUiElement.prototype.width.call(this, px, lockAspect, modifier, noUpdate);
	
			// Update the font entity width - 10px for margin
			this._fontEntity.width(px - 10, lockAspect, modifier, noUpdate);
	
			return val;
		},
	
		/**
		 * Extended method to auto-update the height of the child
		 * font entity automatically to fill the text box.
		 * @param px
		 * @param lockAspect
		 * @param modifier
		 * @param noUpdate
		 * @return {*}
		 */
		height: function (px, lockAspect, modifier, noUpdate) {
			var val;
	
			// Call the main super class method
			val = IgeUiElement.prototype.height.call(this, px, lockAspect, modifier, noUpdate);
	
			// Update the font entity height
			this._fontEntity.height(px, lockAspect, modifier, noUpdate);
	
			return val;
		},
	
		/**
		 * Gets / sets the text value of the input box.
		 * @param {String=} val The text value.
		 * @return {*}
		 */
		value: function (val) {
			if (val !== undefined) {
				if (this._value !== val) {
					this._value = val;
		
					if (!val && this._placeHolder) {
						// Assign placeholder text and color
						this._fontEntity.text(this._placeHolder);
						this._fontEntity.color(this._placeHolderColor);
					} else {
						// Set the text of the font entity to the value
						if (!this._mask) {
							// Assign text directly
							this._fontEntity.text(this._value);
						} else {
							// Assign a mask value instead
							this._fontEntity.text(new Array(this._value.length + 1).join(this._mask))
						}
						this._fontEntity.color(this._color);
					}
					
					this.emit('change', this._value);
				}
				return this;
			}
	
			return this._value;
		},
		
		placeHolder: function (val) {
			if (val !== undefined) {
				this._placeHolder = val;
				return this;
			}
			
			return this._placeHolder;
		},
		
		placeHolderColor: function (val) {
			if (val !== undefined) {
				this._placeHolderColor = val;
				return this;
			}
			
			return this._placeHolderColor;
		},
		
		mask: function (val) {
			if (val !== undefined) {
				this._mask = val;
				return this;
			}
			
			return this._mask;
		},
	
		/**
		 * Gets / sets the font sheet (texture) that the text box will
		 * use when rendering text inside the box.
		 * @param fontSheet
		 * @return {*}
		 */
		fontSheet: function (fontSheet) {
			if (fontSheet !== undefined) {
				this._fontSheet = fontSheet;
	
				// Set the font sheet as the texture for our font entity
				this._fontEntity.texture(this._fontSheet);
				return this;
			}
	
			return this._fontSheet;
		},
		
		font: function (val) {
			if (val !== undefined) {
				if (typeof(val) === 'string') {
					// Native font name
					return this.nativeFont(val);
				} else {
					// Font sheet
					return this.fontSheet(val);
				}
			}
			
			if (this._fontEntity._nativeMode) {
				// Return native font
				return this.nativeFont();
			} else {
				// Return font sheet
				return this.fontSheet();
			}
		},
		
		nativeFont: function (val) {
			if (val !== undefined) {
				this._fontEntity.nativeFont(val);
				return this;
			}
			
			return this._fontEntity.nativeFont();
		},
		
		nativeStroke: function (val) {
			if (val !== undefined) {
				this._fontEntity.nativeStroke(val);
				return this;
			}
			
			return this._fontEntity.nativeStroke();
		},
		
		nativeStrokeColor: function (val) {
			if (val !== undefined) {
				this._fontEntity.nativeStrokeColor(val);
				return this;
			}
			
			return this._fontEntity.nativeStrokeColor();
		},
		
		color: function (val) {
			if (val !== undefined) {
				this._color = val;
				
				if (!this._value && this._placeHolder && this._placeHolderColor) {
					this._fontEntity.color(this._placeHolderColor);
				} else {
					this._fontEntity.color(val);
				}
				return this;
			}
			
			return this._color;
		},
		
		_mounted: function () {
			// Check if we have a text value
			if (!this._value && this._placeHolder) {
				// Assign placeholder text and color
				this._fontEntity.text(this._placeHolder);
				this._fontEntity.color(this._placeHolderColor);
			}
			
			IgeUiElement.prototype._mounted.call(this);
		},
	
		destroy: function () {
			/* The 'blur' function is called to destroy the DOM textbox. */
			this.blur();
			IgeUiElement.prototype.destroy.call(this);
		}
	});
	
	return IgeUiTextBox;
});
},{"irrelon-appcore":125}],121:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiTimeStream', function (IgeUiElement) {
	var IgeUiTimeStream = IgeUiElement.extend({
		classId: 'IgeUiTimeStream',
		
		monitor: function (entity) {
			this._entity = entity;
		},
		
		tick: function (ctx) {
			// Draw timeline
			var i, text, xAdjust,
				arr, arrCount, arrItem,
				renderTime = $time._tickStart - $ige.engine.network.stream._renderLatency,
				deltaTime;
			
			IgeUiElement.prototype.tick.call(this, ctx);
			
			ctx.strokeStyle = '#fffc00';
			ctx.beginPath();
			ctx.moveTo(-200, -25.5);
			ctx.lineTo(200, -25.5);
			ctx.stroke();
			
			ctx.font = 'normal 10px Verdana';
			
			for (i = 0; i < 9; i++) {
				ctx.beginPath();
				if (((i - 2) * 10) === 0) {
					// This is the render point, change colour for this one
					ctx.strokeStyle = '#ff6600';
				} else {
					ctx.strokeStyle = '#ffffff';
				}
				ctx.moveTo(-200.5 + (i * 50), -30);
				ctx.lineTo(-200.5 + (i * 50), 30);
				ctx.stroke();
				
				text = -$ige.engine.network.stream._renderLatency + ((i - 2) * 10) + 'ms';
				xAdjust = ctx.measureText(text);
				ctx.strokeText(text, -200 + (i * 50) - (xAdjust.width / 2), -38);
				
				if (((i - 2) * 10) === 0) {
					text = 'Render Point';
					xAdjust = ctx.measureText(text);
					ctx.strokeText(text, -200 + (i * 50) - (xAdjust.width / 2), -52);
				}
			}
			
			if (this._entity) {
				arr = this._entity._timeStream;
				
				// Check if we have a time stream and data
				if (arr && arr.length) {
					arrCount = arr.length;
					
					for (i = 0; i < arrCount; i++) {
						arrItem = arr[i];
						
						deltaTime = arrItem[0] - renderTime;
						
						ctx.strokeRect(-105 + ((deltaTime / 10) * 50), -5, 10, 10);
					}
				}
				
				$ige.engine.client.custom2.value = this._entity._timeStreamDataDelta;
				$ige.engine.client.custom3.value = this._entity._timeStreamOffsetDelta;
				$ige.engine.client.custom4.value = this._entity._timeStreamCurrentInterpolateTime;
			}
		}
	});
	
	return IgeUiTimeStream;
});
},{"irrelon-appcore":125}],122:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiTogglePanel', function (IgeUiElement) {
	var IgeUiTogglePanel = IgeUiElement.extend({
		classId: 'IgeUiTogglePanel',
		
		init: function (title, titleTexture, toggleOffTexture, toggleOnTexture) {
			IgeUiElement.prototype.init.call(this);
			
			this.backgroundColor('#222222');
			
			this._toggleState = false;
			
			this._toggleOffTexture = toggleOffTexture;
			this._toggleOnTexture = toggleOnTexture;
			
			this._panelImage = new IgeUiElement()
				.id('panelImage')
				.texture(toggleOffTexture)
				.left(5)
				.middle(0.5)
				.width(16)
				.height(16)
				.mount(this);
			
			this._panelTitle = new IgeFontEntity()
				.id('panelTitle')
				.texture(titleTexture)
				.left(25)
				.middle(0.5)
				.width('100%')
				.height(20)
				.textAlignX(0)
				.textAlignY(1)
				.text(title)
				.mount(this);
			
			this.mouseOver(function () {
				this.backgroundColor('#666666');
			});
			
			this.mouseOut(function () {
				this.backgroundColor('#222222');
			});
			
			this.mouseUp(function () {
				this._toggleState = !this._toggleState;
				
				if (this._toggleState) {
					this._panelImage.texture(this._toggleOnTexture);
					if (this._toggleOn) {
						this._toggleOn.apply(this);
					}
				} else {
					this._panelImage.texture(this._toggleOffTexture);
					if (this._toggleOff) {
						this._toggleOff.apply(this);
					}
				}
			});
		},
		
		toggleOn: function (method) {
			this._toggleOn = method;
			return this;
		},
		
		toggleOff: function (method) {
			this._toggleOff = method;
			return this;
		}
	});
	
	return IgeUiTogglePanel;
});
},{"irrelon-appcore":125}],123:[function(_dereq_,module,exports){
var appCore = _dereq_('irrelon-appcore');

appCore.module('IgeUiTooltip', function (IgeUiElement) {
	/**
	 * Provides a UI tooltip. Change properties (textBox, fonts, backgroundcolor)
	 * at free will.
	 */
	var IgeUiTooltip = IgeUiElement.extend({
		classId: 'IgeUiTooltip',
		
		/**
		 * @constructor
		 * @param parent Where the mousemove is captured i.e. on which element the tooltip should appear
		 * @param mountEntity Where the tooltip should be mounted. A scene is suggested.
		 * @param width Width of the tooltip
		 * @param height Height of the tooltip
		 * @param content The content which is set with public method "setContent". Can be string, array(2) or an entity
		 */
		init: function (parent, mountEntity, width, height, content) {
			IgeUiElement.prototype.init.call(this);
			
			var self = this;
			this.titleBox = new IgeUiElement()
				.left(0)
				.top(0)
				.width(width)
				.height(30)
				.mount(this);
			this.titleBox.borderBottomColor('#ffffff');
			this.titleBox.borderBottomWidth(1);
			
			this.textBox = new IgeUiElement()
				.left(0)
				.top(30)
				.width(width)
				.height(height - 30)
				.mount(this);
			
			this.fontEntityTitle = new IgeFontEntity()
				.left(5)
				.top(-4)
				.textAlignX(0)
				.textAlignY(0)
				.nativeFont('10pt Arial')
				.textLineSpacing(-5)
				.mount(this.titleBox);
			
			this.fontEntityText = new IgeFontEntity()
				.left(5)
				.top(0)
				.textAlignX(0)
				.textAlignY(0)
				.nativeFont('10pt Arial')
				.textLineSpacing(-5)
				.mount(this.textBox);
			
			this.setContent(content);
			this.hide();
			this._mountEntity = mountEntity;
			this.mount(mountEntity);
			this.backgroundColor('#53B2F3');
			this.depth(10000);
			this.translateTo(parent._translate.x, parent._translate.y, parent._translate.z);
			this.width(width);
			this.height(height);
			
			parent._tooltip = this;
			
			// Listen for keyboard events to capture text input
			parent._mouseEventsActive = true;
			parent.on('mouseMove', self._mousemove);
			parent.on('mouseOut', self._mouseout);
			
			return this;
		},
		
		/**
		 * Extended method to auto-update the width of the child
		 * font entity automatically to fill the text box.
		 * @param px
		 * @param lockAspect
		 * @param modifier
		 * @param noUpdate
		 * @return {*}
		 */
		width: function (px, lockAspect, modifier, noUpdate) {
			var val;
			
			// Call the main super class method
			val = IgeUiElement.prototype.width.call(this, px, lockAspect, modifier, noUpdate);
			
			// Update the font entity width
			this.fontEntityTitle.width(px, lockAspect, modifier, noUpdate);
			this.fontEntityText.width(px, lockAspect, modifier, noUpdate);
			
			return val;
		},
		
		/**
		 * Extended method to auto-update the height of the child
		 * font entity automatically to fill the text box.
		 * @param px
		 * @param lockAspect
		 * @param modifier
		 * @param noUpdate
		 * @return {*}
		 */
		height: function (px, lockAspect, modifier, noUpdate) {
			var val;
			
			// Call the main super class method
			val = IgeUiElement.prototype.height.call(this, px, lockAspect, modifier, noUpdate);
			
			// Update the font entity height
			this.fontEntityTitle.width(px, lockAspect, modifier, noUpdate);
			this.fontEntityText.width(px, lockAspect, modifier, noUpdate);
			
			return val;
		},
		
		/**
		 * Sets the content of the tooltip. Can be a string for
		 * simple text, an array with two strings for text and title
		 * or a whole entity
		 * @param val The content, be it string, array(2) or an entity
		 * @return {*}
		 */
		setContent: function (val) {
			if (val !== undefined) {
				this.titleBox.unMount();
				this.textBox.unMount();
				this._children.forEach(function(child) {
					child.unMount();
					child.destroy();
				});
				if (typeof(val) == 'string') {
					this.textBox.mount(this);
					this.textBox.height(this._bounds2d.y);
					this.textBox.top(0);
					// Set the text of the font entity to the value
					this.fontEntityText.text(this._value);
				}
				else if (typeof(val) == 'object' && typeof(val[0] == 'string') && typeof(val[1] == 'string')) {
					this.titleBox.mount(this);
					this.textBox.mount(this);
					this.textBox.height(this._bounds2d.y - this.titleBox._bounds2d.y);
					this.textBox.top(this.titleBox._bounds2d.y);
					//title + text
					this.fontEntityTitle.text(val[0]);
					this.fontEntityText.text(val[1]);
				}
				else if (typeof(val) == 'object') {
					val.mount(this);
				}
				this.updateUiChildren();
			}
			
			return this;
		},
		
		/**
		 * Gets / sets the font sheet (texture) that the text box will
		 * use when rendering text inside the box.
		 * @param fontSheet
		 * @return {*}
		 */
		fontSheet: function (fontSheet) {
			if (fontSheet !== undefined) {
				// Set the font sheet as the texture for our font entity
				this.fontEntityTitle.texture(fontSheet);
				this.fontEntityText.texture(fontSheet);
			}
			return this;
		},
		
		/**
		 * Handles mousemove event to show the textbox and adjust its
		 * position according to the mouse position
		 * @param event
		 * @private
		 */
		_mousemove: function (event) {
			var tt = this._tooltip;
			if (tt._hidden) tt.show();
			var mountPos = tt._mountEntity.worldPosition();
			tt.translateTo(event.igeX - mountPos.x + tt._bounds2d.x2 + 10, event.igeY - mountPos.y + tt._bounds2d.y2, 0);
			tt.updateUiChildren();
		},
		
		/**
		 * Handles mouseout event to hide the tooltip
		 * @param event
		 * @private
		 */
		_mouseout: function (event) {
			this._tooltip.hide();
		}
	});
	
	return IgeUiTooltip;
});
},{"irrelon-appcore":125}],124:[function(_dereq_,module,exports){
"use strict";

var appCore = _dereq_('irrelon-appcore');
_dereq_('./engine/serverDependencies.js');

appCore.module('ige', function (IgeEngine) {
	var ige = new IgeEngine();
	
	if (ige.isClient) {
		window.ige = ige;
	}
	
	return ige;
});

if (typeof module !== undefined) {
	module.exports = appCore;
}
},{"./engine/serverDependencies.js":4,"irrelon-appcore":125}],125:[function(_dereq_,module,exports){
/**
 * Irrelon AppCore
 *
 * A very lightweight application dependency manager for maintaining
 * clean modularised code without polluting the global namespace.
 *
 * https://github.com/Irrelon/irrelon-appcore
 * npm install irrelon-appcore
 *
 * License: MIT
 * Copyright 2016 Irrelon Software Limited
 * https://www.irrelon.com
 */
"use strict";

var singleton,
	AppCoreModule = _dereq_('./AppCoreModule'),
	Emitter = _dereq_('irrelon-emitter');

/**
 * The main application class that ties all the application
 * modules together and exposes the appCore to the global scope
 * via window.appCore.
 * @exports AppCore
 * @constructor
 */
var AppCore = function () {
	// Determine the environment we are executing in
	this.isServer = (typeof module !== 'undefined' && typeof module.exports !== 'undefined' && typeof window === 'undefined');
	this.isClient = !this.isServer;
	
	// The object that holds references to all the app's
	// modules that are defined by appCore.module().
	this._modules = {};
	this._moduleDefs = {};
	this._config = [];
	this._run = [];
	this.data = {};
	
	// The object that holds a reference to callbacks that
	// are waiting for a module to become available / loaded
	this._waiting = {};
	
	// Set a log level so we only show warnings (2) and errors (1)
	// level 3 and 4 are info - lots of console spamming
	this._logLevel = 2;
	
	console.log('----------------------------------------------');
	console.log('| Powered by Irrelon AppCore                 |');
	console.log('| (C)opyright ' + new Date().getFullYear() + ' Irrelon Software Limited  |');
	console.log('| https://github.com/irrelon/irrelon-appcore |');
	console.log('----------------------------------------------');
};

Emitter(AppCore);

/**
 * Gets / sets the logging level that AppCore will use to explain
 * what it is doing. Lower levels (1 and 2) are error and warnings,
 * higher levels (up to 4) are info. Setting to 4 is asking for all
 * levels 4 and below.
 * @param {Number=} newLevel If provided, sets the new logging level.
 * @returns {*}
 */
AppCore.prototype.logLevel = function (newLevel) {
	if (newLevel !== undefined) {
		this._logLevel = newLevel;
		return this;
	}
	
	return this._logLevel;
};

/**
 * Gets / registers a module with the application.
 * @param {String} moduleName The name of the module to define.
 * @param {Function=} controllerDefinition Optional. The function to
 * assign as the module's controller. If omitted we will return the module
 * specified by the "name" argument if it exists.
 * @returns {Function|AppCore} If "moduleDefinition" is provided, returns
 * "this" to allow chaining. If "moduleDefinition" is omitted,
 * returns the module specified by the "name" argument.
 */
AppCore.prototype.module = function (moduleName, controllerDefinition) {
	var module;
	
	if (!controllerDefinition) {
		module = this._modules[moduleName];
		
		if (!module) {
			throw('Module with name "' + moduleName + '" not defined!');
		}
		
		return this._modules[moduleName];
	}
	
	this._modules[moduleName] = new AppCoreModule(this, moduleName);
	
	if (controllerDefinition) {
		this._modules[moduleName].controller(controllerDefinition);
	}
	
	// Now inform any waiting dependants that this module is here
	this._moduleLoaded(moduleName);
	
	// Allow chaining
	return this._modules[moduleName];
};

/**
 * Scans a function definition for dependencies and waits for those
 * dependencies to become available, then calls back to the waiting
 * code with the controller return data for each dependency.
 * @param {String} dependantName The dependant module name (the one
 * waiting for the dependencies to become available).
 * @param {Function} definition The function with optional arguments
 * that represent dependencies to inject.
 * @param {Function} callback The callback function to call once all
 * the dependencies are available.
 * @returns {AppCore}
 * @private
 */
AppCore.prototype._getDependencies = function (dependantName, definition, callback) {
	var moduleDeps,
		moduleDepsArr,
		depArgumentArr = [],
		dependenciesSatisfied = 0,
		gotDependency,
		depIndex,
		depTimeout = [];
	
	if (!definition) {
		throw('No function provided to AppCoreModule._getDependencies()!');
	}
	
	// Convert dependency list to an array
	moduleDeps = this._dependencyList(definition);
	moduleDepsArr = moduleDeps.arr;
	
	// Check if the module has dependencies
	if (!moduleDepsArr.length) {
		// No dependencies were found
		if (this._logLevel >= 4) { console.log('AppCore: ' + dependantName + ': Has no dependencies'); }
		
		// We have our dependencies, send them back
		callback(false, depArgumentArr);
		return this;
	}
	
	// Grab the dependencies we need - this is a really simple way
	// to check we got our dependencies by how many times this function
	// gets called.
	gotDependency = function (dependencyName, dependency) {
		var depArgumentIndex;
		
		dependenciesSatisfied++;
		
		// Check which index this dependency should be in
		depArgumentIndex = moduleDepsArr.indexOf(dependencyName);
		
		// Clear the timeout for the dependency
		clearTimeout(depTimeout[depArgumentIndex]);
		depTimeout[depArgumentIndex] = 0;
		
		// Assign the dependency to the correct argument index
		depArgumentArr[depArgumentIndex] = dependency;
		
		// Check if we have all the dependencies we need
		if (dependenciesSatisfied === moduleDepsArr.length) {
			// We have our dependencies, send them back
			return callback(false, depArgumentArr);
		}
	};
	
	// Register our dependency handler for each dependency
	if (this._logLevel >= 4) { console.log('AppCore: ' + dependantName + ': Getting dependencies', moduleDepsArr); }
	for (depIndex = 0; depIndex < moduleDepsArr.length; depIndex++) {
		// Create a timeout that will cause a browser error if we are
		// waiting too long for a dependency to arrive
		depTimeout[depIndex] = setTimeout(this.generateDependencyTimeout(dependantName, moduleDepsArr[depIndex]), 3000);
		
		// Now ask to wait for the module
		this._waitForModule(dependantName, moduleDepsArr[depIndex], gotDependency);
	}
	
	return this;
};

/**
 * Gets an array of dependency names.
 * @param {Function} definition The function to get dependency
 * names for.
 * @returns {{arr: Array, name: *}}
 * @private
 */
AppCore.prototype._dependencyList = function (definition) {
	var moduleString,
		moduleDeps,
		moduleDepsArr = [],
		moduleRegExp = /^function(.*?)\((.*?)\)/gi;
	
	// Handle array style
	if (definition instanceof Array) {
		// We have been given a list of dependencies already
		moduleDepsArr = definition.slice(0, definition.length - 1);
		moduleString = definition[definition.length - 1].toString();
		
		// Loop the array and remove any undefined's
		while (moduleDepsArr.indexOf(undefined) > -1) {
			moduleDepsArr.splice(moduleDepsArr.indexOf(undefined), 1);
		}
		
		moduleString = moduleString
			.replace(/\n/g, '')
			.replace(/\r/g, '')
			.replace(/\t/g, '');
		
		moduleDeps = moduleRegExp.exec(moduleString);
		
		if (moduleDeps && moduleDeps.length) {
			// Clean the function name and dependency list by removing whitespace
			moduleDeps[1] = moduleDeps[1].replace(/ /gi, '');
			moduleDeps[2] = moduleDeps[2].replace(/ /gi, '');
		}
	} else {
		// Stringify the module function
		moduleString = definition.toString();
		moduleString = moduleString
			.replace(/\n/g, '')
			.replace(/\r/g, '')
			.replace(/\t/g, '');
		
		// Scan module function string to extract dependencies
		// via the regular expression. The dependencies this module
		// has will be a string in the moduleDeps array at index 2
		// if any dependencies were provided.
		moduleDeps = moduleRegExp.exec(moduleString);
		
		if (moduleDeps && moduleDeps.length) {
			// Clean the function name and dependency list by removing whitespace
			moduleDeps[1] = moduleDeps[1].replace(/ /gi, '');
			moduleDeps[2] = moduleDeps[2].replace(/ /gi, '');
			
			if (moduleDeps[2] !== "") {
				// Convert dependency list to an array
				moduleDepsArr = moduleDeps[2].split(',');
			}
		}
	}
	
	return {
		arr: moduleDepsArr,
		name: moduleDeps[1] || moduleDeps[0] || 'anonymous'
	};
};

/**
 * Generates a function that will be called by a timeout when a
 * dependency does not load in the given time.
 * @param {String} moduleName The name of the module that is waiting
 * for a module to load.
 * @param {String} dependencyName The name of the dependency module
 * that we are waiting for.
 * @returns {Function}
 */
AppCore.prototype.generateDependencyTimeout = function (moduleName, dependencyName) {
	var self = this;
	
	return function () {
		if (self._logLevel >= 1) { console.error('AppCore: ' + moduleName + ': Dependency failed to load in time: ' + dependencyName); }
	};
};

/**
 * Adds the passed callback function to an array that will be
 * processed once the named module has loaded.
 * @param {String} dependantName The name of the module waiting
 * for the dependency.
 * @param {String} moduleName The name of the module to wait for.
 * @param {Function} callback The function to call once the
 * named module has loaded.
 * @returns {AppCore} Returns "this" for method chaining.
 * @private
 */
AppCore.prototype._waitForModule = function (dependantName, moduleName, callback) {
	var self = this;
	
	// Check if the module we are waiting for already exists
	if (this._modules[moduleName] !== undefined) {
		if (this._logLevel >= 4) { console.log('AppCore: ' + dependantName + ': Dependency "' + moduleName + '" exists'); }
		// The module is already loaded, ask for it
		this._modules[moduleName].config();
		this._modules[moduleName].controller(undefined, function (err, value) {
			self._modules[moduleName].run();
			if (self._logLevel >= 4) { console.log('AppCore: ' + dependantName + ': Dependency "' + moduleName + '" loaded'); }
			callback(moduleName, value);
		});
		return this;
	}
	
	// Add the callback to the waiting list for this module
	if (this._logLevel >= 4) { console.log('AppCore: ' + dependantName + ': Dependency "' + moduleName + '" does not yet exist'); }
	this._waiting[moduleName] = this._waiting[moduleName] || [];
	this._waiting[moduleName].push(function (moduleName, value) {
		if (self._logLevel >= 4) { console.log('AppCore: ' + dependantName + ': Dependency "' + moduleName + '" now exists'); }
		callback(moduleName, value);
	});
	
	return this;
};

/**
 * Called when a module has loaded and will loop the array of
 * waiting functions that have registered to be called when the
 * named module has loaded, telling them the module is now
 * available to use.
 * @param {String} moduleName The name of the module that has loaded.
 * @private
 */
AppCore.prototype._moduleLoaded = function (moduleName) {
	var self = this,
		waitingArr,
		waitingIndex;
	
	// Tell any modules waiting for this one that we are
	// loaded and ready
	waitingArr = this._waiting[moduleName] || null;
	
	if (!waitingArr || !waitingArr.length) {
		// Nothing is waiting for us, exit
		return;
	}
	
	// Now get the module's controller result by executing it
	if (self._logLevel >= 4) { console.log('AppCore: ' + moduleName + ': ' + waitingArr.length + ' Dependants are waiting for "' + moduleName + '" and it now exists, executing...'); }
	this._modules[moduleName].config();
	this._modules[moduleName].controller(undefined, function (err, value) {
		self._modules[moduleName].run();
		// Loop the waiting array and tell the receiver that
		// this module has loaded
		for (waitingIndex = 0; waitingIndex < waitingArr.length; waitingIndex++) {
			waitingArr[waitingIndex](moduleName, value);
		}
		
		// Clear the waiting array for this module
		delete self._waiting[moduleName];
	});
};

/**
 * Takes an array of functions and waits for each function's
 * dependencies to be resolved and then executes the function.
 * This is done in order, one at a time.
 * @param {Array} arr An array of functions.
 * @param {Function} callback Callback to call when complete.
 * @private
 */
AppCore.prototype._executeQueue = function (arr, callback) {
	var self = this,
		definition,
		nextItem,
		valueArr;
	
	valueArr = [];
	
	nextItem = function () {
		var deps;
		
		definition = arr.shift();
		
		if (!definition) {
			return callback(false, valueArr);
		}
		
		deps = self._dependencyList(definition);
		
		self._getDependencies(deps.name, definition, function (err, argsArr) {
			definition = self._getFinalFunc(definition);
			
			// Execute the item function passing the dependencies
			// and store the return value in the valueArr
			valueArr.push(definition.apply(self, argsArr));
			
			if (arr.length) {
				// Process the next item
				return nextItem();
			}
			
			// All processing finished, callback now
			callback(false, valueArr);
		});
	};
	
	// Now start the processing
	nextItem();
};

/**
 * Config functions are checked for dependencies and run as
 * soon as they are declared.
 * @param definition
 */
AppCore.prototype.config = function (definition, callback) {
	var i;
	
	if (definition) {
		this._config.push(definition);
		return this;
	}
	
	// Execute all config blocks
	this._executeQueue(this._config, function (err, valueArr) {
		if (callback) { callback(err, valueArr); }
	});
	
	return this;
};

/**
 * Run functions are executed once the AppCore is bootstrapped.
 * @param definition
 */
AppCore.prototype.run = function (definition, callback) {
	if (definition) {
		this._run.push(definition);
	}
	
	if (definition && !this._initialised) {
		return this;
	}
	
	this._initialised = true;
	
	// Execute all run blocks
	this._executeQueue(this._run, function (err, valueArr) {
		if (callback) { callback(err, valueArr); }
	});
	
	return this;
};

/**
 * Run functions are executed once the AppCore is bootstrapped.
 * @param moduleName
 * @param callback
 */
AppCore.prototype.require = function (moduleName, callback) {
	var self = this;
	
	this._waitForModule('function () {}', moduleName, function (dependencyName, dependency) {
		callback(false, dependency);
	});
	
	return this;
};

/**
 * Starts the app core - this defines the entry point into
 * your application by the passed function.
 * @param {Function} definition The function to call to start
 * the application. Will wait for all the function's dependencies
 * to become available before calling it.
 */
AppCore.prototype.bootstrap = function (definition) {
	var self = this,
		deps;
	
	if (self._logLevel >= 4) { console.log('AppCore: Bootstrapping...'); }
	
	// Execute any config blocks
	self.config(undefined, function () {
		// Get the dependencies for the bootstrap function
		deps = self._dependencyList(definition);
		
		self._getDependencies(deps.name, definition, function (err, depArr) {
			definition = self._getFinalFunc(definition);
			
			// Execute any run blocks
			self.run(undefined, function () {
				// Now execute the bootstrap function
				if (self._logLevel >= 4) { console.log('AppCore: Bootstrap complete, executing bootstrap callback...'); }
				definition.apply(definition, depArr);
			});
		});
	});
};

AppCore.prototype.sanityCheck = function () {
	var i,
		moduleDef,
		moduleDefString,
		moduleNameRegExp,
		moduleDeps,
		moduleNamesArr,
		nameIndex,
		moduleName;
	
	// Grab all module names
	moduleNamesArr = Object.keys(this._moduleDefs);
	
	// Loop the modules
	for (i in this._moduleDefs) {
		if (this._moduleDefs.hasOwnProperty(i)) {
			moduleDef = this._moduleDefs[i];
			moduleDefString = moduleDef.toString();
			
			// Clean definition
			moduleDefString = moduleDefString
				.replace(/(\/\*\*[.\s\S]*?\*\/)/g, '')
				.replace(/\/\/[.\s\S]*?$/gm, '');
			
			moduleDeps = this._dependencyList(moduleDef);
			
			// Loop the module names array
			for (nameIndex = 0; nameIndex < moduleNamesArr.length; nameIndex++) {
				moduleName = moduleNamesArr[nameIndex];
				moduleNameRegExp = new RegExp('\\b' + moduleName + '\\b');
				
				if (moduleName.toLowerCase() !== i.toLowerCase() && moduleDeps.arr.indexOf(moduleName) === -1) {
					// Check for module usage without dependency injection
					if (moduleNameRegExp.test(moduleDefString)) {
						console.warn('AppCore: Module "' + i + '" might require un-injected module "' + moduleName + '"');
					}
				}
			}
		}
	}
};

AppCore.prototype._getFinalFunc = function (data) {
	if (data instanceof Array) {
		return data[data.length - 1];
	}
	
	return data;
};

singleton = new AppCore();

// Create the appCore instance and add to global scope
if (typeof module  !== 'undefined' && typeof module.exports !== 'undefined') {
	module.exports = singleton;
}

if (typeof window !== 'undefined') {
	window.appCore = singleton;
}
},{"./AppCoreModule":126,"irrelon-emitter":127}],126:[function(_dereq_,module,exports){
var Emitter = _dereq_('irrelon-emitter');

/**
 * A class that encapsulates a module's lifecycle.
 * @param {AppCore} appCore The AppCore instance that this module
 * belongs to.
 * @param {String} moduleName The module name.
 * @constructor
 */
var AppCoreModule = function (appCore, moduleName) {
	this._appCore = appCore;
	this._moduleName = moduleName;
	this._config = [];
	this._run = [];
	
	this._initialised = false;
	
	if (this._appCore._logLevel >= 4) { console.log('AppCore: ' + this._moduleName + ': Init...'); }
};

Emitter(AppCoreModule);

/**
 * Config functions are checked for dependencies and run as
 * soon as they are declared.
 * @param definition
 */
AppCoreModule.prototype.config = function (definition, callback) {
	if (definition) {
		this._config.push(definition);
		return this;
	}
	
	// Execute all config blocks
	this._appCore._executeQueue(this._config, function (err, valueArr) {
		if (callback) { callback(err, valueArr); }
	});
	
	return this;
};

/**
 * Run functions are executed once the AppCore is bootstrapped.
 * @param definition
 */
AppCoreModule.prototype.run = function (definition, callback) {
	if (definition) {
		this._run.push(definition);
	}
	
	if (definition && !this._initialised) {
		return this;
	}
	
	this._initialised = true;
	
	// Execute all run blocks
	this._appCore._executeQueue(this._run, function (err, valueArr) {
		if (callback) { callback(err, valueArr); }
	});
	
	return this;
};

/**
 * Controller functions are executed as they are requested from
 * a dependency injection. If a controller has already been
 * injected previously then the existing return value is returned
 * unless the controller has been destroyed using module.destroy()
 * in which case it is executed again and its return value stored
 * against it again.
 * @param definition
 */
AppCoreModule.prototype.controller = function (definition, callback) {
	var self = this;
	
	// Check if we were passed a controller function
	if (definition) {
		this._controller = definition;
		if (this._appCore._logLevel >= 4) { console.log('AppCore: ' + this._moduleName + ': Controller defined'); }
		return this;
	}
	
	// Check if we have a pre-cached controller return value
	if (this._value) {
		if (this._appCore._logLevel >= 4) { console.log('AppCore: ' + this._moduleName + ': Returning cached value'); }
		if (callback) { callback(false, self._value); }
		return this._value;
	}
	
	// Resolve dependencies, execute the controller and store the
	// return value
	self._appCore._getDependencies(self._moduleName, self._controller, function (err, argsArr) {
		var definition = self._appCore._getFinalFunc(self._controller);
		
		if (self._appCore._logLevel >= 4) { console.log('AppCore: ' + self._moduleName + ': All dependencies found, executing controller...'); }
		self._value = definition.apply(self, argsArr);
		
		if (self._appCore._logLevel >= 4) { console.log('AppCore: ' + self._moduleName + ': Controller executed'); }
		if (callback) { callback(false, self._value); }
	});
};

/**
 * Destroys a module's cached controller return data which
 * means next time the module is requested the controller will
 * be re-executed.
 */
AppCoreModule.prototype.destroy = function () {
	// Fire destroy event
	this.emit('destroy');
	if (this._appCore._logLevel >= 4) { console.log('AppCore: ' + this._moduleName + ': Destroying controller instance'); }
	delete this._value;
	this._initialised = false;
	if (this._appCore._logLevel >= 4) { console.log('AppCore: ' + this._moduleName + ': Controller instance destroyed'); }
	this.emit('destroyed');
};

module.exports = AppCoreModule;
},{"irrelon-emitter":127}],127:[function(_dereq_,module,exports){
/*
 The MIT License (MIT)

 Copyright (c) 2014 Irrelon Software Limited
 http://www.irrelon.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice, url and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 Source: https://github.com/irrelon/emitter

 Changelog:
 	Version 2.0.1:
 		Bug fix in this._emitters usage
 	Version 2.0.0:
 		Big update to bring in line with latest developments in other projects. Event emitter can
 		now use deferEmit(), emitId(), emitStatic(), emitStaticId(), willEmit(), willEmitId().
 	Version 1.1.9:
 		Updated changelog correctly
 	Version 1.1.8:
 		Removed tons of dependencies wrongly included in main dependencies, have moved to devDependencies section of package.json
 	Version 1.1.0:
 		Added support for overloaded methods
 		Added support for events with ids
 	Version 1.0.2:
 		Removed AMD support, added browserify support
 		Added package.json
 		Added once() method
 		Added hasListener() method
 		Published to NPM as irrelon-emitter
 	Version 1.0.1:
 		Added ability to extend any object with eventing capability
 		Added AMD / Require.js support
		 Added Node.js support
	Version 1.0.0:
		First commit
 */
"use strict";

var Overload = _dereq_('irrelon-overload');

var EventMethods = {
	on: new Overload({
		/**
		 * Attach an event listener to the passed event.
		 * @param {String} event The name of the event to listen for.
		 * @param {Function} listener The method to call when the event is fired.
		 */
		'string, function': function (event, listener) {
			return this.$main(event, '*', listener);
		},
		
		/**
		 * Attach an event listener to the passed event only if the passed
		 * id matches the document id for the event being fired.
		 * @param {String} event The name of the event to listen for.
		 * @param {*} id The document id to match against.
		 * @param {Function} listener The method to call when the event is fired.
		 */
		'string, *, function': function (event, id, listener) {
			return this.$main(event, id, listener);
		},
		
		'$main': function (event, id, listener) {
			var self = this,
				generateTimeout,
				emitter,
				i;
			
			generateTimeout = function (emitter) {
				setTimeout(function () {
					listener.apply(self, emitter.args);
				}, 1);
			};
			
			this._listeners = this._listeners || {};
			this._listeners[event] = this._listeners[event] || {};
			this._listeners[event][id] = this._listeners[event][id] || [];
			this._listeners[event][id].push(listener);
			
			// Check for any static emitters, and fire the event if any exist
			if (this._emitters && this._emitters[event] && this._emitters[event].length) {
				// Emit events for each emitter
				for (i = 0; i < this._emitters[event].length; i++) {
					emitter = this._emitters[event];
					
					if (id === '*' || emitter.id === id) {
						// Call the listener out of process so that any code that expects a listener
						// to be called at some point in the future rather than immediately on registration
						// will not fail
						generateTimeout(emitter);
					}
				}
			}
			
			return this;
		}
	}),
	
	once: new Overload({
		/**
		 * Attach an event listener to the passed event which will only fire once.
		 * @param {String} event The name of the event to listen for.
		 * @param {Function} listener The method to call when the event is fired.
		 */
		'string, function': function (event, listener) {
			var self = this,
				fired = false,
				internalCallback = function () {
					if (!fired) {
						fired = true;
						self.off(event, internalCallback);
						listener.apply(self, arguments);
					}
				};
			
			return this.on(event, internalCallback);
		},
		
		/**
		 * Attach an event listener to the passed event only if the passed
		 * id matches the document id for the event being fired.
		 * @param {String} event The name of the event to listen for.
		 * @param {*} id The document id to match against.
		 * @param {Function} listener The method to call when the event is fired.
		 */
		'string, *, function': function (event, id, listener) {
			var self = this,
				fired = false,
				internalCallback = function () {
					if (!fired) {
						fired = true;
						self.off(event, id, internalCallback);
						listener.apply(self, arguments);
					}
				};
			
			return this.on(event, id, internalCallback);
		}
	}),
	
	off: new Overload({
		/**
		 * Cancels all event listeners for the passed event.
		 * @param {String} event The name of the event.
		 * @returns {*}
		 */
		'string': function (event) {
			var self = this;
			
			if (this._emitting) {
				this._eventRemovalQueue = this._eventRemovalQueue || [];
				this._eventRemovalQueue.push(function () {
					self.off(event);
				});
			} else {
				if (this._listeners && this._listeners[event]) {
					delete this._listeners[event];
				}
			}
			
			return this;
		},
		
		/**
		 * Cancels the event listener for the passed event and listener function.
		 * @param {String} event The event to cancel listener for.
		 * @param {Function} listener The event listener function used in the on()
		 * or once() call to cancel.
		 * @returns {*}
		 */
		'string, function': function (event, listener) {
			var self = this,
				arr,
				index;
			
			if (this._emitting) {
				this._eventRemovalQueue = this._eventRemovalQueue || [];
				this._eventRemovalQueue.push(function () {
					self.off(event, listener);
				});
			} else {
				if (typeof(listener) === 'string') {
					if (this._listeners && this._listeners[event] && this._listeners[event][listener]) {
						delete this._listeners[event][listener];
					}
				} else {
					if (this._listeners && this._listeners[event]) {
						arr = this._listeners[event]['*'];
						index = arr.indexOf(listener);
						
						if (index > -1) {
							arr.splice(index, 1);
						}
					}
				}
			}
			
			return this;
		},
		
		/**
		 * Cancels an event listener based on an event name, id and listener function.
		 * @param {String} event The event to cancel listener for.
		 * @param {String} id The ID of the event to cancel listening for.
		 * @param {Function} listener The event listener function used in the on()
		 * or once() call to cancel.
		 */
		'string, *, function': function (event, id, listener) {
			var self = this;
			
			if (this._emitting) {
				this._eventRemovalQueue = this._eventRemovalQueue || [];
				this._eventRemovalQueue.push(function () {
					self.off(event, id, listener);
				});
			} else {
				if (this._listeners && this._listeners[event] && this._listeners[event][id]) {
					var arr = this._listeners[event][id],
						index = arr.indexOf(listener);
					
					if (index > -1) {
						arr.splice(index, 1);
					}
				}
			}
		},
		
		/**
		 * Cancels all listeners for an event based on the passed event name and id.
		 * @param {String} event The event name to cancel listeners for.
		 * @param {*} id The ID to cancel all listeners for.
		 */
		'string, *': function (event, id) {
			var self = this;
			
			if (this._emitting) {
				this._eventRemovalQueue = this._eventRemovalQueue || [];
				this._eventRemovalQueue.push(function () {
					self.off(event, id);
				});
			} else {
				if (this._listeners && this._listeners[event] && this._listeners[event][id]) {
					// Kill all listeners for this event id
					delete this._listeners[event][id];
				}
			}
		}
	}),
	
	emit: new Overload({
		/**
		 * Emit an event.
		 * @param {String} event The event to emit.
		 * @returns {*}
		 */
		'string': function (event) {
			// Fire global listeners
			return this.$main(event);
		},
		
		/**
		 * Emit an event with data.
		 * @param {String} event The event to emit.
		 * @param {*} data Data to emit with the event.
		 * @returns {*}
		 */
		'string, ...': function (event, data) {
			// Fire global listeners first
			this.$main.apply(this, arguments);
			
			return this;
		},
		
		/**
		 * Handles emitting events, is an internal method not called directly.
		 * @param {String} event The name of the event to emit.
		 * @param {*} data The data to emit with the event.
		 * @returns {*}
		 * @private
		 */
		'$main': function (event, data) {
			var id = '*';
			this._listeners = this._listeners || {};
			this._emitting = true;
			
			if (this._listeners[event]) {
				var arrIndex,
					arrCount,
					tmpFunc,
					arr;
				
				// Handle global emit
				if (this._listeners[event][id]) {
					arr = this._listeners[event][id];
					arrCount = arr.length;
					
					for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
						// Check we have a function to execute
						tmpFunc = arr[arrIndex];
						
						if (typeof tmpFunc === 'function') {
							tmpFunc.apply(this, Array.prototype.slice.call(arguments, 1));
						}
					}
				}
			}
			
			this._emitting = false;
			this._processRemovalQueue();
			
			return this;
		}
	}),
	
	emitId: new Overload({
		'string': function (event) {
			throw('Missing id from emitId call!');
		},
		
		'string, *': function (event, id) {
			return this.$main(event, id);
		},
		
		'string, *, ...': function (event, id) {
			// Fire global listeners first
			this.$main.apply(this, arguments);
			
			return this;
		},
		
		'$main': function (event, id, data) {
			this._listeners = this._listeners || {};
			this._emitting = true;
			
			if (this._listeners[event]) {
				var arrIndex,
					arrCount,
					tmpFunc,
					arr;
				
				// Handle global emit
				if (this._listeners[event]['*']) {
					arr = this._listeners[event]['*'];
					arrCount = arr.length;
					
					for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
						// Check we have a function to execute
						tmpFunc = arr[arrIndex];
						
						if (typeof tmpFunc === 'function') {
							tmpFunc.apply(this, Array.prototype.slice.call(arguments, 2));
						}
					}
				}
				
				// Handle id emit
				if (this._listeners[event][id]) {
					arr = this._listeners[event][id];
					arrCount = arr.length;
					
					for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
						// Check we have a function to execute
						tmpFunc = arr[arrIndex];
						
						if (typeof tmpFunc === 'function') {
							tmpFunc.apply(this, Array.prototype.slice.call(arguments, 2));
						}
					}
				}
			}
			
			this._emitting = false;
			this._processRemovalQueue();
			
			return this;
		}
	}),
	
	emitStatic: new Overload({
		/**
		 * Emit an event that will fire on listeners even when the listener
		 * is registered AFTER the event has been emitted.
		 *
		 * @param {String} event The event to emit.
		 * @returns {*}
		 */
		'string': function (event) {
			// Fire global listeners
			return this.$main(event);
		},
		
		/**
		 * Emit an event with data that will fire on listeners even when the listener
		 * is registered AFTER the event has been emitted.
		 *
		 * @param {String} event The event to emit.
		 * @param {*} data Data to emit with the event.
		 * @returns {*}
		 */
		'string, ...': function (event, data) {
			// Fire global listeners first
			this.$main.apply(this, arguments);
			
			return this;
		},
		
		/**
		 * Handles emitting events, is an internal method not called directly.
		 * @param {String} event The name of the event to emit.
		 * @param {*} data The data to emit with the event.
		 * @returns {*}
		 * @private
		 */
		'$main': function (event, data) {
			var id = '*';
			this._listeners = this._listeners || {};
			this._emitting = true;
			
			if (this._listeners[event]) {
				var arrIndex,
					arrCount,
					tmpFunc,
					arr;
				
				// Handle global emit
				if (this._listeners[event][id]) {
					arr = this._listeners[event][id];
					arrCount = arr.length;
					
					for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
						// Check we have a function to execute
						tmpFunc = arr[arrIndex];
						
						if (typeof tmpFunc === 'function') {
							tmpFunc.apply(this, Array.prototype.slice.call(arguments, 1));
						}
					}
				}
			}
			
			this._emitting = false;
			
			this._emitters = this._emitters || {};
			this._emitters[event] = this._emitters[event] || [];
			this._emitters[event].push({
				id: '*',
				args: Array.prototype.slice.call(arguments, 1)
			});
			
			this._processRemovalQueue();
			
			return this;
		}
	}),
	
	emitStaticId: new Overload({
		/**
		 * Require an id to emit.
		 * @param event
		 */
		'string': function (event) {
			throw('Missing id from emitId call!');
		},
		
		/**
		 * Emit an event that will fire on listeners even when the listener
		 * is registered AFTER the event has been emitted.
		 *
		 * @param {String} event The event to emit.
		 * @param {String} id The id of the event to emit.
		 * @returns {*}
		 */
		'string, *': function (event, id) {
			return this.$main(event, id);
		},
		
		/**
		 * Emit an event that will fire on listeners even when the listener
		 * is registered AFTER the event has been emitted.
		 *
		 * @param {String} event The event to emit.
		 * @param {String} id The id of the event to emit.
		 * @param {*=} data The data to emit with the event.
		 * @returns {*}
		 */
		'string, *, ...': function (event, id, data) {
			// Fire global listeners first
			this.$main.apply(this, arguments);
			
			return this;
		},
		
		/**
		 * Handles emitting events, is an internal method not called directly.
		 * @param {String} event The name of the event to emit.
		 * @param {String} id The id of the event to emit.
		 * @param {*} data The data to emit with the event.
		 * @returns {*}
		 * @private
		 */
		'$main': function (event, id, data) {
			this._listeners = this._listeners || {};
			this._emitting = true;
			
			if (this._listeners[event]) {
				var arrIndex,
					arrCount,
					tmpFunc,
					arr;
				
				// Handle global emit
				if (this._listeners[event]['*']) {
					arr = this._listeners[event]['*'];
					arrCount = arr.length;
					
					for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
						// Check we have a function to execute
						tmpFunc = arr[arrIndex];
						
						if (typeof tmpFunc === 'function') {
							tmpFunc.apply(this, Array.prototype.slice.call(arguments, 2));
						}
					}
				}
				
				// Handle id emit
				if (this._listeners[event][id]) {
					arr = this._listeners[event][id];
					arrCount = arr.length;
					
					for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
						// Check we have a function to execute
						tmpFunc = arr[arrIndex];
						
						if (typeof tmpFunc === 'function') {
							tmpFunc.apply(this, Array.prototype.slice.call(arguments, 2));
						}
					}
				}
			}
			
			this._emitting = false;
			
			this._emitters = this._emitters || {};
			this._emitters[event] = this._emitters[event] || [];
			this._emitters[event].push({
				id: id,
				args: Array.prototype.slice.call(arguments, 2)
			});
			
			this._processRemovalQueue();
			
			return this;
		}
	}),
	
	/**
	 * Checks if an event has any event listeners or not.
	 * @param {String} event The name of the event to check for.
	 * @returns {boolean} True if one or more event listeners are registered for
	 * the event. False if none are found.
	 */
	willEmit: function (event) {
		var id = '*';
		
		if (this._listeners && this._listeners[event]) {
			var arrIndex,
				arrCount,
				tmpFunc,
				arr;
			
			// Handle global emit
			if (this._listeners[event][id]) {
				arr = this._listeners[event][id];
				arrCount = arr.length;
				
				for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
					// Check we have a function to execute
					tmpFunc = arr[arrIndex];
					
					if (typeof tmpFunc === 'function') {
						return true;
					}
				}
			}
		}
		
		return false;
	},
	
	/**
	 * Checks if an event has any event listeners or not based on the passed id.
	 * @param {String} event The name of the event to check for.
	 * @param {String} id The event ID to check for.
	 * @returns {boolean} True if one or more event listeners are registered for
	 * the event. False if none are found.
	 */
	willEmitId: function (event, id) {
		if (this._listeners && this._listeners[event]) {
			var arrIndex,
				arrCount,
				tmpFunc,
				arr;
			
			// Handle global emit
			if (this._listeners[event]['*']) {
				arr = this._listeners[event]['*'];
				arrCount = arr.length;
				
				for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
					// Check we have a function to execute
					tmpFunc = arr[arrIndex];
					
					if (typeof tmpFunc === 'function') {
						return true;
					}
				}
			}
			
			// Handle id emit
			if (this._listeners[event][id]) {
				arr = this._listeners[event][id];
				arrCount = arr.length;
				
				for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
					// Check we have a function to execute
					tmpFunc = arr[arrIndex];
					
					if (typeof tmpFunc === 'function') {
						return true;
					}
				}
			}
		}
		
		return false;
	},
	
	/**
	 * If events are cleared with the off() method while the event emitter is
	 * actively processing any events then the off() calls get added to a
	 * queue to be executed after the event emitter is finished. This stops
	 * errors that might occur by potentially modifying the event queue while
	 * the emitter is running through them. This method is called after the
	 * event emitter is finished processing.
	 * @private
	 */
	_processRemovalQueue: function () {
		var i;
		
		if (this._eventRemovalQueue && this._eventRemovalQueue.length) {
			// Execute each removal call
			for (i = 0; i < this._eventRemovalQueue.length; i++) {
				this._eventRemovalQueue[i]();
			}
			
			// Clear the removal queue
			this._eventRemovalQueue = [];
		}
	},
	
	/**
	 * Queues an event to be fired. This has automatic de-bouncing so that any
	 * events of the same type that occur within 100 milliseconds of a previous
	 * one will all be wrapped into a single emit rather than emitting tons of
	 * events for lots of chained inserts etc. Only the data from the last
	 * de-bounced event will be emitted.
	 * @param {String} eventName The name of the event to emit.
	 * @param {*=} data Optional data to emit with the event.
	 */
	deferEmit: function (eventName, data) {
		var self = this,
			args;
		
		if (!this._noEmitDefer && (!this._db || (this._db && !this._db._noEmitDefer))) {
			args = arguments;
			
			// Check for an existing timeout
			this._deferTimeout = this._deferTimeout || {};
			if (this._deferTimeout[eventName]) {
				clearTimeout(this._deferTimeout[eventName]);
			}
			
			// Set a timeout
			this._deferTimeout[eventName] = setTimeout(function () {
				self.emit.apply(self, args);
			}, 1);
		} else {
			this.emit.apply(this, arguments);
		}
		
		return this;
	}
};

var Emitter = function (obj) {
	if (obj) {
		// Convert the object prototype to have eventing capability
		obj.prototype.on = EventMethods.on;
		obj.prototype.off = EventMethods.off;
		obj.prototype.once = EventMethods.once;
		obj.prototype.emit = EventMethods.emit;
		obj.prototype.emitId = EventMethods.emitId;
		obj.prototype.emitStatic = EventMethods.emitStatic;
		obj.prototype.emitStaticId = EventMethods.emitStaticId;
		obj.prototype.deferEmit = EventMethods.deferEmit;
		obj.prototype.willEmit = EventMethods.willEmit;
		obj.prototype.willEmitId = EventMethods.willEmitId;
		obj.prototype._processRemovalQueue = EventMethods._processRemovalQueue;
	}
};

module.exports = Emitter;
},{"irrelon-overload":128}],128:[function(_dereq_,module,exports){
"use strict";

/**
 * Allows a method to accept overloaded calls with different parameters controlling
 * which passed overload function is called.
 * @param {Object} def
 * @returns {Function}
 * @constructor
 */
var Overload = function (def) {
	if (def) {
		var self = this,
			index,
			count,
			tmpDef,
			defNewKey,
			sigIndex,
			signatures;

		if (!(def instanceof Array)) {
			tmpDef = {};

			// Def is an object, make sure all prop names are devoid of spaces
			for (index in def) {
				if (def.hasOwnProperty(index)) {
					defNewKey = index.replace(/ /g, '');

					// Check if the definition array has a * string in it
					if (defNewKey.indexOf('*') === -1) {
						// No * found
						tmpDef[defNewKey] = def[index];
					} else {
						// A * was found, generate the different signatures that this
						// definition could represent
						signatures = this.generateSignaturePermutations(defNewKey);

						for (sigIndex = 0; sigIndex < signatures.length; sigIndex++) {
							if (!tmpDef[signatures[sigIndex]]) {
								tmpDef[signatures[sigIndex]] = def[index];
							}
						}
					}
				}
			}

			def = tmpDef;
		}

		return function () {
			var arr = [],
				lookup,
				type;

			// Check if we are being passed a key/function object or an array of functions
			if (def instanceof Array) {
				// We were passed an array of functions
				count = def.length;
				for (index = 0; index < count; index++) {
					if (def[index].length === arguments.length) {
						return self.callExtend(this, '$main', def, def[index], arguments);
					}
				}
			} else {
				// Generate lookup key from arguments
				// Copy arguments to an array
				for (index = 0; index < arguments.length; index++) {
					type = typeof arguments[index];

					// Handle detecting arrays
					if (type === 'object' && arguments[index] instanceof Array) {
						type = 'array';
					}

					// Add the type to the argument types array
					arr.push(type);
				}

				lookup = arr.join(',');

				// Check for an exact lookup match
				if (def[lookup]) {
					return self.callExtend(this, '$main', def, def[lookup], arguments);
				} else {
					for (index = arr.length; index >= 0; index--) {
						// Get the closest match
						lookup = arr.slice(0, index).join(',');

						if (def[lookup + ',...']) {
							// Matched against arguments + "any other"
							return self.callExtend(this, '$main', def, def[lookup + ',...'], arguments);
						}
					}
				}
			}

			throw('ForerunnerDB.Overload "' + this.name() + '": Overloaded method does not have a matching signature for the passed arguments: ' + JSON.stringify(arr));
		};
	}

	return function () {};
};

/**
 * Generates an array of all the different definition signatures that can be
 * created from the passed string with a catch-all wildcard *. E.g. it will
 * convert the signature: string,*,string to all potentials:
 * string,string,string
 * string,number,string
 * string,object,string,
 * string,function,string,
 * string,undefined,string
 *
 * @param {String} str Signature string with a wildcard in it.
 * @returns {Array} An array of signature strings that are generated.
 */
Overload.prototype.generateSignaturePermutations = function (str) {
	var signatures = [],
		newSignature,
		types = ['string', 'object', 'number', 'function', 'undefined'],
		index;

	if (str.indexOf('*') > -1) {
		// There is at least one "any" type, break out into multiple keys
		// We could do this at query time with regular expressions but
		// would be significantly slower
		for (index = 0; index < types.length; index++) {
			newSignature = str.replace('*', types[index]);
			signatures = signatures.concat(this.generateSignaturePermutations(newSignature));
		}
	} else {
		signatures.push(str);
	}

	return signatures;
};

Overload.prototype.callExtend = function (context, prop, propContext, func, args) {
	var tmp,
		ret;

	if (context && propContext[prop]) {
		tmp = context[prop];

		context[prop] = propContext[prop];
		ret = func.apply(context, args);
		context[prop] = tmp;

		return ret;
	} else {
		return func.apply(context, args);
	}
};

module.exports = Overload;
},{}],129:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],130:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],131:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],132:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":131,"_process":129,"inherits":130}]},{},[44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,62,63,64,61,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,1,2,3,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,5,6,7,8,9,10,11,12,13,14,15,16,17,18,21,22,23,24,43,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124]);
