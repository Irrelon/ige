"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_irrelon_ige"] = self["webpackChunk_irrelon_ige"] || []).push([["src_engine_network_client_IgeNetIoClientController_ts"],{

/***/ "./src/engine/network/IgeNetIoBaseController.ts":
/*!******************************************************!*\
  !*** ./src/engine/network/IgeNetIoBaseController.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeNetIoBaseController: () => (/* binding */ IgeNetIoBaseController)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n\nclass IgeNetIoBaseController extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__.IgeEventingClass {\n    constructor() {\n        super(...arguments);\n        this.classId = \"IgeNetIoBaseController\";\n        this._networkCommandsIndex = []; // Maps a command name to an integer via the array index\n        this._networkCommandsLookup = {}; // Maps a command name to its index\n        this._debug = false;\n        this._debugCounter = 0;\n        this._debugMax = 100;\n        this._clientRooms = {};\n        this._socketsByRoomId = {};\n        this._timeSyncInterval = 10000; // Sync the client/server clocks every ten seconds by default\n        this._timeSyncLog = {};\n        this._latency = 0;\n        this._timeSyncStarted = false;\n        this._timeSyncTimer = 0;\n        this._sectionDesignator = \"Â¬\"; // Set the stream data section designator character\n    }\n    timeSyncInterval(val) {\n        if (val !== undefined) {\n            this._timeSyncInterval = val;\n            return this;\n        }\n        return this._timeSyncInterval;\n    }\n    timeToServerTime(time) {\n        if (time !== undefined) {\n            return time + this._latency;\n        }\n        return this._latency;\n    }\n    debug(val) {\n        if (val !== undefined) {\n            this._debug = val;\n            return this;\n        }\n        // Check the debug counter settings\n        if (this._debugMax > 0 && this._debugCounter >= this._debugMax) {\n            this._debug = false;\n            this._debugCounter = 0;\n            this.log(`Discontinuing further debug messages because we reached the maximum message count of ${this._debugMax}. Re-enable by running ige.network.debug(true);`);\n        }\n        return this._debug;\n    }\n    debugMax(val) {\n        if (val !== undefined) {\n            this._debugMax = val;\n            return this;\n        }\n        return this._debugMax;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/network/IgeNetIoBaseController.ts?");

/***/ }),

/***/ "./src/engine/network/client/IgeNetIoClient.ts":
/*!*****************************************************!*\
  !*** ./src/engine/network/client/IgeNetIoClient.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeNetIoClient: () => (/* binding */ IgeNetIoClient)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n// /**\n//  * Define the debug options object.\n//  * @type {Object}\n//  * @private\n//  */\n// NetIo._debug = {\n// \t_enabled: true,\n// \t_node: typeof (module) !== \"undefined\" && typeof (module.exports) !== \"undefined\",\n// \t_level: [\"log\", \"warning\", \"error\"],\n// \t_stacks: false,\n// \t_throwErrors: true,\n// \t_trace: {\n// \t\tsetup: false,\n// \t\tenabled: false,\n// \t\tmatch: \"\"\n// \t},\n// \tenabled: function (val) {\n// \t\tif (val !== undefined) {\n// \t\t\tthis._enabled = val;\n// \t\t\treturn this;\n// \t\t}\n//\n// \t\treturn this._enabled;\n// \t}\n// };\n\nclass IgeNetIoClient extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__.IgeEventingClass {\n    constructor(url, options = {\n        connectionRetry: true,\n        connectionRetryMax: 10,\n        reconnect: true\n    }) {\n        super();\n        this.classId = \"IgeNetIoClient\";\n        this._options = {\n            connectionRetry: true,\n            connectionRetryMax: 10,\n            reconnect: true\n        };\n        this._state = 0;\n        this._debug = false;\n        this._connectionAttempts = 0;\n        this._onOpen = () => {\n            this._state = 2;\n        };\n        this._onData = (evt) => {\n            // Decode packet and emit message event\n            const packet = this._decode(evt.data);\n            // Output debug if required\n            if (this._debug) {\n                console.log(\"Incoming data (event, decoded data):\", evt, packet);\n            }\n            if (packet._netioCmd) {\n                // The packet is a netio command\n                switch (packet._netioCmd) {\n                    case \"id\":\n                        // Store the new id in the socket\n                        this._networkId = packet.data;\n                        // Now we have an id, set the state to connected\n                        this._state = 3;\n                        // Emit the connect event\n                        this.emit(\"connect\", this._networkId);\n                        break;\n                    case \"close\":\n                        // The server told us our connection has been closed\n                        // so store the reason the server gave us!\n                        this._disconnectReason = packet.data;\n                        break;\n                }\n            }\n            else {\n                // The packet is normal data\n                this.emit(\"message\", packet);\n            }\n        };\n        this._onClose = (evt) => {\n            const { code, reason, wasClean } = evt;\n            // If we are already connected and have an id...\n            if (this._state === 3) {\n                this._state = 0;\n                this.emit(\"disconnect\", { reason: this._disconnectReason || reason, wasClean: wasClean, code: code });\n            }\n            // If we are connected but have no id...\n            if (this._state === 2) {\n                this._state = 0;\n                this.emit(\"disconnect\", { reason: this._disconnectReason || reason, wasClean: wasClean, code: code });\n            }\n            // If we were trying to connect...\n            if (this._state === 1) {\n                this._state = 0;\n                this.emit(\"error\", { reason: `Cannot establish connection, is server running? ${reason}` });\n            }\n            // Remove the last disconnect reason\n            delete this._disconnectReason;\n        };\n        this._onError = (evt) => {\n            this.log(\"An error occurred with the net.io socket!\", \"error\", evt);\n            this.emit(\"error\", { reason: \"Unknown error occurred\" });\n        };\n        this.log(\"Net.io client starting...\");\n        this._options = options || {};\n        this._socket = null;\n        this._state = 0;\n        this._debug = false;\n        this._connectionAttempts = 0;\n        // Set some default options\n        if (this._options.connectionRetry === undefined) {\n            this._options.connectionRetry = true;\n        }\n        if (this._options.connectionRetryMax === undefined) {\n            this._options.connectionRetryMax = 10;\n        }\n        if (this._options.reconnect === undefined) {\n            this._options.reconnect = true;\n        }\n        // If we were passed a server url, connect to it\n        if (url !== undefined) {\n            this.connect(url);\n        }\n    }\n    /**\n     * Gets / sets the debug flag. If set to true, net.io\n     * will output debug data about every network event as\n     * it occurs to the console.\n     * @param {boolean=} val\n     * @return {*}\n     */\n    debug(val) {\n        if (val !== undefined) {\n            this._debug = val;\n            return this;\n        }\n        return this._debug;\n    }\n    connect(url) {\n        this.log(`Connecting to server at ${url}`);\n        // Set the state to connecting\n        this._state = 1;\n        // Replace http:// with ws://\n        url = url.replace(\"http://\", \"ws://\");\n        // Create new websocket to the url\n        this._socket = new WebSocket(url, \"netio1\");\n        // Setup event listeners\n        this._socket.onopen = this._onOpen;\n        this._socket.onmessage = this._onData;\n        this._socket.onclose = this._onClose;\n        this._socket.onerror = this._onError;\n    }\n    disconnect(reason) {\n        if (!this._socket) {\n            this.log(\"Cannot disconnect(), no socket defined!\", \"warning\");\n            return;\n        }\n        this._socket.close(1000, reason);\n    }\n    send(data) {\n        if (!this._socket) {\n            this.log(\"Cannot send(), no socket defined!\", \"warning\");\n            return;\n        }\n        this._socket.send(this._encode(data));\n    }\n    _encode(data) {\n        return JSON.stringify(data);\n    }\n    _decode(data) {\n        return JSON.parse(data);\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/network/client/IgeNetIoClient.ts?");

/***/ }),

/***/ "./src/engine/network/client/IgeNetIoClientController.ts":
/*!***************************************************************!*\
  !*** ./src/engine/network/client/IgeNetIoClientController.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeNetIoClientController: () => (/* binding */ IgeNetIoClientController)\n/* harmony export */ });\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_network_client_IgeNetIoClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/network/client/IgeNetIoClient */ \"./src/engine/network/client/IgeNetIoClient.ts\");\n/* harmony import */ var _engine_network_IgeNetIoBaseController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/network/IgeNetIoBaseController */ \"./src/engine/network/IgeNetIoBaseController.ts\");\n/* harmony import */ var _engine_utils_ids__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/utils/ids */ \"./src/engine/utils/ids.ts\");\n/* harmony import */ var _engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/engine/utils/igeClassStore */ \"./src/engine/utils/igeClassStore.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\n/* harmony import */ var _enums_IgeNetworkConnectionState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/enums/IgeNetworkConnectionState */ \"./src/enums/IgeNetworkConnectionState.ts\");\n\n\n\n\n\n\n\n/**\n * The client-side net.io component. Handles all client-side\n * networking systems.\n */\nclass IgeNetIoClientController extends _engine_network_IgeNetIoBaseController__WEBPACK_IMPORTED_MODULE_2__.IgeNetIoBaseController {\n    constructor() {\n        super();\n        this.version = \"1.0.0\";\n        this._networkCommands = {}; // Maps a command name to a command handler function\n        this._initDone = false;\n        this._idCounter = 0;\n        this._requests = {};\n        this._state = _enums_IgeNetworkConnectionState__WEBPACK_IMPORTED_MODULE_6__.IgeNetworkConnectionState.disconnected;\n        this._renderLatency = 100;\n        this._streamDataTime = 0;\n        this._onRequest = (data) => {\n            // Store the network request by its id\n            this._requests[data.id] = data;\n            if (this.debug()) {\n                console.log(\"onRequest\", data);\n                this._debugCounter++;\n            }\n            // The message is a network request so fire the command event\n            // with the request id and the request data\n            if (this._networkCommands[data.cmd]) {\n                this._networkCommands[data.cmd](data.id, data.data);\n            }\n            this.emit(data.cmd, data.id, data.data);\n        };\n        this._onResponse = (responseObj) => {\n            // The message is a network response\n            // to a request we sent earlier\n            const id = responseObj.id;\n            // Get the original request object from\n            // the request id\n            const requestObj = this._requests[id];\n            if (this.debug()) {\n                console.log(\"onResponse\", responseObj);\n                this._debugCounter++;\n            }\n            if (requestObj) {\n                // Fire the request callback!\n                requestObj.callback(...responseObj.data);\n                // Delete the request from memory\n                delete this._requests[id];\n            }\n        };\n        this._onTimeSync = (data) => {\n            const localTime = Math.floor(_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime);\n            const serverTime = data[0];\n            this._latency = localTime - serverTime;\n            /*if (localTime < sendTime) {\n                direction = 'behind';\n            } else if (localTime > sendTime) {\n                direction = 'in front of';\n            } else {\n                direction = 'same as';\n            }\n    \n            this.log('Time sync, client clock ' + (localTime - sendTime) + 'ms ' + direction + ' server, send timestamp: ' + sendTime + ', local timestamp: ' + localTime);*/\n            // Send a response without current clock time to the server\n            this._sendTimeSync([serverTime, localTime]);\n        };\n        /**\n         * Called when the client has an error with the connection.\n         * @param {Object} data\n         * @private\n         */\n        // TODO: Make an error message interface and apply it here\n        this._onError = (data) => {\n            this.log(`Error with connection: ${data.reason}`, \"error\");\n        };\n        /**\n         * Handles receiving the start time of the stream data.\n         * @param data\n         * @private\n         */\n        this._onStreamTime = (data) => {\n            this._streamDataTime = data;\n        };\n        this._onStreamCreate = (data) => {\n            const classId = data[0];\n            const entityId = data[1];\n            const parentId = data[2];\n            const createDataArgs = data[3] || [];\n            const transformData = data[4];\n            const initialData = data[5];\n            const parent = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.$(parentId);\n            //console.log(\"Stream create\", data);\n            // Check the required class exists\n            if (parent) {\n                // Check that the entity doesn't already exist\n                if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.$(entityId)) {\n                    const ClassConstructor = _engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_4__.igeClassStore[classId];\n                    if (ClassConstructor) {\n                        //console.log(\"Creating \", classId, createDataArgs);\n                        // The entity does not currently exist so create it!\n                        const entity = new ClassConstructor(...createDataArgs).id(entityId).mount(parent);\n                        entity.streamSectionData(\"transform\", transformData, true);\n                        entity.onStreamCreateInitialData(initialData);\n                        // Set the just created flag which will stop the renderer\n                        // from handling this entity until after the first stream\n                        // data has been received for it\n                        entity._streamJustCreated = true;\n                        if (entity._streamEmitCreated) {\n                            entity.emit(\"streamCreated\");\n                        }\n                        // Since we just created an entity through receiving stream\n                        // data, inform any interested listeners\n                        this.emit(\"entityCreated\", entity);\n                    }\n                    else {\n                        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network.stop();\n                        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine.stop();\n                        this.log(`Network stream cannot create entity with class \"${classId}\" because the class has not been defined! The engine will now stop.`, \"error\");\n                    }\n                }\n                else {\n                    this.log(`Network stream received \"create entity\" with class \"${classId}\" and id \"${entityId}\" but an entity with that id already exists in the scenegraph!`, \"warning\");\n                }\n            }\n            else {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network.stop();\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine.stop();\n                this.log(`Cannot properly handle network streamed entity with id \"${entityId}\" because it's parent with id \"${parentId}\" does not exist on the scenegraph!`, \"warning\");\n            }\n        };\n        this._onStreamDestroy = (data) => {\n            const entity = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.$(data[1]);\n            //console.log(\"Stream destroy\", data);\n            if (!entity) {\n                return;\n            }\n            const destroyDelta = this._renderLatency + (_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime - data[0]);\n            if (destroyDelta > 0) {\n                // Give the entity a lifespan to destroy it in x ms\n                entity.lifeSpan(destroyDelta, () => {\n                    this.emit(\"entityDestroyed\", entity);\n                });\n                return;\n            }\n            // Destroy immediately\n            this.emit(\"entityDestroyed\", entity);\n            entity.destroy();\n        };\n        /**\n         * Called when the client receives data from the stream system.\n         * Handles decoding the data and calling the relevant entity\n         * _onStreamData() methods.\n         * @param data\n         * @private\n         */\n        this._onStreamData = (data) => {\n            // Read the packet data into variables\n            const sectionDataArr = data.split(this._sectionDesignator);\n            const sectionDataCount = sectionDataArr.length - 1;\n            // We know the first bit of data will always be the\n            // target entity's ID\n            const entityId = sectionDataArr.shift();\n            if (!entityId)\n                return;\n            // Check if the entity with this ID currently exists\n            const entity = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.$(entityId);\n            if (!entity) {\n                //this.log(\"+++ Stream: Data received for unknown entity (\" + entityId + \")\");\n                //this.stop();\n                //ige.engine.stop();\n                return;\n            }\n            // Hold the entity's just created flag\n            const justCreated = entity._streamJustCreated;\n            // Get the entity stream section array\n            const sectionArr = entity._streamSections;\n            // Now loop the data sections array and compile the rest of the\n            // data string from the data section return data\n            for (let sectionIndex = 0; sectionIndex < sectionDataCount; sectionIndex++) {\n                // Tell the entity to handle this section's data\n                entity.streamSectionData(sectionArr[sectionIndex], sectionDataArr[sectionIndex], justCreated);\n            }\n            // Now that the entity has had it's first bit of data\n            // reset the just created flag\n            delete entity._streamJustCreated;\n        };\n        // Define the network stream commands\n        this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_CREATE, this._onStreamCreate);\n        this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_DESTROY, this._onStreamDestroy);\n        this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_DATA, this._onStreamData);\n        this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_TIME, this._onStreamTime);\n    }\n    isReady() {\n        return Promise.resolve();\n    }\n    /**\n     * Gets the current socket id.\n     * @returns {string} The id of the socket connection to the server.\n     */\n    id() {\n        return this._id || \"\";\n    }\n    /**\n     * Connects to the specified server. The promise this function returns\n     * will only resolve when the connection to the server is ready to use.\n     * @param {*} url The game server URL e.g. `http://localhost:2000`.\n     * @param {Function=} callback A callback method to call once the\n     * network has started, or you can use the returned promise.\n     */\n    start(url, callback) {\n        return new Promise((resolve) => {\n            if (this._state === _enums_IgeNetworkConnectionState__WEBPACK_IMPORTED_MODULE_6__.IgeNetworkConnectionState.ready) {\n                // We're already connected\n                if (callback) {\n                    callback();\n                }\n                resolve();\n                return;\n            }\n            if (typeof url !== \"undefined\") {\n                this._url = url;\n            }\n            this.log(`Connecting to net.io server at \"${this._url}\"...`);\n            if (typeof WebSocket === \"undefined\") {\n                return;\n            }\n            this._io = new _engine_network_client_IgeNetIoClient__WEBPACK_IMPORTED_MODULE_1__.IgeNetIoClient(url);\n            this._state = _enums_IgeNetworkConnectionState__WEBPACK_IMPORTED_MODULE_6__.IgeNetworkConnectionState.connecting;\n            this._io.on(\"connect\", (clientId) => {\n                this._state = _enums_IgeNetworkConnectionState__WEBPACK_IMPORTED_MODULE_6__.IgeNetworkConnectionState.connected; // Connected\n                this._id = clientId;\n                this._onConnectToServer();\n            });\n            this._io.on(\"message\", (data) => {\n                if (this._initDone) {\n                    this._onMessageFromServer(data);\n                    return;\n                }\n                let commandCount = 0;\n                // Check if the data is an init packet\n                if (data.cmd === \"init\") {\n                    // Set flag to show we've now received an init command\n                    this._initDone = true;\n                    this._state = _enums_IgeNetworkConnectionState__WEBPACK_IMPORTED_MODULE_6__.IgeNetworkConnectionState.ready; // Connected and init done\n                    // Set up the network commands storage\n                    this._networkCommandsLookup = data.ncmds;\n                    // Fill the reverse lookup on the commands\n                    for (const i in this._networkCommandsLookup) {\n                        if (this._networkCommandsLookup.hasOwnProperty(i)) {\n                            this._networkCommandsIndex[this._networkCommandsLookup[i]] = i;\n                            commandCount++;\n                        }\n                    }\n                    // Set up default commands\n                    this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_REQUEST, this._onRequest);\n                    this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_RESPONSE, this._onResponse);\n                    this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_TIME_SYNC, this._onTimeSync);\n                    this.log(\"Received network command list with count: \" + commandCount);\n                    // Setup timescale and current time\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine.timeScale(parseFloat(data.ts));\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime = parseInt(data.ct);\n                    // Now fire the start() callback\n                    if (callback) {\n                        callback();\n                    }\n                    resolve();\n                }\n            });\n            this._io.on(\"disconnect\", (data) => {\n                this._state = _enums_IgeNetworkConnectionState__WEBPACK_IMPORTED_MODULE_6__.IgeNetworkConnectionState.disconnected; // Disconnected\n                this._onDisconnectFromServer(data);\n            });\n            this._io.on(\"error\", this._onError);\n        });\n    }\n    stop() {\n        var _a;\n        // Check we are connected\n        if (this._state === _enums_IgeNetworkConnectionState__WEBPACK_IMPORTED_MODULE_6__.IgeNetworkConnectionState.ready) {\n            (_a = this._io) === null || _a === void 0 ? void 0 : _a.disconnect(\"Client requested disconnect\");\n        }\n    }\n    /**\n     * Gets / sets a network command and callback. When a network command\n     * is received by the client, the callback set up for that command will\n     * automatically be called and passed the data from the incoming network\n     * packet.\n     * @param {string} commandName The name of the command to define.\n     * @param {Function} callback A function to call when the defined network\n     * command is received by the network.\n     * @return {*}\n     */\n    define(commandName, callback) {\n        if (!commandName || !callback) {\n            this.log(\"Cannot define network command either the commandName or callback parameters were undefined!\", \"error\");\n            return this;\n        }\n        this._networkCommands[commandName] = callback;\n        return this;\n    }\n    /**\n     * Sends a network message with the given command name\n     * and data.\n     * @param commandName\n     * @param data\n     * @param callback\n     */\n    send(commandName, data, callback) {\n        var _a;\n        if (callback) {\n            this.request(commandName, data, callback);\n            return;\n        }\n        const commandIndex = this._networkCommandsLookup[commandName];\n        if (commandIndex !== undefined) {\n            if (this.debug()) {\n                this.log(`Sending \"${commandName}\" (index ${commandIndex}) with data:`, data);\n                this._debugCounter++;\n            }\n            const encodedCommandIndex = String.fromCharCode(commandIndex);\n            (_a = this._io) === null || _a === void 0 ? void 0 : _a.send([encodedCommandIndex, data]);\n        }\n        else {\n            this.log(`Cannot send network packet with command \"${commandName}\" because the command has not been defined!`, \"error\");\n        }\n    }\n    /**\n     * Sends a network request. This is different from a standard\n     * call to send() because the recipient code will be able to\n     * respond by calling ige.network.response(). When the response\n     * is received, the callback method that was passed in the\n     * callback parameter will be fired with the response data.\n     * @param {string} commandName\n     * @param {Object} data\n     * @param {Function=} callback\n     */\n    request(commandName, data, callback) {\n        return new Promise((resolve) => {\n            // Build the request object\n            const req = {\n                id: (0,_engine_utils_ids__WEBPACK_IMPORTED_MODULE_3__.newIdHex)(),\n                cmd: commandName,\n                data: data,\n                callback: (...args) => {\n                    if (callback) {\n                        // @ts-ignore\n                        callback(...args);\n                    }\n                    // @ts-ignore\n                    resolve(...args);\n                },\n                timestamp: new Date().getTime()\n            };\n            // Store the request object\n            this._requests[req.id] = req;\n            // Send the network request packet\n            this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_REQUEST, {\n                id: req.id,\n                cmd: commandName,\n                data: req.data\n            });\n        });\n    }\n    /**\n     * Sends a response to a network request.\n     * @param {string} requestId\n     * @param {Object} data\n     */\n    response(requestId, data) {\n        // Grab the original request object\n        const req = this._requests[requestId];\n        if (req) {\n            // Send the network response packet\n            this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_RESPONSE, {\n                id: requestId,\n                cmd: req.cmd,\n                data: data\n            });\n            // Remove the request as we've now responded!\n            delete this._requests[requestId];\n        }\n    }\n    /**\n     * Called when the network connects to the server.\n     * @private\n     */\n    _onConnectToServer() {\n        this.log(\"Connected to server!\");\n        this.emit(\"connected\");\n    }\n    /**\n     * Called when data from the server is received on the client.\n     * @param data\n     * @private\n     */\n    _onMessageFromServer(data) {\n        const decodedCommandIndex = data[0].charCodeAt(0);\n        const commandName = this._networkCommandsIndex[decodedCommandIndex];\n        if (this._networkCommands[commandName]) {\n            if (this.debug()) {\n                this.log(`Received \"${commandName}\" (index ${decodedCommandIndex}) with data:`, data[1]);\n                this._debugCounter++;\n            }\n            this._networkCommands[commandName](data[1]);\n        }\n        this.emit(commandName, data[1]);\n    }\n    /**\n     * Called when the client is disconnected from the server.\n     * @param data\n     * @private\n     */\n    _onDisconnectFromServer(data) {\n        if (data === \"booted\") {\n            this.log(\"Server rejected our connection because it is not accepting connections at this time!\", \"warning\");\n        }\n        else {\n            this.log(\"Disconnected from server!\");\n        }\n        this.emit(\"disconnected\");\n    }\n    _sendTimeSync(data) {\n        // Send the time sync command\n        this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_TIME_SYNC, data);\n    }\n    /**\n     * Gets /Sets the amount of milliseconds in the past that the renderer will\n     * show updates from the stream. This allows us to interpolate from a previous\n     * position to the next position in the stream update. Updates come in and\n     * are already in the past when they are received so we need to set this\n     * latency value to something greater than the highest level of acceptable\n     * network latency. Usually this is a value between 100 and 200ms. If your\n     * game requires much tighter latency you will have to reduce the number of\n     * players / network updates / data size in order to compensate. A value of\n     * 100 in this call is the standard that most triple-A FPS games accept as\n     * normal render latency and should be OK for your game.\n     *\n     * @param latency\n     */\n    renderLatency(latency) {\n        if (latency !== undefined) {\n            this._renderLatency = latency;\n            return this;\n        }\n        return this._renderLatency;\n    }\n    /**\n     * Asks the server to assign us to a room by the room\n     * id. When assigning a client to a room, any streaming\n     * entities for that room start to stream to the client.\n     *\n     * A client can be joined to multiple rooms. If you want\n     * to join a room without leaving the others the client\n     * is already part of, set the leaveAllOthers flag to\n     * false.\n     * @param roomId\n     * @param leaveAllOthers\n     */\n    joinRoom(roomId, leaveAllOthers = true) {\n        this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_JOIN_ROOM, [roomId, leaveAllOthers]);\n    }\n    leaveRoom(roomId) {\n        this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_LEAVE_ROOM, roomId);\n    }\n    leaveAllRooms() {\n        this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_LEAVE_ROOM, \"\");\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/network/client/IgeNetIoClientController.ts?");

/***/ }),

/***/ "./src/engine/utils/ids.ts":
/*!*********************************!*\
  !*** ./src/engine/utils/ids.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   newId: () => (/* binding */ newId),\n/* harmony export */   newIdHex: () => (/* binding */ newIdHex),\n/* harmony export */   newIdNumber: () => (/* binding */ newIdNumber)\n/* harmony export */ });\nlet _idCounter = 0;\n/**\n * Generates a new unique ID as a number.\n * @return {number}\n */\nconst newIdNumber = () => {\n    _idCounter++;\n    return (_idCounter +\n        (Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17)));\n};\n/**\n * Generates a new unique ID string\n * @return {string}\n */\nconst newId = () => {\n    _idCounter++;\n    return newIdNumber().toString();\n};\n/**\n * Generates a new 16-character hexadecimal unique ID\n * @return {string}\n */\nconst newIdHex = () => {\n    return newIdNumber().toString(16);\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/ids.ts?");

/***/ }),

/***/ "./src/enums/IgeNetworkConnectionState.ts":
/*!************************************************!*\
  !*** ./src/enums/IgeNetworkConnectionState.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeNetworkConnectionState: () => (/* binding */ IgeNetworkConnectionState)\n/* harmony export */ });\nvar IgeNetworkConnectionState;\n(function (IgeNetworkConnectionState) {\n    IgeNetworkConnectionState[IgeNetworkConnectionState[\"disconnected\"] = 0] = \"disconnected\";\n    IgeNetworkConnectionState[IgeNetworkConnectionState[\"connecting\"] = 1] = \"connecting\";\n    IgeNetworkConnectionState[IgeNetworkConnectionState[\"connected\"] = 2] = \"connected\";\n    IgeNetworkConnectionState[IgeNetworkConnectionState[\"ready\"] = 3] = \"ready\";\n})(IgeNetworkConnectionState || (IgeNetworkConnectionState = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeNetworkConnectionState.ts?");

/***/ })

}]);