"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_irrelon_ige"] = self["webpackChunk_irrelon_ige"] || []).push([["src_engine_core_IgeViewport_ts"],{

/***/ "./src/engine/core/IgeCamera.ts":
/*!**************************************!*\
  !*** ./src/engine/core/IgeCamera.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeCamera: () => (/* binding */ IgeCamera)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEntity */ \"./src/engine/core/IgeEntity.ts\");\n/* harmony import */ var _engine_core_IgeTween__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/IgeTween */ \"./src/engine/core/IgeTween.ts\");\n/* harmony import */ var _engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/utils/igeClassStore */ \"./src/engine/utils/igeClassStore.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\n\n\n\n\n/**\n * Creates a new camera that will be attached to a viewport.\n */\nclass IgeCamera extends _engine_core_IgeEntity__WEBPACK_IMPORTED_MODULE_0__.IgeEntity {\n    constructor(viewport) {\n        super();\n        this.classId = \"IgeCamera\";\n        this._trackRotateTarget = undefined;\n        this._trackTranslateTarget = undefined;\n        this._trackRotateSmoothing = undefined;\n        this._trackTranslateSmoothing = undefined;\n        // Store the viewport this camera is attached to\n        this._entity = viewport;\n    }\n    /**\n     * Gets / sets the rectangle that the camera translate\n     * will be limited to using an IgeBounds instance.\n     * @param {IgeBounds=} rect\n     * @return {*}\n     */\n    limit(rect) {\n        // TODO: Write the usage of this limit data, currently does nothing\n        if (rect !== undefined) {\n            this._limit = rect;\n            return this._entity;\n        }\n        return this._limit;\n    }\n    /**\n     * Pan (tween) the camera to the new specified point in\n     * the specified time.\n     * @param {IgePoint3d} point The point describing the co-ordinates to pan to.\n     * @param {number} durationMs The number of milliseconds to span the pan operation over.\n     * @param {string=} easing Optional easing method name.\n     */\n    panTo(point, durationMs, easing = \"none\") {\n        if (point !== undefined) {\n            new _engine_core_IgeTween__WEBPACK_IMPORTED_MODULE_1__.IgeTween(this._translate)\n                .properties({\n                x: point.x,\n                y: point.y,\n                z: point.z\n            })\n                .duration(durationMs)\n                .easing(easing)\n                .start();\n        }\n        return this._entity;\n    }\n    /**\n     * Pan (tween) the camera by the new specified point in\n     * the specified time.\n     * @param {IgePoint3d} point The point describing the co-ordinates to pan by.\n     * @param {number} durationMs The number of milliseconds to span the pan operation over.\n     * @param {string=} easing Optional easing method name.\n     */\n    panBy(point, durationMs, easing = \"none\") {\n        if (point !== undefined) {\n            this._translate\n                .tween()\n                .properties({\n                x: point.x + this._translate.x,\n                y: point.y + this._translate.y,\n                z: point.z + this._translate.z\n            })\n                .duration(durationMs)\n                .easing(easing)\n                .start();\n        }\n        return this._entity;\n    }\n    /**\n     * Tells the camera to track the movement of the specified\n     * target entity. The camera will center on the entity.\n     * @param {IgeEntity} entity\n     * @param {number=} smoothing Determines how quickly the camera\n     * will track the target, the higher the number, the slower the\n     * tracking will be.\n     * @param {boolean=} rounding Sets if the smoothing system is\n     * allowed to use floating point values or not. If enabled then\n     * it will not use floating point values.\n     * @return {*}\n     */\n    trackTranslate(entity, smoothing, rounding) {\n        if (entity !== undefined) {\n            this.log(\"Camera on viewport \" + this._entity.id() + \" is now tracking translation target \" + entity.id());\n            if (rounding !== undefined) {\n                this._trackTranslateRounding = rounding;\n            }\n            if (smoothing !== undefined) {\n                this._trackTranslateSmoothing = smoothing >= 1 ? smoothing : 0;\n            }\n            this._trackTranslateTarget = entity;\n            return this._entity;\n        }\n        return this._trackTranslateTarget;\n    }\n    /**\n     * Gets / sets the `translate` tracking smoothing value.\n     * @param {number=} val\n     * @return {*}\n     */\n    trackTranslateSmoothing(val) {\n        if (val !== undefined) {\n            this._trackTranslateSmoothing = val;\n            return this;\n        }\n        return this._trackTranslateSmoothing;\n    }\n    /**\n     * Gets / sets the `translate` tracking smoothing rounding\n     * either enabled or disabled. When enabled the `translate`\n     * smoothing value will be rounded so that floating point\n     * values are not used which can help when smoothing on a\n     * scene that has texture smoothing disabled so sub-pixel\n     * rendering doesn't work and objects appear to \"snap\"\n     * into position as the smoothing interpolates.\n     * @param {Boolean=} val\n     * @return {*}\n     */\n    trackTranslateRounding(val) {\n        if (val !== undefined) {\n            this._trackTranslateRounding = val;\n            return this;\n        }\n        return this._trackTranslateRounding;\n    }\n    /**\n     * Stops tracking the current tracking target's translation.\n     */\n    unTrackTranslate() {\n        delete this._trackTranslateTarget;\n    }\n    /**\n     * Tells the camera to track the rotation of the specified\n     * target entity.\n     * @param {IgeEntity} entity\n     * @param {number=} smoothing Determines how quickly the camera\n     * will track the target, the higher the number, the slower the\n     * tracking will be.\n     * @return {*}\n     */\n    trackRotate(entity, smoothing) {\n        if (entity !== undefined) {\n            this.log(\"Camera on viewport \" + this._entity.id() + \" is now tracking rotation of target \" + entity.id());\n            this._trackRotateSmoothing = smoothing !== undefined && smoothing >= 1 ? smoothing : 0;\n            this._trackRotateTarget = entity;\n            return this._entity;\n        }\n        return this._trackRotateTarget;\n    }\n    /**\n     * Gets / sets the `rotate` tracking smoothing value.\n     * @param {number=} val\n     * @return {*}\n     */\n    trackRotateSmoothing(val) {\n        if (val !== undefined) {\n            this._trackRotateSmoothing = val;\n            return this;\n        }\n        return this._trackRotateSmoothing;\n    }\n    /**\n     * Stops tracking the current tracking target.\n     */\n    unTrackRotate() {\n        delete this._trackRotateTarget;\n    }\n    /**\n     * Translates the camera to the center of the specified entity so\n     * that the camera is \"looking at\" the entity.\n     * @param {IgeEntity} entity The entity to look at.\n     * @param {number=} durationMs If specified, will cause the\n     * camera to tween to the location of the entity rather than\n     * snapping to it instantly.\n     * @param {string=} easing The easing method name to use if\n     * tweening by duration.\n     * @return {*}\n     */\n    lookAt(entity, durationMs, easing = \"none\") {\n        if (entity !== undefined) {\n            entity.updateTransform();\n            if (!durationMs) {\n                // Copy the target's world matrix translate data\n                this._translate.x = Math.floor(entity._worldMatrix.matrix[2]);\n                this._translate.y = Math.floor(entity._worldMatrix.matrix[5]);\n            }\n            else {\n                this._translate\n                    .tween()\n                    .properties({\n                    x: Math.floor(entity._worldMatrix.matrix[2]),\n                    y: Math.floor(entity._worldMatrix.matrix[5]),\n                    z: 0\n                })\n                    .duration(durationMs)\n                    .easing(easing)\n                    .start();\n            }\n            this.updateTransform();\n        }\n        return this;\n    }\n    update() {\n        // Process any behaviours assigned to the camera\n        this._processBehaviours(_enums__WEBPACK_IMPORTED_MODULE_3__.IgeBehaviourType.preUpdate);\n        // Check if we are tracking the translation value of a target\n        if (this._trackTranslateTarget) {\n            const targetEntity = this._trackTranslateTarget;\n            const targetMatrix = targetEntity._worldMatrix.matrix;\n            const targetX = targetMatrix[2];\n            const targetY = targetMatrix[5];\n            let sourceX, sourceY, distX, distY, destinationX, destinationY;\n            if (!this._trackTranslateSmoothing) {\n                // Copy the target's world matrix translate data\n                this.lookAt(this._trackTranslateTarget);\n            }\n            else {\n                // Ease between the current and target values\n                sourceX = this._translate.x;\n                sourceY = this._translate.y;\n                distX = Math.round(targetX - sourceX);\n                distY = Math.round(targetY - sourceY);\n                if (this._trackTranslateRounding) {\n                    destinationX = this._translate.x + Math.round(distX / this._trackTranslateSmoothing);\n                    destinationY = this._translate.y + Math.round(distY / this._trackTranslateSmoothing);\n                }\n                else {\n                    destinationX = this._translate.x + distX / this._trackTranslateSmoothing;\n                    destinationY = this._translate.y + distY / this._trackTranslateSmoothing;\n                }\n                // Check camera Limits\n                if (this._limit) {\n                    if (destinationX < this._limit.x) {\n                        destinationX = this._limit.x;\n                    }\n                    if (destinationX > this._limit.x + this._limit.width) {\n                        destinationX = this._limit.x + this._limit.width;\n                    }\n                    if (destinationY < this._limit.y) {\n                        destinationY = this._limit.y;\n                    }\n                    if (destinationY > this._limit.y + this._limit.height) {\n                        destinationY = this._limit.y + this._limit.height;\n                    }\n                }\n                this._translate.x = destinationX;\n                this._translate.y = destinationY;\n            }\n        }\n        // Check if we are tracking the rotation values of a target\n        if (this._trackRotateTarget) {\n            const targetParentRZ = this._trackRotateTarget._parent ? this._trackRotateTarget._parent._rotate.z : 0;\n            const targetZ = -(targetParentRZ + this._trackRotateTarget._rotate.z);\n            let sourceZ, distZ;\n            if (!this._trackRotateSmoothing) {\n                // Copy the target's rotate data\n                this._rotate.z = targetZ;\n            }\n            else {\n                // Interpolate between the current and target values\n                sourceZ = this._rotate.z;\n                distZ = targetZ - sourceZ;\n                this._rotate.z += distZ / this._trackRotateSmoothing;\n            }\n        }\n        this.updateTransform();\n    }\n    /**\n     * Process operations during the engine tick.\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    tick(ctx) {\n        // Process any behaviours assigned to the camera\n        this._processBehaviours(_enums__WEBPACK_IMPORTED_MODULE_3__.IgeBehaviourType.preTick, ctx);\n        // Updated local transform matrix and then transform the context\n        this._localMatrix.transformRenderingContext(ctx);\n    }\n    /**\n     * Checks the current transform values against the previous ones. If\n     * any value is different, the appropriate method is called which will\n     * update the transformation matrix accordingly. This version of the\n     * method is specifically designed for cameras!\n     */\n    updateTransform() {\n        this._localMatrix.identity();\n        // On cameras, we do the rotation and scaling FIRST\n        this._localMatrix.multiply(this._localMatrix._newRotate(this._rotate.z));\n        this._localMatrix.multiply(this._localMatrix._newScale(this._scale.x, this._scale.y));\n        // 2d translation - cameras are never in iso mode!\n        this._localMatrix.multiply(this._localMatrix._newTranslate(-this._translate.x, -this._translate.y));\n        if (this._parent) {\n            this._worldMatrix.copy(this._parent._worldMatrix);\n            this._worldMatrix.multiply(this._localMatrix);\n        }\n        else {\n            this._worldMatrix.copy(this._localMatrix);\n        }\n        return this;\n    }\n    /**\n     * Returns a string containing a code fragment that when\n     * evaluated will reproduce this object's properties via\n     * chained commands. This method will only check for\n     * properties that are directly related to this class.\n     * Other properties are handled by their own class method.\n     * @private\n     * @return {string}\n     */\n    _stringify() {\n        // Get the properties for all the super-classes\n        let str = super._stringify();\n        let i;\n        // Loop properties and add property assignment code to string\n        for (i in this) {\n            if (this.hasOwnProperty(i) && this[i] !== undefined) {\n                switch (i) {\n                    case \"_trackTranslateTarget\":\n                        if (this._trackTranslateTarget) {\n                            str +=\n                                \".trackTranslate(ige.$('\" +\n                                    this._trackTranslateTarget.id() +\n                                    \"'), \" +\n                                    this.trackTranslateSmoothing() +\n                                    \")\";\n                        }\n                        break;\n                    case \"_trackRotateTarget\":\n                        if (this._trackRotateTarget) {\n                            str +=\n                                \".trackRotate(ige.$('\" +\n                                    this._trackRotateTarget.id() +\n                                    \"'), \" +\n                                    this.trackRotateSmoothing() +\n                                    \")\";\n                        }\n                        break;\n                }\n            }\n        }\n        return str;\n    }\n}\n(0,_engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_2__.registerClass)(IgeCamera);\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeCamera.ts?");

/***/ }),

/***/ "./src/engine/core/IgeUiEntity.ts":
/*!****************************************!*\
  !*** ./src/engine/core/IgeUiEntity.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeUiEntity: () => (/* binding */ IgeUiEntity)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEntity */ \"./src/engine/core/IgeEntity.ts\");\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/utils/igeClassStore */ \"./src/engine/utils/igeClassStore.ts\");\n/* harmony import */ var _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/utils/maths */ \"./src/engine/utils/maths.ts\");\n// TODO: Implement the _stringify() method for this class\n\n\n\n\n/**\n * Creates a new UI entity. UI entities use more resources and CPU\n * than standard IgeEntity instances so only use them if an IgeEntity\n * won't do the job.\n */\nclass IgeUiEntity extends _engine_core_IgeEntity__WEBPACK_IMPORTED_MODULE_0__.IgeEntity {\n    constructor() {\n        super(...arguments);\n        this.classId = \"IgeUiEntity\";\n        this._color = \"#000000\";\n        this._backgroundSize = { x: 1, y: 1 };\n        this._backgroundPosition = { x: 0, y: 0 };\n        this._borderWidth = 0;\n        this._borderLeftWidth = 0;\n        this._borderTopWidth = 0;\n        this._borderRightWidth = 0;\n        this._borderBottomWidth = 0;\n        this._borderRadius = 0;\n        this._borderTopLeftRadius = 0;\n        this._borderTopRightRadius = 0;\n        this._borderBottomRightRadius = 0;\n        this._borderBottomLeftRadius = 0;\n        this._paddingLeft = 0;\n        this._paddingTop = 0;\n        this._paddingRight = 0;\n        this._paddingBottom = 0;\n        this._marginLeft = 0;\n        this._marginTop = 0;\n        this._marginRight = 0;\n        this._marginBottom = 0;\n    }\n    disabled(val) {\n        if (val !== undefined) {\n            this._disabled = val;\n            return this;\n        }\n        return this._disabled;\n    }\n    display(val) {\n        if (val !== undefined) {\n            this._display = val;\n            return this;\n        }\n        return this._display;\n    }\n    overflow(val) {\n        if (val !== undefined) {\n            this._overflow = val;\n            return this;\n        }\n        return this._overflow;\n    }\n    cell(val) {\n        if (val === undefined) {\n            return this._cell;\n        }\n        super.cell(val);\n        if (this._patternTexture) {\n            this.backgroundImage(this._patternTexture, this._patternRepeat);\n        }\n        return this;\n    }\n    mount(obj) {\n        const ret = super.mount(obj);\n        if (this._parent) {\n            // Now we're mounted update our ui calculations since we have a parent\n            // to calculate from\n            if (this._updateUiPosition) {\n                this._updateUiPosition();\n            }\n            // Also update any children if we have any\n            if (this._children.length) {\n                this.updateUiChildren();\n            }\n            if (this._updateStyle) {\n                this._updateStyle();\n            }\n        }\n        return ret;\n    }\n    tick(ctx, dontTransform = false) {\n        if (!this._hidden && this._inView && (!this._parent || this._parent._inView) && !this._streamJustCreated) {\n            if (!dontTransform) {\n                this._transformContext(ctx);\n            }\n            // TODO: Investigate caching expensive background and border calls\n            //if (!this._cache || this._cacheDirty) {\n            this._renderBackground(ctx);\n            this._renderBorder(ctx);\n            //}\n            if (this._overflow === \"hidden\") {\n                // Limit drawing of child entities to within the bounds\n                // of this one\n                const geom = this._bounds2d;\n                const left = (-(geom.x / 2) + this._paddingLeft) | 0;\n                const top = (-(geom.y / 2) + this._paddingTop) | 0;\n                const width = geom.x + this._paddingRight;\n                const height = geom.y + this._paddingBottom;\n                ctx.rect(left, top, width, height);\n                //ctx.stroke();\n                ctx.clip();\n            }\n            ctx.translate(this._paddingLeft, this._paddingTop);\n            super.tick(ctx, true);\n        }\n    }\n    /**\n     * Handles screen resize events.\n     * @param event\n     * @private\n     */\n    _resizeEvent(event) {\n        if (this._updateUiPosition) {\n            this._updateUiPosition();\n        }\n        else {\n            debugger;\n        }\n        if (this._updateStyle) {\n            this._updateStyle();\n        }\n        super._resizeEvent(event);\n    }\n    _updateStyle() {\n    }\n    left(px, noUpdate = false) {\n        if (px === undefined) {\n            return this._uiLeft;\n        }\n        if (px === null) {\n            // Remove all data\n            delete this._uiLeft;\n            delete this._uiLeftPercent;\n        }\n        else {\n            delete this._uiCenter;\n            delete this._uiCenterPercent;\n            if (typeof px === \"string\") {\n                // Store the percentage value\n                this._uiLeftPercent = px;\n                // Check if we are already mounted\n                const val = parseInt(px, 10);\n                let parentWidth = 0;\n                if (this._parent) {\n                    // We have a parent, use it's geometry\n                    parentWidth = this._parent._bounds2d.x;\n                }\n                else if (_engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine) {\n                    // We don't have a parent so use the main canvas\n                    // as a reference\n                    parentWidth = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._bounds2d.x;\n                }\n                // Calculate real width from percentage\n                this._uiLeft = ((parentWidth / 100) * val) | 0;\n            }\n            else {\n                // The value passed is not a percentage, directly assign it\n                this._uiLeft = px;\n                delete this._uiLeftPercent;\n            }\n        }\n        if (!noUpdate) {\n            this._updateUiPosition();\n        }\n        return this;\n    }\n    right(px, noUpdate = false) {\n        if (px !== undefined) {\n            if (px === null) {\n                // Remove all data\n                delete this._uiRight;\n                delete this._uiRightPercent;\n            }\n            else {\n                delete this._uiCenter;\n                delete this._uiCenterPercent;\n                if (typeof px === \"string\") {\n                    // Store the percentage value\n                    this._uiRightPercent = px;\n                    // Check if we are already mounted\n                    const val = parseInt(px, 10);\n                    let parentWidth = 0;\n                    if (this._parent) {\n                        // We have a parent, use it's geometry\n                        parentWidth = this._parent._bounds2d.x;\n                    }\n                    else if (_engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine) {\n                        // We don't have a parent so use the main canvas\n                        // as a reference\n                        parentWidth = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._bounds2d.x;\n                    }\n                    // Calculate real width from percentage\n                    this._uiRight = ((parentWidth / 100) * val) | 0;\n                }\n                else {\n                    // The value passed is not a percentage, directly assign it\n                    this._uiRight = px;\n                    delete this._uiRightPercent;\n                }\n            }\n            if (!noUpdate) {\n                this._updateUiPosition();\n            }\n            return this;\n        }\n        return this._uiRight;\n    }\n    center(px, noUpdate = false) {\n        if (px !== undefined) {\n            if (px === null) {\n                // Remove all data\n                delete this._uiCenter;\n                delete this._uiCenterPercent;\n            }\n            else {\n                delete this._uiLeft;\n                delete this._uiLeftPercent;\n                delete this._uiRight;\n                delete this._uiRightPercent;\n                if (typeof px === \"string\") {\n                    // Store the percentage value\n                    this._uiCenterPercent = px;\n                    // Check if we are already mounted\n                    const val = parseInt(px, 10);\n                    let parentWidth = 0;\n                    if (this._parent) {\n                        // We have a parent, use it's geometry\n                        parentWidth = this._parent._bounds2d.x2;\n                    }\n                    else if (_engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine) {\n                        // We don't have a parent so use the main canvas\n                        // as a reference\n                        parentWidth = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._bounds2d.x2;\n                    }\n                    // Calculate real width from percentage\n                    this._uiCenter = ((parentWidth / 100) * val) | 0;\n                }\n                else {\n                    // The value passed is not a percentage, directly assign it\n                    this._uiCenter = px;\n                    delete this._uiCenterPercent;\n                }\n            }\n            if (!noUpdate) {\n                this._updateUiPosition();\n            }\n            return this;\n        }\n        return this._uiCenter;\n    }\n    top(px, noUpdate = false) {\n        if (px === undefined) {\n            return this._uiTop;\n        }\n        if (px === null) {\n            // Remove all data\n            delete this._uiTop;\n            delete this._uiTopPercent;\n            return this._uiTop;\n        }\n        else {\n            delete this._uiMiddle;\n            delete this._uiMiddlePercent;\n            if (typeof px === \"string\") {\n                // Store the percentage value\n                this._uiTopPercent = px;\n                // Check if we are already mounted\n                const val = parseInt(px, 10);\n                let parentHeight = 0;\n                if (this._parent) {\n                    // We have a parent, use it's geometry\n                    parentHeight = this._parent._bounds2d.y;\n                }\n                else if (_engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine) {\n                    // We don't have a parent so use the main canvas\n                    // as a reference\n                    parentHeight = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._bounds2d.y;\n                }\n                // Calculate real width from percentage\n                this._uiTop = ((parentHeight / 100) * val) | 0;\n            }\n            else {\n                // The value passed is not a percentage, directly assign it\n                this._uiTop = px;\n                delete this._uiTopPercent;\n            }\n        }\n        if (!noUpdate) {\n            this._updateUiPosition();\n        }\n        return this;\n    }\n    bottom(px, noUpdate = false) {\n        if (px !== undefined) {\n            if (px === null) {\n                // Remove all data\n                delete this._uiBottom;\n                delete this._uiBottomPercent;\n            }\n            else {\n                delete this._uiMiddle;\n                delete this._uiMiddlePercent;\n                if (typeof px === \"string\") {\n                    // Store the percentage value\n                    this._uiBottomPercent = px;\n                    // Check if we are already mounted\n                    const val = parseInt(px, 10);\n                    let parentHeight = 0;\n                    if (this._parent) {\n                        // We have a parent, use it's geometry\n                        parentHeight = this._parent._bounds2d.y;\n                    }\n                    else if (_engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine) {\n                        // We don't have a parent so use the main canvas\n                        // as a reference\n                        parentHeight = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._bounds2d.y;\n                    }\n                    // Calculate real width from percentage\n                    this._uiBottom = ((parentHeight / 100) * val) | 0;\n                }\n                else {\n                    // The value passed is not a percentage, directly assign it\n                    this._uiBottom = px;\n                    delete this._uiBottomPercent;\n                }\n            }\n            if (!noUpdate) {\n                this._updateUiPosition();\n            }\n            return this;\n        }\n        return this._uiBottom;\n    }\n    middle(px, noUpdate = false) {\n        if (px !== undefined) {\n            if (px === null) {\n                // Remove all data\n                delete this._uiMiddle;\n                delete this._uiMiddlePercent;\n            }\n            else {\n                delete this._uiTop;\n                delete this._uiTopPercent;\n                delete this._uiBottom;\n                delete this._uiBottomPercent;\n                if (typeof px === \"string\") {\n                    // Store the percentage value\n                    this._uiMiddlePercent = px;\n                    // Check if we are already mounted\n                    const val = parseInt(px, 10);\n                    let parentWidth = 0;\n                    if (this._parent) {\n                        // We have a parent, use it's geometry\n                        parentWidth = this._parent._bounds2d.y2;\n                    }\n                    else if (_engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine) {\n                        // We don't have a parent so use the main canvas\n                        // as a reference\n                        parentWidth = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._bounds2d.y2;\n                    }\n                    // Calculate real width from percentage\n                    this._uiMiddle = ((parentWidth / 100) * val) | 0;\n                }\n                else {\n                    // The value passed is not a percentage, directly assign it\n                    this._uiMiddle = px;\n                    delete this._uiMiddlePercent;\n                }\n            }\n            if (!noUpdate) {\n                this._updateUiPosition();\n            }\n            return this;\n        }\n        return this._uiMiddle;\n    }\n    width(px, lockAspect = false, modifier, noUpdate = false) {\n        if (px !== undefined) {\n            if (px === null) {\n                // Remove all data\n                delete this._uiWidth;\n                this._bounds2d.x = 0;\n                this._bounds2d.x2 = 0;\n            }\n            else {\n                this._uiWidth = px;\n                this._widthModifier = modifier !== undefined ? modifier : 0;\n                if (typeof px === \"string\") {\n                    if (this._parent) {\n                        // Percentage\n                        const parentWidth = this._parent._bounds2d.x;\n                        const val = parseInt(px, 10);\n                        // Calculate real width from percentage\n                        const newVal = ((parentWidth / 100) * val + this._widthModifier) | 0;\n                        if (lockAspect) {\n                            // Calculate the height from the change in width\n                            const ratio = newVal / this._bounds2d.x;\n                            this.height(this._bounds2d.y / ratio, false, 0, noUpdate);\n                        }\n                        this._bounds2d.x = newVal;\n                        this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);\n                    }\n                    else if (_engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine) {\n                        // We don't have a parent so use the main canvas\n                        // as a reference\n                        const parentWidth = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._bounds2d.x;\n                        const val = parseInt(px, 10);\n                        // Calculate real height from percentage\n                        this._bounds2d.x = ((parentWidth / 100) * val + this._widthModifier) | 0;\n                        this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);\n                    }\n                }\n                else {\n                    if (lockAspect) {\n                        // Calculate the height from the change in width\n                        const ratio = px / this._bounds2d.x;\n                        this.height(this._bounds2d.y * ratio, false, 0, noUpdate);\n                    }\n                    this._bounds2d.x = px;\n                    this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);\n                }\n            }\n            if (!noUpdate) {\n                this._updateUiPosition();\n            }\n            return this;\n        }\n        return this._bounds2d.x;\n    }\n    height(px, lockAspect = false, modifier, noUpdate = false) {\n        if (px !== undefined) {\n            if (px === null) {\n                // Remove all data\n                delete this._uiHeight;\n                this._bounds2d.y = 0;\n                this._bounds2d.y2 = 0;\n            }\n            else {\n                this._uiHeight = px;\n                this._heightModifier = modifier !== undefined ? modifier : 0;\n                if (typeof px === \"string\") {\n                    if (this._parent) {\n                        // Percentage\n                        const parentHeight = this._parent._bounds2d.y;\n                        const val = parseInt(px, 10);\n                        // Calculate real height from percentage\n                        // Calculate real width from percentage\n                        const newVal = ((parentHeight / 100) * val + this._heightModifier) | 0;\n                        if (lockAspect) {\n                            // Calculate the height from the change in width\n                            const ratio = newVal / this._bounds2d.y;\n                            this.width(this._bounds2d.x / ratio, false, 0, noUpdate);\n                        }\n                        this._bounds2d.y = newVal;\n                        this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);\n                    }\n                    else if (_engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine) {\n                        // We don't have a parent so use the main canvas\n                        // as a reference\n                        const parentHeight = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._bounds2d.y;\n                        const val = parseInt(px, 10);\n                        // Calculate real height from percentage\n                        this._bounds2d.y = ((parentHeight / 100) * val + this._heightModifier) | 0;\n                        this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);\n                    }\n                }\n                else {\n                    if (lockAspect) {\n                        // Calculate the height from the change in width\n                        const ratio = px / this._bounds2d.y;\n                        this.width(this._bounds2d.x * ratio, false, 0, noUpdate);\n                    }\n                    this._bounds2d.y = px;\n                    this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);\n                }\n            }\n            if (!noUpdate) {\n                this._updateUiPosition();\n            }\n            return this;\n        }\n        return this._bounds2d.y;\n    }\n    flex(val) {\n        if (val === undefined)\n            return this._uiFlex;\n        this._uiFlex = val;\n        return this;\n    }\n    autoScaleX(val, lockAspect = false) {\n        if (val !== undefined) {\n            this._autoScaleX = val;\n            this._autoScaleLockAspect = lockAspect;\n            this._updateUiPosition();\n            return this;\n        }\n        return this._autoScaleX;\n    }\n    autoScaleY(val, lockAspect = false) {\n        if (val !== undefined) {\n            this._autoScaleY = val;\n            this._autoScaleLockAspect = lockAspect;\n            this._updateUiPosition();\n            return this;\n        }\n        return this._autoScaleY;\n    }\n    /**\n     * Updates the UI position of every child entity down the scenegraph\n     * for this UI entity.\n     * @return {*}\n     */\n    updateUiChildren() {\n        const arr = (this._children || []);\n        if (!arr) {\n            return this;\n        }\n        let arrCount = arr.length;\n        while (arrCount--) {\n            const arrItem = arr[arrCount];\n            if (arrItem._updateUiPosition) {\n                arrItem._updateUiPosition();\n            }\n            if (arrItem.updateUiChildren) {\n                arrItem.updateUiChildren();\n            }\n        }\n        return this;\n    }\n    /**\n     * Sets the correct translation x and y for the viewport's left, right\n     * top and bottom co-ordinates.\n     * @private\n     */\n    _updateUiPosition() {\n        if (!this._parent) {\n            return;\n        }\n        const parentGeom = this._parent._bounds2d;\n        const geomScaled = this._bounds2d.multiplyPoint(this._scale);\n        if (this._autoScaleX) {\n            // Get the percentage as an integer\n            const percent = parseInt(this._autoScaleX, 10);\n            // Calculate new width from percentage\n            const newVal = (parentGeom.x / 100) * percent;\n            // Calculate scale ratio\n            const ratio = newVal / this._bounds2d.x;\n            // Set the new scale\n            this._scale.x = ratio;\n            if (this._autoScaleLockAspect) {\n                this._scale.y = ratio;\n            }\n        }\n        if (this._autoScaleY) {\n            // Get the percentage as an integer\n            const percent = parseInt(this._autoScaleY, 10);\n            // Calculate new height from percentage\n            const newVal = (parentGeom.y / 100) * percent;\n            // Calculate scale ratio\n            const ratio = newVal / this._bounds2d.y;\n            // Set the new scale\n            this._scale.y = ratio;\n            if (this._autoScaleLockAspect) {\n                this._scale.x = ratio;\n            }\n        }\n        if (this._uiWidth) {\n            this.width(this._uiWidth, false, this._widthModifier, true);\n        }\n        if (this._uiHeight) {\n            this.height(this._uiHeight, false, this._heightModifier, true);\n        }\n        if (this._uiCenterPercent) {\n            this.center(this._uiCenterPercent, true);\n        }\n        if (this._uiMiddlePercent) {\n            this.middle(this._uiMiddlePercent, true);\n        }\n        if (this._uiLeftPercent) {\n            this.left(this._uiLeftPercent, true);\n        }\n        if (this._uiRightPercent) {\n            this.right(this._uiRightPercent, true);\n        }\n        if (this._uiTopPercent) {\n            this.top(this._uiTopPercent, true);\n        }\n        if (this._uiBottomPercent) {\n            this.bottom(this._uiBottomPercent, true);\n        }\n        if (this._uiCenter !== undefined) {\n            // The element is center-aligned\n            this._translate.x = Math.floor(this._uiCenter);\n        }\n        else {\n            // The element is not center-aligned, process left and right\n            if (this._uiLeft !== undefined && this._uiRight !== undefined) {\n                // Both left and right values are set, position left and assign width to reach right\n                this.width(parentGeom.x - this._uiLeft - this._uiRight, false, 0, true);\n                // Update translation\n                this._translate.x = Math.floor(this._uiLeft + geomScaled.x2 - parentGeom.x2);\n            }\n            else {\n                if (this._uiLeft !== undefined) {\n                    // Position left aligned\n                    this._translate.x = Math.floor(this._uiLeft + geomScaled.x2 - parentGeom.x2);\n                }\n                if (this._uiRight !== undefined) {\n                    // Position right aligned\n                    this._translate.x = Math.floor(parentGeom.x2 - geomScaled.x2 - this._uiRight);\n                }\n            }\n        }\n        if (this._uiMiddle !== undefined) {\n            // The element is middle-aligned\n            this._translate.y = Math.floor(this._uiMiddle);\n        }\n        else {\n            // The element is not middle-aligned, process top and bottom\n            if (this._uiTop !== undefined && this._uiBottom !== undefined) {\n                // Both top and bottom values are set, position top and assign height to reach bottom\n                this.height(parentGeom.y - this._uiTop - this._uiBottom, false, 0, true);\n                // Update translation\n                this._translate.y = Math.floor(this._uiTop + geomScaled.y2 - parentGeom.y2);\n            }\n            else {\n                if (this._uiTop !== undefined) {\n                    // Position top aligned\n                    this._translate.y = Math.floor(this._uiTop + geomScaled.y2 - parentGeom.y2);\n                }\n                if (this._uiBottom !== undefined) {\n                    // Position bottom aligned\n                    this._translate.y = Math.floor(parentGeom.y2 - geomScaled.y2 - this._uiBottom);\n                }\n            }\n        }\n        this.emit(\"uiUpdate\");\n        this.cacheDirty(true);\n    }\n    color(color) {\n        if (color !== undefined) {\n            this._color = color;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._color;\n    }\n    backgroundImage(texture, repeatType = \"no-repeat\") {\n        if (!(texture && texture.image)) {\n            return this._patternFill;\n        }\n        // Store the repeatType\n        this._patternRepeat = repeatType;\n        // Store the texture\n        this._patternTexture = texture;\n        // Resize the image if required\n        if (this._backgroundSize &&\n            typeof this._backgroundSize.x === \"number\" &&\n            typeof this._backgroundSize.y === \"number\") {\n            texture.resize(this._backgroundSize.x, this._backgroundSize.y);\n            this._patternWidth = this._backgroundSize.x;\n            this._patternHeight = this._backgroundSize.y;\n        }\n        else {\n            this._patternWidth = texture.image.width;\n            this._patternHeight = texture.image.height;\n        }\n        const canvas = new OffscreenCanvas(2, 2);\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) {\n            throw new Error(\"Couldn't get texture canvas 2d context!\");\n        }\n        if (this._cell && this._cell > 1) {\n            // Render the cell to a temporary canvas and set that as the pattern image\n            const cellData = texture._cells[this._cell];\n            canvas.width = cellData[2];\n            canvas.height = cellData[3];\n            ctx.drawImage(texture.image, cellData[0], cellData[1], cellData[2], cellData[3], 0, 0, cellData[2], cellData[3]);\n            // Create the pattern from the texture cell\n            this._patternFill = ctx.createPattern(canvas, repeatType) || undefined;\n        }\n        else {\n            // Create the pattern from the texture\n            this._patternFill = ctx.createPattern(texture.image, repeatType) || undefined;\n        }\n        texture.restoreOriginal();\n        this.cacheDirty(true);\n        return this;\n    }\n    backgroundSize(x, y) {\n        if (!(x !== undefined && y !== undefined)) {\n            return this._backgroundSize;\n        }\n        if (x === \"auto\" && y === \"auto\") {\n            this.log(\"Cannot set both background x and y to auto!\", \"error\");\n            return this;\n        }\n        let finalX = 1;\n        let finalY = 1;\n        if (typeof x === \"string\" && x !== \"auto\") {\n            // Work out the actual size in pixels\n            // from the percentage\n            x = (this._bounds2d.x / 100) * parseInt(x, 10);\n            finalX = x;\n        }\n        if (typeof y === \"string\" && y !== \"auto\") {\n            // Work out the actual size in pixels\n            // from the percentage\n            y = (this._bounds2d.y / 100) * parseInt(y, 10);\n            finalY = y;\n        }\n        if (x === \"auto\" && typeof y === \"number\") {\n            if (this._patternTexture && this._patternTexture.image) {\n                // find out y change and apply it to the x\n                x = this._patternTexture.image.width * (y / this._patternTexture.image.height);\n                finalX = x;\n            }\n            else {\n                x = this._bounds2d.x * (y / this._bounds2d.y);\n                finalX = x;\n            }\n        }\n        else if (y === \"auto\" && typeof x === \"number\") {\n            if (this._patternTexture && this._patternTexture.image) {\n                // find out x change and apply it to the y\n                y = this._patternTexture.image.height * (x / this._patternTexture.image.width);\n                finalY = y;\n            }\n            else {\n                y = this._bounds2d.y * (x / this._bounds2d.x);\n                finalY = y;\n            }\n        }\n        if (x === 0 || y === 0) {\n            throw new Error(\"Cannot set background to zero-sized x or y!\");\n        }\n        this._backgroundSize = { x: finalX, y: finalY };\n        // Reset the background image\n        if (this._patternTexture && this._patternRepeat) {\n            this.backgroundImage(this._patternTexture, this._patternRepeat);\n        }\n        this.cacheDirty(true);\n        return this;\n    }\n    backgroundColor(color) {\n        if (color !== undefined) {\n            this._backgroundColor = color;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._backgroundColor;\n    }\n    backgroundPosition(x, y) {\n        if (x !== undefined && y !== undefined) {\n            this._backgroundPosition = { x, y };\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._backgroundPosition;\n    }\n    borderColor(color) {\n        if (color !== undefined) {\n            this._borderColor = color;\n            this._borderLeftColor = color;\n            this._borderTopColor = color;\n            this._borderRightColor = color;\n            this._borderBottomColor = color;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderColor;\n    }\n    borderLeftColor(color) {\n        if (color !== undefined) {\n            this._borderLeftColor = color;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderLeftColor;\n    }\n    borderTopColor(color) {\n        if (color !== undefined) {\n            this._borderTopColor = color;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderTopColor;\n    }\n    borderRightColor(color) {\n        if (color !== undefined) {\n            this._borderRightColor = color;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderRightColor;\n    }\n    borderBottomColor(color) {\n        if (color !== undefined) {\n            this._borderBottomColor = color;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderBottomColor;\n    }\n    borderWidth(px) {\n        if (px !== undefined) {\n            this._borderWidth = px;\n            this._borderLeftWidth = px;\n            this._borderTopWidth = px;\n            this._borderRightWidth = px;\n            this._borderBottomWidth = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderWidth;\n    }\n    borderLeftWidth(px) {\n        if (px !== undefined) {\n            this._borderLeftWidth = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderLeftWidth;\n    }\n    borderTopWidth(px) {\n        if (px !== undefined) {\n            this._borderTopWidth = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderTopWidth;\n    }\n    borderRightWidth(px) {\n        if (px !== undefined) {\n            this._borderRightWidth = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderRightWidth;\n    }\n    borderBottomWidth(px) {\n        if (px !== undefined) {\n            this._borderBottomWidth = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderBottomWidth;\n    }\n    borderRadius(px) {\n        if (px !== undefined) {\n            this._borderRadius = px;\n            this._borderTopLeftRadius = px;\n            this._borderTopRightRadius = px;\n            this._borderBottomRightRadius = px;\n            this._borderBottomLeftRadius = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderRadius;\n    }\n    borderTopLeftRadius(px) {\n        if (px !== undefined) {\n            this._borderTopLeftRadius = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderTopLeftRadius;\n    }\n    borderTopRightRadius(px) {\n        if (px !== undefined) {\n            this._borderTopRightRadius = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderTopRightRadius;\n    }\n    borderBottomLeftRadius(px) {\n        if (px !== undefined) {\n            this._borderBottomLeftRadius = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderBottomLeftRadius;\n    }\n    borderBottomRightRadius(px) {\n        if (px !== undefined) {\n            this._borderBottomRightRadius = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._borderBottomRightRadius;\n    }\n    padding(...args) {\n        if (args.length === 0)\n            return this._padding;\n        if (args.length === 1) {\n            // Set padding proper\n            this._padding = args[0];\n            this.cacheDirty(true);\n            return this;\n        }\n        // Set padding as box (left, top, right, bottom)\n        this._paddingLeft = args[0];\n        this._paddingTop = args[1];\n        this._paddingRight = args[2];\n        this._paddingBottom = args[3];\n        this.cacheDirty(true);\n        return this;\n    }\n    paddingX(px) {\n        if (px !== undefined) {\n            this._paddingLeft = px;\n            this._paddingRight = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._paddingLeft;\n    }\n    paddingY(px) {\n        if (px !== undefined) {\n            this._paddingTop = px;\n            this._paddingBottom = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._paddingTop;\n    }\n    paddingLeft(px) {\n        if (px !== undefined) {\n            this._paddingLeft = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._paddingLeft;\n    }\n    paddingTop(px) {\n        if (px !== undefined) {\n            this._paddingTop = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._paddingTop;\n    }\n    paddingRight(px) {\n        if (px !== undefined) {\n            this._paddingRight = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._paddingRight;\n    }\n    paddingBottom(px) {\n        if (px !== undefined) {\n            this._paddingBottom = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._paddingBottom;\n    }\n    margin(...args) {\n        if (args.length === 0)\n            return this._margin;\n        if (args.length === 1) {\n            // Set margin proper\n            this._margin = args[0];\n            this.cacheDirty(true);\n            return this;\n        }\n        // Set margin as box (left, top, right, bottom)\n        this._marginLeft = args[0];\n        this._marginTop = args[1];\n        this._marginRight = args[2];\n        this._marginBottom = args[3];\n        this.cacheDirty(true);\n        return this;\n    }\n    marginLeft(px) {\n        if (px !== undefined) {\n            this._marginLeft = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._marginLeft !== undefined ? this._marginLeft : this._margin;\n    }\n    marginTop(px) {\n        if (px !== undefined) {\n            this._marginTop = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._marginTop;\n    }\n    marginRight(px) {\n        if (px !== undefined) {\n            this._marginRight = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._marginRight;\n    }\n    marginBottom(px) {\n        if (px !== undefined) {\n            this._marginBottom = px;\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._marginBottom;\n    }\n    _renderBackground(ctx) {\n        const geom = this._bounds2d;\n        if ((!this._backgroundColor && !this._patternFill) || !ctx) {\n            return;\n        }\n        const left = -(geom.x / 2) | 0;\n        const top = -(geom.y / 2) | 0;\n        const width = geom.x;\n        const height = geom.y;\n        ctx.save();\n        ctx.beginPath();\n        if (!this._borderTopRightRadius &&\n            !this._borderBottomRightRadius &&\n            !this._borderBottomLeftRadius &&\n            !this._borderTopLeftRadius) {\n            ctx.rect(left, top, width, height);\n        }\n        else {\n            // Top border\n            ctx.moveTo(left + this._borderTopLeftRadius, top);\n            ctx.lineTo(left + width - this._borderTopRightRadius, top);\n            if (this._borderTopRightRadius > 0) {\n                // Top-right corner\n                ctx.arcTo(left + width, top, left + width, top + this._borderTopRightRadius, this._borderTopRightRadius);\n            }\n            // Right border\n            ctx.lineTo(left + width, top + height - this._borderBottomRightRadius);\n            if (this._borderBottomRightRadius > 0) {\n                // Bottom-right corner\n                ctx.arcTo(left + width, top + height, left + width - this._borderBottomRightRadius, top + height, this._borderBottomRightRadius);\n            }\n            // Bottom border\n            ctx.lineTo(left + this._borderBottomLeftRadius, top + height);\n            if (this._borderBottomLeftRadius > 0) {\n                // Bottom-left corner\n                ctx.arcTo(left, top + height, left, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius);\n            }\n            // Left border\n            ctx.lineTo(left, top + this._borderTopLeftRadius);\n            if (this._borderTopLeftRadius > 0) {\n                // Top-left corner\n                ctx.arcTo(left, top, left + this._borderTopLeftRadius, top, this._borderTopLeftRadius);\n            }\n            ctx.clip();\n        }\n        if (this._backgroundColor) {\n            ctx.fillStyle = this._backgroundColor;\n            ctx.fill();\n        }\n        if (this._patternFill) {\n            ctx.translate(-((width / 2) | 0) + this._backgroundPosition.x, -((height / 2) | 0) + this._backgroundPosition.y);\n            ctx.fillStyle = this._patternFill;\n            ctx.fill();\n        }\n        ctx.restore();\n    }\n    _anyBorderColor() {\n        return Boolean(this._borderColor ||\n            this._borderLeftColor ||\n            this._borderTopColor ||\n            this._borderRightColor ||\n            this._borderBottomColor);\n    }\n    _anyBorderWidth() {\n        return Boolean(this._borderWidth ||\n            this._borderLeftWidth ||\n            this._borderTopWidth ||\n            this._borderRightWidth ||\n            this._borderBottomWidth);\n    }\n    _anyBorderRadius() {\n        return Boolean(this._borderRadius ||\n            this._borderTopRightRadius ||\n            this._borderBottomRightRadius ||\n            this._borderBottomLeftRadius ||\n            this._borderTopLeftRadius);\n    }\n    _borderWidthsMatch() {\n        return (this._borderLeftWidth === this._borderWidth &&\n            this._borderTopWidth === this._borderWidth &&\n            this._borderRightWidth === this._borderWidth &&\n            this._borderBottomWidth === this._borderWidth);\n    }\n    // TODO: Refactor this to reduce size, breakout\n    _renderBorder(ctx) {\n        const geom = this._bounds2d;\n        const left = (-geom.x2 | 0) + 0.5;\n        const top = (-geom.y2 | 0) + 0.5;\n        const width = geom.x - 1;\n        const height = geom.y - 1;\n        if (!this._anyBorderColor())\n            return;\n        if (!this._anyBorderWidth())\n            return;\n        // Check for early exit if we are rendering a rectangle\n        if (!this._anyBorderRadius() && this._borderWidthsMatch()) {\n            ctx.strokeStyle = this._borderColor;\n            ctx.lineWidth = this._borderWidth;\n            ctx.strokeRect(left, top, width, height);\n        }\n        else {\n            const startNewStroke = function () {\n                ctx.stroke();\n                ctx.beginPath();\n            };\n            ctx.beginPath();\n            if (this._borderTopWidth) {\n                // Top-left corner top-half\n                ctx.strokeStyle = this._borderTopColor;\n                ctx.lineWidth = this._borderTopWidth;\n                if (this._borderTopLeftRadius > 0) {\n                    // Top-left corner top-half\n                    ctx.arc(left + this._borderTopLeftRadius, top + this._borderTopLeftRadius, this._borderTopLeftRadius, 225 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180, 270 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180);\n                }\n                // Top border\n                ctx.moveTo(left + this._borderTopLeftRadius, top);\n                ctx.lineTo(left + width - this._borderTopRightRadius, top);\n                if (this._borderTopRightRadius > 0) {\n                    // Top-right corner top-half\n                    ctx.arc(left + width - this._borderTopRightRadius, top + this._borderTopRightRadius, this._borderTopRightRadius, -90 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180, -44 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180); // use -44 instead of -45 to fully connect with next piece\n                }\n            }\n            if (!this._borderRightWidth ||\n                this._borderTopColor !== this._borderRightColor ||\n                this._borderTopWidth !== this._borderRightWidth)\n                startNewStroke();\n            if (this._borderRightWidth) {\n                // Top-right corner bottom-half\n                ctx.strokeStyle = this._borderRightColor;\n                ctx.lineWidth = this._borderRightWidth;\n                if (this._borderTopRightRadius > 0) {\n                    ctx.arc(left + width - this._borderTopRightRadius, top + this._borderTopRightRadius, this._borderTopRightRadius, -45 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180, 0);\n                }\n                // Right border\n                ctx.moveTo(left + width, top + this._borderTopRightRadius);\n                ctx.lineTo(left + width, top + height - this._borderBottomRightRadius);\n                if (this._borderBottomRightRadius > 0) {\n                    // Bottom-right corner top-half\n                    ctx.arc(left + width - this._borderBottomRightRadius, top + height - this._borderBottomRightRadius, this._borderTopRightRadius, 0, 46 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180); // use 46 instead of 45 to fully connect with next piece\n                }\n            }\n            if (!this._borderBottomWidth ||\n                this._borderRightColor !== this._borderBottomColor ||\n                this._borderRightWidth !== this._borderBottomWidth)\n                startNewStroke();\n            if (this._borderBottomWidth) {\n                // Bottom-right corner bottom-half\n                ctx.strokeStyle = this._borderBottomColor;\n                ctx.lineWidth = this._borderBottomWidth;\n                if (this._borderBottomRightRadius > 0) {\n                    ctx.arc(left + width - this._borderBottomRightRadius, top + height - this._borderBottomRightRadius, this._borderBottomRightRadius, 45 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180, 90 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180);\n                }\n                // Bottom border\n                ctx.moveTo(left + width - this._borderBottomRightRadius, top + height);\n                ctx.lineTo(left + this._borderBottomLeftRadius, top + height);\n                if (this._borderBottomLeftRadius > 0) {\n                    // Bottom-left corner bottom-half\n                    ctx.arc(left + this._borderBottomLeftRadius, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius, 90 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180, 136 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180); // use 136 instead of 135 to fully connect with next piece\n                }\n            }\n            if (!this._borderLeftWidth ||\n                this._borderBottomColor !== this._borderLeftColor ||\n                this._borderBottomWidth !== this._borderLeftWidth)\n                startNewStroke();\n            if (this._borderLeftWidth) {\n                // Bottom-left corner top-half\n                ctx.strokeStyle = this._borderLeftColor;\n                ctx.lineWidth = this._borderLeftWidth;\n                if (this._borderBottomLeftRadius > 0) {\n                    ctx.arc(left + this._borderBottomLeftRadius, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius, 135 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180, 180 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180);\n                }\n                // Left border\n                ctx.moveTo(left, top + height - this._borderBottomLeftRadius);\n                ctx.lineTo(left, top + this._borderTopLeftRadius);\n                if (this._borderTopLeftRadius > 0) {\n                    // Top-left corner bottom-half\n                    ctx.arc(left + this._borderTopLeftRadius, top + this._borderTopLeftRadius, this._borderTopLeftRadius, 180 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180, 226 * _engine_utils_maths__WEBPACK_IMPORTED_MODULE_3__.PI180); // use 226 instead of 225 to fully connect with next piece\n                }\n            }\n            ctx.stroke();\n        }\n    }\n}\n(0,_engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_2__.registerClass)(IgeUiEntity);\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeUiEntity.ts?");

/***/ }),

/***/ "./src/engine/core/IgeViewport.ts":
/*!****************************************!*\
  !*** ./src/engine/core/IgeViewport.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeViewport: () => (/* binding */ IgeViewport)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeBounds */ \"./src/engine/core/IgeBounds.ts\");\n/* harmony import */ var _engine_core_IgeCamera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/IgeCamera */ \"./src/engine/core/IgeCamera.ts\");\n/* harmony import */ var _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/core/IgePoint2d */ \"./src/engine/core/IgePoint2d.ts\");\n/* harmony import */ var _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/core/IgePoint3d */ \"./src/engine/core/IgePoint3d.ts\");\n/* harmony import */ var _engine_core_IgeUiEntity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/engine/core/IgeUiEntity */ \"./src/engine/core/IgeUiEntity.ts\");\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/engine/utils/clientServer */ \"./src/engine/utils/clientServer.ts\");\n/* harmony import */ var _engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/engine/utils/igeClassStore */ \"./src/engine/utils/igeClassStore.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\n\n\n\n\n\n\n\n\n\n// TODO: Turns out we need IgeObject because IgeViewport cannot extend IgeEntity\n//    because IgeEntity imports IgeViewport, creating a circular referencing issue\n/**\n * Creates a new viewport.\n */\nclass IgeViewport extends _engine_core_IgeUiEntity__WEBPACK_IMPORTED_MODULE_4__.IgeUiEntity {\n    constructor(options) {\n        super();\n        this.classId = \"IgeViewport\";\n        this.IgeViewport = true;\n        this._autoSize = false;\n        let width, height;\n        this._alwaysInView = true;\n        this._pointerAlwaysInside = true;\n        this._pointerPos = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(0, 0, 0);\n        this._overflow = \"\";\n        this._clipping = true;\n        this._bornTime = 0;\n        // Set default options if not specified\n        // TODO: Is this required or even used?\n        if (options) {\n            width = options.width;\n            height = options.height;\n            if (options && options.scaleToWidth && options.scaleToHeight) {\n                // Store the w/h we want to lock to\n                this._lockDimension = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(options.scaleToWidth, options.scaleToHeight, 0);\n            }\n        }\n        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine) {\n            throw new Error(\"IgeViewport instantiated before IgeEngine instance was created!\");\n        }\n        // Setup default objects\n        this._bounds2d = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_2__.IgePoint2d(width || _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._bounds2d.x, height || _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._bounds2d.y);\n        this.camera = new _engine_core_IgeCamera__WEBPACK_IMPORTED_MODULE_1__.IgeCamera(this);\n        this.camera._entity = this;\n        //this._drawMouse = true;\n    }\n    /**\n     * Sets the minimum amount of world in pixels to display in width and height.\n     * When set, if the viewport's geometry is reduced below the minimum width or\n     * height, the viewport's camera is automatically scaled to ensure that the\n     * minimum area remains visible in the viewport.\n     * @param {number} width Width in pixels.\n     * @param {number} height Height in pixels.\n     * @returns {*}\n     */\n    minimumVisibleArea(width, height) {\n        // Store the w/h we want to lock to\n        this._lockDimension = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(width, height, 0);\n        if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_6__.isClient) {\n            this._resizeEvent();\n        }\n        return this;\n    }\n    autoSize(val) {\n        if (typeof val !== \"undefined\") {\n            this._autoSize = val;\n            return this;\n        }\n        return this._autoSize;\n    }\n    scene(scene) {\n        if (scene !== undefined) {\n            this._scene = scene;\n            return this;\n        }\n        return this._scene;\n    }\n    /**\n     * Returns the viewport's mouse position.\n     * @return {IgePoint3d}\n     */\n    mousePos() {\n        // Viewport mouse position is calculated and assigned in the\n        // IgeInputComponent class.\n        return this._pointerPos.clone();\n    }\n    mousePosWorld() {\n        return this._transformPoint(this._pointerPos.clone());\n    }\n    /**\n     * Gets the current rectangular area that the viewport is \"looking at\"\n     * in the world. The co-ordinates are in world space.\n     * @returns {IgeBounds}\n     */\n    viewArea(camScaleX = this.camera._scale.x, camScaleY = this.camera._scale.y) {\n        const aabb = this.aabb(), camTrans = this.camera._translate, width = aabb.width * (1 / camScaleX), height = aabb.height * (1 / camScaleY);\n        return new _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_0__.IgeBounds(camTrans.x - width / 2, camTrans.y - height / 2, width, height);\n    }\n    /**\n     * Processes the updates before the render tick is called.\n     * @param tickDelta\n     */\n    update(tickDelta) {\n        // Check if we have a scene attached to this viewport\n        if (!this._scene) {\n            return;\n        }\n        _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._currentCamera = this.camera;\n        _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._currentViewport = this;\n        this._scene._parent = this;\n        this.camera.update();\n        super.update(tickDelta);\n        if (this._scene.newFrame()) {\n            this._scene.update(tickDelta);\n        }\n    }\n    /**\n     * Processes the actions required each render frame.\n     */\n    tick(ctx) {\n        // Check if we have a scene attached to this viewport and ige has a root object\n        if (!this._scene || !_engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine) {\n            return;\n        }\n        _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._currentCamera = this.camera;\n        _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._currentViewport = this;\n        this._scene._parent = this;\n        super.tick(ctx);\n        ctx.translate(-(this._bounds2d.x * this._origin.x) | 0, -(this._bounds2d.y * this._origin.y) | 0);\n        ctx.clearRect(0, 0, this._bounds2d.x, this._bounds2d.y);\n        if (this._clipping || this._borderColor) {\n            ctx.beginPath();\n            ctx.rect(0, 0, this._bounds2d.x / _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._scale.x, this._bounds2d.y / _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._scale.x);\n            // Paint a border if required\n            if (this._borderColor) {\n                ctx.strokeStyle = this._borderColor;\n                ctx.stroke();\n            }\n            if (this._clipping) {\n                ctx.clip();\n            }\n        }\n        ctx.translate(((this._bounds2d.x / 2) | 0) + _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._translate.x, ((this._bounds2d.y / 2) | 0) + _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._translate.y);\n        if (_engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._scale.x !== 1 || _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._scale.y !== 1) {\n            ctx.scale(_engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._scale.x, _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._scale.y);\n        }\n        this.camera.tick(ctx);\n        ctx.save();\n        this._scene.tick(ctx);\n        ctx.restore();\n        if (this._drawGuides) { // Used to have extra condition: && ctx === ige.engine._ctx\n            ctx.save();\n            ctx.translate(-this._translate.x, -this._translate.y);\n            this.paintGuides(ctx);\n            ctx.restore();\n        }\n        if (this._drawBounds) { // Used to have extra condition: && ctx === ige.engine._ctx\n            // Traverse the scenegraph and draw axis-aligned\n            // bounding boxes for every object\n            ctx.save();\n            ctx.translate(-this._translate.x, -this._translate.y);\n            this.paintAabbs(ctx, this._scene, 0);\n            ctx.restore();\n        }\n        if (this._drawMouse) { // Used to have extra condition: && ctx === ige.engine._ctx\n            ctx.save();\n            const mp = this.mousePos();\n            // Re-scale the context to ensure that output is always 1:1\n            ctx.scale(1 / this.camera._scale.x, 1 / this.camera._scale.y);\n            // Work out the re-scale mouse position\n            const mx = Math.floor(mp.x * this.camera._scale.x);\n            const my = Math.floor(mp.y * this.camera._scale.y);\n            ctx.fillStyle = \"#fc00ff\";\n            ctx.fillRect(mx - 5, my - 5, 10, 10);\n            const text = this.id() + \" X: \" + mx + \", Y: \" + my;\n            const textMeasurement = ctx.measureText(text);\n            if (textMeasurement) {\n                ctx.fillStyle = \"rgba(0, 0, 0, 0.8)\";\n                ctx.fillRect(Math.floor(mx - textMeasurement.width / 2 - 5), Math.floor(my - 25), Math.floor(textMeasurement.width + 10), 14);\n                ctx.fillStyle = \"#ffffff\";\n                ctx.fillText(text, mx - textMeasurement.width / 2, my - 15);\n            }\n            ctx.restore();\n        }\n        if (this._drawViewArea) {\n            ctx.save();\n            const va = this.viewArea();\n            ctx.rect(va.x, va.y, va.width, va.height);\n            ctx.stroke();\n            ctx.restore();\n        }\n    }\n    /**\n     * Returns the screen position of the viewport as an IgePoint3d where x is the\n     * \"left\" and y is the \"top\", useful for positioning HTML elements at the\n     * screen location of an IGE entity. The returned values indicate the center\n     * of the viewport on the screen.\n     *\n     * This method assumes that the top-left\n     * of the main canvas element is at 0, 0. If not you can adjust the values\n     * yourself to allow for offset.\n     * @example #Get the screen position of the entity\n     *     var screenPos = entity.screenPosition();\n     * @return {IgePoint3d} The screen position of the entity.\n     */\n    screenPosition() {\n        var _a, _b;\n        return new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(Math.floor(this._worldMatrix.matrix[2] + (((_a = _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._bounds2d) === null || _a === void 0 ? void 0 : _a.x2) || 0)), Math.floor(this._worldMatrix.matrix[5] + (((_b = _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._bounds2d) === null || _b === void 0 ? void 0 : _b.y2) || 0)), 0);\n    }\n    drawViewArea(val) {\n        if (val !== undefined) {\n            this._drawViewArea = val;\n            return this;\n        }\n        return this._drawViewArea;\n    }\n    drawBoundsLimitId(id) {\n        if (id !== undefined) {\n            this._drawBoundsLimitId = id;\n            return this;\n        }\n        return this._drawBoundsLimitId;\n    }\n    drawBoundsLimitCategory(category) {\n        if (category !== undefined) {\n            this._drawBoundsLimitCategory = category;\n            return this;\n        }\n        return this._drawBoundsLimitCategory;\n    }\n    drawCompositeBounds(val) {\n        if (val !== undefined) {\n            this._drawCompositeBounds = val;\n            return this;\n        }\n        return this._drawCompositeBounds;\n    }\n    drawGuides(val) {\n        if (val !== undefined) {\n            this._drawGuides = val;\n            return this;\n        }\n        return this._drawGuides;\n    }\n    paintGuides(ctx) {\n        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine)\n            return;\n        const geom = _engine_instance__WEBPACK_IMPORTED_MODULE_5__.ige.engine._bounds2d;\n        // Check draw-guides setting\n        if (this._drawGuides) {\n            ctx.strokeStyle = \"#ffffff\";\n            ctx.translate(0.5, 0.5);\n            // Draw guide lines in the center\n            ctx.beginPath();\n            ctx.moveTo(0, -geom.y2);\n            ctx.lineTo(0, geom.y);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.moveTo(-geom.x2, 0);\n            ctx.lineTo(geom.x, 0);\n            ctx.stroke();\n        }\n    }\n    /**\n     * Draws the bounding data for each entity in the scenegraph.\n     * @param ctx\n     * @param rootObject\n     * @param index\n     */\n    paintAabbs(ctx, rootObject, index) {\n        const arr = rootObject._children || [];\n        let arrCount, obj, aabb, aabbC, bounds3dPoly, ga, r3d, xl1, xl2, xl3, xl4, xl5, xl6, bf1, bf2, bf3, bf4, tf1, tf2, tf3, tf4;\n        if (!arr || !arr.length) {\n            return;\n        }\n        arrCount = arr.length;\n        while (arrCount--) {\n            obj = arr[arrCount];\n            index++;\n            if (!obj._shouldRender) {\n                continue;\n            }\n            if ((obj.classId !== \"IgeScene2d\" && !this._drawBoundsLimitId && !this._drawBoundsLimitCategory) ||\n                (this._drawBoundsLimitId &&\n                    (this._drawBoundsLimitId instanceof Array\n                        ? this._drawBoundsLimitId.indexOf(obj.id()) > -1\n                        : this._drawBoundsLimitId === obj.id())) ||\n                (this._drawBoundsLimitCategory && this._drawBoundsLimitCategory === obj.category())) {\n                if (typeof obj.aabb === \"function\") {\n                    // Grab the AABB and then draw it\n                    aabb = obj.aabb();\n                    if (this._drawCompositeBounds && obj._compositeCache) {\n                        aabbC = obj.compositeAabb();\n                        // Draw composite bounds\n                        ctx.strokeStyle = \"#ff0000\";\n                        ctx.strokeRect(aabbC.x, aabbC.y, aabbC.width, aabbC.height);\n                    }\n                    if (aabb) {\n                        if (obj._drawBounds || obj._drawBounds === undefined) {\n                            //if (!obj._parent || (obj._parent && obj._parent._mountMode !== IgeMountMode.iso)) {\n                            // Draw a rect around the bounds of the object transformed in world space\n                            /*ctx.save();\n                                obj._worldMatrix.transformRenderingContext(ctx);\n                                ctx.strokeStyle = '#9700ae';\n                                ctx.strokeRect(-obj._bounds2d.x2, -obj._bounds2d.y2, obj._bounds2d.x, obj._bounds2d.y);\n                              ctx.restore();*/\n                            // Draw individual bounds\n                            ctx.strokeStyle = \"#00deff\";\n                            ctx.strokeRect(aabb.x, aabb.y, aabb.width, aabb.height);\n                            //}\n                            // Check if the object is mounted to an isometric mount\n                            if (obj._parent && obj._parent._mountMode === _enums__WEBPACK_IMPORTED_MODULE_8__.IgeMountMode.iso) {\n                                bounds3dPoly = obj.bounds3dPolygon().aabb();\n                                ctx.save();\n                                ctx.strokeStyle = \"#0068b8\";\n                                ctx.strokeRect(bounds3dPoly.x, bounds3dPoly.y, bounds3dPoly.width, bounds3dPoly.height);\n                                ctx.restore();\n                                ctx.save();\n                                ctx.translate(bounds3dPoly.x + bounds3dPoly.width / 2, bounds3dPoly.y + bounds3dPoly.height / 2);\n                                //obj._transformContext(ctx);\n                                // Calculate the 3d bounds data\n                                r3d = obj._bounds3d;\n                                xl1 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(-(r3d.x / 2), 0, 0).toIso();\n                                xl2 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(+(r3d.x / 2), 0, 0).toIso();\n                                xl3 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(0, -(r3d.y / 2), 0).toIso();\n                                xl4 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(0, +(r3d.y / 2), 0).toIso();\n                                xl5 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(0, 0, -(r3d.z / 2)).toIso();\n                                xl6 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(0, 0, +(r3d.z / 2)).toIso();\n                                // Bottom face\n                                bf1 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(-(r3d.x / 2), -(r3d.y / 2), -(r3d.z / 2)).toIso();\n                                bf2 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(+(r3d.x / 2), -(r3d.y / 2), -(r3d.z / 2)).toIso();\n                                bf3 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(+(r3d.x / 2), +(r3d.y / 2), -(r3d.z / 2)).toIso();\n                                bf4 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(-(r3d.x / 2), +(r3d.y / 2), -(r3d.z / 2)).toIso();\n                                // Top face\n                                tf1 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(-(r3d.x / 2), -(r3d.y / 2), r3d.z / 2).toIso();\n                                tf2 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(+(r3d.x / 2), -(r3d.y / 2), r3d.z / 2).toIso();\n                                tf3 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(+(r3d.x / 2), +(r3d.y / 2), r3d.z / 2).toIso();\n                                tf4 = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_3__.IgePoint3d(-(r3d.x / 2), +(r3d.y / 2), r3d.z / 2).toIso();\n                                ga = ctx.globalAlpha;\n                                // Axis lines\n                                ctx.globalAlpha = 1;\n                                ctx.strokeStyle = \"#ff0000\";\n                                ctx.beginPath();\n                                ctx.moveTo(xl1.x, xl1.y);\n                                ctx.lineTo(xl2.x, xl2.y);\n                                ctx.stroke();\n                                ctx.strokeStyle = \"#00ff00\";\n                                ctx.beginPath();\n                                ctx.moveTo(xl3.x, xl3.y);\n                                ctx.lineTo(xl4.x, xl4.y);\n                                ctx.stroke();\n                                ctx.strokeStyle = \"#fffc00\";\n                                ctx.beginPath();\n                                ctx.moveTo(xl5.x, xl5.y);\n                                ctx.lineTo(xl6.x, xl6.y);\n                                ctx.stroke();\n                                ctx.strokeStyle = \"#a200ff\";\n                                if (obj._highlight) {\n                                    ctx.globalAlpha = 0.9;\n                                }\n                                else {\n                                    ctx.globalAlpha = 0.6;\n                                }\n                                // Left face\n                                ctx.fillStyle = \"#545454\";\n                                ctx.beginPath();\n                                ctx.moveTo(bf3.x, bf3.y);\n                                ctx.lineTo(bf4.x, bf4.y);\n                                ctx.lineTo(tf4.x, tf4.y);\n                                ctx.lineTo(tf3.x, tf3.y);\n                                ctx.lineTo(bf3.x, bf3.y);\n                                ctx.fill();\n                                ctx.stroke();\n                                // Right face\n                                ctx.fillStyle = \"#282828\";\n                                ctx.beginPath();\n                                ctx.moveTo(bf3.x, bf3.y);\n                                ctx.lineTo(bf2.x, bf2.y);\n                                ctx.lineTo(tf2.x, tf2.y);\n                                ctx.lineTo(tf3.x, tf3.y);\n                                ctx.lineTo(bf3.x, bf3.y);\n                                ctx.fill();\n                                ctx.stroke();\n                                // Top face\n                                ctx.fillStyle = \"#676767\";\n                                ctx.beginPath();\n                                ctx.moveTo(tf1.x, tf1.y);\n                                ctx.lineTo(tf2.x, tf2.y);\n                                ctx.lineTo(tf3.x, tf3.y);\n                                ctx.lineTo(tf4.x, tf4.y);\n                                ctx.lineTo(tf1.x, tf1.y);\n                                ctx.fill();\n                                ctx.stroke();\n                                ctx.globalAlpha = ga;\n                                ctx.restore();\n                            }\n                        }\n                        if (this._drawBoundsData && (obj._drawBounds || obj._drawBoundsData === undefined)) {\n                            ctx.globalAlpha = 1;\n                            ctx.fillStyle = \"#f6ff00\";\n                            ctx.fillText(\"ID: \" +\n                                obj.id() +\n                                \" \" +\n                                \"(\" +\n                                obj.classId +\n                                \") \" +\n                                obj.layer() +\n                                \":\" +\n                                obj.depth().toFixed(0), aabb.x + aabb.width + 3, aabb.y + 10);\n                            ctx.fillText(\"X: \" +\n                                obj._translate.x.toFixed(2) +\n                                \", \" +\n                                \"Y: \" +\n                                obj._translate.y.toFixed(2) +\n                                \", \" +\n                                \"Z: \" +\n                                obj._translate.z.toFixed(2), aabb.x + aabb.width + 3, aabb.y + 20);\n                            ctx.fillText(\"Num Children: \" + obj._children.length, aabb.x + aabb.width + 3, aabb.y + 40);\n                        }\n                    }\n                }\n            }\n            this.paintAabbs(ctx, obj, index);\n        }\n    }\n    /**\n     * Handles screen resize events.\n     * @param event\n     * @private\n     */\n    _resizeEvent(event) {\n        if (this._autoSize && this._parent) {\n            this._bounds2d = this._parent._bounds2d.clone();\n        }\n        this._updateUiPosition();\n        // Resize the scene\n        if (this._scene) {\n            this._scene._resizeEvent(event);\n        }\n        // Process locked dimension scaling\n        if (this._lockDimension) {\n            // Calculate the new camera scale\n            let ratio = 1, tmpX, tmpY;\n            if (this._bounds2d.x > this._lockDimension.x && this._bounds2d.y > this._lockDimension.y) {\n                // Scale using the lowest ratio\n                tmpX = this._bounds2d.x / this._lockDimension.x;\n                tmpY = this._bounds2d.y / this._lockDimension.y;\n                ratio = tmpX < tmpY ? tmpX : tmpY;\n            }\n            else {\n                if (this._bounds2d.x > this._lockDimension.x && this._bounds2d.y < this._lockDimension.y) {\n                    // Scale out to show height\n                    ratio = this._bounds2d.y / this._lockDimension.y;\n                }\n                if (this._bounds2d.x < this._lockDimension.x && this._bounds2d.y > this._lockDimension.y) {\n                    // Scale out to show width\n                    ratio = this._bounds2d.x / this._lockDimension.x;\n                }\n                if (this._bounds2d.x < this._lockDimension.x && this._bounds2d.y < this._lockDimension.y) {\n                    // Scale using the lowest ratio\n                    tmpX = this._bounds2d.x / this._lockDimension.x;\n                    tmpY = this._bounds2d.y / this._lockDimension.y;\n                    ratio = tmpX < tmpY ? tmpX : tmpY;\n                }\n            }\n            this.camera.scaleTo(ratio, ratio, ratio);\n        }\n    }\n    /**\n     * Returns a string containing a code fragment that when\n     * evaluated will reproduce this object's properties via\n     * chained commands. This method will only check for\n     * properties that are directly related to this class.\n     * Other properties are handled by their own class method.\n     * @return {string}\n     */\n    _stringify() {\n        // Get the properties for all the super-classes\n        let str = super.stringify();\n        // Loop properties and add property assignment code to string\n        for (const i in this) {\n            if (this.hasOwnProperty(i) && this[i] !== undefined) {\n                switch (i) {\n                    case \"_autoSize\":\n                        str += \".autoSize(\" + this._autoSize + \")\";\n                        break;\n                    case \"_scene\":\n                        str += \".scene(ige.$('\" + this.scene().id() + \"'))\";\n                        break;\n                }\n            }\n        }\n        return str;\n    }\n}\n(0,_engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_7__.registerClass)(IgeViewport);\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeViewport.ts?");

/***/ })

}]);