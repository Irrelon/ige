"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_irrelon_ige"] = self["webpackChunk_irrelon_ige"] || []).push([["src_engine_core_IgeEngine_ts"],{

/***/ "./src/engine/core/IgeEngine.ts":
/*!**************************************!*\
  !*** ./src/engine/core/IgeEngine.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeEngine: () => (/* binding */ IgeEngine)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEntity */ \"./src/engine/core/IgeEntity.ts\");\n/* harmony import */ var _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/IgePoint2d */ \"./src/engine/core/IgePoint2d.ts\");\n/* harmony import */ var _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/core/IgePoint3d */ \"./src/engine/core/IgePoint3d.ts\");\n/* harmony import */ var _engine_core_IgeViewport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/core/IgeViewport */ \"./src/engine/core/IgeViewport.ts\");\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/engine/utils/clientServer */ \"./src/engine/utils/clientServer.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nclass IgeEngine extends _engine_core_IgeEntity__WEBPACK_IMPORTED_MODULE_0__.IgeEntity {\n    constructor() {\n        super();\n        this.classId = \"IgeEngine\";\n        this._idRegistered = true;\n        this._renderer = null;\n        this._pause = false;\n        this._useManualRender = false;\n        this._manualRenderQueued = false;\n        this._useManualTicks = false;\n        this._manualFrameAlternator = false;\n        this._state = _enums__WEBPACK_IMPORTED_MODULE_6__.IgeEngineState.stopped;\n        this._viewportDepth = false;\n        this._tickStart = 0;\n        this._dependencyCheckTimeout = 5000; // Wait 30 seconds to load all dependencies then timeout;\n        this._autoSize = true;\n        this._syncIndex = 0;\n        this._syncArr = [];\n        this._devicePixelRatio = 1;\n        this._createdFrontBuffer = false;\n        this._resized = false;\n        this._timeScaleLastTimestamp = 0;\n        this.lastTick = 0;\n        this._setTickout = [];\n        // The engine entity is always \"in view\" as in, no occlusion will stop it from rendering\n        // because it's only the child entities that need occlusion testing\n        this._alwaysInView = true;\n        this.basePath = \"\";\n        this.fontsLoaded = () => {\n            if (!this._webFonts.length && !this._cssFonts.length)\n                return true;\n            const loadedWebFonts = !this._webFonts.length ||\n                this._webFonts.every((webFont) => {\n                    return webFont.status === \"loaded\" || webFont.status === \"error\";\n                });\n            const loadedCssFonts = !this._cssFonts.length ||\n                this._cssFonts.every((cssFont) => {\n                    return this.fontList().includes(cssFont);\n                });\n            return loadedWebFonts && loadedCssFonts;\n        };\n        /**\n         * Handles the screen resize event.\n         * @param event\n         * @private\n         */\n        this._resizeEvent = (event) => {\n            if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isServer)\n                return;\n            if (!this._autoSize)\n                return;\n            const arr = this._children;\n            const newWidth = window.innerWidth;\n            const newHeight = window.innerHeight;\n            let arrCount = arr.length;\n            this._bounds2d = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_1__.IgePoint2d(newWidth, newHeight);\n            // Loop any mounted children and check if\n            // they should also get resized\n            while (arrCount--) {\n                arr[arrCount]._resizeEvent(event);\n            }\n            // if (this._showSgTree) {\n            // \tconst sgTreeElem = document.getElementById(\"igeSgTree\");\n            //\n            // \tif (sgTreeElem) {\n            // \t\tcanvasBoundingRect = this._canvasPosition();\n            //\n            // \t\tsgTreeElem.style.top = canvasBoundingRect.top + 5 + \"px\";\n            // \t\tsgTreeElem.style.left = canvasBoundingRect.left + 5 + \"px\";\n            // \t\tsgTreeElem.style.height = this._bounds2d.y - 30 + \"px\";\n            // \t}\n            // }\n            this._resized = true;\n        };\n        /**\n         * Toggles full-screen output of the renderer canvas. Only works\n         * if called from within a user-generated HTML event listener.\n         */\n        this.toggleFullScreen = () => {\n            var _a;\n            (_a = this._renderer) === null || _a === void 0 ? void 0 : _a.toggleFullScreen();\n        };\n        /**\n         * Finds the first Ige* based class that the passed object\n         * has been derived from.\n         * @param obj\n         * @return {*}\n         */\n        this.findBaseClass = (obj) => {\n            if (obj && obj.constructor && obj.constructor.name) {\n                if (obj.constructor.name.substr(0, 3) === \"Ige\") {\n                    return obj.constructor.name;\n                }\n                else {\n                    if (obj.__proto__.constructor.name) {\n                        return this.findBaseClass(obj.__proto__);\n                    }\n                    else {\n                        return \"\";\n                    }\n                }\n            }\n            else {\n                return \"\";\n            }\n        };\n        /**\n         * Is called every second and does things like calculate the current FPS.\n         * @private\n         */\n        this._secondTick = () => {\n            // Store frames per second\n            this._fps = this._frames;\n            // Store draws per second\n            this._dps = this._dpf * this._fps;\n            // Zero out counters\n            this._frames = 0;\n            this._drawCount = 0;\n        };\n        /**\n         * Checks to ensure that a canvas has been assigned to the engine or that the\n         * engine is in server mode.\n         * @return {boolean}\n         */\n        this.canvasReady = () => {\n            var _a;\n            //return this._canvas !== undefined || isWorker || isServer;\n            return ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.isReady()) || _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isWorker || _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isServer;\n        };\n        /**\n         * Called each frame to traverse and render the scenegraph.\n         */\n        this.engineStep = (timeStamp) => {\n            /* TODO:\n                Make the scenegraph process simplified. Walk the scenegraph once and grab the order in a flat array\n                then process updates and ticks. This will also allow a layered rendering system that can render the\n                first x number of entities then stop, allowing a step through of the renderer in realtime.\n                We can probably implement this in the new renderer subsystem.\n             */\n            // Scale the timestamp according to the current\n            // engine's time scaling factor\n            this.incrementTime(timeStamp, this._timeScaleLastTimestamp);\n            this._timeScaleLastTimestamp = timeStamp;\n            timeStamp = Math.floor(this._currentTime);\n            let startTime = 0;\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n                startTime = new Date().getTime();\n            }\n            if (this._state === _enums__WEBPACK_IMPORTED_MODULE_6__.IgeEngineState.started) {\n                // Alternate the boolean frame alternator flag\n                this._frameAlternator = !this._frameAlternator;\n                // If the engine is not in manual tick mode...\n                if (!this._useManualTicks) {\n                    // Schedule a new frame\n                    this.requestAnimFrame(this.engineStep);\n                }\n                else {\n                    this._manualFrameAlternator = !this._frameAlternator;\n                }\n                // Record the tick start time and adjust the tickStart value\n                // by the difference between the server and the client clocks\n                // (this is only applied when running as the client - the\n                // server always has a clientNetDiff of zero)\n                this._tickStart = timeStamp - this._clientNetDiff;\n                if (!this.lastTick) {\n                    // This is the first time we've run so set the tick delta\n                    // to zero\n                    this._tickDelta = 0;\n                }\n                else {\n                    // Calculate the tick delta - how much time has elapsed\n                    // between the last time we ran engineStep() and now\n                    this._tickDelta = this._tickStart - this.lastTick;\n                }\n                // Check for unborn entities that should be born now\n                this._birthUnbornEntities();\n                // Check if updates are enabled\n                if (this._enableUpdates) {\n                    // Process any behaviours assigned to the engine\n                    this._processBehaviours(_enums__WEBPACK_IMPORTED_MODULE_6__.IgeBehaviourType.preUpdate, this._tickDelta);\n                    // Update the scenegraph\n                    if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n                        const updateStart = new Date().getTime();\n                        this.updateSceneGraph();\n                        this._updateTime = new Date().getTime() - updateStart;\n                    }\n                    else {\n                        this.updateSceneGraph();\n                    }\n                    this._processBehaviours(_enums__WEBPACK_IMPORTED_MODULE_6__.IgeBehaviourType.postUpdate, this._tickDelta);\n                }\n                // Check if renders are enabled\n                if (this._enableRenders) {\n                    this._processBehaviours(_enums__WEBPACK_IMPORTED_MODULE_6__.IgeBehaviourType.preTick, this._tickDelta);\n                    // Check if we should only render after manualRender() has been called\n                    // or if we just render each frame automatically\n                    if (this._useManualRender) {\n                        // We are only rendering when manualRender() is called, check if\n                        // a manual render has been queued by calling manualRender()\n                        if (this._manualRenderQueued) {\n                            // A manual render was queued, so we can render a frame now\n                            if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n                                const renderStart = new Date().getTime();\n                                this.renderSceneGraph();\n                                this._renderTime = new Date().getTime() - renderStart;\n                            }\n                            else {\n                                this.renderSceneGraph();\n                            }\n                            this._manualRenderQueued = false;\n                        }\n                    }\n                    else {\n                        // We are not in manual render mode so render the scenegraph\n                        if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n                            const renderStart = new Date().getTime();\n                            this.renderSceneGraph();\n                            this._renderTime = new Date().getTime() - renderStart;\n                        }\n                        else {\n                            this.renderSceneGraph();\n                        }\n                    }\n                    // Call post-tick methods\n                    this._processBehaviours(_enums__WEBPACK_IMPORTED_MODULE_6__.IgeBehaviourType.postTick);\n                }\n                // Record the lastTick value, so we can\n                // calculate delta on the next tick\n                this.lastTick = this._tickStart;\n                this._frames++;\n                // Record the number of drawings we've done this frame in our\n                // dpf (draws per frame) counter\n                this._dpf = this._drawCount;\n                // Clear the draw count, so it's zero for the next frame\n                this._drawCount = 0;\n            }\n            this._resized = false;\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n                const endTime = new Date().getTime();\n                this._tickTime = endTime - startTime;\n            }\n            const tickOut = this._setTickout.shift();\n            tickOut === null || tickOut === void 0 ? void 0 : tickOut();\n        };\n        /**\n         * Walks the scenegraph and returns an array of all entities that the mouse\n         * is currently over, ordered by their draw order from drawn last (above other\n         * entities) to first (underneath other entities).\n         */\n        this.pointerOverList = (obj, entArr = []) => {\n            let arr, arrCount, mp, mouseTriggerPoly, first = false;\n            if (!obj) {\n                obj = this;\n                entArr = [];\n                first = true;\n            }\n            if (obj === this) {\n                // Loop viewports\n                arr = obj._children;\n                if (arr) {\n                    arrCount = arr.length;\n                    // Loop our children\n                    while (arrCount--) {\n                        const vp = arr[arrCount];\n                        if (vp._scene) {\n                            if (vp._scene._shouldRender) {\n                                this.pointerOverList(vp._scene, entArr);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                // Check if the mouse is over this entity\n                mp = this.mousePosWorld();\n                if (mp && obj.aabb) {\n                    // Trigger mode is against the AABB\n                    mouseTriggerPoly = obj.aabb(); //this.localAabb();\n                    // Check if the current mouse position is inside this aabb\n                    if (mouseTriggerPoly.xyInside(mp.x, mp.y)) {\n                        entArr.push(obj);\n                    }\n                }\n                // Check if the entity has children\n                arr = obj._children;\n                if (arr) {\n                    arrCount = arr.length;\n                    // Loop our children\n                    while (arrCount--) {\n                        this.pointerOverList(arr[arrCount], entArr);\n                    }\n                }\n            }\n            if (first) {\n                entArr.reverse();\n            }\n            return entArr;\n        };\n        this._processSync = () => __awaiter(this, void 0, void 0, function* () {\n            let syncEntry;\n            if (this._syncIndex < this._syncArr.length) {\n                syncEntry = this._syncArr[this._syncIndex];\n                // Call the method\n                yield syncEntry.method.apply(this, syncEntry.attrArr);\n                this._syncIndex++;\n                setTimeout(() => {\n                    this._processSync();\n                }, 1);\n                return;\n            }\n            // Reached end of sync cycle\n            this._syncArr = [];\n            this._syncIndex = 0;\n            this.emit(\"syncComplete\");\n        });\n        this._idCounter = 0;\n        this._pixelRatioScaling = true; // Default to scaling the canvas to get non-blurry output\n        this._requireScriptTotal = 0;\n        this._requireScriptLoading = 0;\n        this._loadingPreText = undefined; // The text to put in front of the loading percent on the loading progress screen\n        this._enableUpdates = true;\n        this._enableRenders = true;\n        this._showSgTree = false;\n        this._debugEvents = {}; // Holds debug event booleans for named events\n        this._renderContext = \"2d\"; // The rendering context, default is 2d\n        this._tickTime = NaN; // The time the tick took to process\n        this._updateTime = NaN; // The time the tick update section took to process\n        this._renderTime = NaN; // The time the tick render section took to process\n        this._tickDelta = 0; // The time between the last tick and the current one\n        this._fpsRate = 60; // Sets the frames per second to execute engine tick's at\n        this._drawCount = 0; // Holds the number of draws since the last frame (calls to drawImage)\n        this._dps = 0; // Number of draws that occurred last tick\n        this._dpf = 0;\n        this._frames = 0; // Number of frames looped through since last second tick\n        this._fps = 0; // Number of frames per second\n        this._clientNetDiff = 0; // The difference between the server and client comms (only non-zero on clients)\n        this._frameAlternator = false; // Is set to the boolean not of itself each frame\n        this._viewportDepth = false;\n        this._pointerPos = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_2__.IgePoint3d(0, 0, 0);\n        this._currentViewport = null; // Set in IgeViewport.js tick(), holds the current rendering viewport\n        this._currentCamera = null; // Set in IgeViewport.js tick(), holds the current rendering viewport's camera\n        this._currentTime = 0; // The current engine time\n        this._globalSmoothing = true; // Determines the default smoothing setting for new textures\n        this._timeSpentInUpdate = {}; // An object holding time-spent-in-update (total time spent in this object's update method)\n        this._timeSpentLastUpdate = {}; // An object holding time-spent-last-update (time spent in this object's update method last tick)\n        this._timeSpentInTick = {}; // An object holding time-spent-in-tick (total time spent in this object's tick method)\n        this._timeSpentLastTick = {}; // An object holding time-spent-last-tick (time spent in this object's tick method last tick)\n        this._timeScale = 1; // The default time scaling factor to speed up or slow down engine time\n        this._globalScale = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_2__.IgePoint3d(1, 1, 1);\n        this._graphInstances = {}; // Holds an array of instances of graph classes\n        this._spawnQueue = []; // Holds an array of entities that are yet to be born\n        this._dependencyQueue = []; // Holds an array of functions that must all return true for the engine to start\n        this._webFonts = []; // Holds an array of web fonts to load\n        this._cssFonts = []; // Holds an array of css fonts we want to wait for (loaded via HTML or CSS rather than our own loadWebFont())\n        this._headless = true;\n        // Set the initial id as the current time in milliseconds. This ensures that under successive\n        // restarts of the engine, new ids will still always be created compared to earlier runs -\n        // which is important when storing persistent data with ids etc\n        this._idCounter = new Date().getTime();\n        // Start a timer to record every second of execution\n        this._secondTimer = setInterval(this._secondTick, 1000);\n        if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isClient) {\n            this._resizeEvent();\n        }\n    }\n    isReady() {\n        return Promise.resolve();\n    }\n    renderer(val) {\n        if (val === undefined) {\n            return this._renderer;\n        }\n        this._renderer = val;\n        // Make sure the renderer has been setup\n        void val.setup();\n        return this;\n    }\n    addComponent(id, Component, options) {\n        return super.addComponent(id, Component, options);\n    }\n    id(id) {\n        if (!id) {\n            return \"ige\";\n        }\n        return this;\n    }\n    loadWebFont(family, url) {\n        this.log(`Font (${family}) loading from url(${url})`);\n        const webFont = new FontFace(family, `url(${url})`);\n        void webFont.load();\n        webFont.loaded\n            .then(() => {\n            // Font is loaded\n            document.fonts.add(webFont);\n            this.log(`Font load (${family}) success`);\n        })\n            .catch((err) => {\n            // Font loading error\n            this.log(`Font load (${family}) error`, err);\n        });\n        this._webFonts.push(webFont);\n    }\n    waitForCssFont(fontName) {\n        this._cssFonts.push(fontName);\n    }\n    fontList() {\n        const { fonts } = document;\n        const it = fonts.entries();\n        const arr = [];\n        let done = false;\n        while (!done) {\n            const font = it.next();\n            if (!font.done) {\n                arr.push(font.value[0].family);\n            }\n            else {\n                done = font.done;\n            }\n        }\n        // converted to set then arr to filter repetitive values\n        return [...new Set(arr)];\n    }\n    headless(val) {\n        if (val === undefined) {\n            return this._headless;\n        }\n        this._headless = val;\n        return this;\n    }\n    /**\n     * Adds an entity to the spawn queue.\n     * @param {IgeEntity} entity The entity to add.\n     * @returns {Ige|[]} Either this, or the spawn queue.\n     */\n    spawnQueue(entity) {\n        if (entity !== undefined) {\n            this._spawnQueue.push(entity);\n            return this;\n        }\n        return this._spawnQueue;\n    }\n    currentViewport(viewport) {\n        if (viewport instanceof _engine_core_IgeViewport__WEBPACK_IMPORTED_MODULE_3__.IgeViewport) {\n            _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._currentViewport = viewport;\n            _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._currentCamera = viewport.camera;\n        }\n        return _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._currentViewport;\n    }\n    createCanvas(options = { smoothing: false, pixelRatioScaling: true }) {\n        // Creates a new canvas instance with the device pixel ratio\n        // and other features setup based on the passed `options` or\n        // current ige settings if no options are provided. This is a\n        // safe way to generate a new canvas for things like caching\n        // stores or whatever\n        const canvas = new OffscreenCanvas(2, 2);\n        // Get the context\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) {\n            throw new Error(\"Could not get canvas rendering context!\");\n        }\n        // Set smoothing mode\n        ctx.imageSmoothingEnabled = options.smoothing !== undefined ? options.smoothing : this._globalSmoothing;\n        const pixelRatioScaling = options.pixelRatioScaling !== undefined ? options.pixelRatioScaling : this._pixelRatioScaling;\n        if (pixelRatioScaling) {\n            // Scale the canvas context to account for the device pixel ratio\n            ctx.scale(this._devicePixelRatio, this._devicePixelRatio);\n        }\n        return {\n            canvas,\n            ctx\n        };\n    }\n    _setInternalCanvasSize(canvas, ctx, newWidth, newHeight) {\n        canvas.width = newWidth * this._devicePixelRatio;\n        canvas.height = newHeight * this._devicePixelRatio;\n        // Scale the canvas context to account for the change\n        ctx.scale(this._devicePixelRatio, this._devicePixelRatio);\n    }\n    /**\n     * Returns an array of all classes the passed object derives from\n     * in order from current to base.\n     * @param obj\n     * @param arr\n     * @return {*}\n     */\n    getClassDerivedList(obj, arr) {\n        if (!arr) {\n            arr = [];\n        }\n        else {\n            if (obj && obj.constructor && obj.constructor.name) {\n                arr.push(obj.constructor.name);\n            }\n        }\n        if (obj && obj.__proto__ && obj.__proto__.constructor && obj.__proto__.constructor.name) {\n            this.getClassDerivedList(obj.__proto__, arr);\n        }\n        return arr;\n    }\n    /**\n     * Gets / sets the current time scalar value. The engine's internal\n     * time is multiplied by this value, and it's default is 1. You can set it to\n     * 0.5 to slow down time by half or 1.5 to speed up time by half. Negative\n     * values will reverse time but not all engine systems handle this well\n     * at the moment.\n     * @param {number=} val The timescale value.\n     * @returns {*}\n     */\n    timeScale(val) {\n        if (val !== undefined) {\n            this._timeScale = val;\n            return this;\n        }\n        return this._timeScale;\n    }\n    /**\n     * Increments the engine's internal time by the passed number of milliseconds.\n     * @param {number} val The number of milliseconds to increment time by.\n     * @param {number=} lastVal The last internal time value, used to calculate\n     * delta internally in the method.\n     * @returns {number}\n     */\n    incrementTime(val, lastVal) {\n        if (!this._pause) {\n            if (!lastVal) {\n                lastVal = val;\n            }\n            this._currentTime += (val - lastVal) * this._timeScale;\n        }\n        return this._currentTime;\n    }\n    /**\n     * Get the current time from the engine.\n     * @return {number} The current time.\n     */\n    currentTime() {\n        return this._currentTime;\n    }\n    /**\n     * Gets / sets the pause flag. If set to true then the engine's\n     * internal time will no longer increment and will instead stay static.\n     * @param val\n     * @returns {*}\n     */\n    pause(val) {\n        if (val !== undefined) {\n            this._pause = val;\n            return this;\n        }\n        return this._pause;\n    }\n    useManualTicks(val) {\n        if (val !== undefined) {\n            this._useManualTicks = val;\n            this._manualFrameAlternator = !this._frameAlternator; // Set this otherwise the first manual frame won't fire\n            return this;\n        }\n        return this._useManualTicks;\n    }\n    /**\n     * Schedules a manual tick.\n     */\n    manualTick() {\n        return new Promise((resolve, reject) => {\n            if (this._manualFrameAlternator !== this._frameAlternator) {\n                this._manualFrameAlternator = this._frameAlternator;\n                this.requestAnimFrame((timeStamp) => {\n                    this.engineStep(timeStamp);\n                    resolve();\n                });\n            }\n            else {\n                reject(new Error(\"Manual tick still in progress\"));\n            }\n        });\n    }\n    /**\n     * Gets / sets the option to determine if the engine should\n     * render on every tick or wait for a manualRender() call.\n     * @param {Boolean=} val True to enable manual rendering, false\n     * to disable.\n     * @return {*}\n     */\n    useManualRender(val) {\n        if (val !== undefined) {\n            this._useManualRender = val;\n            return this;\n        }\n        return this._useManualRender;\n    }\n    /**\n     * Manually render a frame on demand. This is used in conjunction\n     * with the ige.useManualRender(true) call which will cause the\n     * engine to only render new graphics frames from the scenegraph\n     * once this method is called. You must call this method every time\n     * you wish to update the graphical output on screen.\n     *\n     * Calling this method multiple times during a single engine tick\n     * will NOT make it draw more than one frame, therefore it is safe\n     * to call multiple times if required by different sections of game\n     * logic without incurring extra rendering cost.\n     */\n    manualRender() {\n        this._manualRenderQueued = true;\n    }\n    fps() {\n        return this._fps;\n    }\n    dpf() {\n        return this._dpf;\n    }\n    dps() {\n        return this._dps;\n    }\n    analyseTiming() {\n        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n            this.log(\"Cannot analyse timing because the ige.config.debug._timing flag is not enabled so no timing data has been recorded!\", \"warning\");\n        }\n    }\n    // TODO: Fix this so it works in typescript\n    // saveSceneGraph (item?: {obj?: IgeObject, str?: any}) {\n    // \tif (!item) {\n    // \t\titem = this.getSceneGraphData();\n    // \t}\n    //\n    // \tif (item.obj.stringify) {\n    // \t\titem.str = item.obj.stringify();\n    // \t} else {\n    // \t\tconsole.log(\"Class \" + item.constructor.name + \" has no stringify() method! For object: \" + item.id, item.obj);\n    // \t}\n    //\n    // \tconst arr = item.items;\n    //\n    // \tif (arr) {\n    // \t\tconst arrCount = arr.length;\n    //\n    // \t\tfor (let i = 0; i < arrCount; i++) {\n    // \t\t\tthis.saveSceneGraph(arr[i]);\n    // \t\t}\n    // \t}\n    //\n    // \treturn item;\n    // }\n    /**\n     * Walks the scene graph and outputs a console map of the graph.\n     */\n    sceneGraph(obj, currentDepth) {\n        let depthSpace = \"\", di, timingString, arr, arrCount;\n        if (currentDepth === undefined) {\n            currentDepth = 0;\n        }\n        if (!obj) {\n            // Set the obj to the main ige instance\n            obj = this;\n        }\n        for (di = 0; di < currentDepth; di++) {\n            depthSpace += \"----\";\n        }\n        if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n            timingString = \"\";\n            timingString += \"T: \" + this._timeSpentInTick[obj.id()];\n            if (this._timeSpentLastTick[obj.id()]) {\n                if (typeof this._timeSpentLastTick[obj.id()].ms === \"number\") {\n                    timingString += \" | LastTick: \" + this._timeSpentLastTick[obj.id()].ms;\n                }\n                if (typeof this._timeSpentLastTick[obj.id()].depthSortChildren === \"number\") {\n                    timingString += \" | ChildDepthSort: \" + this._timeSpentLastTick[obj.id()].depthSortChildren;\n                }\n            }\n            console.log(depthSpace +\n                obj.id() +\n                \" (\" +\n                obj.constructor.name +\n                \") : \" +\n                obj._inView +\n                \" Timing(\" +\n                timingString +\n                \")\");\n        }\n        else {\n            console.log(depthSpace + obj.id() + \" (\" + obj.constructor.name + \") : \" + obj._inView);\n        }\n        currentDepth++;\n        if (obj === this) {\n            // Loop the viewports\n            arr = obj._children;\n            if (arr) {\n                arrCount = arr.length;\n                // Loop our children\n                while (arrCount--) {\n                    const vp = arr[arrCount];\n                    if (vp._scene) {\n                        if (vp._scene._shouldRender) {\n                            if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n                                timingString = \"\";\n                                timingString += \"T: \" + this._timeSpentInTick[vp.id()];\n                                if (this._timeSpentLastTick[vp.id()]) {\n                                    if (typeof this._timeSpentLastTick[vp.id()].ms === \"number\") {\n                                        timingString += \" | LastTick: \" + this._timeSpentLastTick[vp.id()].ms;\n                                    }\n                                    if (typeof this._timeSpentLastTick[vp.id()].depthSortChildren === \"number\") {\n                                        timingString +=\n                                            \" | ChildDepthSort: \" + this._timeSpentLastTick[vp.id()].depthSortChildren;\n                                    }\n                                }\n                                console.log(depthSpace +\n                                    \"----\" +\n                                    vp.id() +\n                                    \" (\" +\n                                    vp.constructor.name +\n                                    \") : \" +\n                                    vp._inView +\n                                    \" Timing(\" +\n                                    timingString +\n                                    \")\");\n                            }\n                            else {\n                                console.log(depthSpace + \"----\" + vp.id() + \" (\" + vp.constructor.name + \") : \" + vp._inView);\n                            }\n                            this.sceneGraph(vp._scene, currentDepth + 1);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            arr = obj._children;\n            if (arr) {\n                arrCount = arr.length;\n                // Loop our children\n                while (arrCount--) {\n                    this.sceneGraph(arr[arrCount], currentDepth);\n                }\n            }\n        }\n    }\n    /**\n     * Walks the scenegraph and returns a data object of the graph.\n     */\n    getSceneGraphData(rootObject, noRef) {\n        const items = [];\n        let finalRootObject;\n        if (rootObject) {\n            finalRootObject = rootObject;\n        }\n        else {\n            // Set the obj to the main ige instance\n            finalRootObject = this;\n        }\n        const item = {\n            text: \"[\" + finalRootObject.constructor.name + \"] \" + finalRootObject.id(),\n            id: finalRootObject.id(),\n            classId: finalRootObject.constructor.name\n        };\n        if (!noRef) {\n            item.parent = finalRootObject._parent;\n            item.obj = finalRootObject;\n        }\n        else {\n            if (finalRootObject._parent) {\n                item.parentId = finalRootObject._parent.id();\n            }\n            else {\n                item.parentId = \"sceneGraph\";\n            }\n        }\n        if (finalRootObject === this) {\n            // Loop the viewports\n            const arr = finalRootObject._children;\n            if (arr) {\n                let arrCount = arr.length;\n                // Loop our children\n                while (arrCount--) {\n                    const vp = arr[arrCount];\n                    const tempItem = {\n                        text: \"[\" + vp.constructor.name + \"] \" + vp.id(),\n                        id: vp.id(),\n                        classId: vp.constructor.name\n                    };\n                    if (!noRef) {\n                        tempItem.parent = vp._parent;\n                        tempItem.obj = vp;\n                    }\n                    else {\n                        if (vp._parent) {\n                            tempItem.parentId = vp._parent.id();\n                        }\n                    }\n                    if (vp.camera) {\n                        // Add the viewport camera as an object on the scenegraph\n                        const tempCam = {\n                            text: \"[IgeCamera] \" + vp.id(),\n                            id: vp.camera.id(),\n                            classId: vp.camera.constructor.name\n                        };\n                        if (!noRef) {\n                            tempCam.parent = vp;\n                            tempCam.obj = vp.camera;\n                        }\n                        else {\n                            tempCam.parentId = vp.id();\n                        }\n                        if (vp._scene) {\n                            const tempItem2 = this.getSceneGraphData(vp._scene, noRef);\n                            tempItem.items = [tempCam, tempItem2];\n                        }\n                    }\n                    else {\n                        if (vp._scene) {\n                            const tempItem2 = this.getSceneGraphData(vp._scene, noRef);\n                            tempItem.items = [tempItem2];\n                        }\n                    }\n                    items.push(tempItem);\n                }\n            }\n        }\n        else {\n            const arr = finalRootObject._children;\n            if (arr) {\n                let arrCount = arr.length;\n                // Loop our children\n                while (arrCount--) {\n                    const tempItem = this.getSceneGraphData(arr[arrCount], noRef);\n                    items.push(tempItem);\n                }\n            }\n        }\n        if (items.length > 0) {\n            item.items = items;\n        }\n        return item;\n    }\n    /**\n     * Adds a scenegraph class into memory.\n     * @param {string|Object} className The name of the scenegraph class, or the class itself.\n     * @param {Object=} options Optional object to pass to the scenegraph class graph() method.\n     * @returns {*}\n     */\n    addGraph(className, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (className !== undefined) {\n                const classObj = this.getClass(className);\n                if (!classObj) {\n                    throw new Error(`Cannot load graph for class name \"${className}\" because the class could not be found. Did you call registerClass(ClassName)?`);\n                }\n                const classInstance = this.newClassInstance(className);\n                this.log(\"Loading SceneGraph data class: \" + classInstance.constructor.name);\n                // Make sure the graph class implements the required methods \"addGraph\" and \"removeGraph\"\n                if (typeof classInstance.addGraph !== \"function\" || typeof classInstance.removeGraph !== \"function\") {\n                    throw new Error(`Could not load graph for class name \"${className}\" because the class does not implement both the require methods \"addGraph()\" and \"removeGraph()\".`);\n                }\n                // Call the class's addGraph() method passing the options in\n                yield classInstance.addGraph(options);\n                // Add the graph instance to the holding array\n                this._graphInstances[classInstance.constructor.name] = classInstance;\n            }\n            return this;\n        });\n    }\n    /**\n     * Removes a scenegraph class into memory.\n     * @param {string} className The name of the scenegraph class.\n     * @param {Object=} options Optional object to pass to the scenegraph class graph() method.\n     * @returns {*}\n     */\n    removeGraph(className, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (className !== undefined) {\n                const classObj = this.getClass(className);\n                const classInstance = this._graphInstances[classObj.name];\n                if (classInstance) {\n                    this.log(`Removing SceneGraph data class: ${classObj.name}`);\n                    // Call the class's removeGraph() method passing the options in\n                    yield classInstance.removeGraph(options);\n                    // Now remove the graph instance from the graph instance array\n                    delete this._graphInstances[classObj.name];\n                }\n                else {\n                    this.log(\"Cannot remove graph for class name \\\"\" +\n                        className +\n                        \"\\\" because the class instance could not be found. Did you add it via ige.addGraph() ?\", \"error\");\n                }\n            }\n            return this;\n        });\n    }\n    /**\n     * Allows the update() methods of the entire scenegraph to\n     * be temporarily enabled or disabled. Useful for debugging.\n     * @param {Boolean=} val If false, will disable all update() calls.\n     * @returns {*}\n     */\n    enableUpdates(val) {\n        if (val !== undefined) {\n            this._enableUpdates = val;\n            return this;\n        }\n        return this._enableUpdates;\n    }\n    enableRenders(val) {\n        if (val !== undefined) {\n            this._enableRenders = val;\n            return this;\n        }\n        return this._enableRenders;\n    }\n    /**\n     * Enables or disables the engine's debug mode. Enabled by default.\n     * @param {Boolean=} val If true, will enable debug mode.\n     * @returns {*}\n     */\n    debugEnabled(val) {\n        if (val !== undefined) {\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug) {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._enabled = val;\n            }\n            return this;\n        }\n        return _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._enabled;\n    }\n    /**\n     * Enables or disables the engine's debug timing system. The\n     * timing system will time all update and rendering code down\n     * the scenegraph and is useful for tracking long-running code\n     * but comes with a small performance penalty when enabled.\n     * Enabled by default.\n     * @param {Boolean=} val If true, will enable debug timing mode.\n     * @returns {*}\n     */\n    debugTiming(val) {\n        if (val !== undefined) {\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug) {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing = val;\n            }\n            return this;\n        }\n        return _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing;\n    }\n    debug(eventName) {\n        if (this._debugEvents[eventName] === true || this._debugEvents[eventName] === this._frames) {\n            debugger;\n        }\n    }\n    debugEventOn(eventName) {\n        this._debugEvents[eventName] = true;\n    }\n    debugEventOff(eventName) {\n        this._debugEvents[eventName] = false;\n    }\n    triggerDebugEventFrame(eventName) {\n        this._debugEvents[eventName] = this._frames;\n    }\n    /**\n     * Sets the opacity of every object on the scenegraph to\n     * zero *except* the one specified by the given id argument.\n     * @param {string} id The id of the object not to hide.\n     */\n    hideAllExcept(id) {\n        const arr = _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.register.all();\n        for (const key in arr) {\n            if (key !== id && \"opacity\" in arr[key]) {\n                arr[key].opacity(0);\n            }\n        }\n    }\n    /**\n     * Calls the show() method for every object on the scenegraph.\n     */\n    showAll() {\n        const arr = _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.register.all();\n        for (const key in arr) {\n            if (\"show\" in arr[key]) {\n                arr[key].show();\n            }\n        }\n    }\n    /**\n     * Sets the frame rate at which new engine steps are fired.\n     * Setting this rate will override the default requestAnimFrame()\n     * method as defined in IgeBaseClass.js and on the client-side, will\n     * stop usage of any available requestAnimationFrame() method\n     * and will use a setTimeout()-based version instead.\n     * @param {number} fpsRate\n     */\n    setFps(fpsRate) {\n        // Override the default requestAnimFrame handler and set\n        // our own method up so that we can control the frame rate\n        this.requestAnimFrame = (callback) => {\n            setTimeout(() => {\n                callback(new Date().getTime());\n            }, 1000 / fpsRate);\n        };\n    }\n    requestAnimFrame(frameHandlerFunction, element) {\n        if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isClient) {\n            globalThis.requestAnimationFrame(frameHandlerFunction);\n            return;\n        }\n        setTimeout(function () {\n            frameHandlerFunction(new Date().getTime());\n        }, 1000 / 60);\n    }\n    showStats() {\n        this.log(\"showStats has been removed from the ige in favour of the new editor component, please remove this call from your code.\");\n    }\n    /**\n     * Retrieves a class by its ID that was defined with\n     * a call to defineClass().\n     * @param {string} id The ID of the class to retrieve.\n     * @return {Object} The class definition.\n     */\n    getClass(id) {\n        if (typeof id === \"object\" || typeof id === \"function\") {\n            return id;\n        }\n        return _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.classStore[id];\n    }\n    /**\n     * Returns true if the class specified has been defined.\n     * @param {string} id The ID of the class to check for.\n     * @returns {*}\n     */\n    classDefined(id) {\n        return Boolean(_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.classStore[id]);\n    }\n    /**\n     * Generates a new instance of a class defined with a call\n     * to the defineClass() method. Passes the options\n     * parameter to the new class during it's constructor call.\n     * @param id\n     * @param args\n     * @return {*}\n     */\n    newClassInstance(id, ...args) {\n        const ClassDefinition = this.getClass(id);\n        return new ClassDefinition(...args);\n    }\n    /**\n     * Checks if all engine start dependencies have been satisfied.\n     * @return {boolean}\n     */\n    dependencyCheck() {\n        const arr = this._dependencyQueue;\n        let arrCount = arr.length;\n        while (arrCount--) {\n            if (!this._dependencyQueue[arrCount]()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Gets / sets the flag that determines if viewports should be sorted by depth\n     * like regular entities, before they are processed for rendering each frame.\n     * Depth-sorting viewports increases processing requirements so if you do not\n     * need to stack viewports in a particular order, keep this flag false.\n     * @param {Boolean} val\n     * @return {Boolean}\n     */\n    viewportDepth(val) {\n        if (val !== undefined) {\n            this._viewportDepth = val;\n            return this;\n        }\n        return this._viewportDepth;\n    }\n    /**\n     * Sets the number of milliseconds before the engine gives up waiting for dependencies\n     * to be satisfied and cancels the startup procedure.\n     * @param val\n     */\n    dependencyTimeout(val) {\n        this._dependencyCheckTimeout = val;\n    }\n    /**\n     * Updates the loading screen DOM elements to show the update progress.\n     */\n    updateProgress() {\n        var _a;\n        // Check for a loading progress bar DOM element\n        if (!(typeof document !== \"undefined\" && document.getElementById)) {\n            return;\n        }\n        const elem = document.getElementById(\"loadingProgressBar\"), textElem = document.getElementById(\"loadingText\");\n        if (!elem) {\n            return;\n        }\n        const totalWidth = (_a = elem.parentNode) === null || _a === void 0 ? void 0 : _a.offsetWidth;\n        const currentWidth = Math.floor((totalWidth / _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.textures._assetsTotal) * (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.textures._assetsTotal - _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.textures._assetsLoading));\n        elem.style.width = currentWidth + \"px\";\n        if (!textElem) {\n            return;\n        }\n        if (this._loadingPreText === undefined) {\n            // Fill the text to use\n            this._loadingPreText = textElem.innerHTML;\n        }\n        textElem.innerHTML =\n            this._loadingPreText +\n                \" \" +\n                Math.floor((100 / _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.textures._assetsTotal) * (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.textures._assetsTotal - _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.textures._assetsLoading)) +\n                \"%\";\n    }\n    /**\n     * Gets / sets the default smoothing value for all new\n     * IgeTexture class instances. If set to true, all newly\n     * created textures will have smoothing enabled by default.\n     * @param val\n     * @return {*}\n     */\n    globalSmoothing(val) {\n        if (val !== undefined) {\n            this._globalSmoothing = val;\n            return this;\n        }\n        return this._globalSmoothing;\n    }\n    /**\n     * Generates a new 16-character hexadecimal ID based on\n     * the passed string. Will always generate the same ID\n     * for the same string.\n     * @param {string} str A string to generate the ID from.\n     * @return {string}\n     */\n    newIdFromString(str) {\n        if (str === undefined) {\n            return;\n        }\n        const count = str.length;\n        let id, val = 0, i;\n        for (i = 0; i < count; i++) {\n            val += str.charCodeAt(i) * Math.pow(10, 17);\n        }\n        id = val.toString(16);\n        // Check if the ID is already in use\n        while (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.$(id)) {\n            val += Math.pow(10, 17);\n            id = val.toString(16);\n        }\n        return id;\n    }\n    /**\n     * Starts the engine or rejects the promise with an error.\n     */\n    start() {\n        return new Promise((resolve, reject) => {\n            // Check if the state is anything other than zero (stopped)\n            if (this._state === _enums__WEBPACK_IMPORTED_MODULE_6__.IgeEngineState.started) {\n                return resolve(true);\n            }\n            if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isClient && this._dependencyQueue.length === 0) {\n                // Add the textures loaded dependency\n                this._dependencyQueue.push(_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.textures.haveAllTexturesLoaded);\n                this._dependencyQueue.push(this.canvasReady);\n                this._dependencyQueue.push(this.fontsLoaded);\n            }\n            const doDependencyCheck = () => {\n                var _a;\n                if (this.dependencyCheck()) {\n                    // Start the engine\n                    this.log(\"Starting engine...\");\n                    this._state = _enums__WEBPACK_IMPORTED_MODULE_6__.IgeEngineState.started;\n                    // Check if we have a DOM, that there is an igeLoading element\n                    // and if so, remove it from the DOM now\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isClient && !_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isWorker) {\n                        if (document.getElementsByClassName && document.getElementsByClassName(\"igeLoading\")) {\n                            const arr = document.getElementsByClassName(\"igeLoading\");\n                            let arrCount = arr.length;\n                            while (arrCount--) {\n                                (_a = arr[arrCount].parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(arr[arrCount]);\n                            }\n                        }\n                    }\n                    if (!this._useManualTicks) {\n                        this.requestAnimFrame(this.engineStep);\n                    }\n                    this.log(\"Engine started\");\n                    return resolve(true);\n                }\n                // Get the current timestamp\n                const curTime = new Date().getTime();\n                // Record when we first started checking for dependencies\n                if (!this._dependencyCheckStart) {\n                    this._dependencyCheckStart = curTime;\n                }\n                // Check if we have timed out\n                if (curTime - this._dependencyCheckStart > this._dependencyCheckTimeout) {\n                    return reject(new Error(\"Engine start failed because the dependency check timed out after \" +\n                        this._dependencyCheckTimeout / 1000 +\n                        \" seconds\"));\n                }\n                setTimeout(doDependencyCheck, 200);\n            };\n            doDependencyCheck();\n        });\n    }\n    /**\n     * Stops the engine.\n     * @return {boolean}\n     */\n    stop() {\n        // If we are running, stop the engine\n        if (this._state) {\n            this.log(\"Stopping engine...\");\n            this._state = _enums__WEBPACK_IMPORTED_MODULE_6__.IgeEngineState.stopped;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    _birthUnbornEntities() {\n        const unbornQueue = this._spawnQueue;\n        const unbornCount = unbornQueue.length;\n        for (let unbornIndex = unbornCount - 1; unbornIndex >= 0; unbornIndex--) {\n            const unbornEntity = unbornQueue[unbornIndex];\n            if (this._currentTime >= unbornEntity._bornTime && unbornEntity._birthMount) {\n                // Now birth this entity\n                unbornEntity.mount(_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.$(unbornEntity._birthMount));\n                // Remove the newly born entity from the spawn queue\n                unbornQueue.splice(unbornIndex, 1);\n            }\n        }\n    }\n    setTickout(callback, count = 0) {\n        this._setTickout.length = count + 1;\n        this._setTickout[count] = callback;\n        return this;\n    }\n    /**\n     * Gets / sets the _autoSize property. If set to true, the engine will listen\n     * for any change in screen size and resize the front-buffer (canvas) element\n     * to match the new screen size.\n     * @param val\n     * @return {Boolean}\n     */\n    autoSize(val) {\n        if (val !== undefined) {\n            this._autoSize = val;\n            return this;\n        }\n        return this._autoSize;\n    }\n    pixelRatioScaling(val) {\n        if (val !== undefined) {\n            this._pixelRatioScaling = val;\n            return this;\n        }\n        return this._pixelRatioScaling;\n    }\n    /**\n     * Gets / sets the rendering context that will be used when getting the\n     * context from canvas elements.\n     * @param {String=} contextId The context such as '2d'. Defaults to '2d'.\n     * @return {*}\n     */\n    renderContext(contextId) {\n        if (contextId !== undefined) {\n            this._renderContext = contextId;\n            this.log(\"Rendering mode set to: \" + contextId);\n            return this;\n        }\n        return this._renderContext;\n    }\n    /**\n     * @deprecated Please create a renderer instance and assign it via engine.renderer() instead.\n     * Creates a front-buffer or \"drawing surface\" for the renderer.\n     *\n     * @param {Boolean} autoSize Determines if the canvas will auto-resize\n     * when the browser window changes dimensions. If true the canvas will\n     * automatically fill the window when it is resized.\n     *\n     * @param {Boolean=} dontScale If set to true, IGE will ignore device\n     * pixel ratios when setting the width and height of the canvas and will\n     * therefore not take into account \"retina\", high-definition displays or\n     * those whose pixel ratio is different from 1 to 1.\n     */\n    createFrontBuffer(autoSize = true, dontScale = false) {\n        throw new Error(\"IgeEngine.createFrontBuffer() is now deprecated, please assign a renderer instead e.g. `ige.engine.renderer(new IgeCanvas2dRenderer());`\");\n    }\n    /**\n     * Returns the mouse position relative to the main front buffer. Mouse\n     * position is set by the this.input component (IgeInputComponent)\n     * @return {IgePoint3d}\n     */\n    mousePos() {\n        return _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige._pointerPos.clone();\n    }\n    _childMounted(child) {\n        if (child instanceof _engine_core_IgeViewport__WEBPACK_IMPORTED_MODULE_3__.IgeViewport) {\n            // The first mounted viewport gets set as the current\n            // one before any rendering is done\n            if (!_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._currentViewport) {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine.currentViewport(child);\n            }\n        }\n        super._childMounted(child);\n    }\n    updateSceneGraph() {\n        const arr = this._children;\n        const tickDelta = _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._tickDelta;\n        if (arr) {\n            let arrCount = arr.length;\n            // Loop our viewports and call their update methods\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n                while (arrCount--) {\n                    const us = new Date().getTime();\n                    arr[arrCount].update(tickDelta);\n                    const ud = new Date().getTime() - us;\n                    if (arr[arrCount]) {\n                        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentInUpdate[arr[arrCount].id()]) {\n                            _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentInUpdate[arr[arrCount].id()] = 0;\n                        }\n                        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentLastUpdate[arr[arrCount].id()]) {\n                            _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentLastUpdate[arr[arrCount].id()] = {};\n                        }\n                        _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentInUpdate[arr[arrCount].id()] += ud;\n                        _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentLastUpdate[arr[arrCount].id()].ms = ud;\n                    }\n                }\n            }\n            else {\n                while (arrCount--) {\n                    arr[arrCount].update(tickDelta);\n                }\n            }\n        }\n    }\n    renderSceneGraph() {\n        var _a;\n        let ts, td;\n        // Depth-sort the viewports\n        if (this._viewportDepth) {\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.config.debug._timing) {\n                ts = new Date().getTime();\n                this.depthSortChildren();\n                td = new Date().getTime() - ts;\n                if (!_engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentLastTick[this.id()]) {\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentLastTick[this.id()] = {};\n                }\n                _engine_instance__WEBPACK_IMPORTED_MODULE_4__.ige.engine._timeSpentLastTick[this.id()].depthSortChildren = td;\n            }\n            else {\n                this.depthSortChildren();\n            }\n        }\n        // Hand rendering tasks to the renderer\n        (_a = this._renderer) === null || _a === void 0 ? void 0 : _a.renderSceneGraph(this, this._children);\n        // ctx.save();\n        // ctx.translate(this._bounds2d.x2, this._bounds2d.y2);\n        // //ctx.scale(this._globalScale.x, this._globalScale.y);\n        //\n        // // Process the current engine tick for all child objects\n        // const arr = this._children;\n        //\n        // if (arr) {\n        // \tlet arrCount = arr.length;\n        //\n        // \t// Loop our viewports and call their tick methods\n        // \tif (ige.config.debug._timing) {\n        // \t\twhile (arrCount--) {\n        // \t\t\tctx.save();\n        // \t\t\tts = new Date().getTime();\n        // \t\t\tarr[arrCount].tick(ctx);\n        // \t\t\ttd = new Date().getTime() - ts;\n        // \t\t\tif (arr[arrCount]) {\n        // \t\t\t\tif (!ige.engine._timeSpentInTick[arr[arrCount].id()]) {\n        // \t\t\t\t\tige.engine._timeSpentInTick[arr[arrCount].id()] = 0;\n        // \t\t\t\t}\n        //\n        // \t\t\t\tif (!ige.engine._timeSpentLastTick[arr[arrCount].id()]) {\n        // \t\t\t\t\tige.engine._timeSpentLastTick[arr[arrCount].id()] = {};\n        // \t\t\t\t}\n        //\n        // \t\t\t\tige.engine._timeSpentInTick[arr[arrCount].id()] += td;\n        // \t\t\t\tige.engine._timeSpentLastTick[arr[arrCount].id()].ms = td;\n        // \t\t\t}\n        // \t\t\tctx.restore();\n        // \t\t}\n        // \t} else {\n        // \t\twhile (arrCount--) {\n        // \t\t\tctx.save();\n        // \t\t\tarr[arrCount].tick(ctx);\n        // \t\t\tctx.restore();\n        // \t\t}\n        // \t}\n        // }\n        //\n        // ctx.restore();\n    }\n    destroy() {\n        var _a;\n        // Stop the engine and kill any timers\n        this.stop();\n        // Remove the front buffer (canvas) if we created it\n        if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_5__.isClient) {\n            (_a = this._renderer) === null || _a === void 0 ? void 0 : _a.destroy();\n        }\n        super.destroy();\n        this.log(\"Engine destroy complete.\");\n        return this;\n    }\n    /**\n     * Load a js script file into memory via a path or url.\n     * @param {String} url The file's path or url.\n     * @param configFunc\n     */\n    requireScript(url, configFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (url === undefined) {\n                return;\n            }\n            return new Promise((resolve) => {\n                this._requireScriptTotal++;\n                this._requireScriptLoading++;\n                const elem = document.createElement(\"script\");\n                if (configFunc) {\n                    configFunc(elem);\n                }\n                elem.addEventListener(\"load\", () => {\n                    this._requireScriptLoaded(elem);\n                    setTimeout(() => {\n                        resolve();\n                    }, 100);\n                });\n                document.body.appendChild(elem);\n                elem.src = url;\n                this.log(\"Loading script from: \" + url);\n                this.emit(\"requireScriptLoading\", url);\n            });\n        });\n    }\n    /**\n     * Called when a js script has been loaded via the requireScript\n     * method.\n     * @param {Element} elem The script element added to the DOM.\n     * @private\n     */\n    _requireScriptLoaded(elem) {\n        this._requireScriptLoading--;\n        this.emit(\"requireScriptLoaded\", elem.src);\n        if (this._requireScriptLoading === 0) {\n            // All scripts have loaded, fire the engine event\n            this.emit(\"allRequireScriptsLoaded\");\n        }\n    }\n    /**\n     * Load a css style file into memory via a path or url.\n     * @param {String} url The file's path or url.\n     */\n    requireStylesheet(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (url === undefined) {\n                throw new Error(`Cannot require a stylesheet with no url!`);\n            }\n            const css = document.createElement(\"link\");\n            css.rel = \"stylesheet\";\n            css.type = \"text/css\";\n            css.media = \"all\";\n            css.href = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(css);\n            this.log(\"Load css stylesheet from: \" + url);\n        });\n    }\n    sync(method, attrArr) {\n        if (!Array.isArray(attrArr)) {\n            attrArr = [attrArr];\n        }\n        this._syncArr = this._syncArr || [];\n        this._syncArr.push({ method: method, attrArr: attrArr });\n        if (this._syncArr.length === 1) {\n            // Start sync waterfall\n            this._syncIndex = 0;\n            this._processSync();\n        }\n    }\n    /**\n     * Returns the engine's children as an array of IgeViewport\n     * instances.\n     * @example #Get the viewports array\n     *     const vpArray = ige.engine.children();\n     * @return {Array} The array of IgeViewport instances.\n     */\n    children() {\n        // Children of the ige.engine are ONLY IgeViewports\n        return this._children;\n    }\n    drawBounds(val, recursive = true) {\n        if (val === undefined) {\n            return this._drawBounds;\n        }\n        this._drawBounds = val;\n        if (recursive) {\n            this.children().forEach((child) => {\n                var _a;\n                child.drawBounds(val, recursive);\n                (_a = child._scene) === null || _a === void 0 ? void 0 : _a.drawBounds(val, recursive);\n            });\n        }\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeEngine.ts?");

/***/ })

}]);