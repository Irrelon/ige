"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_irrelon_ige"] = self["webpackChunk_irrelon_ige"] || []).push([["src_engine_core_IgeEntity_ts"],{

/***/ "./src/engine/core/IgeBounds.ts":
/*!**************************************!*\
  !*** ./src/engine/core/IgeBounds.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeBounds: () => (/* binding */ IgeBounds)\n/* harmony export */ });\n/* harmony import */ var _engine_utils_intersections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/utils/intersections */ \"./src/engine/utils/intersections.ts\");\n\n/**\n * Creates a new bounds rectangle (x, y, width, height).\n * This differs from the IgeRect in that the x, y are the top-left\n * co-ordinates of the bounds rectangle, whereas the IgeRect assumes\n * that the x, y are the centre co-ordinates.\n */\nclass IgeBounds {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        this.classId = \"IgeBounds\";\n        this._igeShapeType = \"rect\";\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n        this.x2 = 0;\n        this.y2 = 0;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.x2 = this.x / 2;\n        this.y2 = this.y / 2;\n    }\n    translateTo(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    translateBy(x, y) {\n        this.x += x;\n        this.y += y;\n        return this;\n    }\n    /**\n     * Combines the extents of the passed IgeBounds with this rect\n     * to create a new rect whose bounds encapsulate both rects.\n     * @param {IgeBounds} rect The rect to combine with this one.\n     * @return {IgeBounds} The new rect encapsulating both rects.\n     */\n    combineRect(rect) {\n        const thisRectMaxX = this.x + this.width, thisRectMaxY = this.y + this.height, thatRectMaxX = rect.x + rect.width, thatRectMaxY = rect.y + rect.height, x = Math.min(this.x, rect.x), y = Math.min(this.y, rect.y), width = Math.max(thisRectMaxX - this.x, thatRectMaxX - this.x), height = Math.max(thisRectMaxY - this.y, thatRectMaxY - this.y);\n        return new IgeBounds(x, y, width, height);\n    }\n    /**\n     * Combines the extents of the passed IgeBounds with this rect\n     * and replaces this rect with one whose bounds encapsulate\n     * both rects.\n     * @param {IgeBounds} rect The rect to combine with this one.\n     */\n    thisCombineRect(rect) {\n        const thisRectMaxX = this.x + this.width, thisRectMaxY = this.y + this.height, thatRectMaxX = rect.x + rect.width, thatRectMaxY = rect.y + rect.height;\n        this.x = Math.min(this.x, rect.x);\n        this.y = Math.min(this.y, rect.y);\n        this.width = Math.max(thisRectMaxX - this.x, thatRectMaxX - this.x);\n        this.height = Math.max(thisRectMaxY - this.y, thatRectMaxY - this.y);\n    }\n    minusPoint(point) {\n        return new IgeBounds(this.x - point.x, this.y - point.y, this.width, this.height);\n    }\n    /**\n     * Compares this rects dimensions with the passed rect and returns\n     * true if they are the same and false if any is different.\n     * @param {IgeBounds} rect\n     * @return {boolean}\n     */\n    compare(rect) {\n        return (rect && this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height);\n    }\n    /**\n     * Returns boolean indicating if the passed x, y is\n     * inside the rectangle.\n     * @param x\n     * @param y\n     * @return {Boolean}\n     */\n    xyInside(x, y) {\n        //return x >= this.x && y > this.y && x <= this.x + this.width && y <= this.y + this.height;\n        return (0,_engine_utils_intersections__WEBPACK_IMPORTED_MODULE_0__.pointIntersectsRect)({ x, y }, this);\n    }\n    /**\n     * Returns boolean indicating if the passed point is\n     * inside the rectangle.\n     * @param {IgePoint3d} point\n     * @return {Boolean}\n     */\n    pointInside(point) {\n        return (0,_engine_utils_intersections__WEBPACK_IMPORTED_MODULE_0__.pointIntersectsRect)(point, this);\n    }\n    /**\n     * Multiplies this rects data by the values specified\n     * and returns a new IgeBounds whose values are the result.\n     * @param x1\n     * @param y1\n     * @param x2\n     * @param y2\n     * @return {*}\n     */\n    multiply(x1, y1, x2, y2) {\n        return new IgeBounds(this.x * x1, this.y * y1, this.width * x2, this.height * y2);\n    }\n    /**\n     * Multiplies this rects data by the values specified and\n     * overwrites the previous values with the result.\n     * @param x1\n     * @param y1\n     * @param x2\n     * @param y2\n     * @return {*}\n     */\n    thisMultiply(x1, y1, x2, y2) {\n        this.x *= x1;\n        this.y *= y1;\n        this.width *= x2;\n        this.height *= y2;\n        return this;\n    }\n    /**\n     * Returns a clone of this object that is not a reference\n     * but retains the same values.\n     * @return {IgeBounds}\n     */\n    clone() {\n        return new IgeBounds(this.x, this.y, this.width, this.height);\n    }\n    /**\n     * Returns a string representation of the rects x, y, width,\n     * height, converting floating point values into fixed using the\n     * passed precision parameter. If no precision is specified\n     * then the precision defaults to 2.\n     * @param {number=} precision\n     * @return {String}\n     */\n    toString(precision) {\n        if (precision === undefined) {\n            precision = 2;\n        }\n        return (this.x.toFixed(precision) +\n            \",\" +\n            this.y.toFixed(precision) +\n            \",\" +\n            this.width.toFixed(precision) +\n            \",\" +\n            this.height.toFixed(precision));\n    }\n    /**\n     * Returns boolean indicating if the passed IgeBounds is\n     * intersecting the rectangle.\n     * @param {IgeShape} shape\n     * @return {boolean}\n     */\n    intersects(shape) {\n        switch (shape._igeShapeType) {\n            case \"circle\":\n                return (0,_engine_utils_intersections__WEBPACK_IMPORTED_MODULE_0__.circleIntersectsRect)(shape, this);\n            case \"rect\":\n                return (0,_engine_utils_intersections__WEBPACK_IMPORTED_MODULE_0__.rectIntersectsRect)(this, shape);\n            case \"polygon\":\n                return (0,_engine_utils_intersections__WEBPACK_IMPORTED_MODULE_0__.rectIntersectsPolygon)(this, shape);\n        }\n        return false;\n    }\n    /**\n     * Draws the polygon bounding lines to the passed context.\n     */\n    render(ctx, fillStyle = \"\") {\n        ctx.rect(this.x, this.y, this.width, this.height);\n        if (fillStyle) {\n            ctx.fillStyle = fillStyle;\n            ctx.fill();\n        }\n        ctx.stroke();\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeBounds.ts?");

/***/ }),

/***/ "./src/engine/core/IgeDummyCanvas.ts":
/*!*******************************************!*\
  !*** ./src/engine/core/IgeDummyCanvas.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeDummyCanvas: () => (/* binding */ IgeDummyCanvas)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeDummyContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeDummyContext */ \"./src/engine/core/IgeDummyContext.ts\");\n\nclass IgeDummyCanvas {\n    constructor() {\n        this.dummy = true;\n        this.width = 0;\n        this.height = 0;\n        this.getContext = (type) => {\n            return new _engine_core_IgeDummyContext__WEBPACK_IMPORTED_MODULE_0__.IgeDummyContext();\n        };\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeDummyCanvas.ts?");

/***/ }),

/***/ "./src/engine/core/IgeDummyContext.ts":
/*!********************************************!*\
  !*** ./src/engine/core/IgeDummyContext.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeDummyContext: () => (/* binding */ IgeDummyContext),\n/* harmony export */   nullMethod: () => (/* binding */ nullMethod),\n/* harmony export */   undefinedMethod: () => (/* binding */ undefinedMethod)\n/* harmony export */ });\nconst undefinedMethod = () => { };\nconst nullMethod = () => {\n    return null;\n};\nclass IgeDummyContext {\n    constructor() {\n        this.dummy = true;\n        this.imageSmoothingEnabled = false;\n        this.globalAlpha = 1;\n        this.fillStyle = \"\";\n        this.strokeStyle = \"\";\n        this.shadowColor = \"\";\n        this.shadowBlur = 0;\n        this.shadowOffsetX = 0;\n        this.shadowOffsetY = 0;\n        this.lineWidth = 1;\n        this.textAlign = \"left\";\n        this.textBaseline = \"middle\";\n        this.lineCap = \"square\";\n        this.save = undefinedMethod;\n        this.restore = undefinedMethod;\n        this.translate = undefinedMethod;\n        this.rotate = undefinedMethod;\n        this.scale = undefinedMethod;\n        this.drawImage = undefinedMethod;\n        this.fillRect = undefinedMethod;\n        this.strokeRect = undefinedMethod;\n        this.stroke = undefinedMethod;\n        this.fill = undefinedMethod;\n        this.rect = undefinedMethod;\n        this.moveTo = undefinedMethod;\n        this.lineTo = undefinedMethod;\n        this.ellipse = undefinedMethod;\n        this.arc = undefinedMethod;\n        this.arcTo = undefinedMethod;\n        this.clearRect = undefinedMethod;\n        this.beginPath = undefinedMethod;\n        this.closePath = undefinedMethod;\n        this.clip = undefinedMethod;\n        this.transform = undefinedMethod;\n        this.setTransform = undefinedMethod;\n        this.fillText = undefinedMethod;\n        this.createImageData = undefinedMethod;\n        this.createPattern = nullMethod;\n        this.getImageData = undefinedMethod;\n        this.putImageData = undefinedMethod;\n        this.strokeText = undefinedMethod;\n        this.createLinearGradient = undefinedMethod;\n        this.measureText = () => ({ width: 0, height: 0 });\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeDummyContext.ts?");

/***/ }),

/***/ "./src/engine/core/IgeEntity.ts":
/*!**************************************!*\
  !*** ./src/engine/core/IgeEntity.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeEntity: () => (/* binding */ IgeEntity)\n/* harmony export */ });\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_core_IgeDummyCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/IgeDummyCanvas */ \"./src/engine/core/IgeDummyCanvas.ts\");\n/* harmony import */ var _engine_core_IgeMatrix2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/core/IgeMatrix2d */ \"./src/engine/core/IgeMatrix2d.ts\");\n/* harmony import */ var _engine_core_IgeObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/core/IgeObject */ \"./src/engine/core/IgeObject.ts\");\n/* harmony import */ var _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/engine/core/IgePoint2d */ \"./src/engine/core/IgePoint2d.ts\");\n/* harmony import */ var _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/engine/core/IgePoint3d */ \"./src/engine/core/IgePoint3d.ts\");\n/* harmony import */ var _engine_core_IgePoly2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/engine/core/IgePoly2d */ \"./src/engine/core/IgePoly2d.ts\");\n/* harmony import */ var _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/engine/core/IgeBounds */ \"./src/engine/core/IgeBounds.ts\");\n/* harmony import */ var _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/engine/utils/clientServer */ \"./src/engine/utils/clientServer.ts\");\n/* harmony import */ var _engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/engine/utils/igeClassStore */ \"./src/engine/utils/igeClassStore.ts\");\n/* harmony import */ var _engine_utils_maths__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/engine/utils/maths */ \"./src/engine/utils/maths.ts\");\n/* harmony import */ var _engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/engine/utils/trace */ \"./src/engine/utils/trace.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Creates an entity and handles the entity's life cycle and\n * all related entity actions / methods.\n */\nclass IgeEntity extends _engine_core_IgeObject__WEBPACK_IMPORTED_MODULE_3__.IgeObject {\n    constructor() {\n        super();\n        this.classId = \"IgeEntity\";\n        this._renderMode = _enums__WEBPACK_IMPORTED_MODULE_12__.IgeEntityRenderMode.flat;\n        //_entity?: IgeEntity; // We comment this because any class wanting to override return values of methods can do so individually e.g. viewport.camera.width().height()\n        this._parent = null;\n        this._children = [];\n        this.customTriggerPolygon = () => new _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_7__.IgeBounds();\n        this._sortChildren = (compareFn) => {\n            return this._children.sort(compareFn);\n        };\n        /**\n         * Gets / sets the shape / polygon that the mouse events\n         * are triggered against. There are two options, 'aabb' and\n         * 'isoBounds'. The default is 'aabb'.\n         * @param val\n         * @returns {*}\n         * @deprecated Please use triggerPolygonFunctionName() instead\n         */\n        this.mouseEventTrigger = (val) => {\n            this.log(\"mouseEventTrigger is no longer in use. Please see triggerPolygonFunctionName() instead.\", \"warning\");\n        };\n        /**\n         * Handler method that determines which mouse-move event\n         * to fire, a mouse-over or a mouse-move.\n         * @private\n         */\n        this._handleMouseIn = (event, evc, data) => {\n            // Check if the mouse move is a mouse over\n            if (!this._pointerStateOver) {\n                this._pointerStateOver = true;\n                if (this._pointerOver) {\n                    this._pointerOver(event, evc, data);\n                }\n                /**\n                 * Fires when the mouse moves over the entity.\n                 * @event IgeEntity#pointerOver\n                 * @param {Object} The DOM event object.\n                 * @param {Object} The IGE event control object.\n                 * @param {*} Any further event data.\n                 */\n                this.emit(\"pointerOver\", event, evc, data);\n            }\n            if (this._pointerMove) {\n                this._pointerMove(event, evc, data);\n            }\n            this.emit(\"pointerMove\", event, evc, data);\n        };\n        /**\n         * Handler method that determines if a mouse-out event\n         * should be fired.\n         * @private\n         */\n        this._handleMouseOut = (event, evc, data) => {\n            // The mouse went away from this entity so\n            // set mouse-down to false, regardless of the situation\n            this._pointerStateDown = false;\n            // Check if the mouse move is a mouse out\n            if (!this._pointerStateOver) {\n                return;\n            }\n            this._pointerStateOver = false;\n            if (this._pointerOut) {\n                this._pointerOut(event, evc, data);\n            }\n            /**\n             * Fires when the mouse moves away from the entity.\n             * @event IgeEntity#pointerOut\n             * @param {Object} The DOM event object.\n             * @param {Object} The IGE event control object.\n             * @param {*} Any further event data.\n             */\n            this.emit(\"pointerOut\", event, evc, data);\n        };\n        /**\n         * Handler method that determines if a mouse-wheel event\n         * should be fired.\n         * @private\n         */\n        this._handleMouseWheel = (event, evc, data) => {\n            if (this._pointerWheel) {\n                this._pointerWheel(event, evc, data);\n            }\n            /**\n             * Fires when the mouse wheel is moved over the entity.\n             * @event IgeEntity#pointerWheel\n             * @param {Object} The DOM event object.\n             * @param {Object} The IGE event control object.\n             * @param {*} Any further event data.\n             */\n            this.emit(\"pointerWheel\", event, evc, data);\n        };\n        /**\n         * Handler method that determines if a mouse-up event\n         * should be fired.\n         * @private\n         */\n        this._handleMouseUp = (event, evc, data) => {\n            // Reset the mouse-down flag\n            this._pointerStateDown = false;\n            if (this._pointerUp) {\n                this._pointerUp(event, evc, data);\n            }\n            /**\n             * Fires when a mouse up occurs on the entity.\n             * @event IgeEntity#pointerUp\n             * @param {Object} The DOM event object.\n             * @param {Object} The IGE event control object.\n             * @param {*} Any further event data.\n             */\n            this.emit(\"pointerUp\", event, evc, data);\n        };\n        /**\n         * Handler method that determines if a mouse-down event\n         * should be fired.\n         * @private\n         */\n        this._handleMouseDown = (event, evc, data) => {\n            if (!this._pointerStateDown) {\n                this._pointerStateDown = true;\n                if (this._pointerDown) {\n                    this._pointerDown(event, evc, data);\n                }\n                /**\n                 * Fires when a mouse down occurs on the entity.\n                 * @event IgeEntity#pointerDown\n                 * @param {Object} The DOM event object.\n                 * @param {Object} The IGE event control object.\n                 * @param {*} Any further event data.\n                 */\n                this.emit(\"pointerDown\", event, evc, data);\n            }\n        };\n        /**\n         * Checks mouse input types and fires the correct mouse event\n         * handler. This is an internal method that should never be\n         * called externally.\n         * @param {Object} evc The input component event control object.\n         * @param {Object} eventData Data passed by the input component into\n         * the new event.\n         * @private\n         */\n        this._mouseInTrigger = (evc, eventData) => {\n            const input = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.input;\n            if (input.pointerMove) {\n                // There is a mouse move event\n                this._handleMouseIn(input.pointerMove, evc, eventData);\n            }\n            if (input.pointerDown) {\n                // There is a mouse down event\n                this._handleMouseDown(input.pointerDown, evc, eventData);\n            }\n            if (input.pointerUp) {\n                // There is a mouse up event\n                this._handleMouseUp(input.pointerUp, evc, eventData);\n            }\n            if (input.pointerWheel) {\n                // There is a mouse wheel event\n                this._handleMouseWheel(input.pointerWheel, evc, eventData);\n            }\n        };\n        // Register the IgeEntity special properties handler for\n        // serialise and de-serialise support\n        this._specialProp.push(\"_texture\");\n        this._specialProp.push(\"_eventListeners\");\n        this._specialProp.push(\"_aabb\");\n        //this._mouseEventTrigger = 0;\n        if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_8__.isServer) {\n            // Set the stream floating point precision to 2 as default\n            this.streamFloatPrecision(2);\n        }\n        // Set the default stream sections as just the transform data\n        this.streamSections([\"transform\"]);\n    }\n    /**\n     * Calculates the distance to the passed entity from this one.\n     * @param {IgeEntity} entity The entity to calculate distance\n     * to.\n     * @returns {number} Distance.\n     */\n    distanceTo(entity) {\n        const a = this._translate.x - entity._translate.x, b = this._translate.y - entity._translate.y;\n        return Math.sqrt(a * a + b * b);\n    }\n    /**\n     * Clones the object and all its children and returns a new object.\n     */\n    clone(options) {\n        // Make sure we have an options object\n        if (options === undefined) {\n            options = {};\n        }\n        // Set some default option values\n        if (options.id === undefined) {\n            options.id = false;\n        }\n        if (options.mount === undefined) {\n            options.mount = false;\n        }\n        if (options.transform === undefined) {\n            options.transform = true;\n        }\n        // Loop all children and clone them, then return cloned version of ourselves\n        return eval(this.stringify(options));\n    }\n    /**\n     * Checks the current transform values against the previous ones. If\n     * any value is different, the appropriate method is called which will\n     * update the transformation matrix accordingly.\n     */\n    updateTransform() {\n        this._localMatrix.identity();\n        if (this._renderMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeEntityRenderMode.flat) {\n            // 2d translation\n            this._localMatrix.multiply(this._localMatrix._newTranslate(this._translate.x, this._translate.y));\n        }\n        if (this._renderMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeEntityRenderMode.iso) {\n            // iso translation\n            const isoPoint = (this._translateIso = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(this._translate.x, this._translate.y, this._translate.z + this._bounds3d.z / 2).toIso());\n            if (this._parent && this._parent._bounds3d.z) {\n                // This adjusts the child entity so that 0, 0, 0 inside the\n                // parent is the center of the base of the parent\n                isoPoint.y += this._parent._bounds3d.z / 1.6;\n            }\n            this._localMatrix.multiply(this._localMatrix._newTranslate(isoPoint.x, isoPoint.y));\n        }\n        this._localMatrix.rotateBy(this._rotate.z);\n        this._localMatrix.scaleBy(this._scale.x, this._scale.y);\n        // Adjust local matrix for origin values if not at center\n        if (this._origin.x !== 0.5 || this._origin.y !== 0.5) {\n            this._localMatrix.translateBy(this._bounds2d.x * (0.5 - this._origin.x), this._bounds2d.y * (0.5 - this._origin.y));\n        }\n        // TODO: If the parent and local transforms are unchanged, we should used cached values\n        if (this._parent) {\n            this._worldMatrix.copy(this._parent._worldMatrix);\n            this._worldMatrix.multiply(this._localMatrix);\n        }\n        else {\n            this._worldMatrix.copy(this._localMatrix);\n        }\n        // Check if the world matrix has changed and if so, set a few flags\n        // to allow other methods to know that a matrix change has occurred\n        if (!this._worldMatrix.compare(this._oldWorldMatrix)) {\n            this._oldWorldMatrix.copy(this._worldMatrix);\n            this._transformChanged = true;\n            this._aabbDirty = true;\n            this._bounds3dPolygonDirty = true;\n            this.cacheDirty(true);\n        }\n        else {\n            this._transformChanged = false;\n        }\n        // Check if the geometry has changed and if so, update the aabb dirty\n        if (!this._oldBounds2d.compare(this._bounds2d)) {\n            this._aabbDirty = true;\n            // Record the new geometry to the oldGeometry data\n            this._oldBounds2d.copy(this._bounds2d);\n        }\n        if (!this._oldBounds3d.compare(this._bounds3d)) {\n            this._bounds3dPolygonDirty = true;\n            // Record the new geometry to the oldGeometry data\n            this._oldBounds3d.copy(this._bounds3d);\n        }\n        return this;\n    }\n    /**\n     * Sets the entity as visible and able to be interacted with.\n     * @example #Show a hidden entity\n     *     entity.show();\n     * @return {*} The object this method was called from to allow\n     * method chaining.\n     */\n    show() {\n        this._hidden = false;\n        return this;\n    }\n    /**\n     * Sets the entity as hidden and cannot be interacted with.\n     * @example #Hide a visible entity\n     *     entity.hide();\n     * @return {*} The object this method was called from to allow\n     * method chaining.\n     */\n    hide() {\n        this._hidden = true;\n        return this;\n    }\n    /**\n     * Checks if the entity is visible.\n     * @returns {boolean} True if the entity is visible.\n     */\n    isVisible() {\n        return !this._hidden;\n    }\n    /**\n     * Checks if the entity is hidden.\n     * @returns {boolean} True if the entity is hidden.\n     */\n    isHidden() {\n        return this._hidden;\n    }\n    cacheSmoothing(val) {\n        if (val !== undefined) {\n            this._cacheSmoothing = val;\n            return this;\n        }\n        return this._cacheSmoothing;\n    }\n    /**\n     * Gets the position of the mouse relative to this entity's\n     * center point.\n     * @param {IgeViewport=} viewport The viewport to use as the\n     * base from which the mouse position is determined. If no\n     * viewport is specified then the current viewport the engine\n     * is rendering to is used instead.\n     * @example #Get the mouse position relative to the entity\n     *     // The returned value is an object with properties x, y, z\n     *     var mousePos = entity.mousePos();\n     * @return {IgePoint3d} The mouse point relative to the entity\n     * center.\n     */\n    mousePos(viewport) {\n        viewport = viewport || _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentViewport;\n        if (!viewport) {\n            return new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0, 0, 0);\n        }\n        const mp = viewport._pointerPos.clone();\n        // if (this._ignoreCamera) {\n        //      const cam = ige.engine._currentCamera;\n        // \t    mp.thisMultiply(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);\n        // \t    //mp.thisRotate(-cam._rotate.z);\n        // \t    mp.thisAddPoint(cam._translate);\n        // }\n        // TODO: No idea why viewport doesn't have _translate, it's extended from IgeEntity!\n        // @ts-ignore\n        mp.x += viewport._translate.x;\n        // @ts-ignore\n        mp.y += viewport._translate.y;\n        this._transformPoint(mp);\n        return mp;\n    }\n    /**\n     * Gets the position of the mouse relative to this entity not\n     * taking into account viewport translation.\n     * @param {IgeViewport=} viewport The viewport to use as the\n     * base from which the mouse position is determined. If no\n     * viewport is specified then the current viewport the engine\n     * is rendering to is used instead.\n     * @example #Get absolute mouse position\n     *     var mousePosAbs = entity.mousePosAbsolute();\n     * @return {IgePoint3d} The mouse point relative to the entity\n     * center.\n     */\n    mousePosAbsolute(viewport) {\n        viewport = viewport || _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentViewport;\n        if (viewport) {\n            const mp = viewport._pointerPos.clone();\n            this._transformPoint(mp);\n            return mp;\n        }\n        return new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0, 0, 0);\n    }\n    /**\n     * Gets the position of the mouse in world co-ordinates.\n     * @param {IgeViewport=} viewport The viewport to use as the\n     * base from which the mouse position is determined. If no\n     * viewport is specified then the current viewport the engine\n     * is rendering to is used instead.\n     * @example #Get mouse position in world co-ordinates\n     *     var mousePosWorld = entity.mousePosWorld();\n     * @return {IgePoint3d} The mouse point relative to the world\n     * center.\n     */\n    mousePosWorld(viewport) {\n        viewport = viewport || _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentViewport;\n        const mp = this.mousePos(viewport);\n        this.localToWorldPoint(mp, viewport);\n        if (this._ignoreCamera) {\n            //viewport.camera._worldMatrix.getInverse().transform([mp]);\n        }\n        return mp;\n    }\n    /**\n     * Rotates the entity to point at the target point around the z axis.\n     * @param {IgePoint3d} point The point in world co-ordinates to\n     * point the entity at.\n     * @example #Point the entity at another one\n     *     entity.rotateToPoint(otherEntity.worldPosition());\n     * @example #Point the entity at mouse\n     *     entity.rotateToPoint(ige.engine._currentViewport.mousePos());\n     * @example #Point the entity at an arbitrary point x, y\n     *     entity.rotateToPoint(new IgePoint3d(x, y, 0));\n     * @return {*}\n     */\n    rotateToPoint(point) {\n        var _a, _b, _c;\n        const worldPos = this.worldPosition();\n        this.rotateTo(this._rotate.x, this._rotate.y, Math.atan2(worldPos.y - point.y, worldPos.x - point.x) -\n            ((_c = (_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._rotate) === null || _b === void 0 ? void 0 : _b.z) !== null && _c !== void 0 ? _c : 0) +\n            (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_10__.degreesToRadians)(270));\n        return this;\n    }\n    backgroundPattern(texture, repeat = \"repeat\", trackCamera = false, isoTile = false) {\n        if (texture !== undefined) {\n            this._backgroundPattern = texture;\n            this._backgroundPatternRepeat = repeat;\n            this._backgroundPatternTrackCamera = trackCamera;\n            this._backgroundPatternIsoTile = isoTile;\n            this._backgroundPatternFill = null;\n            return this;\n        }\n        return this._backgroundPattern;\n    }\n    smartBackground(renderMethod) {\n        if (renderMethod !== undefined) {\n            this._smartBackground = renderMethod;\n            return this;\n        }\n        return this._smartBackground;\n    }\n    /**\n     * Set the object's width to the number of tile width's specified.\n     * @param {number} val Number of tiles.\n     * @param {Boolean=} lockAspect If true, sets the height according\n     * to the texture aspect ratio and the new width.\n     * @example #Set the width of the entity based on the tile width of the map the entity is mounted to\n     *     // Set the entity width to the size of 1 tile with\n     *     // lock aspect enabled which will automatically size\n     *     // the height as well, to maintain the aspect\n     *     // ratio of the entity\n     *     entity.widthByTile(1, true);\n     * @return {*} The object this method was called from to allow\n     * method chaining.\n     */\n    widthByTile(val, lockAspect = false) {\n        if (!(this._parent &&\n            this._parent.IgeTileMap2d &&\n            this._parent._tileWidth !== undefined &&\n            this._parent._tileHeight !== undefined)) {\n            throw new Error(\"Cannot set width by tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.\");\n        }\n        const tileSize = this._renderMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeEntityRenderMode.flat ? this._parent._tileWidth : this._parent._tileWidth * 2;\n        if (lockAspect) {\n            if (this._texture) {\n                this.width(val * tileSize);\n                // Calculate the height based on the new width\n                const ratio = this._texture._sizeX / this._bounds2d.x;\n                this.height(this._texture._sizeY / ratio);\n            }\n            else {\n                // No texture assigned, simply maintain aspect ratio\n                const ratio = this._bounds2d.x / (val * tileSize);\n                this.height(this._bounds2d.y / ratio);\n            }\n        }\n        else {\n            this.width(val * tileSize);\n        }\n        return this;\n    }\n    /**\n     * Set the object's height to the number of tile height's specified.\n     * @param {number} val Number of tiles.\n     * @param {Boolean=} lockAspect If true, sets the width according\n     * to the texture aspect ratio and the new height.\n     * @example #Set the height of the entity based on the tile height of the map the entity is mounted to\n     *     // Set the entity height to the size of 1 tile with\n     *     // lock aspect enabled which will automatically size\n     *     // the width as well to maintain the aspect ratio\n     *     entity.heightByTile(1, true);\n     * @return {*} The object this method was called from to allow\n     * method chaining.\n     */\n    heightByTile(val, lockAspect = false) {\n        if (!(this._parent &&\n            this._parent.IgeTileMap2d &&\n            this._parent._tileWidth !== undefined &&\n            this._parent._tileHeight !== undefined)) {\n            throw new Error(\"Cannot set height by tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.\");\n        }\n        const tileSize = this._renderMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeEntityRenderMode.flat ? this._parent._tileHeight : this._parent._tileHeight * 2;\n        this.height(val * tileSize);\n        if (lockAspect) {\n            if (this._texture) {\n                // Calculate the width based on the new height\n                const ratio = this._texture._sizeY / this._bounds2d.y;\n                this.width(this._texture._sizeX / ratio);\n            }\n            else {\n                this.log(\"Cannot set width based on texture aspect ratio and new height because no texture is currently assigned to the entity!\", \"error\");\n            }\n        }\n        return this;\n    }\n    /**\n     * Adds the object to the tile map at the passed tile co-ordinates. If\n     * no tile co-ordinates are passed, will use the current tile position\n     * and the tileWidth() and tileHeight() values.\n     * @param {number=} x X co-ordinate of the tile to occupy.\n     * @param {number=} y Y co-ordinate of the tile to occupy.\n     * @param {number=} width Number of tiles along the x-axis to occupy.\n     * @param {number=} height Number of tiles along the y-axis to occupy.\n     */\n    occupyTile(x, y, width, height) {\n        // Check that the entity is mounted to a tile map\n        if (!(this._parent && this._parent.IgeTileMap2d)) {\n            return this;\n        }\n        if (this._tileWidth === undefined || this._tileHeight === undefined) {\n            return this;\n        }\n        if (x !== undefined && y !== undefined) {\n            this._parent.occupyTile(x, y, width, height, this);\n            return this;\n        }\n        // Occupy tiles based upon tile point and tile width/height\n        const trPoint = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(this._translate.x - (this._tileWidth / 2 - 0.5) * this._parent._tileWidth, this._translate.y - (this._tileHeight / 2 - 0.5) * this._parent._tileHeight, 0);\n        const tilePoint = this._parent.pointToTile(trPoint);\n        if (this._parent._mountMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeMountMode.iso) {\n            tilePoint.thisToIso();\n        }\n        this._parent.occupyTile(tilePoint.x, tilePoint.y, this._tileWidth, this._tileHeight, this);\n        return this;\n    }\n    /**\n     * Removes the object from the tile map at the passed tile co-ordinates.\n     * If no tile co-ordinates are passed, will use the current tile position\n     * and the tileWidth() and tileHeight() values.\n     * @param {number=} x X co-ordinate of the tile to un-occupy.\n     * @param {number=} y Y co-ordinate of the tile to un-occupy.\n     * @param {number=} width Number of tiles along the x-axis to un-occupy.\n     * @param {number=} height Number of tiles along the y-axis to un-occupy.\n     * @private\n     */\n    unOccupyTile(x, y, width, height) {\n        // Check that the entity is mounted to a tile map\n        if (!(this._parent && this._parent.IgeTileMap2d)) {\n            return this;\n        }\n        if (this._tileWidth === undefined || this._tileHeight === undefined) {\n            return this;\n        }\n        if (x !== undefined && y !== undefined) {\n            this._parent.unOccupyTile(x, y, width, height);\n            return this;\n        }\n        // Un-occupy tiles based upon tile point and tile width/height\n        const trPoint = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(this._translate.x - (this._tileWidth / 2 - 0.5) * this._parent._tileWidth, this._translate.y - (this._tileHeight / 2 - 0.5) * this._parent._tileHeight, 0), tilePoint = this._parent.pointToTile(trPoint);\n        if (this._parent._mountMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeMountMode.iso) {\n            tilePoint.thisToIso();\n        }\n        this._parent.unOccupyTile(tilePoint.x, tilePoint.y, this._tileWidth, this._tileHeight);\n        return this;\n    }\n    /**\n     * Returns an array of tile co-ordinates that the object is currently\n     * over, calculated using the current world co-ordinates of the object\n     * as well as its 3d geometry.\n     * @private\n     * @return {Array} The array of tile co-ordinates as IgePoint3d instances.\n     */\n    overTiles() {\n        // Check that the entity is mounted to a tile map\n        if (!(this._parent && this._parent.IgeTileMap2d)) {\n            return;\n        }\n        const tileWidth = this._tileWidth || 1;\n        const tileHeight = this._tileHeight || 1;\n        const tile = this._parent.pointToTile(this._translate);\n        //TODO: Should this be point2d instead?\n        const tileArr = [];\n        for (let x = 0; x < tileWidth; x++) {\n            for (let y = 0; y < tileHeight; y++) {\n                tileArr.push(new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(tile.x + x, tile.y + y, 0));\n            }\n        }\n        return tileArr;\n    }\n    anchor(x, y) {\n        if (x !== undefined && y !== undefined) {\n            this._anchor = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_4__.IgePoint2d(x, y);\n            return this;\n        }\n        return this._anchor;\n    }\n    width(px, lockAspect = false) {\n        if (px === undefined) {\n            return this._bounds2d.x;\n        }\n        if (typeof px === \"string\") {\n            px = parseFloat(px);\n        }\n        if (lockAspect) {\n            // Calculate the height from the change in width\n            const ratio = px / this._bounds2d.x;\n            this.height(this._bounds2d.y * ratio);\n        }\n        this._bounds2d.x = px;\n        this._bounds2d.x2 = px / 2;\n        return this;\n    }\n    height(px, lockAspect = false) {\n        if (px === undefined) {\n            return this._bounds2d.y;\n        }\n        if (typeof px === \"string\") {\n            px = parseFloat(px);\n        }\n        if (lockAspect) {\n            // Calculate the width from the change in height\n            const ratio = px / this._bounds2d.y;\n            this.width(this._bounds2d.x * ratio);\n        }\n        this._bounds2d.y = px;\n        this._bounds2d.y2 = px / 2;\n        return this;\n    }\n    bounds2d(x, y) {\n        if (x !== undefined && y !== undefined && typeof x === \"number\") {\n            this._bounds2d = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_4__.IgePoint2d(x, y);\n            return this;\n        }\n        // TODO: Is this exception still something we use?\n        if (typeof x === \"object\" && y === undefined) {\n            const bounds = x;\n            // x is considered an IgePoint2d instance\n            this._bounds2d = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_4__.IgePoint2d(bounds.x, bounds.y);\n        }\n        return this._bounds2d;\n    }\n    bounds3d(x, y, z) {\n        if (x !== undefined && y !== undefined && z !== undefined) {\n            this._bounds3d = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(x, y, z);\n            return this;\n        }\n        return this._bounds3d;\n    }\n    lifeSpan(milliseconds, deathCallback) {\n        if (milliseconds !== undefined) {\n            this.deathTime(_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime + milliseconds, deathCallback);\n            return this;\n        }\n        return (this.deathTime() || 0) - _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime;\n    }\n    deathTime(val, deathCallback) {\n        if (val !== undefined) {\n            this._deathTime = val;\n            if (deathCallback !== undefined) {\n                this._deathCallBack = deathCallback;\n            }\n            return this;\n        }\n        return this._deathTime;\n    }\n    opacity(val) {\n        if (val !== undefined) {\n            this._opacity = val;\n            return this;\n        }\n        return this._opacity;\n    }\n    noAabb(val) {\n        if (val !== undefined) {\n            this._noAabb = val;\n            return this;\n        }\n        return this._noAabb;\n    }\n    texture(texture) {\n        if (texture !== undefined) {\n            this._texture = texture;\n            return this;\n        }\n        return this._texture;\n    }\n    cell(val) {\n        if (val !== undefined && (val === null || val > 0)) {\n            this._cell = val;\n            return this;\n        }\n        return this._cell;\n    }\n    cellById(val) {\n        if (val !== undefined) {\n            if (this._texture) {\n                // Find the cell index this id corresponds to\n                const tex = this._texture;\n                const cells = tex._cells;\n                for (let i = 1; i < cells.length; i++) {\n                    if (cells[i][4] === val) {\n                        // Found the cell id so assign this cell index\n                        this.cell(i);\n                        return this;\n                    }\n                }\n                // We were unable to find the cell index from the cell\n                // id so produce an error\n                this.log(`Could not find the cell id \"${val}\" in the assigned entity texture ${tex.id()}, please check your sprite sheet (texture) cell definition to ensure the cell id \"${val}\" has been assigned to a cell!`, \"error\");\n            }\n            else {\n                this.log(\"Cannot assign cell index from cell ID until an IgeSpriteSheet has been set as the texture for this entity. Please set the texture before calling cellById().\", \"error\");\n            }\n        }\n        return this._cell;\n    }\n    /**\n     * Sets the geometry of the entity to match the width and height\n     * of the assigned texture.\n     * @param {number=} percent The percentage size to resize to.\n     * @example #Set the entity dimensions based on the assigned texture\n     *     var texture = new IgeTexture('path/to/some/texture.png');\n     *\n     *     // Assign the texture, and then set the entity to the\n     *     // size of the texture automatically!\n     *     entity.texture(texture)\n     *         .dimensionsFromTexture();\n     * @return {*} The object this method was called from to allow\n     * method chaining.\n     */\n    dimensionsFromTexture(percent) {\n        if (this._texture) {\n            if (percent === undefined) {\n                this.width(this._texture._sizeX);\n                this.height(this._texture._sizeY);\n            }\n            else {\n                this.width(Math.floor((this._texture._sizeX / 100) * percent));\n                this.height(Math.floor((this._texture._sizeY / 100) * percent));\n            }\n            // Recalculate localAabb\n            this.localAabb(true);\n        }\n        return this;\n    }\n    /**\n     * Sets the geometry of the entity to match the width and height\n     * of the assigned texture cell. If the texture is not cell-based\n     * the entire texture width / height will be used.\n     * @param {number=} percent The percentage size to resize to.\n     * @example #Set the entity dimensions based on the assigned texture and cell\n     *     var texture = new IgeSpriteSheet('path/to/some/cellSheet.png', [\n     *         [0, 0, 40, 40, 'robotHead'],\n     *         [40, 0, 40, 40, 'humanHead'],\n     *     ]);\n     *\n     *     // Assign the texture, set the cell to use and then\n     *     // set the entity to the size of the cell automatically!\n     *     entity.texture(texture)\n     *         .cellById('robotHead')\n     *         .dimensionsFromCell();\n     * @return {*} The object this method was called from to allow\n     * method chaining\n     */\n    dimensionsFromCell(percent) {\n        if (typeof this._cell !== \"number\") {\n            throw new Error(\"Cell of type string cannot access dimensions\");\n        }\n        if (this._texture) {\n            if (this._texture._cells && this._texture._cells.length && this._cell) {\n                if (percent === undefined) {\n                    this.width(this._texture._cells[this._cell][2]);\n                    this.height(this._texture._cells[this._cell][3]);\n                }\n                else {\n                    this.width(Math.floor((this._texture._cells[this._cell][2] / 100) * percent));\n                    this.height(Math.floor((this._texture._cells[this._cell][3] / 100) * percent));\n                }\n                // Recalculate localAabb\n                this.localAabb(true);\n            }\n        }\n        return this;\n    }\n    highlight(val, highlightChildEntities = true) {\n        if (val !== undefined) {\n            this._highlight = val;\n            if (highlightChildEntities) {\n                this._children.forEach((child) => {\n                    if (!(\"highlight\" in child))\n                        return;\n                    child.highlight(val);\n                });\n            }\n            this.cacheDirty(true);\n            return this;\n        }\n        return this._highlight;\n    }\n    // Commented as this can't have ever worked\n    // mouseInBounds3d (recalculate = false): boolean {\n    // \tconst poly = this.localBounds3dPolygon(recalculate),\n    // \t\tmp = this.mousePos();\n    //\n    // \t// TODO this won't work because pointInside doesn't exist on IgePoly2d\n    // \treturn poly.pointInside(mp);\n    // }\n    /**\n     * Calculates and returns the current axis-aligned bounding box in\n     * world co-ordinates.\n     * @param {Boolean=} recalculate If true this will force the\n     * recalculation of the AABB instead of returning a cached\n     * value.\n     * @param inverse\n     * @example #Get the entity axis-aligned bounding box dimensions\n     *     var aabb = entity.aabb();\n     *\n     *     console.log(aabb.x);\n     *     console.log(aabb.y);\n     *     console.log(aabb.width);\n     *     console.log(aabb.height);\n     * @example #Get the entity axis-aligned bounding box dimensions forcing the engine to update the values first\n     *     var aabb = entity.aabb(true); // Call with true to force update\n     *\n     *     console.log(aabb.x);\n     *     console.log(aabb.y);\n     *     console.log(aabb.width);\n     *     console.log(aabb.height);\n     * @return {IgeBounds} The axis-aligned bounding box in world co-ordinates.\n     */\n    aabb(recalculate = true, inverse = false) {\n        if (!(this._aabbDirty || !this._aabb || recalculate)) {\n            return this._aabb;\n        }\n        //  && this.newFrame()\n        const poly = new _engine_core_IgePoly2d__WEBPACK_IMPORTED_MODULE_6__.IgePoly2d();\n        const anc = this._anchor;\n        const ancX = anc.x;\n        const ancY = anc.y;\n        const geom = this._bounds2d;\n        const geomX2 = geom.x2;\n        const geomY2 = geom.y2;\n        const x = geomX2;\n        const y = geomY2;\n        poly.addPoint(-x + ancX, -y + ancY);\n        poly.addPoint(x + ancX, -y + ancY);\n        poly.addPoint(x + ancX, y + ancY);\n        poly.addPoint(-x + ancX, y + ancY);\n        this._renderPos = { x: -x + ancX, y: -y + ancY };\n        // Convert the poly's points from local space to world space\n        this.localToWorld(poly._poly, null, inverse);\n        // Get the extents of the newly transformed poly\n        const minX = Math.min(poly._poly[0].x, poly._poly[1].x, poly._poly[2].x, poly._poly[3].x);\n        const minY = Math.min(poly._poly[0].y, poly._poly[1].y, poly._poly[2].y, poly._poly[3].y);\n        const maxX = Math.max(poly._poly[0].x, poly._poly[1].x, poly._poly[2].x, poly._poly[3].x);\n        const maxY = Math.max(poly._poly[0].y, poly._poly[1].y, poly._poly[2].y, poly._poly[3].y);\n        if (isNaN(minX) || isNaN(minY) || isNaN(maxX) || isNaN(maxY)) {\n            debugger;\n        }\n        this._aabb = new _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_7__.IgeBounds(minX, minY, maxX - minX, maxY - minY);\n        this._aabbDirty = false;\n        return this._aabb;\n    }\n    /**\n     * Calculates and returns the local axis-aligned bounding box\n     * for the entity. This is the AABB relative to the entity's\n     * center point.\n     * @param {Boolean=} recalculate If true this will force the\n     * recalculation of the local AABB instead of returning a cached\n     * value.\n     * @example #Get the entity local axis-aligned bounding box dimensions\n     *     var aabb = entity.localAabb();\n     *\n     *     console.log(aabb.x);\n     *     console.log(aabb.y);\n     *     console.log(aabb.width);\n     *     console.log(aabb.height);\n     * @example #Get the entity local axis-aligned bounding box dimensions forcing the engine to update the values first\n     *     var aabb = entity.localAabb(true); // Call with true to force update\n     *\n     *     console.log(aabb.x);\n     *     console.log(aabb.y);\n     *     console.log(aabb.width);\n     *     console.log(aabb.height);\n     * @return {IgeBounds} The local AABB.\n     */\n    localAabb(recalculate = false) {\n        if (this._localAabb && !recalculate) {\n            return this._localAabb;\n        }\n        const aabb = this.aabb();\n        this._localAabb = new _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_7__.IgeBounds(-Math.floor(aabb.width / 2), -Math.floor(aabb.height / 2), Math.floor(aabb.width), Math.floor(aabb.height));\n    }\n    /**\n     * Takes two values and returns them as an array where argument[0]\n     * is the y argument and argument[1] is the x argument. This method\n     * is used specifically in the 3d bounds intersection process to\n     * determine entity depth sorting.\n     * @private\n     * @param num1\n     * @param num2\n     * @return {Array} The swapped arguments.\n     */\n    _swapVars(num1, num2) {\n        return [num1, num2];\n    }\n    _internalsOverlap(x0, x1, y0, y1) {\n        let tempSwap;\n        if (x0 > x1) {\n            tempSwap = this._swapVars(x0, x1);\n            x0 = tempSwap[0];\n            x1 = tempSwap[1];\n        }\n        if (y0 > y1) {\n            tempSwap = this._swapVars(y0, y1);\n            y0 = tempSwap[0];\n            y1 = tempSwap[1];\n        }\n        if (x0 > y0) {\n            tempSwap = this._swapVars(x0, y0);\n            y0 = tempSwap[1];\n            tempSwap = this._swapVars(x1, y1);\n            x1 = tempSwap[0];\n        }\n        return y0 < x1;\n    }\n    _projectionOverlap(otherObject) {\n        const thisG3d = this._bounds3d;\n        const otherG3d = otherObject._bounds3d;\n        const thisMin = {\n            x: this._translate.x - thisG3d.x / 2,\n            y: this._translate.y - thisG3d.y / 2,\n            z: this._translate.z - thisG3d.z\n        };\n        const thisMax = {\n            x: this._translate.x + thisG3d.x / 2,\n            y: this._translate.y + thisG3d.y / 2,\n            z: this._translate.z + thisG3d.z\n        };\n        const otherMin = {\n            x: otherObject._translate.x - otherG3d.x / 2,\n            y: otherObject._translate.y - otherG3d.y / 2,\n            z: otherObject._translate.z - otherG3d.z\n        };\n        const otherMax = {\n            x: otherObject._translate.x + otherG3d.x / 2,\n            y: otherObject._translate.y + otherG3d.y / 2,\n            z: otherObject._translate.z + otherG3d.z\n        };\n        return (this._internalsOverlap(thisMin.x - thisMax.y, thisMax.x - thisMin.y, otherMin.x - otherMax.y, otherMax.x - otherMin.y) &&\n            this._internalsOverlap(thisMin.x - thisMax.z, thisMax.x - thisMin.z, otherMin.x - otherMax.z, otherMax.x - otherMin.z) &&\n            this._internalsOverlap(thisMin.z - thisMax.y, thisMax.z - thisMin.y, otherMin.z - otherMax.y, otherMax.z - otherMin.y));\n    }\n    /**\n     * Compares the current entity's 3d bounds to the passed entity and\n     * determines if the current entity is \"behind\" the passed one. If an\n     * entity is behind another, it is drawn first during the scenegraph\n     * render phase.\n     * @param {IgeEntity} otherObject The other entity to check this\n     * entity's 3d bounds against.\n     * @example #Determine if this entity is \"behind\" another entity based on the current depth-sort\n     *     var behind = entity.isBehind(otherEntity);\n     * @return {Boolean} If true this entity is \"behind\" the passed entity\n     * or false if not.\n     */\n    isBehind(otherObject) {\n        const thisG3d = this._bounds3d, otherG3d = otherObject._bounds3d, thisTranslate = this._translate.clone(), otherTranslate = otherObject._translate.clone();\n        // thisTranslate.thisToIso();\n        // otherTranslate.thisToIso();\n        if (this._origin.x !== 0.5 || this._origin.y !== 0.5) {\n            thisTranslate.x += this._bounds2d.x * (0.5 - this._origin.x);\n            thisTranslate.y += this._bounds2d.y * (0.5 - this._origin.y);\n        }\n        if (otherObject._origin.x !== 0.5 || otherObject._origin.y !== 0.5) {\n            otherTranslate.x += otherObject._bounds2d.x * (0.5 - otherObject._origin.x);\n            otherTranslate.y += otherObject._bounds2d.y * (0.5 - otherObject._origin.y);\n        }\n        const thisX = thisTranslate.x, thisY = thisTranslate.y, otherX = otherTranslate.x, otherY = otherTranslate.y, thisMin = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(thisX - thisG3d.x / 2, thisY - thisG3d.y / 2, this._translate.z), thisMax = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(thisX + thisG3d.x / 2, thisY + thisG3d.y / 2, this._translate.z + thisG3d.z), otherMin = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(otherX - otherG3d.x / 2, otherY - otherG3d.y / 2, otherObject._translate.z), otherMax = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(otherX + otherG3d.x / 2, otherY + otherG3d.y / 2, otherObject._translate.z + otherG3d.z);\n        if (thisMax.x <= otherMin.x) {\n            return false;\n        }\n        if (otherMax.x <= thisMin.x) {\n            return true;\n        }\n        if (thisMax.y <= otherMin.y) {\n            return false;\n        }\n        if (otherMax.y <= thisMin.y) {\n            return true;\n        }\n        if (thisMax.z <= otherMin.z) {\n            return false;\n        }\n        if (otherMax.z <= thisMin.z) {\n            return true;\n        }\n        return thisX + thisY + this._translate.z > otherX + otherY + otherObject._translate.z;\n    }\n    pointerEventsActive(val) {\n        if (val !== undefined) {\n            this._pointerEventsActive = val;\n            return this;\n        }\n        return this._pointerEventsActive;\n    }\n    /**\n     * Sets the _ignoreCamera internal flag to the value passed for this\n     * and all child entities down the scenegraph.\n     * @param val\n     */\n    ignoreCameraComposite(val) {\n        const arr = this._children;\n        const arrCount = arr.length;\n        this._ignoreCamera = val;\n        for (let i = 0; i < arrCount; i++) {\n            const arrItem = arr[i];\n            if (\"ignoreCameraComposite\" in arrItem) {\n                arrItem.ignoreCameraComposite(val);\n            }\n        }\n    }\n    /**\n     * Determines if the frame alternator value for this entity\n     * matches the engine's frame alternator value. The entity's\n     * frame alternator value will be set to match the engine's\n     * after each call to the entity.tick() method so the return\n     * value of this method can be used to determine if the tick()\n     * method has already been run for this entity.\n     *\n     * This is useful if you have multiple viewports which will\n     * cause the entity tick() method to fire once for each viewport,\n     * but you only want to execute update code such as movement,\n     * on the first time the tick() method is called.\n     *\n     * @example #Determine if the entity has already had its tick method called\n     *     var tickAlreadyCalled = entity.newFrame();\n     * @return {Boolean} If false, the entity's tick method has\n     * not yet been processed for this tick.\n     */\n    newFrame() {\n        return _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._frameAlternator !== this._frameAlternatorCurrent;\n    }\n    /**\n     * Sets the canvas context transform properties to match the game\n     * object's current transform values.\n     * @param {CanvasRenderingContext2D} ctx The canvas context to apply\n     * the transformation matrix to.\n     * @param inverse\n     * @example #Transform a canvas context to the entity's local matrix values\n     *     var canvas = document.createElement('canvas');\n     *     canvas.width = 800;\n     *     canvas.height = 600;\n     *\n     *     var ctx = canvas.getContext('2d');\n     *     entity._transformContext(ctx);\n     * @private\n     */\n    _transformContext(ctx, inverse = false) {\n        var _a;\n        if (this._parent) {\n            ctx.globalAlpha = this._computedOpacity = this._parent._computedOpacity * this._opacity;\n        }\n        else {\n            ctx.globalAlpha = this._computedOpacity = this._opacity;\n        }\n        if (!inverse) {\n            this._localMatrix.transformRenderingContext(ctx);\n        }\n        else {\n            (_a = this._localMatrix.getInverse()) === null || _a === void 0 ? void 0 : _a.transformRenderingContext(ctx);\n        }\n    }\n    pointerAlwaysInside(val) {\n        if (val !== undefined) {\n            this._pointerAlwaysInside = val;\n            return this;\n        }\n        return this._pointerAlwaysInside;\n    }\n    /**\n     * Processes the actions required each render frame.\n     * @param {CanvasRenderingContext2D} ctx The canvas context to render to.\n     * @param {boolean} [dontTransform=false] If set to true, the tick method will\n     * not transform the context based on the entity's matrices. This is useful\n     * if you have extended the class and want to process down the inheritance\n     * chain but have already transformed the entity in a previous overloaded\n     * method.\n     */\n    tick(ctx, dontTransform = false) {\n        if (!(!this._hidden && this._inView && (!this._parent || this._parent._inView) && !this._streamJustCreated)) {\n            return;\n        }\n        this._processBehaviours(_enums__WEBPACK_IMPORTED_MODULE_12__.IgeBehaviourType.preTick, ctx);\n        // Check for cached version\n        if (this._cache || this._compositeCache) {\n            // Caching is enabled\n            if (this._cacheDirty) {\n                // The cache is dirty, redraw it\n                this._refreshCache(dontTransform);\n            }\n            // Now render the cached image data to the main canvas\n            this._renderCache(ctx);\n        }\n        else {\n            // Non-cached output\n            // Transform the context by the current transform settings\n            if (!dontTransform) {\n                this._transformContext(ctx);\n            }\n            // Render the entity\n            this._renderEntity(ctx);\n        }\n        // WEBGPU - Move to postTick?\n        // if (this._streamMode === IgeStreamMode.simple) {\n        // \tthis.streamSync();\n        // }\n        if (this._compositeCache) {\n            if (this._cacheDirty && this._cacheCtx) {\n                // Process children\n                super.tick(this._cacheCtx);\n                this._renderCache(ctx);\n                this._cacheDirty = false;\n            }\n        }\n        else {\n            // Process children\n            super.tick(ctx);\n        }\n    }\n    _processTriggerHitTests(mp) {\n        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentViewport) {\n            return false;\n        }\n        if (this._pointerAlwaysInside) {\n            return true;\n        }\n        if (!mp) {\n            mp = this.mousePosWorld();\n        }\n        let mouseTriggerPoly;\n        // Use the trigger polygon function if defined\n        if (this._triggerPolygonFunctionName && this[this._triggerPolygonFunctionName]) {\n            mouseTriggerPoly = this[this._triggerPolygonFunctionName]();\n        }\n        else {\n            // Default to either aabb or bounds3dPolygon depending on entity parent mounting mode\n            if (this._parent && this._parent._mountMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeMountMode.iso) {\n                // Use bounds3dPolygon\n                mouseTriggerPoly = this.bounds3dPolygon();\n            }\n            else {\n                // Use aabb\n                mouseTriggerPoly = this.aabb();\n            }\n        }\n        // Check if the current mouse position is inside this aabb\n        return mouseTriggerPoly.xyInside(mp.x, mp.y);\n    }\n    _refreshCache(dontTransform = false) {\n        // The cache is not clean so re-draw it\n        // Render the entity to the cache\n        const _canvas = this._cacheCanvas;\n        const _ctx = this._cacheCtx;\n        if (!_canvas || !_ctx) {\n            return;\n        }\n        if (this._compositeCache) {\n            // Get the composite entity AABB and alter the internal canvas\n            // to the composite size, so we can render the entire entity\n            const aabbC = this.compositeAabb();\n            this._compositeAabbCache = aabbC;\n            if (aabbC.width > 0 && aabbC.height > 0) {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._setInternalCanvasSize(_canvas, _ctx, aabbC.width, aabbC.height);\n                /*_canvas.width = Math.ceil(aabbC.width);\n                _canvas.height = Math.ceil(aabbC.height);*/\n            }\n            else {\n                // We cannot set a zero size for a canvas, it will\n                // cause the browser to freak out\n                _canvas.width = 2;\n                _canvas.height = 2;\n            }\n            // Translate to the center of the canvas\n            _ctx.translate(-aabbC.x, -aabbC.y);\n            /**\n             * Fires when the entity's composite cache is ready.\n             * @event IgeEntity#compositeReady\n             */\n            this.emit(\"compositeReady\");\n        }\n        else {\n            if (this._bounds2d.x > 0 && this._bounds2d.y > 0) {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._setInternalCanvasSize(_canvas, _ctx, this._bounds2d.x, this._bounds2d.y);\n                /*_canvas.width = this._bounds2d.x;\n                _canvas.height = this._bounds2d.y;*/\n            }\n            else {\n                // We cannot set a zero size for a canvas, it will\n                // cause the browser to freak out\n                _canvas.width = 1;\n                _canvas.height = 1;\n            }\n            // Translate to the center of the canvas\n            _ctx.translate(this._bounds2d.x2, this._bounds2d.y2);\n            this._cacheDirty = false;\n        }\n        // Transform the context by the current transform settings\n        if (!dontTransform) {\n            this._transformContext(_ctx);\n        }\n        this._renderEntity(_ctx);\n    }\n    /**\n     * Handles calling the texture.render() method if a texture\n     * is applied to the entity. This part of the tick process has\n     * been abstracted to allow it to be overridden by an extending\n     * class.\n     * @param {CanvasRenderingContext2D} ctx The canvas context to render\n     * the entity to.\n     * @private\n     */\n    _renderEntity(ctx) {\n        if (this._opacity <= 0 || !_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera || !_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentViewport) {\n            return;\n        }\n        if (this._backgroundPattern && this._backgroundPattern.image) {\n            if (!this._backgroundPatternFill) {\n                // We have a pattern but no fill produced\n                // from it. Check if we have a context to\n                // generate a pattern from\n                if (ctx) {\n                    // Produce the pattern fill\n                    this._backgroundPatternFill = ctx.createPattern(this._backgroundPattern.image, this._backgroundPatternRepeat);\n                }\n            }\n            if (this._backgroundPatternFill) {\n                // Draw the fill\n                ctx.save();\n                ctx.fillStyle = this._backgroundPatternFill;\n                if (this._smartBackground) {\n                    this._smartBackground.render(ctx, this);\n                }\n                else {\n                    // TODO: When firefox has fixed their bug regarding negative rect co-ordinates, revert this change\n                    // This is the proper way to do this but firefox has a bug which I'm going to report,\n                    // so instead I have to use ANOTHER translate call instead. So crap!\n                    //ctx.rect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);\n                    ctx.translate(-this._bounds2d.x2, -this._bounds2d.y2);\n                    ctx.rect(0, 0, this._bounds2d.x, this._bounds2d.y);\n                    if (this._backgroundPatternTrackCamera) {\n                        ctx.translate(-_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera._translate.x, -_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera._translate.y);\n                        ctx.scale(_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera._scale.x, _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera._scale.y);\n                    }\n                    ctx.fill();\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.metrics.drawCount++;\n                    if (this._backgroundPatternIsoTile) {\n                        ctx.translate(-Math.floor(this._backgroundPattern.image.width) / 2, -Math.floor(this._backgroundPattern.image.height / 2));\n                        ctx.fill();\n                        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.metrics.drawCount++;\n                    }\n                }\n                ctx.restore();\n            }\n        }\n        const texture = this._texture;\n        if (texture && texture._loaded) {\n            if (this._textureOffset) {\n                ctx.translate(this._textureOffset.x, this._textureOffset.y);\n            }\n            // Draw the entity image\n            texture.render(ctx, this);\n            if (this._highlight) {\n                ctx.save();\n                ctx.globalCompositeOperation = this._highlightToGlobalCompositeOperation(this._highlight);\n                texture.render(ctx, this);\n                ctx.restore();\n            }\n        }\n        if (this._compositeCache && _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentViewport._drawCompositeBounds) {\n            //console.log('moo');\n            ctx.fillStyle = \"rgba(0, 0, 255, 0.3)\";\n            ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.fillText(\"Composite Entity\", -this._bounds2d.x2, -this._bounds2d.y2 - 15);\n            ctx.fillText(this.id(), -this._bounds2d.x2, -this._bounds2d.y2 - 5);\n        }\n    }\n    /**\n     * Draws the cached off-screen canvas image data to the passed canvas\n     * context.\n     * @param {CanvasRenderingContext2D} ctx The canvas context to render\n     * the entity to.\n     * @private\n     */\n    _renderCache(ctx) {\n        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentViewport)\n            return;\n        if (!this._cacheCanvas || this._cacheCanvas instanceof _engine_core_IgeDummyCanvas__WEBPACK_IMPORTED_MODULE_1__.IgeDummyCanvas)\n            return;\n        ctx.save();\n        if (this._compositeCache && this._compositeAabbCache) {\n            const aabbC = this._compositeAabbCache;\n            ctx.translate(this._bounds2d.x2 + aabbC.x, this._bounds2d.y2 + aabbC.y);\n            if (this._parent && this._parent._ignoreCamera) {\n                // Translate the entity back to negate the scene translate\n                const cam = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera;\n                //ctx.translate(-cam._translate.x, -cam._translate.y);\n                /*this.scaleTo(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);\n                this.rotateTo(-cam._rotate.x, -cam._rotate.y, -cam._rotate.z);*/\n            }\n        }\n        // We have a clean cached version so output that. We use the destination width and height\n        // here because the cache canvas might not be the destination size and should be scaled\n        // as it is rendered (usually because of device pixel ratio related stuff)\n        ctx.drawImage(this._cacheCanvas, -this._bounds2d.x2, -this._bounds2d.y2);\n        //, this._bounds2d.x, this._bounds2d.y);\n        if (_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentViewport._drawCompositeBounds) {\n            ctx.fillStyle = \"rgba(0, 255, 0, 0.5)\";\n            ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._cacheCanvas.width, this._cacheCanvas.height);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.fillText(\"Composite Cache\", -this._bounds2d.x2, -this._bounds2d.y2 - 15);\n            ctx.fillText(this.id(), -this._bounds2d.x2, -this._bounds2d.y2 - 5);\n        }\n        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.metrics.drawCount++;\n        ctx.restore();\n    }\n    /**\n     * Helper method to transform an array of points using _transformPoint.\n     * @param {Array} points The points array to transform.\n     * @private\n     */\n    _transformPoints(points) {\n        let point, pointCount = points.length;\n        while (pointCount--) {\n            point = points[pointCount];\n            if (this._parent) {\n                const tempMat = new _engine_core_IgeMatrix2d__WEBPACK_IMPORTED_MODULE_2__.IgeMatrix2d();\n                // Copy the parent world matrix\n                tempMat.copy(this._parent._worldMatrix);\n                // Apply any local transforms\n                tempMat.multiply(this._localMatrix);\n                // Now transform the point\n                tempMat.getInverse().transformCoord(point, this);\n            }\n            else {\n                this._localMatrix.transformCoord(point, this);\n            }\n        }\n    }\n    /**\n     * Generates a string containing a code fragment that when\n     * evaluated will reproduce this object's properties via\n     * chained commands. This method will only check for\n     * properties that are directly related to this class.\n     * Other properties are handled by their own class method.\n     * @return {String} The string code fragment that will\n     * reproduce this entity when evaluated.\n     */\n    stringify(options) {\n        // Make sure we have an options object\n        if (options === undefined) {\n            options = {};\n        }\n        // Get the properties for all the super-classes\n        let str = \"\";\n        // Loop properties and add property assignment code to string\n        for (const i in this) {\n            if (this.hasOwnProperty(i) && this[i] !== undefined) {\n                switch (i) {\n                    case \"_opacity\":\n                        str += `.opacity(${this.opacity()})`;\n                        break;\n                    case \"_texture\":\n                        const tmpTexture = this.texture();\n                        if (tmpTexture) {\n                            str += `.texture(ige.$('${tmpTexture.id()}'))`;\n                        }\n                        break;\n                    case \"_cell\":\n                        str += \".cell(\" + this.cell() + \")\";\n                        break;\n                    case \"_translate\":\n                        if (options.transform && options.translate) {\n                            str += `.translateTo(${this._translate.x}, ${this._translate.y}, ${this._translate.z})`;\n                        }\n                        break;\n                    case \"_rotate\":\n                        if (options.transform && options.rotate) {\n                            str += `.rotateTo(${this._rotate.x}, ${this._rotate.y}, ${this._rotate.z})`;\n                        }\n                        break;\n                    case \"_scale\":\n                        if (options.transform && options.scale) {\n                            str += `.scaleTo(${this._scale.x}, ${this._scale.y}, ${this._scale.z})`;\n                        }\n                        break;\n                    case \"_origin\":\n                        if (options.origin) {\n                            str += `.originTo(${this._origin.x}, ${this._origin.y}, ${this._origin.z})`;\n                        }\n                        break;\n                    case \"_anchor\":\n                        if (options.anchor) {\n                            str += `.anchor(${this._anchor.x}, ${this._anchor.y})`;\n                        }\n                        break;\n                    case \"_width\":\n                        if (typeof this.width() === \"string\") {\n                            str += `.width('${this.width()}')`;\n                        }\n                        else {\n                            str += `.width(${this.width()})`;\n                        }\n                        break;\n                    case \"_height\":\n                        if (typeof this.height() === \"string\") {\n                            str += `.height('${this.height()}')`;\n                        }\n                        else {\n                            str += `.height(${this.height()})`;\n                        }\n                        break;\n                    case \"_bounds3d\":\n                        str += `.bounds3d(${this._bounds3d.x}, ${this._bounds3d.y}, ${this._bounds3d.z})`;\n                        break;\n                    case \"_deathTime\":\n                        if (options.deathTime && options.lifeSpan) {\n                            str += `.deathTime(${this.deathTime()})`;\n                        }\n                        break;\n                    case \"_highlight\":\n                        str += `.highlight(${this.highlight()})`;\n                        break;\n                    case \"_renderMode\":\n                        str += \".mode(\" + this._renderMode + \")\";\n                        break;\n                }\n            }\n        }\n        return str;\n    }\n    isometric(val) {\n        if (val !== undefined) {\n            // TODO: When setting to true, do we also want to automatically set\n            //  the triggerPolygonFunctionName to \"bounds3dPolygon\" ?\n            this._renderMode = val ? _enums__WEBPACK_IMPORTED_MODULE_12__.IgeEntityRenderMode.iso : _enums__WEBPACK_IMPORTED_MODULE_12__.IgeEntityRenderMode.flat;\n            return this;\n        }\n        return this._renderMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeEntityRenderMode.iso;\n    }\n    /**\n     * Destroys the entity by removing it from the scenegraph,\n     * calling destroy() on any child entities and removing\n     * any active event listeners for the entity. Once an entity\n     * has been destroyed it's this._alive flag is also set to\n     * false.\n     * @example #Destroy the entity\n     *     entity.destroy();\n     */\n    destroy() {\n        this._alive = false;\n        // Check if the entity is streaming\n        if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_8__.isServer && this._streamMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeStreamMode.simple) {\n            this._streamDataCache = \"\";\n            this.streamDestroy();\n        }\n        /**\n         * Fires when the entity has been destroyed.\n         * @event IgeEntity#destroyed\n         * @param {IgeEntity} The entity that has been destroyed.\n         */\n        this.emit(\"destroyed\", this);\n        // Remove ourselves from any parent\n        this.unMount();\n        // Remove any children\n        if (this._children) {\n            this.destroyChildren();\n        }\n        // Remove the object from the lookup system\n        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.register.remove(this);\n        // Set a flag in case a reference to this object\n        // has been held somewhere, shows that the object\n        // should no longer be interacted with\n        this._alive = false;\n        // Remove the event listeners array in case any\n        // object references still exist there\n        this._eventListeners = {};\n        return super.destroy();\n    }\n    /**\n     * Sorts the _children array by the layer and then depth of each object.\n     */\n    depthSortChildren() {\n        if (this._depthSortMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeIsometricDepthSortMode.none) {\n            return;\n        }\n        if (this._mountMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeMountMode.flat) {\n            // The mount mode for this entity is a 2d plane or \"flat\" mode, so we don't have any\n            // isometric rendering to deal with and as such, just called the IgeObject version\n            // of this method because IgeObject as a base class has no understanding of isometric\n            // mounting since IgeObject instances don't actually render anything. This will use\n            // the layer and depth of each object to sort against each other.\n            return super.depthSortChildren();\n        }\n        const arr = this._children;\n        let arrCount = arr.length;\n        if (!arr || !arrCount) {\n            return;\n        }\n        if (this._depthSortMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeIsometricDepthSortMode.bounds3d) {\n            // Slowest, uses 3d bounds\n            // Calculate depths from 3d bounds\n            const sortObj = {\n                adj: [],\n                c: [],\n                p: [],\n                order: [],\n                order_ind: arrCount - 1\n            };\n            for (let i = 0; i < arrCount; ++i) {\n                const childItemA = arr[i];\n                sortObj.c[i] = 0;\n                sortObj.p[i] = -1;\n                sortObj.adj[i] = sortObj.adj[i] || [];\n                for (let j = i + 1; j < arrCount; ++j) {\n                    const childItemB = arr[j];\n                    sortObj.adj[j] = sortObj.adj[j] || [];\n                    if (childItemA._inView &&\n                        childItemB._inView &&\n                        \"_projectionOverlap\" in childItemA &&\n                        \"_projectionOverlap\" in childItemB) {\n                        if (childItemA._projectionOverlap(childItemB)) {\n                            if (childItemA.isBehind(childItemB)) {\n                                sortObj.adj[j].push(i);\n                            }\n                            else {\n                                sortObj.adj[i].push(j);\n                            }\n                        }\n                    }\n                }\n            }\n            for (let i = 0; i < arrCount; ++i) {\n                if (sortObj.c[i] !== 0) {\n                    continue;\n                }\n                this._depthSortVisit(i, sortObj);\n            }\n            for (let i = 0; i < sortObj.order.length; i++) {\n                arr[sortObj.order[i]].depth(i);\n            }\n            this._sortChildren((a, b) => {\n                const layerIndex = b._layer - a._layer;\n                if (layerIndex === 0) {\n                    // On same layer so sort by depth\n                    return b._depth - a._depth;\n                }\n                else {\n                    // Not on same layer so sort by layer\n                    return layerIndex;\n                }\n            });\n        }\n        if (this._depthSortMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeIsometricDepthSortMode.cuboid) {\n            // Medium speed, optimised for almost-cube shaped 3d bounds\n            // Now sort the entities by depth\n            this._sortChildren((a, b) => {\n                const layerIndex = b._layer - a._layer;\n                if (layerIndex === 0) {\n                    // On same layer so sort by depth\n                    //if (a._projectionOverlap(b)) {\n                    if (a.isBehind(b)) {\n                        return -1;\n                    }\n                    else {\n                        return 1;\n                    }\n                    //}\n                }\n                else {\n                    // Not on same layer so sort by layer\n                    return layerIndex;\n                }\n            });\n        }\n        if (this._depthSortMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeIsometricDepthSortMode.cube) {\n            // Fastest, optimised for cube-shaped 3d bounds\n            while (arrCount--) {\n                const sortObj = arr[arrCount];\n                const j = sortObj._translate;\n                if (!j) {\n                    continue;\n                }\n                sortObj._depth = j.x + j.y + j.z;\n            }\n            // Now sort the entities by depth\n            this._sortChildren((a, b) => {\n                const layerIndex = b._layer - a._layer;\n                if (layerIndex === 0) {\n                    // On same layer so sort by depth\n                    return b._depth - a._depth;\n                }\n                else {\n                    // Not on same layer so sort by layer\n                    return layerIndex;\n                }\n            });\n        }\n    }\n    pointerMove(callback) {\n        if (callback !== undefined) {\n            if (callback === null) {\n                this._pointerMove = undefined;\n            }\n            else {\n                this._pointerMove = callback;\n            }\n            this._pointerEventsActive = true;\n            return this;\n        }\n        return this._pointerMove;\n    }\n    pointerOver(callback) {\n        if (callback !== undefined) {\n            if (callback === null) {\n                this._pointerOver = undefined;\n            }\n            else {\n                this._pointerOver = callback;\n            }\n            this._pointerEventsActive = true;\n            return this;\n        }\n        return this._pointerOver;\n    }\n    pointerOut(callback) {\n        if (callback !== undefined) {\n            if (callback === null) {\n                this._pointerOut = undefined;\n            }\n            else {\n                this._pointerOut = callback;\n            }\n            this._pointerEventsActive = true;\n            return this;\n        }\n        return this._pointerOut;\n    }\n    pointerUp(callback) {\n        if (callback !== undefined) {\n            if (callback === null) {\n                this._pointerUp = undefined;\n            }\n            else {\n                this._pointerUp = callback;\n            }\n            this._pointerEventsActive = true;\n            return this;\n        }\n        return this._pointerUp;\n    }\n    pointerDown(callback) {\n        if (callback !== undefined) {\n            if (callback === null) {\n                this._pointerDown = undefined;\n            }\n            else {\n                this._pointerDown = callback;\n            }\n            this._pointerEventsActive = true;\n            return this;\n        }\n        return this._pointerDown;\n    }\n    pointerWheel(callback) {\n        if (callback !== undefined) {\n            if (callback === null) {\n                this._pointerWheel = undefined;\n            }\n            else {\n                this._pointerWheel = callback;\n            }\n            this._pointerEventsActive = true;\n            return this;\n        }\n        return this._pointerWheel;\n    }\n    /**\n     * Removes the callback that is fired when a mouse\n     * move event is triggered.\n     */\n    pointerMoveOff() {\n        delete this._pointerMove;\n        return this;\n    }\n    /**\n     * Removes the callback that is fired when a mouse\n     * over event is triggered.\n     */\n    pointerOverOff() {\n        delete this._pointerOver;\n        return this;\n    }\n    /**\n     * Removes the callback that is fired when a mouse\n     * out event is triggered.\n     */\n    pointerOutOff() {\n        delete this._pointerOut;\n        return this;\n    }\n    /**\n     * Removes the callback that is fired when a mouse\n     * up event is triggered.\n     */\n    pointerUpOff() {\n        delete this._pointerUp;\n        return this;\n    }\n    /**\n     * Removes the callback that is fired when a mouse\n     * down event is triggered if the listener was registered\n     * via the pointerDown() method.\n     */\n    pointerDownOff() {\n        delete this._pointerDown;\n        return this;\n    }\n    /**\n     * Removes the callback that is fired when a mouse\n     * wheel event is triggered.\n     */\n    pointerWheelOff() {\n        delete this._pointerWheel;\n        return this;\n    }\n    triggerPolygonFunctionName(funcName) {\n        if (funcName !== undefined) {\n            this._triggerPolygonFunctionName = funcName;\n            return this;\n        }\n        return this._triggerPolygonFunctionName;\n    }\n    /**\n     * Will return the polygon used when determining if a pointer event occurs\n     * on this entity.\n     */\n    triggerPolygon() {\n        return this[this._triggerPolygonFunctionName]();\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // TRANSFORM\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    /**\n     * Enables tracing calls which inadvertently assign NaN values to\n     * transformation properties. When called on an entity this system\n     * will break with a debug line when a transform property is set\n     * to NaN allowing you to step back through the call stack and\n     * determine where the offending value originated.\n     * @returns {IgeEntity}\n     */\n    debugTransforms() {\n        this.log(\"Debug transforms enabled\");\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._translate, \"x\", 1, (val) => {\n            return isNaN(val);\n        });\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._translate, \"y\", 1, (val) => {\n            return isNaN(val);\n        });\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._translate, \"z\", 1, (val) => {\n            return isNaN(val);\n        });\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._rotate, \"x\", 1, (val) => {\n            return isNaN(val);\n        });\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._rotate, \"y\", 1, (val) => {\n            return isNaN(val);\n        });\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._rotate, \"z\", 1, (val) => {\n            return isNaN(val);\n        });\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._scale, \"x\", 1, (val) => {\n            return isNaN(val);\n        });\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._scale, \"y\", 1, (val) => {\n            return isNaN(val);\n        });\n        (0,_engine_utils_trace__WEBPACK_IMPORTED_MODULE_11__.traceSet)(this._scale, \"z\", 1, (val) => {\n            return isNaN(val);\n        });\n        return this;\n    }\n    velocityTo(x, y, z) {\n        if (x !== undefined && y !== undefined && z !== undefined) {\n            this._velocity.x = x;\n            this._velocity.y = y;\n            this._velocity.z = z;\n        }\n        else {\n            this.log(\"velocityTo() called with a missing or undefined x, y or z parameter!\", \"error\");\n        }\n        return this; // Used to include this._entity\n    }\n    velocityBy(x, y, z) {\n        if (x !== undefined && y !== undefined && z !== undefined) {\n            this._velocity.x += x;\n            this._velocity.y += y;\n            this._velocity.z += z;\n        }\n        else {\n            this.log(\"velocityBy() called with a missing or undefined x, y or z parameter!\", \"error\");\n        }\n        return this; // Used to include this._entity\n    }\n    /**\n     * Translates the entity to the passed point.\n     * @param {IgePoint3d} point The point with co-ordinates.\n     * @example #Translate the entity to 10, 0, 0\n     *     var point = new IgePoint3d(10, 0, 0),\n     *         entity = new IgeEntity();\n     *\n     *     entity.translateToPoint(point);\n     * @return {*}\n     */\n    translateToPoint(point) {\n        if (point !== undefined) {\n            this._translate.x = point.x;\n            this._translate.y = point.y;\n            this._translate.z = point.z;\n        }\n        else {\n            this.log(\"translateToPoint() called with a missing or undefined point parameter!\", \"error\");\n        }\n        return this; // Used to include this._entity\n    }\n    /**\n     * Translates the object to the tile co-ordinates passed.\n     * @param {number} x The x tile co-ordinate.\n     * @param {number} y The y tile co-ordinate.\n     * @param {number=} z The z tile co-ordinate.\n     * @example #Translate entity to tile\n     *     // Create a tile map\n     *     var tileMap = new IgeTileMap2d()\n     *         .tileWidth(40)\n     *         .tileHeight(40);\n     *\n     *     // Mount our entity to the tile map\n     *     entity.mount(tileMap);\n     *\n     *     // Translate the entity to the tile x:10, y:12\n     *     entity.translateToTile(10, 12, 0);\n     * @return {*} The object this method was called from to allow\n     * method chaining.\n     */\n    translateToTile(x, y, z = 0) {\n        if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {\n            let finalZ;\n            // Handle being passed a z co-ordinate\n            if (z !== undefined) {\n                finalZ = z * this._parent._tileDepth;\n            }\n            else {\n                finalZ = this._translate.z;\n            }\n            this.translateTo(x * this._parent._tileWidth + this._parent._tileWidth / 2, y * this._parent._tileHeight + this._parent._tileHeight / 2, finalZ);\n        }\n        else {\n            this.log(\"Cannot translate to tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.\", \"warning\");\n        }\n        return this;\n    }\n    tileX() {\n        if (this._parent && this._parent._tileWidth !== undefined) {\n            return Math.floor(this._translate.x / this._parent._tileWidth);\n        }\n    }\n    tileY() {\n        if (this._parent && this._parent._tileHeight !== undefined) {\n            return Math.floor(this._translate.y / this._parent._tileHeight);\n        }\n    }\n    tileZ(val) {\n        if (this._parent && val !== undefined) {\n            this._translate.z = val * this._parent._tileDepth;\n            return this;\n        }\n        if (this._parent && this._parent._tileDepth !== undefined) {\n            return this._translate.z / this._parent._tileDepth;\n        }\n    }\n    /**\n     * Gets the `translate` accessor object.\n     * @example #Use the `translate` accessor object to alter the y co-ordinate of the entity to 10\n     *     entity.translate().y(10);\n     * @return {*}\n     */\n    translate(...args) {\n        if (args.length) {\n            throw new Error(\"You called translate with arguments, did you mean translateTo or translateBy instead of translate?\");\n        }\n        // used to be this._entity || { x, y z }\n        return {\n            x: this._translateAccessorX,\n            y: this._translateAccessorY,\n            z: this._translateAccessorZ\n        };\n    }\n    _translateAccessorX(val) {\n        if (val !== undefined) {\n            this._translate.x = val;\n            return this; // Used to include this._entity\n        }\n        return this._translate.x;\n    }\n    _translateAccessorY(val) {\n        if (val !== undefined) {\n            this._translate.y = val;\n            return this; // Used to include this._entity\n        }\n        return this._translate.y;\n    }\n    _translateAccessorZ(val) {\n        // TODO: Do we need to do anything to the matrix here for iso views?\n        //this._localMatrix.translateTo(this._translate.x, this._translate.y);\n        if (val !== undefined) {\n            this._translate.z = val;\n            return this; // Used to include this._entity\n        }\n        return this._translate.z;\n    }\n    /**\n     * Gets the `translate` accessor object.\n     * @example #Use the `rotate` accessor object to rotate the entity about the z-axis 10 degrees\n     *     entity.rotate().z(degreesToRadians(10));\n     * @return {*}\n     */\n    rotate(...args) {\n        if (args.length) {\n            throw new Error(\"You called rotate with arguments, did you mean rotateTo or rotateBy instead of rotate?\");\n        }\n        // used to be this._entity || { x, y z }\n        return {\n            x: this._rotateAccessorX,\n            y: this._rotateAccessorY,\n            z: this._rotateAccessorZ\n        };\n    }\n    _rotateAccessorX(val) {\n        if (val !== undefined) {\n            this._rotate.x = val;\n            return this; // Used to include this._entity\n        }\n        return this._rotate.x;\n    }\n    _rotateAccessorY(val) {\n        if (val !== undefined) {\n            this._rotate.y = val;\n            return this; // Used to include this._entity\n        }\n        return this._rotate.y;\n    }\n    _rotateAccessorZ(val) {\n        if (val !== undefined) {\n            this._rotate.z = val;\n            return this; // Used to include this._entity\n        }\n        return this._rotate.z;\n    }\n    /**\n     * Gets the `scale` accessor object.\n     * @example #Use the scale accessor object to set the scale of the entity on the x axis to 1\n     *     entity.scale().x(1);\n     * @return {*}\n     */\n    scale(...args) {\n        if (args.length) {\n            throw new Error(\"You called scale with arguments, did you mean scaleTo or scaleBy instead of scale?\");\n        }\n        // used to be this._entity || { x, y z }\n        return {\n            x: this._scaleAccessorX,\n            y: this._scaleAccessorY,\n            z: this._scaleAccessorZ\n        };\n    }\n    _scaleAccessorX(val) {\n        if (val !== undefined) {\n            this._scale.x = val;\n            return this; // Used to include this._entity\n        }\n        return this._scale.x;\n    }\n    _scaleAccessorY(val) {\n        if (val !== undefined) {\n            this._scale.y = val;\n            return this; // Used to include this._entity\n        }\n        return this._scale.y;\n    }\n    _scaleAccessorZ(val) {\n        if (val !== undefined) {\n            this._scale.z = val;\n            return this; // Used to include this._entity\n        }\n        return this._scale.z;\n    }\n    /**\n     * Sets the `origin` of the entity by adding the passed values to\n     * the current origin values.\n     * @param {number} x The x co-ordinate.\n     * @param {number} y The y co-ordinate.\n     * @param {number} z The z co-ordinate.\n     * @example #Add 0.5 to the origin on the x-axis\n     *     entity.originBy(0.5, 0, 0);\n     * @return {*}\n     */\n    originBy(x, y, z) {\n        if (x !== undefined && y !== undefined && z !== undefined) {\n            this._origin.x += x;\n            this._origin.y += y;\n            this._origin.z += z;\n        }\n        else {\n            this.log(\"originBy() called with a missing or undefined x, y or z parameter!\", \"error\");\n        }\n        return this; // Used to include this._entity\n    }\n    /**\n     * Set the `origin` of the entity to the passed values.\n     * @param {number} x The x co-ordinate.\n     * @param {number} y The y co-ordinate.\n     * @param {number} z The z co-ordinate.\n     * @example #Set the entity origin to 0.5 on all axes\n     *     entity.originTo(0.5, 0.5, 0.5);\n     * @return {*}\n     */\n    originTo(x, y, z) {\n        if (x !== undefined && y !== undefined && z !== undefined) {\n            this._origin.x = x;\n            this._origin.y = y;\n            this._origin.z = z;\n        }\n        else {\n            this.log(\"originTo() called with a missing or undefined x, y or z parameter!\", \"error\");\n        }\n        return this; // Used to include this._entity\n    }\n    /**\n     * Gets the `origin` accessor object.\n     * @example #Use the origin accessor object to set the origin of the entity on the x-axis to 1\n     *     entity.origin().x(1);\n     * @return {*}\n     */\n    origin() {\n        // used to be this._entity || { x, y z }\n        return {\n            x: this._originAccessorX,\n            y: this._originAccessorY,\n            z: this._originAccessorZ\n        };\n    }\n    _originAccessorX(val) {\n        if (val !== undefined) {\n            this._origin.x = val;\n            return this; // Used to include this._entity\n        }\n        return this._origin.x;\n    }\n    _originAccessorY(val) {\n        if (val !== undefined) {\n            this._origin.y = val;\n            return this; // Used to include this._entity\n        }\n        return this._origin.y;\n    }\n    _originAccessorZ(val) {\n        if (val !== undefined) {\n            this._origin.z = val;\n            return this; // Used to include this._entity\n        }\n        return this._origin.z;\n    }\n    _rotatePoint(point, radians, origin) {\n        const cosAngle = Math.cos(radians), sinAngle = Math.sin(radians);\n        return {\n            x: origin.x + (point.x - origin.x) * cosAngle + (point.y - origin.y) * sinAngle,\n            y: origin.y - (point.x - origin.x) * sinAngle + (point.y - origin.y) * cosAngle\n        };\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // INTERPOLATOR\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    /**\n     * Calculates the current value based on the time along the\n     * value range.\n     * @param {number} startValue The value that the interpolation started from.\n     * @param {number} endValue The target value to be interpolated to.\n     * @param {number} startTime The time the interpolation started.\n     * @param {number} currentTime The current time.\n     * @param {number} endTime The time the interpolation will end.\n     * @return {number} The interpolated value.\n     */\n    interpolateValue(startValue, endValue, startTime, currentTime, endTime) {\n        const totalValue = endValue - startValue;\n        const dataDelta = endTime - startTime;\n        const offsetDelta = currentTime - startTime;\n        let deltaTime = offsetDelta / dataDelta;\n        // Clamp the current time from 0 to 1\n        if (deltaTime < 0) {\n            deltaTime = 0;\n        }\n        else if (deltaTime > 1) {\n            deltaTime = 1;\n        }\n        return totalValue * deltaTime + startValue;\n    }\n    /**\n     * Processes the time stream for the entity.\n     * @param {number} renderTime The time that the time stream is\n     * targeting to render the entity at.\n     * @param {number} maxLerp The maximum lerp before the value\n     * is assigned directly instead of being interpolated.\n     * @private\n     */\n    _processInterpolate(renderTime, maxLerp = 200) {\n        // Set the maximum lerp to 200 if none is present\n        if (!maxLerp) {\n            maxLerp = 200;\n        }\n        //const maxLerpSquared = maxLerp * maxLerp;\n        const timeStream = this._timeStream;\n        const currentTransform = [];\n        let previousData, nextData, dataDelta, offsetDelta, currentTime, previousTransform, nextTransform, i = 1;\n        // Find the point in the time stream that is\n        // closest to the render time and assign the\n        // previous and next data points\n        while (timeStream[i]) {\n            if (timeStream[i][0] > renderTime) {\n                // We have previous and next data points from the\n                // time stream so store them\n                previousData = timeStream[i - 1];\n                nextData = timeStream[i];\n                break;\n            }\n            i++;\n        }\n        // Check if we have some data to use\n        if (!nextData && !previousData) {\n            // No in-time data was found, check for lagging data\n            if (timeStream.length > 2) {\n                if (timeStream[timeStream.length - 1][0] < renderTime) {\n                    // Lagging data is available, use that\n                    previousData = timeStream[timeStream.length - 2];\n                    nextData = timeStream[timeStream.length - 1];\n                    timeStream.shift();\n                    /**\n                     * Fires when the entity interpolates against old data, usually\n                     * the result of slow processing on the client or too much data\n                     * being sent from the server.\n                     * @event IgeEntity#interpolationLag\n                     */\n                    this.emit(\"interpolationLag\");\n                }\n            }\n        }\n        else {\n            // TODO: Shouldn't we do this if we find old data as well? e.g. timeStream.length > 2\n            // We have some new data so clear the old data\n            timeStream.splice(0, i - 1);\n        }\n        // If we have data to use\n        if (nextData && previousData) {\n            // Check if the previous data has a timestamp and if not,\n            // use the next data's timestamp\n            if (isNaN(previousData[0])) {\n                previousData[0] = nextData[0];\n            }\n            // Store the data so outside systems can access them\n            this._timeStreamPreviousData = previousData;\n            this._timeStreamNextData = nextData;\n            // Calculate the delta times\n            dataDelta = nextData[0] - previousData[0];\n            offsetDelta = renderTime - previousData[0];\n            this._timeStreamDataDelta = Math.floor(dataDelta);\n            this._timeStreamOffsetDelta = Math.floor(offsetDelta);\n            // Calculate the current time between the two data points\n            currentTime = offsetDelta / dataDelta;\n            this._timeStreamCurrentInterpolateTime = currentTime;\n            // Clamp the current time from 0 to 1\n            //if (currentTime < 0) { currentTime = 0.0; } else if (currentTime > 1) { currentTime = 1.0; }\n            // Set variables up to store the previous and next data\n            previousTransform = previousData[1].map(parseFloat);\n            nextTransform = nextData[1].map(parseFloat);\n            // Translate\n            currentTransform[0] = this.interpolateValue(previousTransform[0], nextTransform[0], previousData[0], renderTime, nextData[0]);\n            currentTransform[1] = this.interpolateValue(previousTransform[1], nextTransform[1], previousData[0], renderTime, nextData[0]);\n            currentTransform[2] = this.interpolateValue(previousTransform[2], nextTransform[2], previousData[0], renderTime, nextData[0]);\n            // Scale\n            currentTransform[3] = this.interpolateValue(previousTransform[3], nextTransform[3], previousData[0], renderTime, nextData[0]);\n            currentTransform[4] = this.interpolateValue(previousTransform[4], nextTransform[4], previousData[0], renderTime, nextData[0]);\n            currentTransform[5] = this.interpolateValue(previousTransform[5], nextTransform[5], previousData[0], renderTime, nextData[0]);\n            // Rotate\n            currentTransform[6] = this.interpolateValue(previousTransform[6], nextTransform[6], previousData[0], renderTime, nextData[0]);\n            currentTransform[7] = this.interpolateValue(previousTransform[7], nextTransform[7], previousData[0], renderTime, nextData[0]);\n            currentTransform[8] = this.interpolateValue(previousTransform[8], nextTransform[8], previousData[0], renderTime, nextData[0]);\n            this.translateTo(currentTransform[0], currentTransform[1], currentTransform[2]);\n            this.scaleTo(currentTransform[3], currentTransform[4], currentTransform[5]);\n            this.rotateTo(currentTransform[6], currentTransform[7], currentTransform[8]);\n            // Record the last time we updated the entity, so we can disregard any updates\n            // that arrive and are before this timestamp (not applicable in TCP but will\n            // apply if we ever get UDP in websockets)\n            this._lastUpdate = new Date().getTime();\n        }\n    }\n    _highlightToGlobalCompositeOperation(val) {\n        if (val) {\n            return \"lighter\";\n        }\n    }\n    /**\n     * Processes the updates required each render frame. Any code in the update()\n     * method will be called ONCE for each render frame BEFORE the tick() method.\n     * This differs from the tick() method in that the tick method can be called\n     * multiple times during a render frame depending on how many viewports your\n     * simulation is being rendered to, whereas the update() method is only called\n     * once. It is therefore the perfect place to put code that will control your\n     * entity's motion, AI etc.\n     * @param {number} tickDelta The delta between the last tick time and this one.\n     */\n    update(tickDelta) {\n        var _a;\n        // Check if the entity should still exist\n        if (this._deathTime !== undefined && this._deathTime <= _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._tickStart) {\n            // Check if the deathCallBack was set\n            if (this._deathCallBack) {\n                this._deathCallBack.apply(this);\n                delete this._deathCallBack;\n            }\n            // The entity should be removed because it has died\n            this.destroy();\n            return;\n        }\n        // Check that the entity has been born\n        if (_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime >= this._bornTime) {\n            // Remove the stream data cache\n            this._streamDataCache = \"\";\n            // Process any behaviours assigned to the entity\n            this._processBehaviours(_enums__WEBPACK_IMPORTED_MODULE_12__.IgeBehaviourType.preUpdate, tickDelta);\n            // Process velocity\n            if (this._velocity.x || this._velocity.y) {\n                this._translate.x += (this._velocity.x / 16) * tickDelta;\n                this._translate.y += (this._velocity.y / 16) * tickDelta;\n            }\n            if (this._timeStream.length) {\n                // Process any interpolation\n                this._processInterpolate(_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._tickStart - _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network._renderLatency);\n            }\n            // Check for changes to the transform values\n            // directly without calling the transform methods\n            this.updateTransform();\n            if (!this._noAabb && this._aabbDirty) {\n                // Update the aabb\n                this.aabb();\n            }\n            this._oldTranslate = this._translate.clone();\n            // Update this object's current frame alternator value\n            // which allows us to determine if we are still on the\n            // same frame\n            this._frameAlternatorCurrent = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._frameAlternator;\n            if (this._streamMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeStreamMode.simple) {\n                this.streamSync();\n            }\n        }\n        else {\n            // The entity is not yet born, unmount it and add to the spawn queue\n            this._birthMount = (_a = this._parent) === null || _a === void 0 ? void 0 : _a.id();\n            this.unMount();\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine.spawnQueue(this);\n        }\n        // Process super class\n        super.update(tickDelta);\n        // TODO: This could be a behaviour instead to enable\n        //   customisation of the flow\n        if (this._pointerEventsActive) {\n            const input = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.input;\n            if (this._processTriggerHitTests()) {\n                // Point is inside the trigger bounds\n                input.queueEvent(this._mouseInTrigger, null);\n            }\n            else {\n                if (input.pointerMove) {\n                    // There is a mouse move event, but we are not inside the entity\n                    // so fire a mouse out event (_handleMouseOut will check if the\n                    // mouse WAS inside before firing an out event).\n                    this._handleMouseOut(input.pointerMove);\n                }\n            }\n        }\n    }\n    /**\n     * Gets / sets the data for the specified data section id. This method\n     * is usually not called directly and instead is part of the network\n     * stream system. General use case is to write your own custom streamSectionData\n     * method in a class that extends IgeEntity so that you can control the\n     * data that the entity will send and receive over the network stream.\n     * @param {String} sectionId A string identifying the section to\n     * handle data get / set for.\n     * @param {*=} data If present, this is the data that has been sent\n     * from the server to the client for this entity. If not present then\n     * we should return the data to be sent over the network.\n     * @param {Boolean=} bypassTimeStream If true, will assign transform\n     * directly to entity instead of adding the values to the time stream.\n     * @param {Boolean=} bypassChangeDetection If set to true, bypasses\n     * any change detection on stream data (useful especially when we are\n     * sending stream data to a client for the first time even if the data\n     * has existed on the server for a while - ensuring that even unchanged\n     * data makes it to the new client).\n     * @return {*} \"this\" when a data argument is passed to allow method\n     * chaining or the current value if no data argument is specified.\n     */\n    streamSectionData(sectionId, data, bypassTimeStream = false, bypassChangeDetection = false) {\n        switch (sectionId) {\n            case \"bounds2d\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_8__.isClient) {\n                        const geom = data.split(\",\");\n                        this.bounds2d(parseFloat(geom[0]), parseFloat(geom[1]));\n                    }\n                }\n                else {\n                    return String(this._bounds2d.x + \",\" + this._bounds2d.y);\n                }\n                break;\n            case \"bounds3d\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_8__.isClient) {\n                        const geom = data.split(\",\");\n                        this.bounds3d(parseFloat(geom[0]), parseFloat(geom[1]), parseFloat(geom[2]));\n                    }\n                }\n                else {\n                    return String(this._bounds3d.x + \",\" + this._bounds3d.y + \",\" + this._bounds3d.z);\n                }\n                break;\n            case \"hidden\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_8__.isClient) {\n                        if (data === \"true\") {\n                            this.hide();\n                        }\n                        else {\n                            this.show();\n                        }\n                    }\n                }\n                else {\n                    return String(this.isHidden());\n                }\n                break;\n            case \"width\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_8__.isClient) {\n                        this.width(parseInt(data));\n                    }\n                }\n                else {\n                    return String(this.width());\n                }\n                break;\n            case \"height\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_8__.isClient) {\n                        this.height(parseInt(data));\n                    }\n                }\n                else {\n                    return String(this.height());\n                }\n                break;\n            default:\n                return super.streamSectionData(sectionId, data, bypassTimeStream, bypassChangeDetection);\n        }\n    }\n}\n(0,_engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_9__.registerClass)(IgeEntity);\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeEntity.ts?");

/***/ }),

/***/ "./src/engine/core/IgeMatrix2d.ts":
/*!****************************************!*\
  !*** ./src/engine/core/IgeMatrix2d.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeMatrix2d: () => (/* binding */ IgeMatrix2d)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeBaseClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeBaseClass */ \"./src/engine/core/IgeBaseClass.ts\");\n/* harmony import */ var _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/IgePoint3d */ \"./src/engine/core/IgePoint3d.ts\");\n/* harmony import */ var _engine_utils_maths__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/utils/maths */ \"./src/engine/utils/maths.ts\");\n\n\n\n/**\n * Creates a new transformation matrix.\n */\nclass IgeMatrix2d extends _engine_core_IgeBaseClass__WEBPACK_IMPORTED_MODULE_0__.IgeBaseClass {\n    constructor() {\n        super(...arguments);\n        this.matrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n        this._rotateOrigin = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_1__.IgePoint3d(0, 0, 0);\n        this._scaleOrigin = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_1__.IgePoint3d(0, 0, 0);\n    }\n    transformCoord(point, obj) {\n        const { x, y } = point;\n        const tm = this.matrix;\n        point.x = x * tm[0] + y * tm[1] + tm[2];\n        point.y = x * tm[3] + y * tm[4] + tm[5];\n        /* DEXCLUDE */\n        if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {\n            obj.log(\"The matrix operation produced a NaN value!\", \"error\");\n            debugger;\n        }\n        /* DEXCLUDE */\n        return point;\n    }\n    /**\n     * Transform a point by this matrix in inverse. The parameter point will be modified with the transformation values.\n     * @param {IgePoint3d} point.\n     * @param obj\n     * @return {IgePoint3d} The passed point.\n     */\n    transformCoordInverse(point, obj) {\n        const { x, y } = point;\n        const tm = this.matrix;\n        point.x = x * tm[0] - y * tm[1] + tm[2];\n        point.y = x * tm[3] + y * tm[4] - tm[5];\n        /* DEXCLUDE */\n        if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {\n            obj.log(\"The matrix operation produced a NaN value!\", \"error\");\n            debugger;\n        }\n        /* DEXCLUDE */\n        return point;\n    }\n    transform(points, obj) {\n        const pointCount = points.length;\n        for (let pointIndex = 0; pointIndex < pointCount; pointIndex++) {\n            this.transformCoord(points[pointIndex], obj);\n        }\n        return points;\n    }\n    /**\n     * Create a new rotation matrix and set it up for the specified angle in radians.\n     * @param {number} angle\n     * @return {IgeMatrix2d} A new matrix object.\n     */\n    _newRotate(angle) {\n        const m = new IgeMatrix2d();\n        m.rotateTo(angle);\n        return m;\n    }\n    rotateBy(angle) {\n        const m = new IgeMatrix2d();\n        m.translateBy(this._rotateOrigin.x, this._rotateOrigin.y);\n        m.rotateTo(angle);\n        m.translateBy(-this._rotateOrigin.x, -this._rotateOrigin.y);\n        this.multiply(m);\n        return this;\n    }\n    rotateTo(angle) {\n        const tm = this.matrix;\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        tm[0] = c;\n        tm[1] = -s;\n        tm[3] = s;\n        tm[4] = c;\n        /* DEXCLUDE */\n        if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {\n            this.log(\"The matrix operation produced a NaN value!\", \"error\");\n            debugger;\n        }\n        /* DEXCLUDE */\n        return this;\n    }\n    /**\n     * Gets the rotation from the matrix and returns it in\n     * radians.\n     * @return {number}\n     */\n    rotationRadians() {\n        return Math.asin(this.matrix[3]);\n    }\n    /**\n     * Gets the rotation from the matrix and returns it in\n     * degrees.\n     * @return {number}\n     */\n    rotationDegrees() {\n        return (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_2__.radiansToDegrees)(Math.acos(this.matrix[0]));\n    }\n    /**\n     * Create a scale matrix.\n     * @param {number} x X scale magnitude.\n     * @param {number} y Y scale magnitude.\n     *\n     * @return {IgeMatrix2d} a matrix object.\n     *\n     * @static\n     */\n    _newScale(x, y) {\n        const m = new IgeMatrix2d();\n        m.matrix[0] = x;\n        m.matrix[4] = y;\n        return m;\n    }\n    scaleBy(x, y) {\n        const m = new IgeMatrix2d();\n        m.matrix[0] = x;\n        m.matrix[4] = y;\n        this.multiply(m);\n        return this;\n    }\n    scaleTo(x, y) {\n        const tm = this.matrix;\n        //this.identity();\n        tm[0] = x;\n        tm[4] = y;\n        /* DEXCLUDE */\n        if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {\n            this.log(\"The matrix operation produced a NaN value!\", \"error\");\n            debugger;\n        }\n        /* DEXCLUDE */\n        return this;\n    }\n    /**\n     * Create a translation matrix.\n     * @param {number} x X translation magnitude.\n     * @param {number} y Y translation magnitude.\n     * @return {IgeMatrix2d} A new matrix object.\n     */\n    _newTranslate(x, y) {\n        const m = new IgeMatrix2d();\n        m.matrix[2] = x;\n        m.matrix[5] = y;\n        return m;\n    }\n    translateBy(x, y) {\n        const m = new IgeMatrix2d();\n        m.matrix[2] = x;\n        m.matrix[5] = y;\n        this.multiply(m);\n        return this;\n    }\n    /**\n     * Sets this matrix as a translation matrix.\n     * @param x\n     * @param y\n     */\n    translateTo(x, y) {\n        const tm = this.matrix;\n        tm[2] = x;\n        tm[5] = y;\n        /* DEXCLUDE */\n        if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {\n            this.log(\"The matrix operation produced a NaN value!\", \"error\");\n            debugger;\n        }\n        /* DEXCLUDE */\n        return this;\n    }\n    /**\n     * Copy into this matrix the given matrix values.\n     * @param {IgeMatrix2d} matrix\n     * @return {Object} \"this\".\n     */\n    copy(matrix) {\n        const internalMatrix = matrix.matrix;\n        const thisMatrix = this.matrix;\n        thisMatrix[0] = internalMatrix[0];\n        thisMatrix[1] = internalMatrix[1];\n        thisMatrix[2] = internalMatrix[2];\n        thisMatrix[3] = internalMatrix[3];\n        thisMatrix[4] = internalMatrix[4];\n        thisMatrix[5] = internalMatrix[5];\n        thisMatrix[6] = internalMatrix[6];\n        thisMatrix[7] = internalMatrix[7];\n        thisMatrix[8] = internalMatrix[8];\n        return this;\n    }\n    compare(matrix) {\n        const thisMatrix = this.matrix, thatMatrix = matrix.matrix;\n        for (let i = 0; i < 9; i++) {\n            if (thisMatrix[i] !== thatMatrix[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Set this matrix to the identity matrix.\n     * @return {Object} \"this\".\n     */\n    identity() {\n        const m = this.matrix;\n        m[0] = 1.0;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n        m[4] = 1.0;\n        m[5] = 0.0;\n        m[6] = 0.0;\n        m[7] = 0.0;\n        m[8] = 1.0;\n        return this;\n    }\n    /**\n     * Multiply this matrix by a given matrix.\n     * @param {IgeMatrix2d} m The IgeMatrix2d to multiply the\n     * current matrix by.\n     * @return {Object} \"this\".\n     */\n    multiply(m) {\n        const tm = this.matrix, mm = m.matrix, tm0 = tm[0], tm1 = tm[1], tm2 = tm[2], tm3 = tm[3], tm4 = tm[4], tm5 = tm[5], tm6 = tm[6], tm7 = tm[7], tm8 = tm[8], mm0 = mm[0], mm1 = mm[1], mm2 = mm[2], mm3 = mm[3], mm4 = mm[4], mm5 = mm[5], mm6 = mm[6], mm7 = mm[7], mm8 = mm[8];\n        tm[0] = tm0 * mm0 + tm1 * mm3 + tm2 * mm6;\n        tm[1] = tm0 * mm1 + tm1 * mm4 + tm2 * mm7;\n        tm[2] = tm0 * mm2 + tm1 * mm5 + tm2 * mm8;\n        tm[3] = tm3 * mm0 + tm4 * mm3 + tm5 * mm6;\n        tm[4] = tm3 * mm1 + tm4 * mm4 + tm5 * mm7;\n        tm[5] = tm3 * mm2 + tm4 * mm5 + tm5 * mm8;\n        tm[6] = tm6 * mm0 + tm7 * mm3 + tm8 * mm6;\n        tm[7] = tm6 * mm1 + tm7 * mm4 + tm8 * mm7;\n        tm[8] = tm6 * mm2 + tm7 * mm5 + tm8 * mm8;\n        return this;\n    }\n    /**\n     * Premultiply this matrix by a given matrix.\n     * @param {IgeMatrix2d} m The IgeMatrix2d to premultiply the\n     * current matrix by.\n     * @return {Object} \"this\".\n     */\n    premultiply(m) {\n        const m00 = m.matrix[0] * this.matrix[0] + m.matrix[1] * this.matrix[3] + m.matrix[2] * this.matrix[6];\n        const m01 = m.matrix[0] * this.matrix[1] + m.matrix[1] * this.matrix[4] + m.matrix[2] * this.matrix[7];\n        const m02 = m.matrix[0] * this.matrix[2] + m.matrix[1] * this.matrix[5] + m.matrix[2] * this.matrix[8];\n        const m10 = m.matrix[3] * this.matrix[0] + m.matrix[4] * this.matrix[3] + m.matrix[5] * this.matrix[6];\n        const m11 = m.matrix[3] * this.matrix[1] + m.matrix[4] * this.matrix[4] + m.matrix[5] * this.matrix[7];\n        const m12 = m.matrix[3] * this.matrix[2] + m.matrix[4] * this.matrix[5] + m.matrix[5] * this.matrix[8];\n        const m20 = m.matrix[6] * this.matrix[0] + m.matrix[7] * this.matrix[3] + m.matrix[8] * this.matrix[6];\n        const m21 = m.matrix[6] * this.matrix[1] + m.matrix[7] * this.matrix[4] + m.matrix[8] * this.matrix[7];\n        const m22 = m.matrix[6] * this.matrix[2] + m.matrix[7] * this.matrix[5] + m.matrix[8] * this.matrix[8];\n        this.matrix[0] = m00;\n        this.matrix[1] = m01;\n        this.matrix[2] = m02;\n        this.matrix[3] = m10;\n        this.matrix[4] = m11;\n        this.matrix[5] = m12;\n        this.matrix[6] = m20;\n        this.matrix[7] = m21;\n        this.matrix[8] = m22;\n        return this;\n    }\n    /**\n     * Creates a new inverse matrix from this matrix.\n     * @return {IgeMatrix2d} An inverse matrix.\n     */\n    getInverse() {\n        const tm = this.matrix;\n        const m00 = tm[0], m01 = tm[1], m02 = tm[2], m10 = tm[3], m11 = tm[4], m12 = tm[5], m20 = tm[6], m21 = tm[7], m22 = tm[8], newMatrix = new IgeMatrix2d(), determinant = m00 * (m11 * m22 - m21 * m12) - m10 * (m01 * m22 - m21 * m02) + m20 * (m01 * m12 - m11 * m02);\n        if (determinant === 0) {\n            // TODO: This used to be `return null`, was it correct?\n            return this;\n        }\n        const m = newMatrix.matrix;\n        m[0] = m11 * m22 - m12 * m21;\n        m[1] = m02 * m21 - m01 * m22;\n        m[2] = m01 * m12 - m02 * m11;\n        m[3] = m12 * m20 - m10 * m22;\n        m[4] = m00 * m22 - m02 * m20;\n        m[5] = m02 * m10 - m00 * m12;\n        m[6] = m10 * m21 - m11 * m20;\n        m[7] = m01 * m20 - m00 * m21;\n        m[8] = m00 * m11 - m01 * m10;\n        newMatrix.multiplyScalar(1 / determinant);\n        return newMatrix;\n    }\n    /**\n     * Multiply this matrix by a scalar.\n     * @param {number} scalar Scalar value.\n     * @return this\n     */\n    multiplyScalar(scalar) {\n        let i;\n        for (i = 0; i < 9; i++) {\n            this.matrix[i] *= scalar;\n        }\n        return this;\n    }\n    /**\n     * Transforms the passed rendering context by the current matrix\n     * data using the setTransform() method so that the matrix data\n     * is set non-cumulative with the previous matrix data.\n     * @param {CanvasRenderingContext2D} ctx The rendering context to\n     * set the transform matrix for.\n     */\n    transformRenderingContextSet(ctx) {\n        const m = this.matrix;\n        ctx.setTransform(m[0], m[3], m[1], m[4], Math.floor(m[2]), Math.floor(m[5]));\n        return this;\n    }\n    /**\n     * Transforms the passed rendering context by the current matrix\n     * data using the transform() method so that the matrix data\n     * is set cumulative with the previous matrix data.\n     * @param {CanvasRenderingContext2D} ctx The rendering context to\n     * set the transform matrix for.\n     */\n    transformRenderingContext(ctx) {\n        const m = this.matrix;\n        ctx.transform(m[0], m[3], m[1], m[4], Math.floor(m[2]), Math.floor(m[5]));\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeMatrix2d.ts?");

/***/ }),

/***/ "./src/engine/core/IgeObject.ts":
/*!**************************************!*\
  !*** ./src/engine/core/IgeObject.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeObject: () => (/* binding */ IgeObject)\n/* harmony export */ });\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_core_IgeDummyCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/IgeDummyCanvas */ \"./src/engine/core/IgeDummyCanvas.ts\");\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n/* harmony import */ var _engine_core_IgeMatrix2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/core/IgeMatrix2d */ \"./src/engine/core/IgeMatrix2d.ts\");\n/* harmony import */ var _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/engine/core/IgePoint2d */ \"./src/engine/core/IgePoint2d.ts\");\n/* harmony import */ var _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/engine/core/IgePoint3d */ \"./src/engine/core/IgePoint3d.ts\");\n/* harmony import */ var _engine_core_IgePoly2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/engine/core/IgePoly2d */ \"./src/engine/core/IgePoly2d.ts\");\n/* harmony import */ var _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/engine/core/IgeBounds */ \"./src/engine/core/IgeBounds.ts\");\n/* harmony import */ var _engine_utils_arrays__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/engine/utils/arrays */ \"./src/engine/utils/arrays.ts\");\n/* harmony import */ var _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/engine/utils/clientServer */ \"./src/engine/utils/clientServer.ts\");\n/* harmony import */ var _engine_utils_ids__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/engine/utils/ids */ \"./src/engine/utils/ids.ts\");\n/* harmony import */ var _engine_utils_maths__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/engine/utils/maths */ \"./src/engine/utils/maths.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass IgeObject extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_2__.IgeEventingClass {\n    constructor() {\n        super();\n        this.classId = \"IgeObject\";\n        this._idRegistered = false;\n        this._categoryRegistered = false;\n        this._category = \"\";\n        this._drawBounds = false;\n        this._drawBoundsData = false;\n        this._drawMouse = false;\n        this._drawMouseData = false;\n        this._ignoreCamera = false;\n        this._parent = null;\n        this._children = [];\n        this._transformChanged = false;\n        this._tileWidth = 1;\n        this._tileHeight = 1;\n        this._tileDepth = 1;\n        this._specialProp = [];\n        this._streamDataCache = \"\";\n        this._streamSections = [\"transform\", \"props\"];\n        this._streamProperty = {};\n        this._streamSyncDelta = 0;\n        this._streamSyncSectionInterval = {}; // Holds minimum delta before the stream section is included in the next stream data packet\n        this._streamSyncSectionDelta = {}; // Stores the game time elapsed since the last time the section was included in a stream data packet\n        this._timeStream = []; // Holds an array of transform data for the object that was sent from the server\n        this._streamFloatPrecision = 2;\n        this._floatRemoveRegExp = new RegExp(\"\\\\.00,\", \"g\");\n        this._compositeStream = false;\n        this._disableInterpolation = false;\n        this._newBorn = true;\n        this._alive = true;\n        this._mountMode = _enums__WEBPACK_IMPORTED_MODULE_12__.IgeMountMode.flat;\n        this._layer = 0;\n        this._depth = 0;\n        this._depthSortMode = _enums__WEBPACK_IMPORTED_MODULE_12__.IgeIsometricDepthSortMode.bounds3d;\n        this._inView = true;\n        this._managed = 1;\n        this._triggerPolygonFunctionName = \"aabb\";\n        this._compositeCache = false;\n        this._compositeParent = false;\n        this._cell = 1;\n        this._bornTime = 0;\n        this._pointerStateDown = false;\n        this._pointerStateOver = false;\n        this._pointerAlwaysInside = false;\n        this._cache = false;\n        this._cacheDirty = false;\n        this._cacheSmoothing = false;\n        this._aabbDirty = false;\n        this._aabb = new _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_7__.IgeBounds();\n        this._indestructible = false;\n        this._shouldRender = true;\n        this._frameAlternatorCurrent = false;\n        this._backgroundPatternRepeat = null;\n        this._bounds3dPolygonDirty = false;\n        this.components = {};\n        this._sortChildren = (compareFn) => {\n            return this._children.sort(compareFn);\n        };\n        this._specialProp.push(\"_id\");\n        this._specialProp.push(\"_parent\");\n        this._specialProp.push(\"_children\");\n        this._anchor = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_4__.IgePoint2d(0, 0);\n        this._renderPos = { x: 0, y: 0 };\n        this._computedOpacity = 1;\n        this._opacity = 1;\n        this._cell = 1;\n        this._deathTime = undefined;\n        this._translate = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0, 0, 0);\n        this._oldTranslate = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0, 0, 0);\n        this._rotate = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0, 0, 0);\n        this._scale = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(1, 1, 1);\n        this._origin = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0.5, 0.5, 0.5);\n        this._bounds2d = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_4__.IgePoint2d(40, 40);\n        this._bounds3d = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0, 0, 0);\n        this._oldBounds2d = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_4__.IgePoint2d(40, 40);\n        this._oldBounds3d = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0, 0, 0);\n        this._highlight = false;\n        this._pointerEventsActive = false;\n        this._velocity = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(0, 0, 0);\n        this._localMatrix = new _engine_core_IgeMatrix2d__WEBPACK_IMPORTED_MODULE_3__.IgeMatrix2d();\n        this._worldMatrix = new _engine_core_IgeMatrix2d__WEBPACK_IMPORTED_MODULE_3__.IgeMatrix2d();\n        this._oldWorldMatrix = new _engine_core_IgeMatrix2d__WEBPACK_IMPORTED_MODULE_3__.IgeMatrix2d();\n        this._inView = true;\n        this._hidden = false;\n    }\n    id(id) {\n        if (id !== undefined) {\n            // Check if we're changing the id\n            if (id === this._id) {\n                // The same ID we already have is being applied,\n                // ignore the request and return\n                return this;\n            }\n            // Check if this ID already exists in the object register\n            if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.register.get(id)) {\n                // Check if we already have an id assigned\n                if (this._id && _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.register.get(this._id)) {\n                    // Unregister the old ID before setting this new one\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.register.remove(this);\n                }\n                this._id = id;\n                // Now register this object with the object register\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.register.add(this);\n                return this;\n            }\n            // Already an object with this ID!\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.register.get(id) !== this) {\n                this.log(`Cannot set ID of object to \"${id}\" because that ID is already in use by another object!`, \"error\");\n            }\n        }\n        if (!this._id) {\n            // The item has no id so generate one automatically\n            this._id = (0,_engine_utils_ids__WEBPACK_IMPORTED_MODULE_10__.newIdHex)();\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.register.add(this);\n        }\n        return this._id;\n    }\n    category(val) {\n        if (val === undefined) {\n            return this._category;\n        }\n        // Check if we already have a category\n        if (this._category) {\n            // Check if the category being assigned is different from\n            // the current one\n            if (this._category !== val) {\n                // The category is different so remove this object\n                // from the current category association\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.categoryRegister.remove(this);\n            }\n        }\n        this._category = val;\n        // Check the category is not a blank string\n        if (val) {\n            // Now register this object with the category it has been assigned\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.categoryRegister.add(this);\n        }\n        return this;\n    }\n    drawBounds(val, recursive = true) {\n        if (val === undefined) {\n            return this._drawBounds;\n        }\n        this._drawBounds = val;\n        if (recursive) {\n            this.children().forEach((child) => child.drawBounds(val, recursive));\n        }\n        return this;\n    }\n    drawBoundsData(val) {\n        if (val !== undefined) {\n            this._drawBoundsData = val;\n            return this;\n        }\n        return this._drawBoundsData;\n    }\n    drawMouse(val) {\n        if (val !== undefined) {\n            this._drawMouse = val;\n            return this;\n        }\n        return this._drawMouse;\n    }\n    drawMouseData(val) {\n        if (val !== undefined) {\n            this._drawMouseData = val;\n            return this;\n        }\n        return this._drawMouseData;\n    }\n    /**\n     * Returns the absolute world position of the entity as an\n     * IgePoint3d.\n     * @example #Get the world position of the entity\n     *     var wordPos = entity.worldPosition();\n     * @return {IgePoint3d} The absolute world position of the\n     * entity.\n     */\n    worldPosition() {\n        return new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(this._worldMatrix.matrix[2], this._worldMatrix.matrix[5], 0);\n    }\n    /**\n     * Returns the absolute world rotation z of the entity as a\n     * value in radians.\n     * @example #Get the world rotation of the entity's z axis\n     *     var wordRot = entity.worldRotationZ();\n     * @return {number} The absolute world rotation z of the\n     * entity.\n     */\n    worldRotationZ() {\n        return this._worldMatrix.rotationRadians();\n    }\n    /**\n     * Converts an array of points from local space to this entity's\n     * world space using its world transform matrix. This will alter\n     * the points passed in the array directly.\n     * @param {Array} points The array of IgePoints to convert.\n     * @param viewport\n     * @param inverse\n     */\n    localToWorld(points, viewport, inverse = false) {\n        // TODO: Commented as this was doing literally nothing\n        //viewport = viewport || ige.engine._currentViewport;\n        if (this._adjustmentMatrix) {\n            // Apply the optional adjustment matrix\n            this._worldMatrix.multiply(this._adjustmentMatrix);\n        }\n        if (!inverse) {\n            this._worldMatrix.transform(points, this);\n        }\n        else {\n            this._localMatrix.transform(points, this);\n            //this._worldMatrix.getInverse().transform(points, this);\n        }\n        if (this._ignoreCamera) {\n            // TODO: It looks like the ignoreCamera functionality needs further\n            //  investigation to make sure it works as expected\n            //viewport.camera._worldMatrix.transform(points, this);\n        }\n    }\n    /**\n     * Converts a point from local space to this entity's world space\n     * using its world transform matrix. This will alter the passed\n     * point's data directly.\n     * @param {IgePoint3d} point The IgePoint3d to convert.\n     */\n    localToWorldPoint(point, viewport) {\n        // TODO: We commented this because it doesn't even get used... is this a mistake?\n        //viewport = viewport || ige.engine._currentViewport;\n        this._worldMatrix.transform([point], this);\n    }\n    /**\n     * Returns the screen position of the entity as an IgePoint3d where x is the\n     * horizontal center of the entity and y is the vertical center of the entity,\n     * useful for positioning HTML elements at the screen location of an IGE entity.\n     * This method assumes that the top-left of the main canvas element is at 0, 0.\n     * If not you can adjust the values yourself to allow for offset.\n     * @example #Get the screen position of the entity\n     *     var screenPos = entity.screenPosition();\n     * @return {IgePoint3d} The screen position of the entity.\n     */\n    screenPosition() {\n        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera) {\n            throw new Error(\"Cannot get screen position of entity, ige instance has no camera!\");\n        }\n        return new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_5__.IgePoint3d(Math.floor((this._worldMatrix.matrix[2] - _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera._translate.x) *\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera._scale.x +\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._bounds2d.x2), Math.floor((this._worldMatrix.matrix[5] - _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera._translate.y) *\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentCamera._scale.y +\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._bounds2d.y2), 0);\n    }\n    /**\n     * Gets the polygon that encompasses the 3d bounds of the entity in local space.\n     * @param {boolean=false} recalculate If true, will force a recalculation\n     * of the polygon instead of using an existing cached value.\n     */\n    localBounds3dPolygon(recalculate = false) {\n        if (this._bounds3dPolygonDirty || !this._localBounds3dPolygon || recalculate) {\n            const geom = this._bounds3d, poly = new _engine_core_IgePoly2d__WEBPACK_IMPORTED_MODULE_6__.IgePoly2d(), \n            // Bottom face\n            bf2 = (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_11__.toIso)(+geom.x2, -geom.y2, -geom.z2), bf3 = (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_11__.toIso)(+geom.x2, +geom.y2, -geom.z2), bf4 = (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_11__.toIso)(-geom.x2, +geom.y2, -geom.z2), \n            // Top face\n            tf1 = (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_11__.toIso)(-geom.x2, -geom.y2, geom.z2), tf2 = (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_11__.toIso)(+geom.x2, -geom.y2, geom.z2), tf4 = (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_11__.toIso)(-geom.x2, +geom.y2, geom.z2);\n            poly.addPoint(tf1.x, tf1.y)\n                .addPoint(tf2.x, tf2.y)\n                .addPoint(bf2.x, bf2.y)\n                .addPoint(bf3.x, bf3.y)\n                .addPoint(bf4.x, bf4.y)\n                .addPoint(tf4.x, tf4.y)\n                .addPoint(tf1.x, tf1.y);\n            this._localBounds3dPolygon = poly;\n            this._bounds3dPolygonDirty = false;\n        }\n        return this._localBounds3dPolygon;\n    }\n    /**\n     * Gets the polygon that encompasses the 3d bounds of the entity in world space.\n     * @param {boolean=false} recalculate If true, will force a recalculation\n     * of the polygon instead of using an existing cached value.\n     */\n    bounds3dPolygon(recalculate = false) {\n        if (this._bounds3dPolygonDirty || !this._bounds3dPolygon || recalculate) {\n            const poly = this.localBounds3dPolygon(recalculate).clone();\n            // Convert local co-ordinates to world based on entities world matrix\n            this.localToWorld(poly._poly);\n            this._bounds3dPolygon = poly;\n        }\n        return this._bounds3dPolygon;\n    }\n    update(tickDelta) {\n        // Check that we are alive before processing further\n        if (!this._alive) {\n            return;\n        }\n        if (this._newBorn) {\n            this._newBorn = false;\n        }\n        const arr = this._children;\n        if (!arr) {\n            return;\n        }\n        let arrCount = arr.length;\n        // Depth sort all child objects\n        // if (arrCount && !ige.engine._headless) {\n        if (arrCount) {\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.config.debug._timing) {\n                if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[this.id()]) {\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[this.id()] = {};\n                }\n                const ts = new Date().getTime();\n                this.depthSortChildren();\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[this.id()].depthSortChildren = new Date().getTime() - ts;\n            }\n            else {\n                this.depthSortChildren();\n            }\n        }\n        // Loop our children and call their update methods\n        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.config.debug._timing) {\n            while (arrCount--) {\n                arr[arrCount].update(tickDelta);\n            }\n            return;\n        }\n        while (arrCount--) {\n            const ts = new Date().getTime();\n            arr[arrCount].update(tickDelta);\n            const td = new Date().getTime() - ts;\n            if (!arr[arrCount]) {\n                continue;\n            }\n            if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentInTick[arr[arrCount].id()]) {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentInTick[arr[arrCount].id()] = 0;\n            }\n            if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[arr[arrCount].id()]) {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[arr[arrCount].id()] = {};\n            }\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentInTick[arr[arrCount].id()] += td;\n            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[arr[arrCount].id()].tick = td;\n        }\n        return;\n    }\n    tick(ctx) {\n        // Check that we are alive before processing further\n        if (!this._alive) {\n            return;\n        }\n        const arr = this._children;\n        if (!arr) {\n            return;\n        }\n        let arrCount = arr.length;\n        if (_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.config.debug._timing) {\n            while (arrCount--) {\n                if (!arr[arrCount]) {\n                    this.log(\"Object _children is undefined for index \" + arrCount + \" and _id: \" + this._id, \"error\");\n                    continue;\n                }\n                if (!arr[arrCount]._newBorn) {\n                    ctx.save();\n                    const ts = new Date().getTime();\n                    arr[arrCount].tick(ctx);\n                    const td = new Date().getTime() - ts;\n                    if (arr[arrCount]) {\n                        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentInTick[arr[arrCount].id()]) {\n                            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentInTick[arr[arrCount].id()] = 0;\n                        }\n                        if (!_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[arr[arrCount].id()]) {\n                            _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[arr[arrCount].id()] = {};\n                        }\n                        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentInTick[arr[arrCount].id()] += td;\n                        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeSpentLastTick[arr[arrCount].id()].tick = td;\n                    }\n                    ctx.restore();\n                }\n            }\n        }\n        else {\n            while (arrCount--) {\n                if (!arr[arrCount]) {\n                    this.log(`Object _children is undefined for index ${arrCount} and _id: ${this._id}`, \"error\");\n                    continue;\n                }\n                if (!arr[arrCount]._newBorn) {\n                    ctx.save();\n                    arr[arrCount].tick(ctx);\n                    ctx.restore();\n                }\n            }\n        }\n    }\n    updateTransform() {\n    }\n    aabb(recalculate = true, inverse = false) {\n        return this._aabb;\n    }\n    /**\n     * Calls each behaviour method for the object.\n     */\n    _processBehaviours(type, ...args) {\n        if (!this._behaviours || !this._behaviours[type])\n            return;\n        const arr = this._behaviours[type];\n        let arrCount = arr.length;\n        while (arrCount--) {\n            arr[arrCount].method(this, ...args);\n        }\n    }\n    parent(id) {\n        if (!id) {\n            return this._parent;\n        }\n        if (this._parent) {\n            if (this._parent.id() === id) {\n                return this._parent;\n            }\n            else {\n                return this._parent.parent(id);\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns the object's children as an array of objects.\n     * @example #Get the child objects array\n     *     // Create a couple of entities and give them ids\n     *     var entity1 = new IgeEntity().id('entity1'),\n     *         entity2 = new IgeEntity().id('entity2');\n     *\n     *     // Mount entity2 to entity1\n     *     entity2.mount(entity1);\n     *\n     *     // Get the children array entity1\n     *     var childArray = entity1.children();\n     *\n     *     // Log the child array contents (will contain entity2)\n     *     console.log(childArray);\n     * @return {Array} The array of child objects.\n     */\n    children() {\n        return this._children;\n    }\n    /**\n     * Mounts this object to the passed object in the scenegraph.\n     * @param {IgeEntity} obj\n     * @example #Mount an entity to another entity\n     *     // Create a couple of entities and give them ids\n     *     var entity1 = new IgeEntity().id('entity1'),\n     *         entity2 = new IgeEntity().id('entity2');\n     *\n     *     // Mount entity2 to entity1\n     *     entity2.mount(entity1);\n     * @return {*} Returns this on success or false on failure.\n     */\n    mount(obj) {\n        if (!obj) {\n            throw new Error(\"Must provide an object to mount to!\");\n        }\n        if (obj === this) {\n            this.log(\"Cannot mount an object to itself!\", \"error\");\n            return this;\n        }\n        if (!obj._children) {\n            // The object has no _children array!\n            throw new Error(\"Cannot mount object because it has no _children array! If you are mounting to a custom class, ensure that you have extended from IgeObject.\");\n        }\n        // Check that the engine will allow us to register this object\n        this.id(); // Generates a new id if none is currently set, and registers it on the object register!\n        if (this._parent) {\n            if (this._parent === obj) {\n                // We are already mounted to the parent!\n                return this;\n            }\n            // We are already mounted to a different parent\n            this.unMount();\n        }\n        // Set our parent to the object we are mounting to\n        this._parent = obj;\n        // Check if we need to set the \"ignore camera\" flag\n        if (!this._ignoreCamera && this._parent._ignoreCamera) {\n            this._ignoreCamera = this._parent._ignoreCamera;\n            /*if (this.ignoreCameraComposite) {\n                this.ignoreCameraComposite(this._parent._ignoreCamera);\n            }*/\n        }\n        // Make sure we keep the child's room id in sync with its parent\n        if (this._parent._streamRoomId) {\n            this._streamRoomId = this._parent._streamRoomId;\n        }\n        if (this._bornTime === 0) {\n            this._bornTime = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime;\n        }\n        obj._children.push(this);\n        this._parent._childMounted(this);\n        obj.updateTransform();\n        obj.aabb(true);\n        if (obj._compositeCache) {\n            this._compositeParent = true;\n        }\n        else {\n            this._compositeParent = false;\n        }\n        this._mounted(this._parent);\n        this.emit(\"mounted\", this._parent);\n        return this;\n    }\n    /**\n     * Unmounts this object from its parent object in the scenegraph.\n     * @example #Unmount an entity from another entity\n     *     // Create a couple of entities and give them ids\n     *     var entity1 = new IgeEntity().id('entity1'),\n     *         entity2 = new IgeEntity().id('entity2');\n     *\n     *     // Mount entity2 to entity1\n     *     entity2.mount(entity1);\n     *\n     *     // Now unmount entity2 from entity1\n     *     entity2.unMount();\n     * @return {*} Returns this on success or false on failure.\n     */\n    unMount() {\n        if (!this._parent) {\n            return this;\n        }\n        const childArr = this._parent._children, index = childArr.indexOf(this), oldParent = this._parent;\n        if (index <= -1) {\n            // Cannot find this in the parent._children array\n            return this;\n        }\n        // Found this in the parent._children array so remove it\n        childArr.splice(index, 1);\n        this._parent._childUnMounted(this);\n        this._parent = null;\n        this._unMounted(oldParent);\n        return this;\n    }\n    /**\n     * Determines if the object has a parent up the scenegraph whose\n     * id matches the one passed. Will traverse each parent object\n     * checking if the id matches. This information will be cached when\n     * first called and can be refreshed by setting the \"fresh\" parameter\n     * to true.\n     * @param {string} parentId The id of the parent to check for.\n     * @param {Boolean=} fresh If true will force a full check instead of\n     * using the cached value from an earlier check.\n     */\n    hasParent(parentId, fresh = false) {\n        let bool = false;\n        // Check for a cached value\n        if (!fresh && this._hasParent && this._hasParent[parentId] !== undefined) {\n            return this._hasParent[parentId];\n        }\n        if (this._parent) {\n            if (this._parent.id() === parentId) {\n                bool = true;\n            }\n            else {\n                bool = this._parent.hasParent(parentId, fresh);\n            }\n        }\n        this._hasParent = this._hasParent || {};\n        this._hasParent[parentId] = bool;\n        return bool;\n    }\n    /**\n     * Override the _childMounted method and apply entity-based flags.\n     * @param {IgeEntity} child\n     * @private\n     */\n    _childMounted(child) {\n        // Check if we need to set the compositeStream and streamMode\n        if (this.compositeStream()) {\n            child.compositeStream(true);\n            child.streamMode(this.streamMode());\n            child.streamControl(this.streamControl());\n        }\n        this._resizeEvent();\n        // Check if we are compositeCached and update the cache\n        if (this.compositeCache()) {\n            this.cacheDirty(true);\n        }\n    }\n    alive(val) {\n        if (val !== undefined) {\n            this._alive = val;\n            return this;\n        }\n        return this._alive;\n    }\n    indestructible(val) {\n        if (val !== undefined) {\n            this._indestructible = val;\n            return this;\n        }\n        return this._indestructible;\n    }\n    layer(val) {\n        if (val !== undefined) {\n            this._layer = val;\n            return this;\n        }\n        return this._layer;\n    }\n    depth(val) {\n        if (val === undefined) {\n            return this._depth;\n        }\n        this._depth = val;\n        return this;\n    }\n    /**\n     * Loops through all child objects of this object and destroys them\n     * by calling each child's destroy() method then clears the object's\n     * internal _children array.\n     */\n    destroyChildren() {\n        const arr = this._children;\n        if (arr) {\n            let arrCount = arr.length;\n            while (arrCount--) {\n                arr[arrCount].destroy();\n            }\n        }\n        this._children = [];\n        return this;\n    }\n    isometricMounts(val) {\n        if (val !== undefined) {\n            this._mountMode = val ? _enums__WEBPACK_IMPORTED_MODULE_12__.IgeMountMode.iso : _enums__WEBPACK_IMPORTED_MODULE_12__.IgeMountMode.flat;\n            return this;\n        }\n        return this._mountMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeMountMode.iso;\n    }\n    depthSortMode(val) {\n        if (val !== undefined) {\n            this._depthSortMode = val;\n            return this;\n        }\n        return this._depthSortMode;\n    }\n    /**\n     * Sorts the _children array by the layer and then depth of each object.\n     */\n    depthSortChildren() {\n        if (this._depthSortMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeIsometricDepthSortMode.none) {\n            return;\n        }\n        const arr = this._children;\n        if (!arr || !arr.length) {\n            return;\n        }\n        // Now sort the entities by depth\n        this._sortChildren((a, b) => {\n            const layerIndex = b._layer - a._layer;\n            if (layerIndex === 0) {\n                // On same layer so sort by depth\n                return b._depth - a._depth;\n            }\n            else {\n                // Not on same layer so sort by layer\n                return layerIndex;\n            }\n        });\n        return;\n    }\n    _depthSortVisit(u, sortObj) {\n        const arr = sortObj.adj[u];\n        const arrCount = arr.length;\n        sortObj.c[u] = 1;\n        for (let i = 0; i < arrCount; ++i) {\n            const v = arr[i];\n            if (sortObj.c[v] === 0) {\n                sortObj.p[v] = u;\n                this._depthSortVisit(v, sortObj);\n            }\n        }\n        sortObj.c[u] = 2;\n        sortObj.order[sortObj.order_ind] = u;\n        --sortObj.order_ind;\n    }\n    /**\n     * Handles screen resize events. Calls the _resizeEvent method of\n     * every child object mounted to this object.\n     * @param event\n     * @private\n     */\n    _resizeEvent(event) {\n        const arr = this._children;\n        if (!arr) {\n            return;\n        }\n        let arrCount = arr.length;\n        while (arrCount--) {\n            arr[arrCount]._resizeEvent(event);\n        }\n    }\n    /**\n     * Called when a child object is un-mounted from this object.\n     * @param obj\n     * @private\n     */\n    _childUnMounted(obj) {\n    }\n    /**\n     * Called when this object is mounted to an object.\n     * @param obj\n     * @private\n     */\n    _mounted(obj) {\n    }\n    /**\n     * Called when this object is un-mounted from its parent.\n     * @param obj\n     * @private\n     */\n    _unMounted(obj) {\n    }\n    isMounted() {\n        return Boolean(this._parent);\n    }\n    childSortingAlgorithm(val) {\n        if (val !== undefined) {\n            this._sortChildren = val;\n            return this;\n        }\n        return this._sortChildren;\n    }\n    /**\n     * Transforms a point by the entity's parent world matrix and\n     * its own local matrix transforming the point to this entity's\n     * world space.\n     * @param {IgePoint3d} point The point to transform.\n     * @example #Transform a point by the entity's world matrix values\n     *     var point = new IgePoint3d(0, 0, 0);\n     *     entity._transformPoint(point);\n     *\n     *     console.log(point);\n     * @return {IgePoint3d} The transformed point.\n     */\n    _transformPoint(point) {\n        if (this._parent) {\n            const tempMat = new _engine_core_IgeMatrix2d__WEBPACK_IMPORTED_MODULE_3__.IgeMatrix2d();\n            // Copy the parent world matrix\n            tempMat.copy(this._parent._worldMatrix);\n            // Apply any local transforms\n            tempMat.multiply(this._localMatrix);\n            // Now transform the point\n            tempMat.getInverse().transformCoord(point, this);\n        }\n        else {\n            this._localMatrix.transformCoord(point, this);\n        }\n        return point;\n    }\n    /**\n     * Adds a behaviour to the object's active behaviour list.\n     * @param type\n     * @param {string} id\n     * @param {Function} behaviour\n     * during the tick() method instead of the update() method.\n     * @example #Add a behaviour with the id \"myBehaviour\"\n     *     var entity = new IgeEntity();\n     *     entity.addBehaviour(IgeBehaviourType.preUpdate, 'myBehaviour', function () {\n     *         // Code here will execute during each engine update for\n     *         // this entity. I can access the entity via the \"this\"\n     *         // keyword such as:\n     *         this._somePropertyOfTheEntity = 'moo';\n     *     });\n     *\n     *     // Now since each update we are setting _somePropertyOfTheEntity\n     *     // to equal \"moo\" we can console log the property and get\n     *     // the value as \"moo\"\n     *     console.log(entity._somePropertyOfTheEntity);\n     * @return {*} Returns this on success or false on failure.\n     */\n    addBehaviour(type, id, behaviour) {\n        this._behaviours = this._behaviours || {};\n        this._behaviours[type] = this._behaviours[type] || [];\n        this._behaviours[type].push({\n            id,\n            method: behaviour\n        });\n        return this;\n    }\n    /**\n     * Removes a behaviour to the object's active behaviour list by its id.\n     * @param type\n     * @param {string} id\n     * @example #Remove a behaviour with the id \"myBehaviour\"\n     *     var entity = new IgeEntity();\n     *     entity.addBehaviour(IgeBehaviourType.preUpdate, 'myBehaviour', function () {\n     *         // Code here will execute during each engine update for\n     *         // this entity. I can access the entity via the \"this\"\n     *         // keyword such as:\n     *         this._somePropertyOfTheEntity = 'moo';\n     *     });\n     *\n     *     // Now remove the \"myBehaviour\" behaviour\n     *     entity.removeBehaviour(IgeBehaviourType.preUpdate, 'myBehaviour');\n     * @return {*} Returns this on success or false on failure.\n     */\n    removeBehaviour(type, id) {\n        if (!this._behaviours)\n            return;\n        const arr = this._behaviours[type];\n        // Find the behaviour\n        if (arr) {\n            let arrCount = arr.length;\n            while (arrCount--) {\n                if (arr[arrCount].id === id) {\n                    // Remove the item from the array\n                    arr.splice(arrCount, 1);\n                    return this;\n                }\n            }\n        }\n    }\n    /**\n     * Checks if the object has the specified behaviour already added to it.\n     * @param type\n     * @param {string} id\n     * from the tick method rather than the update method.\n     * @example #Check for a behaviour with the id \"myBehaviour\"\n     *     var entity = new IgeEntity();\n     *     entity.addBehaviour(IgeBehaviourType.preUpdate, 'myBehaviour', function () {\n     *         // Code here will execute during each engine update for\n     *         // this entity. I can access the entity via the \"this\"\n     *         // keyword such as:\n     *         this._somePropertyOfTheEntity = 'moo';\n     *     });\n     *\n     *     // Now check for the \"myBehaviour\" behaviour\n     *     console.log(entity.hasBehaviour(IgeBehaviourType.preUpdate, 'myBehaviour')); // Will log \"true\"\n     * @return {*} Returns this on success or false on failure.\n     */\n    hasBehaviour(type, id) {\n        if (!this._behaviours || !id)\n            return false;\n        const arr = this._behaviours[type];\n        // Find the behaviour\n        if (!arr) {\n            return false;\n        }\n        let arrCount = arr.length;\n        while (arrCount--) {\n            if (arr[arrCount].id === id) {\n                return true;\n            }\n        }\n        return false;\n    }\n    cache(val, propagateToChildren = false) {\n        if (val === undefined) {\n            return this._cache;\n        }\n        this._cache = val;\n        if (propagateToChildren) {\n            this._children.forEach((child) => {\n                if (!(\"cache\" in child))\n                    return;\n                child.cache(val, true);\n            });\n        }\n        if (!val) {\n            // Remove the off-screen canvas\n            delete this._cacheCanvas;\n            return this;\n        }\n        // Create the off-screen canvas\n        if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isClient) {\n            // Use a real canvas\n            const canvasObj = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine.createCanvas({ smoothing: this._cacheSmoothing, pixelRatioScaling: true });\n            this._cacheCanvas = canvasObj.canvas;\n            this._cacheCtx = canvasObj.ctx;\n        }\n        else {\n            // Use dummy objects for canvas and context\n            this._cacheCanvas = new _engine_core_IgeDummyCanvas__WEBPACK_IMPORTED_MODULE_1__.IgeDummyCanvas();\n            this._cacheCtx = this._cacheCanvas.getContext(\"2d\");\n        }\n        this._cacheDirty = true;\n        // Switch off composite caching\n        if (this.compositeCache()) {\n            this.compositeCache(false);\n        }\n        return this;\n    }\n    compositeCache(val, propagateToChildren = false) {\n        if (!_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isClient) {\n            return this;\n        }\n        if (val === undefined) {\n            return this._compositeCache;\n        }\n        if (val) {\n            // Switch off normal caching\n            this.cache(false);\n            // Create the off-screen canvas\n            const canvasObj = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine.createCanvas({ smoothing: this._cacheSmoothing, pixelRatioScaling: true });\n            this._cacheCanvas = canvasObj.canvas;\n            this._cacheCtx = canvasObj.ctx;\n            this._cacheDirty = true;\n        }\n        // Loop children and set _compositeParent to the correct value\n        this._children.forEach((child) => {\n            child._compositeParent = val;\n            if (propagateToChildren && \"compositeCache\" in child) {\n                child.compositeCache(val, propagateToChildren);\n            }\n        });\n        this._compositeCache = val;\n        return this;\n    }\n    cacheDirty(val) {\n        if (val === undefined) {\n            return this._cacheDirty;\n        }\n        this._cacheDirty = val;\n        // Check if the entity is a child of a composite or composite\n        // entity chain and propagate the dirty cache up the chain\n        if (val && this._compositeParent && this._parent && \"cacheDirty\" in this._parent) {\n            this._parent.cacheDirty(val);\n            if (!this._cache && !this._compositeCache) {\n                // Set clean immediately as no caching is enabled on this child\n                this._cacheDirty = false;\n            }\n        }\n        return this;\n    }\n    /**\n     * Registers ourselves to the ige.classStore.\n     */\n    registerNetworkClass() {\n        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.classStore[this.constructor.name] = this.constructor;\n    }\n    /**\n     * Translates the entity to the passed values.\n     * @param {number} x The x co-ordinate.\n     * @param {number} y The y co-ordinate.\n     * @param {number} z The z co-ordinate.\n     * @example #Translate the entity to 10, 0, 0\n     *     entity.translateTo(10, 0, 0);\n     * @return {*}\n     */\n    translateTo(x, y, z) {\n        if (x === undefined || y === undefined || z === undefined) {\n            this.log(\"translateTo() called with a missing or undefined x, y or z parameter!\", \"error\");\n            return this;\n        }\n        this._translate.x = x;\n        this._translate.y = y;\n        this._translate.z = z;\n        return this;\n    }\n    /**\n     * Translates the entity by adding the passed values to\n     * the current translation values.\n     * @param {number} x The x co-ordinate.\n     * @param {number} y The y co-ordinate.\n     * @param {number} z The z co-ordinate.\n     * @example #Translate the entity by 10 along the x axis\n     *     entity.translateBy(10, 0, 0);\n     * @return {*}\n     */\n    translateBy(x, y, z) {\n        if (x === undefined || y === undefined || z === undefined) {\n            this.log(\"translateBy() called with a missing or undefined x, y or z parameter!\", \"error\");\n            return this;\n        }\n        this._translate.x += x;\n        this._translate.y += y;\n        this._translate.z += z;\n        return this;\n    }\n    /**\n     * Scale the entity to the passed values.\n     * @param {number} x The x co-ordinate.\n     * @param {number} y The y co-ordinate.\n     * @param {number} z The z co-ordinate.\n     * @example #Set the entity scale to 1 on all axes\n     *     entity.scaleTo(1, 1, 1);\n     * @return {*}\n     */\n    scaleTo(x, y, z) {\n        if (x === undefined || y === undefined || z === undefined) {\n            this.log(\"scaleTo() called with a missing or undefined x, y or z parameter!\", \"error\");\n            return this;\n        }\n        this._scale.x = x;\n        this._scale.y = y;\n        this._scale.z = z;\n        return this; // Used to include this._entity\n    }\n    /**\n     * Scales the entity by adding the passed values to\n     * the current scale values.\n     * @param {number} x The x co-ordinate.\n     * @param {number} y The y co-ordinate.\n     * @param {number} z The z co-ordinate.\n     * @example #Scale the entity by 2 on the x-axis\n     *     entity.scaleBy(2, 0, 0);\n     * @return {*}\n     */\n    scaleBy(x, y, z) {\n        if (x === undefined || y === undefined || z === undefined) {\n            this.log(\"scaleBy() called with a missing or undefined x, y or z parameter!\", \"error\");\n            return this;\n        }\n        this._scale.x += x;\n        this._scale.y += y;\n        this._scale.z += z;\n        return this;\n    }\n    /**\n     * Rotates the entity by adding the passed values to\n     * the current rotation values.\n     * @param {number} x The x co-ordinate.\n     * @param {number} y The y co-ordinate.\n     * @param {number} z The z co-ordinate.\n     * @example #Rotate the entity by 10 degrees about the z axis\n     *     entity.rotateBy(0, 0, degreesToRadians(10));\n     * @return {*}\n     */\n    rotateBy(x, y, z) {\n        if (x === undefined || y === undefined || z === undefined) {\n            this.log(\"rotateBy() called with a missing or undefined x, y or z parameter!\", \"error\");\n            return this;\n        }\n        this._rotate.x += x;\n        this._rotate.y += y;\n        this._rotate.z += z;\n        return this; // Used to include this._entity\n    }\n    /**\n     * Rotates the entity to the passed values.\n     * @param {number} x The x co-ordinate.\n     * @param {number} y The y co-ordinate.\n     * @param {number} z The z co-ordinate.\n     * @example #Rotate the entity to 10 degrees about the z axis\n     *     entity.rotateTo(0, 0, degreesToRadians(10));\n     * @return {*}\n     */\n    rotateTo(x, y, z) {\n        if (x === undefined || y === undefined || z === undefined) {\n            this.log(\"rotateTo() called with a missing or undefined x, y or z parameter!\", \"error\");\n            return this;\n        }\n        this._rotate.x = x;\n        this._rotate.y = y;\n        this._rotate.z = z;\n        return this;\n    }\n    originTo(x, y, z) {\n        if (x === undefined || y === undefined || z === undefined) {\n            this.log(\"originTo() called with a missing or undefined x, y or z parameter!\", \"error\");\n            return this;\n        }\n        this._origin.x = x;\n        this._origin.y = y;\n        this._origin.z = z;\n        return this;\n    }\n    disableInterpolation(val) {\n        if (val !== undefined) {\n            this._disableInterpolation = val;\n            return this;\n        }\n        return this._disableInterpolation;\n    }\n    compositeStream(val) {\n        if (val !== undefined) {\n            this._compositeStream = val;\n            return this;\n        }\n        return this._compositeStream;\n    }\n    streamSections(sectionArray) {\n        if (sectionArray !== undefined) {\n            this._streamSections = sectionArray;\n            return this;\n        }\n        return this._streamSections;\n    }\n    /**\n     * Adds a section into the existing streamed sections array.\n     * @param {string} sectionName The section name to add.\n     */\n    streamSectionsPush(sectionName) {\n        if (this._streamSections.indexOf(sectionName) > -1) {\n            throw new Error(`Attempting to add the stream section ${sectionName} failed, this section already exists!`);\n        }\n        this._streamSections = this._streamSections || [];\n        this._streamSections.push(sectionName);\n        return this;\n    }\n    /**\n     * Removes a section into the existing streamed sections array.\n     * @param {string} sectionName The section name to remove.\n     */\n    streamSectionsPull(sectionName) {\n        if (this._streamSections) {\n            (0,_engine_utils_arrays__WEBPACK_IMPORTED_MODULE_8__.arrPull)(this._streamSections, sectionName);\n        }\n        return this;\n    }\n    streamProperty(propName, propVal) {\n        if (!this._id || _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isClient)\n            return;\n        const network = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network;\n        this._streamProperty = this._streamProperty || {};\n        network._streamPropertyChange = network._streamPropertyChange || {};\n        network._streamPropertyChange[this._id] = network._streamPropertyChange[this._id] || {};\n        if (propVal !== undefined) {\n            if (this._streamProperty[propName] !== propVal) {\n                network._streamPropertyChange[this._id][propName] = true;\n            }\n            this._streamProperty[propName] = propVal;\n            return this;\n        }\n        return this._streamProperty[propName];\n    }\n    /**\n     * Called on the client-side when a property updated is received for this\n     * object from the server. Override this method in your own class to handle\n     * stream property changes.\n     * @param propName\n     * @param propVal\n     */\n    onStreamProperty(propName, propVal) {\n        return this;\n    }\n    streamMode(val) {\n        if (val !== undefined) {\n            if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isServer) {\n                this._streamMode = val;\n            }\n            return this;\n        }\n        return this._streamMode;\n    }\n    streamControl(method) {\n        if (method !== undefined) {\n            this._streamControl = method;\n            return this;\n        }\n        return this._streamControl;\n    }\n    streamSyncInterval(val, sectionId) {\n        if (val === undefined) {\n            return this._streamSyncInterval;\n        }\n        if (sectionId) {\n            this._streamSyncSectionInterval = this._streamSyncSectionInterval || {};\n            this._streamSyncSectionDelta = this._streamSyncSectionDelta || {};\n            if (val < 16) {\n                delete this._streamSyncSectionInterval[sectionId];\n            }\n            else {\n                this._streamSyncSectionDelta[sectionId] = 0;\n                this._streamSyncSectionInterval[sectionId] = val;\n            }\n            return this;\n        }\n        if (val < 16) {\n            delete this._streamSyncInterval;\n        }\n        else {\n            this._streamSyncDelta = 0;\n            this._streamSyncInterval = val;\n        }\n        return this;\n    }\n    streamFloatPrecision(val) {\n        if (val === undefined) {\n            return this._streamFloatPrecision;\n        }\n        this._streamFloatPrecision = val;\n        let i, floatRemove = \"\\\\.\";\n        // Update the floatRemove regular expression pattern\n        for (i = 0; i < this._streamFloatPrecision; i++) {\n            floatRemove += \"0\";\n        }\n        // Add the trailing comma\n        floatRemove += \",\";\n        // Create the new regexp\n        this._floatRemoveRegExp = new RegExp(floatRemove, \"g\");\n        return this;\n    }\n    /**\n     * Queues stream data for this entity to be sent to the\n     * specified client id or array of client ids.\n     * @param {Array} clientIds An array of string IDs of each\n     * client to send the stream data to.\n     * @return {IgeEntity} \"this\".\n     */\n    streamSync(clientIds) {\n        if (this._streamMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeStreamMode.simple) {\n            // In stream mode 1, the streamSync function will not\n            // be called with `clientIds` so we don't use that in this\n            // block of code\n            // Check if we have a stream sync interval\n            if (this._streamSyncInterval) {\n                this._streamSyncDelta += _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._tickDelta;\n                if (this._streamSyncDelta < this._streamSyncInterval) {\n                    // The stream sync interval is still higher than\n                    // the stream sync delta so exit without calling the\n                    // stream sync method\n                    return this;\n                }\n                else {\n                    // We've reached the delta we want so zero it now\n                    // ready for the next loop\n                    this._streamSyncDelta = 0;\n                }\n            }\n            // Grab an array of connected clients from the network system\n            const recipientArr = [];\n            const clientsById = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network.clients(this._streamRoomId);\n            Object.keys(clientsById).forEach((clientId) => {\n                // Check for a stream control method\n                if (this._streamControl) {\n                    // Call the callback method and if it returns true,\n                    // send the stream data to this client\n                    if (this._streamControl(clientId, this._streamRoomId)) {\n                        recipientArr.push(clientId);\n                    }\n                }\n                else {\n                    // No control method so process for this client\n                    recipientArr.push(clientId);\n                }\n            });\n            this._queueStreamDataToSend(recipientArr);\n            return this;\n        }\n        if (this._streamMode === _enums__WEBPACK_IMPORTED_MODULE_12__.IgeStreamMode.advanced) {\n            // Stream mode is advanced\n            this._queueStreamDataToSend(clientIds, this._streamRoomId);\n            return this;\n        }\n        return this;\n    }\n    /**\n     * Override this method if your entity should send arguments through to\n     * the client when it is being created on the client for the first\n     * time through the network stream. The array will be spread to the\n     * constructor call, so you should expect to receive it as per this example:\n     * @renamed This used to be called streamCreateData.\n     * @example #Using and Receiving Stream Create Constructor Arguments\n     *     class MyNewClass extends IgeEntity {\n     *         classId = \"MyNewClass\";\n     *\n     *         // Define the constructor with the parameter to receive the\n     *         // data you return from the streamCreateConstructorArgs() method\n     *         constructor (myFirstArg, mySecondArg) => {\n     *         \t   super();\n     *             this._myData1 = myFirstArg;\n     *             this._myData2 = mySecondArg;\n     *         }\n     *\n     *         streamCreateConstructorArgs () {\n     *             return [this._myData1, this._myData2];\n     *         }\n     *     });\n     *\n     * Valid return values must not include circular references and must be\n     * serialisable via JSON.stringify(). If you want to pass in instances\n     * of things to a constructor, modify the constructor to take the id of\n     * the instance and then do a lookup so that you can still pass the id via\n     * the network.\n     */\n    streamCreateConstructorArgs() {\n        // TODO: Do a sanity check in case the developer has forgotten to provide\n        //   vital info that will otherwise break the network stream\n        //   Extract the constructor function definition and then count the\n        //   number of arguments being returned here. Provide a warning to the\n        //   developer if they've potentially forgotten arguments. Warning can\n        //   be silenced by providing their own streamCreateConstructorArgs\n        //   function to override this one.\n        return;\n    }\n    /**\n     * Override this method if your entity should send arbitrary data through\n     * to the client when it is being created on the client for the first\n     * time through the network stream. The array will be received on the\n     * client via the `onStreamCreateInitialData()` event handler directly after\n     * being instantiated. The data is wrapped into the initial `_igeStreamCreate`\n     * network message sent from the server so the order of execution on receipt\n     * is:\n     *\n     * \t\tconstructor()\n     * \t\tid()\n     * \t\tmount()\n     * \t\tset transform (translate, rotate and scale)\n     * \t\tonStreamCreateInitialData()\n     *\n     * This means that the data that you have passed will have been provided to\n     * the `onStreamCreateInitialData()` before any subsequent code executes, as\n     * long as that code is outside the constructor and not related to setting\n     * the id, mounting or setting the initial transform of your class instance.\n     *\n     * If you need to execute a function in the constructor that relies on this\n     * arbitrary data, you should place it in a setTimeout so that the data has\n     * time to be assigned, or call it inside the `onStreamCreateInitialData()`\n     * function after you have dealt with the incoming data.\n     *\n     * You should expect to receive this data as per this example:\n     * @example #Using and Receiving Stream Create Initial Props\n     *     class MyNewClass extends IgeEntity {\n     *         classId = \"MyNewClass\";\n     *\n     *         constructor () {\n     *         \t   // This is set on the server-side\n     *             this._brand = \"awesomeBrand\";\n     *             this._color = \"amazingColor\";\n     *         }\n     *\n     *         streamCreateInitialData () {\n     *         \t   // This is called on the server-side\n     *             return [this._brand, this._color];\n     *         }\n     *\n     *         onStreamCreateInitialData = (data) => {\n     *         \t\t// This is received on the client-side\n     *         \t\tthis._brand = data[0]; // Will be \"awesomeBrand\"\n     *         \t\tthis._color = data[1]; // Will be \"amazingColor\"\n     *         }\n     *     });\n     *\n     * Valid return values must not include circular references and must be\n     * serialisable via JSON.stringify(). If you want to pass in instances\n     * of things to a constructor, modify the constructor to take the id of\n     * the instance and then do a lookup so that you can still pass the id via\n     * the network.\n     */\n    streamCreateInitialData() {\n        return;\n    }\n    onStreamCreateInitialData(data) {\n        if (data) {\n            console.log(data);\n            this.log(\"onStreamCreateInitialProps() received data but your class instance has not acted on it.\", \"warning\");\n        }\n        return;\n    }\n    streamEmitCreated(val) {\n        if (val !== undefined) {\n            this._streamEmitCreated = val;\n            return this;\n        }\n        return this._streamEmitCreated;\n    }\n    /**\n     * Asks the stream system to queue the stream data to the specified\n     * client id or array of ids.\n     * @param {Array} recipientArr The array of ids of the client(s) to\n     * queue stream data for. The stream data being queued\n     * is returned by a call to this._generateStreamData().\n     * @param {string} streamRoomId The id of the room the entity belongs\n     * in (can be undefined or null if no room assigned).\n     * @private\n     */\n    _queueStreamDataToSend(recipientArr = [], streamRoomId) {\n        const arrCount = recipientArr.length;\n        const thisId = this.id();\n        const filteredArr = [];\n        const network = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network;\n        let data = \"\";\n        let createResult = true; // We set this to true by default\n        // Loop the recipient array\n        for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n            const clientId = recipientArr[arrIndex];\n            // Check if the client has already received a create\n            // command for this entity\n            network._streamClientCreated[thisId] = network._streamClientCreated[thisId] || {};\n            if (!network._streamClientCreated[thisId][clientId]) {\n                createResult = this.sendStreamCreate(clientId);\n            }\n            // Make sure that if we had to create the entity for\n            // this client that the operation worked before bothering\n            // to waste bandwidth on stream updates\n            if (createResult) {\n                // Get the stream data\n                data = this._generateStreamData();\n                // Is the data different from the last data we sent\n                // this client?\n                network._streamClientData[thisId] = network._streamClientData[thisId] || {};\n                if (network._streamClientData[thisId][clientId] !== data) {\n                    filteredArr.push(clientId);\n                    // Store the new data for later comparison\n                    network._streamClientData[thisId][clientId] = data;\n                }\n            }\n        }\n        if (filteredArr.length) {\n            network.queue(thisId, data, filteredArr);\n        }\n    }\n    /**\n     * Forces the stream to push this entity's full stream data on the\n     * next stream sync regardless of what clients have received in the\n     * past. This should only be used when required rather than every\n     * tick as it will reduce the overall efficiency of the stream if\n     * used every tick.\n     * @returns {*}\n     */\n    streamForceUpdate() {\n        const thisId = this.id();\n        const network = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network;\n        // Invalidate the stream client data lookup to ensure\n        // the latest data will be pushed on the next stream sync\n        if (network && network._streamClientData && network._streamClientData[thisId]) {\n            network._streamClientData[thisId] = {};\n        }\n        return this;\n    }\n    /**\n     * Issues a create entity command to the passed client id\n     * or array of ids. If no id is passed it will issue the\n     * command to all connected clients. If using streamMode(1)\n     * this method is called automatically.\n     * @param {*} clientId The id or array of ids to send\n     * the command to.\n     * @renamed Was called streamCreate.\n     * @example #Send a create command for this entity to all clients.\n     *     entity.sendStreamCreate();\n     * @example #Send a create command for this entity to an array of client ids\n     *     entity.sendStreamCreate(['43245325', '326755464', '436743453']);\n     * @example #Send a create command for this entity to a single client id\n     *     entity.sendStreamCreate('43245325');\n     * @return {Boolean}\n     */\n    sendStreamCreate(clientId) {\n        if (!this._parent) {\n            return false;\n        }\n        const thisId = this.id();\n        const network = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network;\n        // Send the client an entity create command first\n        network.send(_enums__WEBPACK_IMPORTED_MODULE_12__.IGE_NETWORK_STREAM_CREATE, [\n            this.constructor.name,\n            thisId,\n            this._parent.id(),\n            this.streamCreateConstructorArgs(),\n            this.streamSectionData(\"transform\"),\n            this.streamCreateInitialData()\n        ], clientId);\n        network._streamClientCreated[thisId] = network._streamClientCreated[thisId] || {};\n        if (clientId) {\n            if (typeof clientId === \"string\") {\n                // Mark the client as having received a create\n                // command for this entity\n                network._streamClientCreated[thisId][clientId] = true;\n            }\n            else {\n                // The clientId is an array of strings\n                clientId.forEach((tmpClientId) => {\n                    // Mark the client as having received a create\n                    // command for this entity\n                    network._streamClientCreated[thisId][tmpClientId] = true;\n                });\n            }\n        }\n        else {\n            // Mark all clients as having received this create\n            const clientsById = network.clients();\n            Object.keys(clientsById).forEach((tmpClientId) => {\n                network._streamClientCreated[thisId][tmpClientId] = true;\n            });\n        }\n        return true;\n    }\n    /**\n     * Gets / sets the data for the specified data section id. This method\n     * is usually not called directly and instead is part of the network\n     * stream system. General use case is to write your own custom streamSectionData\n     * method in a class that extends IgeEntity so that you can control the\n     * data that the entity will send and receive over the network stream.\n     * @param {String} sectionId A string identifying the section to\n     * handle data get / set for.\n     * @param {*=} data If present, this is the data that has been sent\n     * from the server to the client for this entity. If not present then\n     * we should return the data to be sent over the network.\n     * @param {Boolean=} bypassTimeStream If true, will assign transform\n     * directly to entity instead of adding the values to the time stream.\n     * @param {Boolean=} bypassChangeDetection If set to true, bypasses\n     * any change detection on stream data (useful especially when we are\n     * sending stream data to a client for the first time even if the data\n     * has existed on the server for a while - ensuring that even unchanged\n     * data makes it to the new client).\n     * @return {*} \"this\" when a data argument is passed to allow method\n     * chaining or the current value if no data argument is specified.\n     */\n    streamSectionData(sectionId, data, bypassTimeStream = false, bypassChangeDetection = false) {\n        switch (sectionId) {\n            case \"transform\":\n                if (data) {\n                    // We have received updated data\n                    const dataArr = data.split(\",\");\n                    const network = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network;\n                    if (!this._disableInterpolation && !bypassTimeStream && !this._streamJustCreated) {\n                        const parsedDataArr = dataArr.map((dataItem) => {\n                            return parseFloat(dataItem);\n                        });\n                        // Add it to the time stream\n                        this._timeStream.push([network._streamDataTime + network._latency, parsedDataArr]);\n                        // Check stream length, don't allow higher than 10 items\n                        if (this._timeStream.length > 10) {\n                            // Remove the first item\n                            this._timeStream.shift();\n                        }\n                    }\n                    else {\n                        // Assign all the transform values immediately\n                        this.translateTo(parseFloat(dataArr[0]), parseFloat(dataArr[1]), parseFloat(dataArr[2]));\n                        //this._translate.x = parseFloat(dataArr[0]);\n                        //this._translate.y = parseFloat(dataArr[1]);\n                        //this._translate.z = parseFloat(dataArr[2]);\n                        // Scale\n                        this.scaleTo(parseFloat(dataArr[3]), parseFloat(dataArr[4]), parseFloat(dataArr[5]));\n                        //this._scale.x = parseFloat(dataArr[3]);\n                        //this._scale.y = parseFloat(dataArr[4]);\n                        //this._scale.z = parseFloat(dataArr[5]);\n                        // Rotate\n                        this.rotateTo(parseFloat(dataArr[6]), parseFloat(dataArr[7]), parseFloat(dataArr[8]));\n                        //this._rotate.x = parseFloat(dataArr[6]);\n                        //this._rotate.y = parseFloat(dataArr[7]);\n                        //this._rotate.z = parseFloat(dataArr[8]);\n                        // If we are using composite caching ensure we update the cache\n                        if (this._compositeCache) {\n                            this.cacheDirty(true);\n                        }\n                    }\n                }\n                else {\n                    // We should return the transform data as a comma separated string\n                    return (this._translate.toString(this._streamFloatPrecision) +\n                        \",\" + // translate\n                        this._scale.toString(this._streamFloatPrecision) +\n                        \",\" + // scale\n                        this._rotate.toString(this._streamFloatPrecision)); // rotate\n                }\n                break;\n            case \"depth\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isClient) {\n                        this.depth(parseInt(data));\n                    }\n                }\n                else {\n                    return String(this.depth());\n                }\n                break;\n            case \"layer\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isClient) {\n                        this.layer(parseInt(data));\n                    }\n                }\n                else {\n                    return String(this.layer());\n                }\n                break;\n            case \"mount\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isClient) {\n                        if (data) {\n                            const newParent = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.$(data);\n                            if (newParent) {\n                                this.mount(newParent);\n                            }\n                        }\n                        else {\n                            // Unmount\n                            this.unMount();\n                        }\n                    }\n                }\n                else {\n                    const parent = this.parent();\n                    if (parent) {\n                        return parent.id();\n                    }\n                    else {\n                        return \"\";\n                    }\n                }\n                break;\n            case \"origin\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isClient) {\n                        const geom = data.split(\",\");\n                        this.originTo(parseFloat(geom[0]), parseFloat(geom[1]), parseFloat(geom[2]));\n                        //this._origin.x = parseFloat(geom[0]);\n                        //this._origin.y = parseFloat(geom[1]);\n                        //this._origin.z = parseFloat(geom[2]);\n                    }\n                }\n                else {\n                    return String(this._origin.x + \",\" + this._origin.y + \",\" + this._origin.z);\n                }\n                break;\n            case \"props\":\n                if (data !== undefined) {\n                    if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_9__.isClient) {\n                        this._streamProperty = this._streamProperty || {};\n                        const props = JSON.parse(data);\n                        // Update properties that have been sent through\n                        for (const i in props) {\n                            if (this._streamProperty[i] !== props[i]) {\n                                //console.log('Updated stream property ' + i + ' to', props[i]);\n                                this._streamProperty[i] = props[i];\n                                if (this.onStreamProperty) {\n                                    this.onStreamProperty(i, props[i]);\n                                }\n                                this.emit(\"streamPropChange\", i, props[i]);\n                            }\n                        }\n                    }\n                }\n                else {\n                    const newData = {};\n                    const network = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network;\n                    for (const i in this._streamProperty) {\n                        if ((network._streamPropertyChange &&\n                            network._streamPropertyChange[this._id] &&\n                            network._streamPropertyChange[this._id][i]) ||\n                            bypassChangeDetection) {\n                            newData[i] = this._streamProperty[i];\n                        }\n                    }\n                    return JSON.stringify(newData);\n                }\n                break;\n        }\n    }\n    /**\n     * Issues a `destroy entity` command to the passed client id\n     * or array of ids. If no id is passed it will issue the\n     * command to all connected clients. If using streamMode(1)\n     * this method is called automatically.\n     * @param {*} clientId The id or array of ids to send\n     * the command to.\n     * @example #Send a destroy command for this entity to all clients.\n     *     entity.streamDestroy();\n     * @example #Send a destroy command for this entity to an array of client ids.\n     *     entity.streamDestroy(['43245325', '326755464', '436743453']);\n     * @example #Send a destroy command for this entity to a single client id.\n     *     entity.streamDestroy('43245325');\n     * @return {Boolean}\n     */\n    streamDestroy(clientId) {\n        const thisId = this.id();\n        const network = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network;\n        // Send clients the stream destroy command for this entity\n        network.send(_enums__WEBPACK_IMPORTED_MODULE_12__.IGE_NETWORK_STREAM_DESTROY, [_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime, thisId], clientId);\n        network._streamClientCreated[thisId] = network._streamClientCreated[thisId] || {};\n        network._streamClientData[thisId] = network._streamClientData[thisId] || {};\n        if (clientId) {\n            // Mark the client as having received a destroy\n            // command for this entity\n            network._streamClientCreated[thisId][clientId] = false;\n            network._streamClientData[thisId][clientId] = \"\";\n            return true;\n        }\n        // Mark all clients as having received this destroy\n        const clientsById = network.clients();\n        Object.keys(clientsById).forEach((tmpClientId) => {\n            network._streamClientCreated[thisId][tmpClientId] = false;\n            network._streamClientData[thisId][tmpClientId] = \"\";\n        });\n        return true;\n    }\n    /**\n     * Generates and returns the current stream data for this entity. The\n     * data will usually include only properties that have changed since\n     * the last time the stream data was generated. The returned data is\n     * a string that has been compressed in various ways to reduce network\n     * overhead during transmission.\n     * @return {String} The string representation of the stream data for\n     * this entity.\n     * @private\n     */\n    _generateStreamData() {\n        // Check if we already have a cached version of the streamData\n        if (this._streamDataCache) {\n            return this._streamDataCache;\n        }\n        // Let's generate our stream data\n        const sectionArr = this._streamSections;\n        const sectionCount = sectionArr.length;\n        let streamData = \"\", sectionDataString = \"\", sectionData, sectionIndex, sectionId;\n        // Add the entity id\n        streamData += this.id();\n        // Only send further data if the entity is still \"alive\"\n        if (this._alive) {\n            // Now loop the data sections array and compile the rest of the\n            // data string from the data section return data\n            for (sectionIndex = 0; sectionIndex < sectionCount; sectionIndex++) {\n                sectionData = \"\";\n                sectionId = sectionArr[sectionIndex];\n                // Stream section sync intervals allow individual stream sections\n                // to be streamed at different (usually longer) intervals than other\n                // sections, so you could for instance reduce the number of updates\n                // a particular section sends out in a second because the data is\n                // not that important compared to updated transformation data\n                if (this._streamSyncSectionInterval && this._streamSyncSectionInterval[sectionId]) {\n                    // Check if the section interval has been reached\n                    this._streamSyncSectionDelta[sectionId] += _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._tickDelta;\n                    if (this._streamSyncSectionDelta[sectionId] >= this._streamSyncSectionInterval[sectionId]) {\n                        // Get the section data for this section id\n                        sectionData = this.streamSectionData(sectionId);\n                        // Reset the section delta\n                        this._streamSyncSectionDelta[sectionId] = 0;\n                    }\n                }\n                else {\n                    // Get the section data for this section id\n                    sectionData = this.streamSectionData(sectionId);\n                }\n                // Add the section start designator character. We do this\n                // regardless of if there is actually any section data because\n                // we want to be able to identify sections in a serial fashion\n                // on receipt of the data string on the client\n                sectionDataString += _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network._sectionDesignator;\n                // Check if we were returned any data\n                if (sectionData !== undefined) {\n                    // Add the data to the section string\n                    sectionDataString += sectionData;\n                }\n            }\n            // Add any custom data to the stream string at this point\n            if (sectionDataString) {\n                streamData += sectionDataString;\n            }\n            // Remove any .00 from the string since we don't need that data\n            // TODO: What about if a property is a string with something.00 and it should be kept?\n            streamData = streamData.replace(this._floatRemoveRegExp, \",\");\n        }\n        // Store the data in cache in case we are asked for it again this tick\n        // the update() method of the IgeEntity class clears this every tick\n        this._streamDataCache = streamData;\n        return streamData;\n    }\n    /**\n     * Removes all references to any behaviour methods that were added to\n     * this object.\n     */\n    destroyBehaviours() {\n        this._behaviours = {};\n    }\n    /**\n     * Destroys the object and all it's child objects, removing them from the\n     * scenegraph and from memory.\n     */\n    destroy() {\n        // Remove ourselves from any parent\n        this.unMount();\n        // Remove any children\n        if (this._children) {\n            this.destroyChildren();\n        }\n        // Remove any behaviours\n        this.destroyBehaviours();\n        // Remove the object from the lookup system\n        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.register.remove(this);\n        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.categoryRegister.remove(this);\n        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.groupRegister.remove(this);\n        // Set a flag in case a reference to this object\n        // has been held somewhere, shows that the object\n        // should no longer be interacted with\n        this._alive = false;\n        // Remove the event listeners array in case any\n        // object references still exist there\n        this._eventListeners = {};\n        return this;\n    }\n    /**\n     * Calculates the axis-aligned bounding box for this entity, including\n     * all child entity bounding boxes and returns the final composite\n     * bounds.\n     * @example #Get the composite AABB\n     *     var entity = new IgeEntity(),\n     *         aabb = entity.compositeAabb();\n     * @return {IgeBounds}\n     */\n    compositeAabb(inverse = false) {\n        const arr = this._children;\n        const rect = this.aabb(true, inverse).clone();\n        // Now loop all children and get the aabb for each of\n        // them add those bounds to the current rect\n        if (arr) {\n            let arrCount = arr.length;\n            while (arrCount--) {\n                rect.thisCombineRect(arr[arrCount].compositeAabb(inverse));\n            }\n        }\n        return rect;\n    }\n    /**\n     * Returns a string containing a code fragment that when\n     * evaluated will reproduce this object.\n     * @return {String}\n     */\n    stringify(options = {}) {\n        // TODO: Use the advanced serialiser system from ForerunnerDB\n        let str = `new ${this.constructor.name}()`;\n        // Every object has an ID, assign that first\n        if (options.id) {\n            str += `.id('${this.id()}')`;\n        }\n        // Now check if there is a parent and mount that\n        const parent = this.parent();\n        if (options.mount && parent) {\n            str += `.mount($ige.engine.$('${parent.id()}'))`;\n        }\n        // Now get all other properties\n        str += this._stringify(options);\n        return str;\n    }\n    /**\n     * Returns a string containing a code fragment that when\n     * evaluated will reproduce this object's properties via\n     * chained commands. This method will only check for\n     * properties that are directly related to this class.\n     * Other properties are handled by their own class method.\n     * @return {String}\n     */\n    _stringify(options = {}) {\n        let str = \"\";\n        // Loop properties and add property assignment code to string\n        for (const key in this) {\n            if (this.hasOwnProperty(key) && this[key] !== undefined) {\n                switch (key) {\n                    case \"_category\":\n                        str += \".category(\" + this.category() + \")\";\n                        break;\n                    case \"_drawBounds\":\n                        str += \".drawBounds(\" + this.drawBounds() + \")\";\n                        break;\n                    case \"_drawBoundsData\":\n                        str += \".drawBoundsData(\" + this.drawBoundsData() + \")\";\n                        break;\n                    case \"_drawMouse\":\n                        str += \".drawMouse(\" + this.drawMouse() + \")\";\n                        break;\n                    case \"_isometricMounts\":\n                        str += \".isometricMounts(\" + this.isometricMounts() + \")\";\n                        break;\n                    case \"_indestructible\":\n                        str += \".indestructible(\" + this.indestructible() + \")\";\n                        break;\n                    case \"_layer\":\n                        str += \".layer(\" + this.layer() + \")\";\n                        break;\n                    case \"_depth\":\n                        str += \".depth(\" + this.depth() + \")\";\n                        break;\n                }\n            }\n        }\n        return str;\n    }\n    addComponent(id, Component, options) {\n        const instance = new Component(this, options);\n        instance._entity = this;\n        this.components[id] = instance;\n        return this;\n    }\n    removeComponent(id) {\n        const instance = this.components[id];\n        if (!instance)\n            return this;\n        if (instance && instance.destroy) {\n            instance.destroy();\n        }\n        delete this.components[id];\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeObject.ts?");

/***/ }),

/***/ "./src/engine/core/IgePoint2d.ts":
/*!***************************************!*\
  !*** ./src/engine/core/IgePoint2d.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgePoint2d: () => (/* binding */ IgePoint2d)\n/* harmony export */ });\n/**\n * Creates a new 2d point (x, y).\n */\nclass IgePoint2d {\n    constructor(x = 0, y = 0, floor = false) {\n        this.classId = \"IgePoint2d\";\n        this.x = 0;\n        this.y = 0;\n        this.x2 = 0;\n        this.y2 = 0;\n        this._floor = false;\n        this.x = x;\n        this.y = y;\n        this._floor = floor;\n        if (this._floor) {\n            this.x2 = Math.floor(x / 2);\n            this.y2 = Math.floor(y / 2);\n            return this;\n        }\n        this.x2 = x / 2;\n        this.y2 = y / 2;\n    }\n    floor(val) {\n        if (val !== undefined) {\n            this._floor = val;\n            return this;\n        }\n        return this._floor;\n    }\n    /**\n     * Compares this point's x, y data with the passed point and returns\n     * true if they are the same and false if any is different.\n     * @param {IgePoint2d} point The point to compare data with.\n     * @return {Boolean}\n     */\n    compare(point) {\n        return point && this.x === point.x && this.y === point.y;\n    }\n    /**\n     * Copies the x, y data from the passed point and overwrites this\n     * point's data with those values.\n     * @param {IgePoint2d} point The point to copy values from.\n     * @returns {*}\n     */\n    copy(point) {\n        this.x = point.x;\n        this.y = point.y;\n        return this;\n    }\n    /**\n     * Converts the point's x, y to an isometric x, y 2d co-ordinate\n     * and returns an object whose x, y values are the result.\n     * @return {Object}\n     */\n    toIso() {\n        return {\n            x: this.x - this.y,\n            y: (this.x + this.y) * 0.5\n        };\n    }\n    /**\n     * Converts this point's x, y data into isometric co-ordinate space\n     * and overwrites the previous x, y values with the result.\n     * @return {*}\n     */\n    thisToIso() {\n        const val = this.toIso();\n        this.x = val.x;\n        this.y = val.y;\n        return this;\n    }\n    /**\n     * Converts this point's x, y data into 2d co-ordinate space\n     * and returns an object whose x, y values are the result.\n     * @return {Object}\n     */\n    to2d() {\n        return {\n            x: this.y + this.x / 2,\n            y: this.y - this.x / 2\n        };\n    }\n    /**\n     * Converts this point's x, y data into 2d co-ordinate space\n     * and overwrites the previous x, y values with the result.\n     * @return {*}\n     */\n    thisTo2d() {\n        const val = this.to2d();\n        this.x = val.x;\n        this.y = val.y;\n        return this;\n    }\n    /**\n     * Adds this point's data by the x, y, values specified\n     * and returns a new IgePoint2d whose values are the result.\n     * @param point\n     * @return {*}\n     */\n    addPoint(point) {\n        return new IgePoint2d(this.x + point.x, this.y + point.y);\n    }\n    /**\n     * Adds this point's data by the x, y values specified and\n     * overwrites the previous x, y values with the result.\n     * @param point\n     * @return {*}\n     */\n    thisAddPoint(point) {\n        this.x += point.x;\n        this.y += point.y;\n        return this;\n    }\n    /**\n     * Minuses this point's data by the x, y values specified\n     * and returns a new IgePoint2d whose values are the result.\n     * @param point\n     * @return {*}\n     */\n    minusPoint(point) {\n        return new IgePoint2d(this.x - point.x, this.y - point.y);\n    }\n    /**\n     * Minuses this point's data by the x, y values specified and\n     * overwrites the previous x, y values with the result.\n     * @param point\n     * @return {*}\n     */\n    thisMinusPoint(point) {\n        this.x -= point.x;\n        this.y -= point.y;\n        return this;\n    }\n    /**\n     * Multiplies this point's data by the x, y values specified\n     * and returns a new IgePoint2d whose values are the result.\n     * @param x\n     * @param y\n     * @return {*}\n     */\n    multiply(x, y) {\n        return new IgePoint2d(this.x * x, this.y * y);\n    }\n    /**\n     * Multiplies this point's data by the point specified\n     * and returns a new IgePoint2d whose values are the result.\n     * @param point\n     * @return {*}\n     */\n    multiplyPoint(point) {\n        return new IgePoint2d(this.x * point.x, this.y * point.y);\n    }\n    /**\n     * Multiplies this point's data by the x, y values specified and\n     * overwrites the previous x, y values with the result.\n     * @param {number} x\n     * @param {number} y\n     * @return {*}\n     */\n    thisMultiply(x, y) {\n        this.x *= x;\n        this.y *= y;\n        return this;\n    }\n    /**\n     * Divides this point's data by the x, y values specified\n     * and returns a new IgePoint2d whose values are the result.\n     * @param {number} x\n     * @param {number} y\n     * @return {*}\n     */\n    divide(x, y) {\n        return new IgePoint2d(this.x / x, this.y / y);\n    }\n    /**\n     * Divides this point's data by the point specified\n     * and returns a new IgePoint2d whose values are the result.\n     * @param {IgePoint2d} point\n     * @return {*}\n     */\n    dividePoint(point) {\n        let newX = this.x, newY = this.y;\n        if (point.x) {\n            newX = this.x / point.x;\n        }\n        if (point.y) {\n            newY = this.y / point.y;\n        }\n        return new IgePoint2d(newX, newY);\n    }\n    /**\n     * Divides this point's data by the x, y values specified and\n     * overwrites the previous x, y values with the result.\n     * @param {number} x\n     * @param {number} y\n     * @return {*}\n     */\n    thisDivide(x, y) {\n        this.x /= x;\n        this.y /= y;\n        return this;\n    }\n    /**\n     * Returns a clone of this IgePoint2d's data as a new instance.\n     * @return {*}\n     */\n    clone() {\n        return new IgePoint2d(this.x, this.y);\n    }\n    /**\n     * Interpolates the x, y values of this point towards the endPoint's\n     * x, y values based on the passed time variables and returns a new\n     * IgePoint2d whose values are the result.\n     * @param {IgePoint2d} endPoint\n     * @param {number} startTime\n     * @param {number} currentTime\n     * @param {number} endTime\n     * @return {*}\n     */\n    interpolate(endPoint, startTime, currentTime, endTime) {\n        const totalX = endPoint.x - this.x, totalY = endPoint.y - this.y, totalTime = endTime - startTime, deltaTime = totalTime - (currentTime - startTime), timeRatio = deltaTime / totalTime;\n        return new IgePoint2d(endPoint.x - totalX * timeRatio, endPoint.y - totalY * timeRatio);\n    }\n    /**\n     * Rotates the point by the given radians.\n     * @param {number} radians Radians to rotate by.\n     * @return {IgePoint2d} A new point with the rotated x, y.\n     */\n    rotate(radians) {\n        const s = Math.sin(radians), c = Math.cos(radians), x = c * this.x - s * this.y, y = s * this.x - c * this.y;\n        return new IgePoint2d(x, y);\n    }\n    /**\n     * Rotates the point by the given radians and updates this point\n     * to the new x, y values.\n     * @param {number} radians Radians to rotate by.\n     * @return {IgePoint2d} This point.\n     */\n    thisRotate(radians) {\n        const s = Math.sin(radians), c = Math.cos(radians), { x, y } = this;\n        this.x = c * x - s * y;\n        this.y = s * x - c * y;\n        return this;\n    }\n    /**\n     * Returns a string representation of the point's x, y\n     * converting floating point values into fixed using the\n     * passed precision parameter. If no precision is specified\n     * then the precision defaults to 2.\n     * @param {number} [precision]\n     * @return {String}\n     */\n    toString(precision = 2) {\n        return this.x.toFixed(precision) + \",\" + this.y.toFixed(precision);\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgePoint2d.ts?");

/***/ }),

/***/ "./src/engine/core/IgePoly2d.ts":
/*!**************************************!*\
  !*** ./src/engine/core/IgePoly2d.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgePoly2d: () => (/* binding */ IgePoly2d)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeBounds */ \"./src/engine/core/IgeBounds.ts\");\n/* harmony import */ var _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/IgePoint2d */ \"./src/engine/core/IgePoint2d.ts\");\n/* harmony import */ var _engine_utils_intersections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/utils/intersections */ \"./src/engine/utils/intersections.ts\");\n\n\n\n/**\n * Creates a new 2d polygon made up of IgePoint2d instances.\n */\nclass IgePoly2d {\n    constructor() {\n        this.classId = \"IgePoly2d\";\n        this.x = 0;\n        this.y = 0;\n        this._igeShapeType = \"polygon\";\n        this._poly = [];\n        this._scale = new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_1__.IgePoint2d(1, 1);\n    }\n    translateTo(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    translateBy(x, y) {\n        this.x += x;\n        this.y += y;\n        return this;\n    }\n    scale(x, y) {\n        if (x !== undefined && y !== undefined) {\n            this._scale.x = x;\n            this._scale.y = y;\n            return this;\n        }\n        return this._scale;\n    }\n    /**\n     * Multiplies the points of the polygon by the supplied factor.\n     * @param {number} factor The multiplication factor.\n     * @return {*}\n     */\n    multiply(factor) {\n        // TODO: Look at IgeBounds and normalise this function name\n        if (factor !== undefined) {\n            const polyPoints = this._poly;\n            const pointCount = polyPoints.length;\n            for (let pointIndex = 0; pointIndex < pointCount; pointIndex++) {\n                polyPoints[pointIndex].x *= factor;\n                polyPoints[pointIndex].y *= factor;\n            }\n        }\n        return this;\n    }\n    /**\n     * Divides the points of the polygon by the supplied value.\n     * @param {number} value The divide value.\n     * @return {*}\n     */\n    divide(value) {\n        if (value !== undefined) {\n            const polyPoints = this._poly;\n            const pointCount = polyPoints.length;\n            for (let pointIndex = 0; pointIndex < pointCount; pointIndex++) {\n                polyPoints[pointIndex].x /= value;\n                polyPoints[pointIndex].y /= value;\n            }\n        }\n        return this;\n    }\n    /**\n     * Adds a point to the polygon relative to the polygon center at 0, 0.\n     * @param {number} x\n     * @param {number} y\n     */\n    addPoint(x, y) {\n        this._poly.push(new _engine_core_IgePoint2d__WEBPACK_IMPORTED_MODULE_1__.IgePoint2d(x, y));\n        return this;\n    }\n    /**\n     * Returns the length of the poly array.\n     * @return {number}\n     */\n    length() {\n        return this._poly.length;\n    }\n    /**\n     * Check if a point is inside this polygon.\n     * @deprecated Please use pointInside() instead.\n     */\n    pointInPoly() {\n        throw new Error(\"Deprecated, please use pointInside() instead.\");\n    }\n    /**\n     * Check if a point is inside this polygon.\n     * @param {IgePoint2d | IgePoint3d} point\n     * @return {boolean}\n     */\n    pointInside(point) {\n        return this.xyInside(point.x, point.y);\n    }\n    /**\n     * Check if the passed x and y are inside this polygon.\n     * @param {number} x\n     * @param {number} y\n     * @return {boolean}\n     */\n    xyInside(x, y) {\n        const polyPoints = this._poly;\n        const pointCount = polyPoints.length;\n        let oldPointIndex = pointCount - 1;\n        let c = false;\n        for (let pointIndex = 0; pointIndex < pointCount; oldPointIndex = pointIndex++) {\n            if (polyPoints[pointIndex].y > y !== polyPoints[oldPointIndex].y > y &&\n                x <\n                    ((polyPoints[oldPointIndex].x - polyPoints[pointIndex].x) * (y - polyPoints[pointIndex].y)) /\n                        (polyPoints[oldPointIndex].y - polyPoints[pointIndex].y) +\n                        polyPoints[pointIndex].x) {\n                c = !c;\n            }\n        }\n        return c;\n    }\n    /**\n     * Calculates and returns the axis-aligned bounding-box for this polygon.\n     */\n    aabb() {\n        const xArr = [];\n        const yArr = [];\n        const arr = this._poly;\n        const arrCount = arr.length;\n        for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n            xArr.push(arr[arrIndex].x);\n            yArr.push(arr[arrIndex].y);\n        }\n        // Get the extents of the newly transformed poly\n        const minX = Math.min(...xArr);\n        const minY = Math.min(...yArr);\n        const maxX = Math.max(...xArr);\n        const maxY = Math.max(...yArr);\n        return new _engine_core_IgeBounds__WEBPACK_IMPORTED_MODULE_0__.IgeBounds(minX, minY, maxX - minX, maxY - minY);\n    }\n    /**\n     * Returns a copy of this IgePoly2d object that is its own version,\n     * separate from the original.\n     * @return {IgePoly2d}\n     */\n    clone() {\n        const newPoly = new IgePoly2d();\n        const arr = this._poly;\n        const arrCount = arr.length;\n        for (let i = 0; i < arrCount; i++) {\n            newPoly.addPoint(arr[i].x, arr[i].y);\n        }\n        newPoly.scale(this._scale.x, this._scale.y);\n        return newPoly;\n    }\n    /**\n     * Determines if the polygon is clockwise or not.\n     * @return {boolean} A boolean true if clockwise or false if not.\n     */\n    clockWiseTriangle() {\n        // Loop the polygon points and determine if they are counter-clockwise\n        const arr = this._poly;\n        const p1 = arr[0];\n        const p2 = arr[1];\n        const p3 = arr[2];\n        const val = p1.x * p2.y + p2.x * p3.y + p3.x * p1.y - p2.y * p3.x - p3.y * p1.x - p1.y * p2.x;\n        return val > 0;\n    }\n    /**\n     * Modifies the points of this triangle so that the points are clock-wise.\n     */\n    makeClockWiseTriangle() {\n        // If our data is already clockwise exit\n        if (this.clockWiseTriangle())\n            return;\n        const p1 = this._poly[1];\n        const p2 = this._poly[2];\n        this._poly[2] = p1;\n        this._poly[1] = p2;\n    }\n    /**\n     * Converts this polygon into many triangles so that there are no convex\n     * parts to the polygon.\n     */\n    triangulate() {\n        // Get the indices of each new triangle\n        const poly = this._poly;\n        const triangles = [];\n        const indices = this.triangulationIndices();\n        // Generate new polygons from the index data\n        for (let i = 0; i < indices.length; i += 3) {\n            const point1 = poly[indices[i]];\n            const point2 = poly[indices[i + 1]];\n            const point3 = poly[indices[i + 2]];\n            const newPoly = new IgePoly2d();\n            newPoly.addPoint(point1.x, point1.y);\n            newPoly.addPoint(point2.x, point2.y);\n            newPoly.addPoint(point3.x, point3.y);\n            // Check the new poly and make sure it's clockwise\n            newPoly.makeClockWiseTriangle();\n            triangles.push(newPoly);\n        }\n        return triangles;\n    }\n    triangulationIndices() {\n        const indices = [];\n        const n = this._poly.length;\n        const V = [];\n        if (n < 3) {\n            return indices;\n        }\n        if (this._area() > 0) {\n            for (let v = 0; v < n; v++) {\n                V[v] = v;\n            }\n        }\n        else {\n            for (let v = 0; v < n; v++) {\n                V[v] = n - 1 - v;\n            }\n        }\n        let nv = n;\n        let count = 2 * nv;\n        for (let v = nv - 1; nv > 2;) {\n            if (count-- <= 0) {\n                return indices;\n            }\n            let u = v;\n            if (nv <= u) {\n                u = 0;\n            }\n            v = u + 1;\n            if (nv <= v) {\n                v = 0;\n            }\n            let w = v + 1;\n            if (nv <= w) {\n                w = 0;\n            }\n            if (this._snip(u, v, w, nv, V)) {\n                const a = V[u];\n                const b = V[v];\n                const c = V[w];\n                indices.push(a);\n                indices.push(b);\n                indices.push(c);\n                let s = v;\n                for (let t = v + 1; t < nv; t++) {\n                    V[s] = V[t];\n                    s++;\n                }\n                nv--;\n                count = 2 * nv;\n            }\n        }\n        indices.reverse();\n        return indices;\n    }\n    _area() {\n        const n = this._poly.length;\n        let a = 0.0;\n        let q = 0;\n        for (let p = n - 1; q < n; p = q++) {\n            const pval = this._poly[p];\n            const qval = this._poly[q];\n            a += pval.x * qval.y - qval.x * pval.y;\n        }\n        return a * 0.5;\n    }\n    _snip(u, v, w, n, V) {\n        const A = this._poly[V[u]];\n        const B = this._poly[V[v]];\n        const C = this._poly[V[w]];\n        // Replaced Math.Epsilon with 0.00001\n        if (0.00001 > (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x)) {\n            return false;\n        }\n        for (let p = 0; p < n; p++) {\n            // eslint-disable-next-line eqeqeq\n            if (p == u || p == v || p == w) {\n                continue;\n            }\n            const P = this._poly[V[p]];\n            if (this._insideTriangle(A, B, C, P)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Determines if the point P is inside the triangle defined by points\n     * A, B and C.\n     * @param {IgePoint2d} A\n     * @param {IgePoint2d} B\n     * @param {IgePoint2d} C\n     * @param {IgePoint2d} P\n     */\n    _insideTriangle(A, B, C, P) {\n        const ax = C.x - B.x;\n        const ay = C.y - B.y;\n        const bx = A.x - C.x;\n        const by = A.y - C.y;\n        const cx = B.x - A.x;\n        const cy = B.y - A.y;\n        const apx = P.x - A.x;\n        const apy = P.y - A.y;\n        const bpx = P.x - B.x;\n        const bpy = P.y - B.y;\n        const cpx = P.x - C.x;\n        const cpy = P.y - C.y;\n        const aCROSSbp = ax * bpy - ay * bpx;\n        const cCROSSap = cx * apy - cy * apx;\n        const bCROSScp = bx * cpy - by * cpx;\n        return aCROSSbp >= 0.0 && bCROSScp >= 0.0 && cCROSSap >= 0.0;\n    }\n    intersects(shape) {\n        switch (shape._igeShapeType) {\n            case \"circle\":\n                return (0,_engine_utils_intersections__WEBPACK_IMPORTED_MODULE_2__.circleIntersectsPolygon)(shape, this);\n            case \"rect\":\n                return (0,_engine_utils_intersections__WEBPACK_IMPORTED_MODULE_2__.rectIntersectsPolygon)(shape, this);\n            case \"polygon\":\n                return (0,_engine_utils_intersections__WEBPACK_IMPORTED_MODULE_2__.polygonIntersectsPolygon)(this, shape);\n        }\n        return false;\n    }\n    /**\n     * Draws the polygon bounding lines to the passed context.\n     */\n    render(ctx, fillStyle = \"\") {\n        const polyPoints = this._poly;\n        const pointCount = polyPoints.length;\n        const scaleX = this._scale.x;\n        const scaleY = this._scale.y;\n        ctx.beginPath();\n        ctx.moveTo(polyPoints[0].x * scaleX, polyPoints[0].y * scaleY);\n        for (let i = 1; i < pointCount; i++) {\n            ctx.lineTo(polyPoints[i].x * scaleX, polyPoints[i].y * scaleY);\n        }\n        ctx.lineTo(polyPoints[0].x * scaleX, polyPoints[0].y * scaleY);\n        if (fillStyle) {\n            ctx.fillStyle = fillStyle;\n            ctx.fill();\n        }\n        ctx.stroke();\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgePoly2d.ts?");

/***/ }),

/***/ "./src/engine/utils/ids.ts":
/*!*********************************!*\
  !*** ./src/engine/utils/ids.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   newId: () => (/* binding */ newId),\n/* harmony export */   newIdHex: () => (/* binding */ newIdHex),\n/* harmony export */   newIdNumber: () => (/* binding */ newIdNumber)\n/* harmony export */ });\nlet _idCounter = 0;\n/**\n * Generates a new unique ID as a number.\n * @return {number}\n */\nconst newIdNumber = () => {\n    _idCounter++;\n    return (_idCounter +\n        (Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17)));\n};\n/**\n * Generates a new unique ID string\n * @return {string}\n */\nconst newId = () => {\n    _idCounter++;\n    return newIdNumber().toString();\n};\n/**\n * Generates a new 16-character hexadecimal unique ID\n * @return {string}\n */\nconst newIdHex = () => {\n    return newIdNumber().toString(16);\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/ids.ts?");

/***/ }),

/***/ "./src/engine/utils/intersections.ts":
/*!*******************************************!*\
  !*** ./src/engine/utils/intersections.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circleIntersectsCircle: () => (/* binding */ circleIntersectsCircle),\n/* harmony export */   circleIntersectsPolygon: () => (/* binding */ circleIntersectsPolygon),\n/* harmony export */   circleIntersectsRect: () => (/* binding */ circleIntersectsRect),\n/* harmony export */   lineIntersectsCircle: () => (/* binding */ lineIntersectsCircle),\n/* harmony export */   lineIntersectsLine: () => (/* binding */ lineIntersectsLine),\n/* harmony export */   lineIntersectsPolygon: () => (/* binding */ lineIntersectsPolygon),\n/* harmony export */   pointIntersectsCircle: () => (/* binding */ pointIntersectsCircle),\n/* harmony export */   pointIntersectsPolygon: () => (/* binding */ pointIntersectsPolygon),\n/* harmony export */   pointIntersectsRect: () => (/* binding */ pointIntersectsRect),\n/* harmony export */   polygonIntersectsPolygon: () => (/* binding */ polygonIntersectsPolygon),\n/* harmony export */   rectIntersectsPolygon: () => (/* binding */ rectIntersectsPolygon),\n/* harmony export */   rectIntersectsRect: () => (/* binding */ rectIntersectsRect),\n/* harmony export */   rectToPolygon: () => (/* binding */ rectToPolygon)\n/* harmony export */ });\n/* harmony import */ var _engine_utils_maths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/utils/maths */ \"./src/engine/utils/maths.ts\");\n\nfunction rectToPolygon(rect) {\n    var _a, _b;\n    const rectW2 = rect.width * (((_a = rect._origin) === null || _a === void 0 ? void 0 : _a.x) || 0);\n    const rectH2 = rect.height * (((_b = rect._origin) === null || _b === void 0 ? void 0 : _b.y) || 0);\n    return {\n        x: rect.x,\n        y: rect.y,\n        _poly: [\n            { x: rect.x - rectW2, y: rect.y - rectH2 },\n            { x: rect.x + rectW2, y: rect.y - rectH2 },\n            { x: rect.x + rectW2, y: rect.y + rectH2 },\n            { x: rect.x - rectW2, y: rect.y + rectH2 }\n        ]\n    };\n}\n//////////////////////////////////////////////////////////////////////\n// Source is point\n//////////////////////////////////////////////////////////////////////\nfunction pointIntersectsRect(point, rect) {\n    var _a, _b;\n    const rectOriginX = rect.width * (((_a = rect._origin) === null || _a === void 0 ? void 0 : _a.x) || 0);\n    const rectOriginY = rect.height * (((_b = rect._origin) === null || _b === void 0 ? void 0 : _b.y) || 0);\n    const rectLeft = rect.x - rectOriginX;\n    const rectRight = rect.x + rect.width - rectOriginX;\n    const rectTop = rect.y - rectOriginY;\n    const rectBottom = rect.y + rect.height - rectOriginY;\n    return (point.x >= rectLeft &&\n        point.x <= rectRight &&\n        point.y >= rectTop &&\n        point.y <= rectBottom);\n}\nfunction pointIntersectsCircle(point, circle) {\n    const dist = (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_0__.distance)(circle.x, circle.y, point.x, point.y);\n    return dist < circle.radius;\n}\nfunction pointIntersectsPolygon(point, polygon) {\n    const polyPoints = polygon._poly;\n    const pointCount = polyPoints.length;\n    let oldPointIndex = pointCount - 1;\n    let c = false;\n    for (let pointIndex = 0; pointIndex < pointCount; oldPointIndex = pointIndex++) {\n        if (polyPoints[pointIndex].y > point.y !== polyPoints[oldPointIndex].y > point.y\n            && point.x < ((polyPoints[oldPointIndex].x - polyPoints[pointIndex].x) * (point.y - polyPoints[pointIndex].y)) / (polyPoints[oldPointIndex].y - polyPoints[pointIndex].y) + polyPoints[pointIndex].x) {\n            c = !c;\n        }\n    }\n    return c;\n}\n//////////////////////////////////////////////////////////////////////\n// Source is line\n//////////////////////////////////////////////////////////////////////\nfunction lineIntersectsLine(line1, line2) {\n    // Calculate the direction vectors\n    const dx1 = line1.x2 - line1.x1;\n    const dy1 = line1.y2 - line1.y1;\n    const dx2 = line2.x2 - line2.x1;\n    const dy2 = line2.y2 - line2.y1;\n    // Calculate the determinants\n    const determinant = dx1 * dy2 - dy1 * dx2;\n    const delta_x_13 = line1.x1 - line2.x1;\n    const delta_y_13 = line1.y1 - line2.y1;\n    // Check if the lines are parallel or coincident\n    if (determinant === 0) {\n        return false;\n    }\n    // Calculate the parameters for the intersection point\n    const s = (delta_x_13 * dy2 - delta_y_13 * dx2) / determinant;\n    const t = (delta_x_13 * dy1 - delta_y_13 * dx1) / determinant;\n    // Check if the intersection point lies within the line segments\n    return (s >= 0 && s <= 1 && t >= 0 && t <= 1);\n}\nfunction lineIntersectsPolygon(line, polygon) {\n    const numVertices = polygon._poly.length;\n    // Iterate through each edge of the polygon\n    for (let i = 0; i < numVertices; i++) {\n        const vertex1 = polygon._poly[i];\n        const vertex2 = polygon._poly[(i + 1) % numVertices];\n        // Check if the edge intersects the line\n        if (lineIntersectsLine({ x1: vertex1.x, y1: vertex1.y, x2: vertex2.x, y2: vertex2.y }, line)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction lineIntersectsCircle(line, circle) {\n    const dx = line.x2 - line.x1;\n    const dy = line.y2 - line.y1;\n    const len = Math.sqrt(dx * dx + dy * dy);\n    const dot = ((circle.x - line.x1) * dx + (circle.y - line.y1) * dy) / (len * len);\n    const closestX = line.x1 + dot * dx;\n    const closestY = line.y1 + dot * dy;\n    if (closestX < Math.min(line.x1, line.x2) || closestX > Math.max(line.x1, line.x2) || closestY < Math.min(line.y1, line.y2) || closestY > Math.max(line.y1, line.y2)) {\n        return false;\n    }\n    const dist = Math.sqrt((closestX - circle.x) * (closestX - circle.x) + (closestY - circle.y) * (closestY - circle.y));\n    return dist <= circle.radius;\n}\n//////////////////////////////////////////////////////////////////////\n// Source is circle\n//////////////////////////////////////////////////////////////////////\nfunction circleIntersectsCircle(circle1, circle2) {\n    return (0,_engine_utils_maths__WEBPACK_IMPORTED_MODULE_0__.distance)(circle1.x, circle1.y, circle2.x, circle2.y) < (circle2.radius + circle1.radius);\n}\nfunction circleIntersectsRect(circle, rect) {\n    var _a, _b;\n    if (pointIntersectsRect(circle, rect))\n        return true;\n    // Calculate the half-width and half-height of the rectangle\n    const halfWidth = rect.width * (((_a = rect._origin) === null || _a === void 0 ? void 0 : _a.x) || 0);\n    const halfHeight = rect.height * (((_b = rect._origin) === null || _b === void 0 ? void 0 : _b.y) || 0);\n    // Calculate the center coordinates of the rectangle\n    const rectCenterX = rect.x;\n    const rectCenterY = rect.y;\n    // Calculate the closest point on the rectangle to the circle\n    const closestX = Math.max(rectCenterX - halfWidth, Math.min(circle.x, rectCenterX + halfWidth));\n    const closestY = Math.max(rectCenterY - halfHeight, Math.min(circle.y, rectCenterY + halfHeight));\n    // Calculate the distance between the closest point and the circle center\n    const distanceX = circle.x - closestX;\n    const distanceY = circle.y - closestY;\n    const distanceSquared = distanceX * distanceX + distanceY * distanceY;\n    // Check if the distance is less than or equal to the square of the circle's radius\n    return distanceSquared <= circle.radius * circle.radius;\n}\nfunction circleIntersectsPolygon(circle, polygon) {\n    // Check if the circle's center lies inside the polygon\n    if (pointIntersectsPolygon(circle, polygon))\n        return true;\n    // Check if any line segment of the polygon intersects the circle\n    for (let i = 0; i < polygon._poly.length; i++) {\n        const p1 = polygon._poly[i];\n        const p2 = polygon._poly[(i + 1) % polygon._poly.length];\n        if (lineIntersectsCircle({\n            x1: p1.x, // * polygon._scale.x,\n            y1: p1.y, // * polygon._scale.y,\n            x2: p2.x, // * polygon._scale.x,\n            y2: p2.y // * polygon._scale.y\n        }, circle)) {\n            return true;\n        }\n    }\n    return false;\n}\n//////////////////////////////////////////////////////////////////////\n// Source is rect\n//////////////////////////////////////////////////////////////////////\nfunction rectIntersectsRect(rect1, rect2) {\n    var _a, _b, _c, _d;\n    if (!rect1 || !rect2) {\n        return false;\n    }\n    const sX1 = rect1.x - (rect1.width * (((_a = rect1._origin) === null || _a === void 0 ? void 0 : _a.x) || 0)), sY1 = rect1.y - (rect1.height * (((_b = rect1._origin) === null || _b === void 0 ? void 0 : _b.x) || 0)), sW = rect1.width, sH = rect1.height, dX1 = rect2.x - (rect2.width * (((_c = rect2._origin) === null || _c === void 0 ? void 0 : _c.x) || 0)), dY1 = rect2.y - (rect2.height * (((_d = rect2._origin) === null || _d === void 0 ? void 0 : _d.x) || 0)), dW = rect2.width, dH = rect2.height, sX2 = sX1 + sW, sY2 = sY1 + sH, dX2 = dX1 + dW, dY2 = dY1 + dH;\n    return sX1 < dX2 && sX2 > dX1 && sY1 < dY2 && sY2 > dY1;\n}\nfunction rectIntersectsPolygon(rect, polygon) {\n    return polygonIntersectsPolygon(rectToPolygon(rect), polygon);\n}\n//////////////////////////////////////////////////////////////////////\n// Source is polygon\n//////////////////////////////////////////////////////////////////////\nfunction polygonIntersectsPolygon(polygon1, polygon2) {\n    // Check if any edge of polygon1 intersects with any edge of polygon2\n    for (let i = 0; i < polygon1._poly.length; i++) {\n        const edge1Vertex1 = polygon1._poly[i];\n        const edge1Vertex2 = polygon1._poly[(i + 1) % polygon1._poly.length];\n        // Check if any vertex of one polygon is inside the other polygon\n        if (pointIntersectsPolygon(polygon1._poly[i], polygon2)) {\n            return true;\n        }\n        for (let j = 0; j < polygon2._poly.length; j++) {\n            const edge2Vertex1 = polygon2._poly[j];\n            const edge2Vertex2 = polygon2._poly[(j + 1) % polygon2._poly.length];\n            // Check if any vertex of one polygon is inside the other polygon\n            if (pointIntersectsPolygon(polygon2._poly[j], polygon1)) {\n                return true;\n            }\n            if (lineIntersectsLine({\n                x1: edge1Vertex1.x,\n                y1: edge1Vertex1.y,\n                x2: edge1Vertex2.x,\n                y2: edge1Vertex2.y\n            }, {\n                x1: edge2Vertex1.x,\n                y1: edge2Vertex1.y,\n                x2: edge2Vertex2.x,\n                y2: edge2Vertex2.y\n            })) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/intersections.ts?");

/***/ }),

/***/ "./src/engine/utils/maths.ts":
/*!***********************************!*\
  !*** ./src/engine/utils/maths.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PI180: () => (/* binding */ PI180),\n/* harmony export */   PI180R: () => (/* binding */ PI180R),\n/* harmony export */   PI2: () => (/* binding */ PI2),\n/* harmony export */   degreesToRadians: () => (/* binding */ degreesToRadians),\n/* harmony export */   distance: () => (/* binding */ distance),\n/* harmony export */   radiansToDegrees: () => (/* binding */ radiansToDegrees),\n/* harmony export */   toIso: () => (/* binding */ toIso)\n/* harmony export */ });\n/**\n * Stores a pre-calculated PI / 180 value.\n * @type {number}\n */\nconst PI180 = Math.PI / 180;\n/**\n * Stores a pre-calculated 180 / PI value.\n * @type {number}\n */\nconst PI180R = 180 / Math.PI;\nconst PI2 = Math.PI * 2;\nconst toIso = (x, y, z) => {\n    const sx = x - y;\n    const sy = -z * 1.2247 + (x + y) * 0.5;\n    return { x: sx, y: sy };\n};\n/**\n * Converts degrees to radians.\n * @param {number} degrees\n * @return {number} radians\n */\nconst degreesToRadians = (degrees) => {\n    return degrees * PI180;\n};\n/**\n * Converts radians to degrees.\n * @param {number} radians\n * @return {number} degrees\n */\nconst radiansToDegrees = (radians) => {\n    return radians * PI180R;\n};\n/**\n * Calculates the distance from the first point to the second point.\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @return {number}\n */\nconst distance = (x1, y1, x2, y2) => {\n    return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/maths.ts?");

/***/ }),

/***/ "./src/engine/utils/trace.ts":
/*!***********************************!*\
  !*** ./src/engine/utils/trace.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   traceSet: () => (/* binding */ traceSet),\n/* harmony export */   traceSetOff: () => (/* binding */ traceSetOff)\n/* harmony export */ });\n/**\n * Sets a trace up on the setter of the passed object's\n * specified property. When the property is set by any\n * code the debugger line is activated and code execution\n * will be paused allowing you to step through code or\n * examine the call stack to see where the property set\n * originated.\n * @param {Object} obj The object whose property you want\n * to trace.\n * @param {string} propName The name of the property you\n * want to put the trace on.\n * @param {number} sampleCount The number of times you\n * want the trace to break with the debugger line before\n * automatically switching off the trace.\n * @param {Function=} callbackEvaluator Optional callback\n * that if returns true, will fire debugger. Method is passed\n * the setter value as first argument.\n */\nconst traceSet = (obj, propName, sampleCount, callbackEvaluator) => {\n    obj.___igeTraceCurrentVal = obj.___igeTraceCurrentVal || {};\n    obj.___igeTraceCurrentVal[propName] = obj[propName];\n    obj.___igeTraceMax = sampleCount || 1;\n    obj.___igeTraceCount = 0;\n    Object.defineProperty(obj, propName, {\n        get() {\n            return obj.___igeTraceCurrentVal[propName];\n        },\n        set: (val) => {\n            if (callbackEvaluator) {\n                if (callbackEvaluator(val)) {\n                    debugger; // jshint ignore:line\n                }\n            }\n            else {\n                debugger; // jshint ignore:line\n            }\n            obj.___igeTraceCurrentVal[propName] = val;\n            obj.___igeTraceCount++;\n            if (obj.___igeTraceCount === obj.___igeTraceMax) {\n                // Maximum amount of trace samples reached, turn off\n                // the trace system\n                traceSetOff(obj, propName);\n            }\n        }\n    });\n};\n/**\n * Turns off a trace that was created by calling traceSet.\n * @param {Object} obj The object whose property you want\n * to disable a trace against.\n * @param {string} propName The name of the property you\n * want to disable the trace for.\n */\nconst traceSetOff = (obj, propName) => {\n    Object.defineProperty(obj, propName, {\n        set(val) {\n            this.___igeTraceCurrentVal[propName] = val;\n        }\n    });\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/trace.ts?");

/***/ })

}]);