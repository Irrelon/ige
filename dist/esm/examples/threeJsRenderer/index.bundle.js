/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/engine/components/IgeInputComponent.ts":
/*!****************************************************!*\
  !*** ./src/engine/components/IgeInputComponent.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeInputComponent: () => (/* binding */ IgeInputComponent)\n/* harmony export */ });\n/* harmony import */ var _engine_components_IgeInputControlMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/components/IgeInputControlMap */ \"./src/engine/components/IgeInputControlMap.ts\");\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n/* harmony import */ var _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/core/IgePoint3d */ \"./src/engine/core/IgePoint3d.ts\");\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_utils_general__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/engine/utils/general */ \"./src/engine/utils/general.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\n\n\n\n\n\n\nclass IgeInputComponent extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_1__.IgeEventingClass {\n    constructor() {\n        super();\n        this.classId = \"IgeInputComponent\";\n        this.componentId = \"input\";\n        this._evRef = {};\n        // State <DeviceCode, <InputCode, InputValue>>\n        this._state = {};\n        this._previousState = {};\n        this._controlMap = {};\n        this.debug = (val) => {\n            if (val !== undefined) {\n                this._debug = val;\n                return this;\n            }\n            return this._debug;\n        };\n        /**\n         * Sets up the event listeners on the main window and front\n         * buffer DOM objects.\n         * @private\n         */\n        this.setupListeners = (canvas) => {\n            if (!canvas) {\n                this.log(\"Cannot set up input event listeners - no canvas was supplied\");\n                return;\n            }\n            this.log(\"Setting up input event listeners...\");\n            // Define event functions and keep references for later removal\n            this._evRef = {\n                pointerdown: (event) => {\n                    this._rationalise(event, \"pointer\");\n                    this._pointerDown(event);\n                },\n                pointerup: (event) => {\n                    this._rationalise(event, \"pointer\");\n                    this._pointerUp(event);\n                },\n                pointermove: (event) => {\n                    this._rationalise(event, \"pointer\");\n                    this._pointerMove(event);\n                },\n                pointerWheel: (event) => {\n                    this._rationalise(event, \"wheel\");\n                    this._pointerWheel(event);\n                },\n                // \"touchmove\": (event: TouchEvent) => {\n                // \tthis._rationalise(event, \"touch\");\n                // \tthis._pointerMove(event);\n                // },\n                // \"touchstart\": (event: TouchEvent) => {\n                // \tthis._rationalise(event, \"touch\");\n                // \tthis._pointerDown(event);\n                // },\n                // \"touchend\": (event: TouchEvent) => {\n                // \tthis._rationalise(event, \"touch\");\n                // \tthis._pointerUp(event);\n                // },\n                contextmenu: (event) => {\n                    event.preventDefault();\n                    this._rationalise(event, \"pointer\");\n                    this._contextMenu(event);\n                },\n                keydown: (event) => {\n                    this._rationalise(event, \"keyboard\");\n                    this._keyDown(event);\n                },\n                keyup: (event) => {\n                    this._rationalise(event, \"keyboard\");\n                    this._keyUp(event);\n                }\n            };\n            // Listen for pointer events\n            canvas.addEventListener(\"pointerdown\", this._evRef.pointerdown, false);\n            canvas.addEventListener(\"pointerup\", this._evRef.pointerup, false);\n            canvas.addEventListener(\"pointermove\", this._evRef.pointermove, false);\n            canvas.addEventListener(\"wheel\", this._evRef.pointerWheel, false);\n            // Touch events\n            // canvas.addEventListener(\"touchmove\", this._evRef.touchmove, false);\n            // canvas.addEventListener(\"touchstart\", this._evRef.touchstart, false);\n            // canvas.addEventListener(\"touchend\", this._evRef.touchend, false);\n            // Kill the context menu on right-click, urgh!\n            canvas.addEventListener(\"contextmenu\", this._evRef.contextmenu, false);\n            // Listen for keyboard events\n            window.addEventListener(\"keydown\", this._evRef.keydown, false);\n            window.addEventListener(\"keyup\", this._evRef.keyup, false);\n        };\n        this.destroyListeners = (canvas) => {\n            this.log(\"Removing input event listeners...\");\n            // Keyboard events\n            window.removeEventListener(\"keydown\", this._evRef.keydown, false);\n            window.removeEventListener(\"keyup\", this._evRef.keyup, false);\n            if (!canvas)\n                return;\n            // Pointer events\n            canvas.removeEventListener(\"pointerdown\", this._evRef.pointerdown, false);\n            canvas.removeEventListener(\"pointerup\", this._evRef.pointerup, false);\n            canvas.removeEventListener(\"pointermove\", this._evRef.pointermove, false);\n            canvas.removeEventListener(\"wheel\", this._evRef.pointerWheel, false);\n            // Touch events\n            // canvas.removeEventListener(\"touchmove\", this._evRef.touchmove, false);\n            // canvas.removeEventListener(\"touchstart\", this._evRef.touchstart, false);\n            // canvas.removeEventListener(\"touchend\", this._evRef.touchend, false);\n            // Context menu events\n            canvas.removeEventListener(\"contextmenu\", this._evRef.contextmenu, false);\n        };\n        /**\n         * Fires an input event that didn't occur on the main canvas, as if it had\n         * occurred on the main canvas, allowing you to pass through events like\n         * pointerdown and pointerup that occurred elsewhere on the DOM but might be\n         * useful for the engine to be aware of, such as if you are dragging an entity\n         * and then the pointer goes off-canvas and the button is released.\n         * @param {string} eventName The lowercase name of the event to fire e.g. pointerdown.\n         * @param {Object} eventObj The event object that was passed by the DOM.\n         */\n        this.fireManualEvent = (eventName, eventObj) => {\n            if (eventName && eventObj) {\n                if (this._evRef[eventName]) {\n                    this._evRef[eventName](eventObj);\n                }\n                else {\n                    this.log(`Cannot fire manual event \"${eventName}\" because no listener exists in the engine for this event type!`, \"warning\");\n                }\n            }\n            else {\n                this.log(\"Cannot fire manual event because both eventName and eventObj params are required.\", \"warning\");\n            }\n        };\n        /**\n         * Emits the \"pointerDown\" event.\n         * @param event\n         * @private\n         */\n        this._pointerDown = (event) => {\n            if (this._debug) {\n                console.log(\"Pointer Down\", event);\n            }\n            // Update the pointer position within the viewports\n            this._updatePointerData(event);\n            const mx = event.igeX - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.x2;\n            const my = event.igeY - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.y2;\n            if (event.button === 0) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button0, true);\n            }\n            if (event.button === 1) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button1, true);\n            }\n            if (event.button === 2) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button2, true);\n            }\n            if (event.button === 3) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button3, true);\n            }\n            if (event.button === 4) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button4, true);\n            }\n            if (event.button === 5) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button5, true);\n            }\n            this.pointerDown = event;\n            if (this.emit(\"prePointerDown\", event, mx, my, event.button) !== _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel) {\n                this.queueEvent(() => {\n                    this.emit(\"pointerDown\", event, mx, my, event.button);\n                });\n            }\n        };\n        /**\n         * Emits the \"pointerUp\" event.\n         * @param event\n         * @private\n         */\n        this._pointerUp = (event) => {\n            if (this._debug) {\n                console.log(\"Pointer Up\", event);\n            }\n            // Update the pointer position within the viewports\n            this._updatePointerData(event);\n            const mx = event.igeX - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.x2;\n            const my = event.igeY - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.y2;\n            if (event.button === 0) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button0, false);\n            }\n            if (event.button === 1) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button1, false);\n            }\n            if (event.button === 2) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button2, false);\n            }\n            if (event.button === 3) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button3, false);\n            }\n            if (event.button === 4) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button4, false);\n            }\n            if (event.button === 5) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button5, false);\n            }\n            this.pointerUp = event;\n            if (this.emit(\"prePointerUp\", event, mx, my, event.button) !== _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel) {\n                this.queueEvent(() => {\n                    this.emit(\"pointerUp\", event, mx, my, event.button);\n                });\n            }\n        };\n        this._contextMenu = (event) => {\n            if (this._debug) {\n                console.log(\"Context Menu\", event);\n            }\n            // Update the pointer position within the viewports\n            this._updatePointerData(event);\n            const mx = event.igeX - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.x2;\n            const my = event.igeY - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.y2;\n            if (event.button === 0) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button0, false);\n            }\n            if (event.button === 1) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button1, false);\n            }\n            if (event.button === 2) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button2, false);\n            }\n            if (event.button === 3) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button3, false);\n            }\n            if (event.button === 4) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button4, false);\n            }\n            if (event.button === 5) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.button5, false);\n            }\n            this.contextMenu = event;\n            if (this.emit(\"preContextMenu\", event, mx, my, event.button) !== _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel) {\n                this.queueEvent(() => {\n                    this.emit(\"contextMenu\", event, mx, my, event.button);\n                });\n            }\n        };\n        /**\n         * Emits the \"pointerMove\" event.\n         * @param event\n         * @private\n         */\n        this._pointerMove = (event) => {\n            // Update the pointer position within the viewports\n            _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige._pointerOverVp = this._updatePointerData(event);\n            const mx = event.igeX - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.x2;\n            const my = event.igeY - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.y2;\n            this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.x, mx);\n            this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.y, my);\n            this.pointerMove = event;\n            if (this.emit(\"prePointerMove\", event, mx, my, event.button) !== _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel) {\n                this.queueEvent(() => {\n                    this.emit(\"pointerMove\", event, mx, my, event.button);\n                });\n            }\n        };\n        /**\n         * Emits the \"pointerWheel\" event.\n         * @param event\n         * @private\n         */\n        this._pointerWheel = (event) => {\n            if (this._debug) {\n                console.log(\"PointerWheel\", event);\n            }\n            // Update the pointer position within the viewports\n            this._updatePointerData(event);\n            const mx = event.igeX - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.x2;\n            const my = event.igeY - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.y2;\n            if (event.deltaX !== 0) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelX, event.deltaX);\n                if (event.deltaX > 0) {\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelRight, true);\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelLeft, false);\n                }\n                else {\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelLeft, true);\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelRight, false);\n                }\n            }\n            if (event.deltaY !== 0) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelY, event.deltaY);\n                if (event.deltaY > 0) {\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelUp, true);\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelDown, false);\n                }\n                else {\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelDown, true);\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelUp, false);\n                }\n            }\n            if (event.deltaZ !== 0) {\n                this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelZ, event.deltaZ);\n                if (event.deltaZ > 0) {\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelBackward, true);\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelForward, false);\n                }\n                else {\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelForward, true);\n                    this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.wheelBackward, false);\n                }\n            }\n            this.pointerWheel = event;\n            if (this.emit(\"prePointerWheel\", event, mx, my, event.button) !== _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel) {\n                this.queueEvent(() => {\n                    this.emit(\"pointerWheel\", event, mx, my, event.button);\n                });\n            }\n        };\n        /**\n         * Emits the \"keyDown\" event.\n         * @param event\n         * @private\n         */\n        this._keyDown = (event) => {\n            this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.keyboard, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputKeyboardMap[event.code], true);\n            if (this._debug) {\n                console.log(\"Key Down\", event);\n            }\n            if (this.emit(\"preKeyDown\", event, event.code) !== _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel) {\n                this.queueEvent(() => {\n                    this.emit(\"keyDown\", event, event.code);\n                });\n            }\n        };\n        /**\n         * Emits the \"keyUp\" event.\n         * @param event\n         * @private\n         */\n        this._keyUp = (event) => {\n            this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.keyboard, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputKeyboardMap[event.code], false);\n            if (this._debug) {\n                console.log(\"Key Up\", event);\n            }\n            if (this.emit(\"preKeyUp\", event, event.code) !== _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel) {\n                this.queueEvent(() => {\n                    this.emit(\"keyUp\", event, event.code);\n                });\n            }\n        };\n        /**\n         * Loops the mounted viewports and updates their respective pointer\n         * co-ordinates so that pointer events can work out where on a viewport\n         * they occurred.\n         *\n         * @param {Event} event The HTML DOM event that occurred.\n         * @return {*}\n         * @private\n         */\n        this._updatePointerData = (event) => {\n            // Loop the viewports and check if the pointer is inside\n            const arr = _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._children;\n            const mx = event.igeX - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.x2 - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._translate.x;\n            const my = event.igeY - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._bounds2d.y2 - _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._translate.y;\n            let arrCount = arr.length;\n            let vpUpdated;\n            _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige._pointerPos.x = mx;\n            _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige._pointerPos.y = my;\n            while (arrCount--) {\n                const vp = arr[arr.length - (arrCount + 1)];\n                // Check if the pointer is inside this viewport's bounds\n                // TODO: Update this code to take into account viewport rotation and camera rotation\n                if (mx > vp._translate.x - vp._bounds2d.x / 2 && mx < vp._translate.x + vp._bounds2d.x / 2) {\n                    if (my > vp._translate.y - vp._bounds2d.y / 2 && my < vp._translate.y + vp._bounds2d.y / 2) {\n                        // Pointer is inside this viewport\n                        vp._pointerPos = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_2__.IgePoint3d(Math.floor((mx - vp._translate.x) / vp.camera._scale.x + vp.camera._translate.x), Math.floor((my - vp._translate.y) / vp.camera._scale.y + vp.camera._translate.y), 0);\n                        vpUpdated = vp;\n                        // Record the viewport that this event occurred on in the\n                        // event object\n                        event.igeViewport = vp;\n                        break;\n                    }\n                }\n            }\n            return vpUpdated;\n        };\n        /**\n         * Adds an event method to the eventQueue array. The array is\n         * processed during each tick after the scenegraph has been\n         * rendered.\n         * @param {Function} eventFunction The event function.\n         * @param {*} [eventData] The event data.\n         */\n        this.queueEvent = (eventFunction, eventData) => {\n            if (eventFunction !== undefined) {\n                this._eventQueue.push([eventFunction, eventData]);\n            }\n            return this;\n        };\n        // Set up the input objects to hold the current input state\n        this._eventQueue = [];\n        this._eventControl = {\n            _cancelled: false,\n            stopPropagation() {\n                this._cancelled = true;\n            }\n        };\n        this.tick();\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.keyboard);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.gamePad1);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.gamePad2);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.gamePad3);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.gamePad4);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.gamePad5);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.gamePad6);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.gamePad7);\n        this._ensureState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.gamePad8);\n        // Set default values for the pointer position\n        this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.x, 0);\n        this._updateState(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputDevice.pointer1, _enums__WEBPACK_IMPORTED_MODULE_5__.IgeInputPointerMap.y, 0);\n    }\n    isReady() {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.dependencies.waitFor([\"engine\"], () => {\n                    // Register a post-tick behaviour with the engine\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine.addBehaviour(_enums__WEBPACK_IMPORTED_MODULE_5__.IgeBehaviourType.postTick, \"inputComponentPostTick\", this.tick.bind(this));\n                    resolve();\n                });\n            }, 1);\n        });\n    }\n    _ensureState(device) {\n        this._state[device] = this._state[device] || {};\n        this._previousState[device] = this._previousState[device] || {};\n    }\n    _updateState(device, inputId, newValue) {\n        this._previousState[device][inputId] = this._state[device][inputId];\n        this._state[device][inputId] = newValue;\n    }\n    _rationalise(event, type) {\n        var _a;\n        event.igeType = type;\n        // Check if we want to prevent default behaviour\n        if (type === \"keyboard\") {\n            const keyboardEvent = event;\n            if (keyboardEvent.code === \"Backspace\") {\n                // Backspace\n                // Check if the event occurred on the body\n                const elem = event.target;\n                if (((elem === null || elem === void 0 ? void 0 : elem.tagName) || \"body\").toLowerCase() === \"body\") {\n                    // The event occurred on our body element so prevent\n                    // default behaviour. This allows other elements on\n                    // the page to retain focus such as text boxes etc\n                    // and allows them to behave normally.\n                    event.preventDefault();\n                }\n            }\n        }\n        // if (type === \"touch\") {\n        // \tconst touchEvent = event as TouchEvent;\n        // \ttouchEvent.preventDefault();\n        // \ttouchEvent.button = 0; // Emulate left pointer button\n        //\n        // \t// Handle touch changed\n        // \tif (touchEvent.changedTouches && touchEvent.changedTouches.length) {\n        // \t\ttouchEvent.igePageX = touchEvent.changedTouches[0].pageX;\n        // \t\ttouchEvent.igePageY = touchEvent.changedTouches[0].pageY;\n        // \t}\n        // }\n        if (type === \"pointer\") {\n            const pointerEvent = event;\n            pointerEvent.igePageX = pointerEvent.pageX;\n            pointerEvent.igePageY = pointerEvent.pageY;\n        }\n        if (type === \"wheel\") {\n            const wheelEvent = event;\n            wheelEvent.igePageX = wheelEvent.pageX;\n            wheelEvent.igePageY = wheelEvent.pageY;\n        }\n        const canvasPosition = (0,_engine_utils_general__WEBPACK_IMPORTED_MODULE_4__.getElementPosition)((_a = _engine_instance__WEBPACK_IMPORTED_MODULE_3__.ige.engine._renderer) === null || _a === void 0 ? void 0 : _a.canvasElement());\n        event.igeX = event.igePageX - canvasPosition.left;\n        event.igeY = event.igePageY - canvasPosition.top;\n        this.emit(\"inputEvent\", event);\n    }\n    /**\n     * Defines an action that will be emitted when the specified event type\n     * occurs.\n     * @param actionCode\n     * @param inputMap\n     */\n    mapAction(actionCode, inputMap) {\n        this._controlMap[actionCode] = this._controlMap[actionCode] || new _engine_components_IgeInputControlMap__WEBPACK_IMPORTED_MODULE_0__.IgeInputControlMap();\n        for (let i = 0; i < inputMap.length; i++) {\n            this._controlMap[actionCode].push(inputMap[i]);\n        }\n    }\n    /**\n     * Returns the passed action's input state value.\n     * @param actionCode\n     */\n    actionVal(actionCode) {\n        return this._controlMap[actionCode].val();\n    }\n    /**\n     * Returns true if the passed action's input is pressed or its state\n     * is not zero.\n     * @param actionCode\n     */\n    actionState(actionCode) {\n        return this._controlMap[actionCode].state();\n    }\n    /**\n     * Returns an input's current value.\n     * @param device\n     * @param inputId\n     * @return {*}\n     */\n    val(device, inputId) {\n        return this._state[device][inputId];\n    }\n    /**\n     * Returns an input's previous value.\n     * @param device\n     * @param inputId\n     * @return {*}\n     */\n    previousVal(device, inputId) {\n        return this._state[device][inputId];\n    }\n    /**\n     * Returns an input's current state as a boolean.\n     * @param device\n     * @param inputId\n     * @return {boolean}\n     */\n    state(device, inputId) {\n        return Boolean(this.val(device, inputId));\n    }\n    /**\n     * Returns an input's previous state as a boolean.\n     * @param device\n     * @param inputId\n     * @return {boolean}\n     */\n    previousState(device, inputId) {\n        return Boolean(this.previousVal(device, inputId));\n    }\n    /**\n     * Stops further event propagation for this tick.\n     * @return {*}\n     */\n    stopPropagation() {\n        this._eventControl._cancelled = true;\n        return this;\n    }\n    /**\n     * Called by the engine after ALL other tick methods have processed.\n     * Call originates in IgeEngine.engineStep(). Allows us to reset any flags\n     * etc.\n     */\n    tick() {\n        // If we have an event queue, process it\n        const arr = this._eventQueue;\n        const evc = this._eventControl;\n        let arrCount = arr.length;\n        while (arrCount--) {\n            arr[arrCount][0](evc, arr[arrCount][1]);\n            if (evc._cancelled) {\n                // The last event queue method stopped propagation so cancel all further\n                // event processing (the last event took control of the input)\n                break;\n            }\n        }\n        // Reset all the flags and variables for the next tick\n        this._eventQueue = [];\n        this._eventControl._cancelled = false;\n        delete this.dblClick; // TODO: Add double-click event handling\n        delete this.pointerMove;\n        delete this.pointerDown;\n        delete this.pointerUp;\n        delete this.pointerWheel;\n    }\n    /**\n     * Emit an event by name. Overrides the IgeEventingClass emit method and\n     * checks for propagation stopped by calling ige.input.stopPropagation().\n     * @param {Object} eventName The name of the event to emit.\n     * @param data\n     * If you are sending multiple arguments, use an array containing each argument.\n     * @return {number}\n     */\n    emit(eventName, ...data) {\n        if (!this._eventListeners) {\n            return _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.none;\n        }\n        const evc = this._eventControl;\n        const id = \"*\";\n        let returnFlag = _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.none;\n        this._eventsEmitting = true;\n        if (this._eventListeners[eventName] && this._eventListeners[eventName][id]) {\n            // Handle global emit\n            const arr = this._eventListeners[eventName][id];\n            const arrCount = arr.length;\n            for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                if (evc._cancelled) {\n                    // The stopPropagation() method was called, cancel all other event calls\n                    break;\n                }\n                // Check we have a function to execute\n                const tmpFunc = arr[arrIndex];\n                if (typeof tmpFunc === \"function\") {\n                    const result = tmpFunc(...data);\n                    if (result || evc._cancelled) {\n                        returnFlag = _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel;\n                    }\n                }\n            }\n        }\n        this._eventsEmitting = false;\n        this._processRemovalQueue();\n        return returnFlag;\n    }\n}\nIgeInputComponent.componentTargetClass = \"Ige\";\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/components/IgeInputComponent.ts?");

/***/ }),

/***/ "./src/engine/components/IgeInputControlMap.ts":
/*!*****************************************************!*\
  !*** ./src/engine/components/IgeInputControlMap.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeInputControlMap: () => (/* binding */ IgeInputControlMap)\n/* harmony export */ });\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n\nclass IgeInputControlMap {\n    constructor() {\n        this._inputMap = [];\n    }\n    push(inputMap) {\n        this._inputMap.push(inputMap);\n    }\n    state() {\n        if (this._inputMap.length === 1) {\n            return Boolean(_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.input._state[this._inputMap[0][0]][this._inputMap[0][1]]);\n        }\n        for (let i = 0; i < this._inputMap.length; i++) {\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.input._state[this._inputMap[i][0]][this._inputMap[i][1]]) {\n                return true;\n            }\n        }\n    }\n    val() {\n        if (this._inputMap.length === 1) {\n            return _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.input._state[this._inputMap[0][0]][this._inputMap[0][1]];\n        }\n        for (let i = 0; i < this._inputMap.length; i++) {\n            if (_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.input._state[this._inputMap[i][0]][this._inputMap[i][1]]) {\n                return _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.input._state[this._inputMap[i][0]][this._inputMap[i][1]];\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/components/IgeInputControlMap.ts?");

/***/ }),

/***/ "./src/engine/core/Ige.ts":
/*!********************************!*\
  !*** ./src/engine/core/Ige.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ige: () => (/* binding */ Ige)\n/* harmony export */ });\n/* harmony import */ var _engine_components_IgeInputComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/components/IgeInputComponent */ \"./src/engine/components/IgeInputComponent.ts\");\n/* harmony import */ var _engine_core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/core/config */ \"./src/engine/core/config.ts\");\n/* harmony import */ var _engine_core_IgeArrayRegister__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/core/IgeArrayRegister */ \"./src/engine/core/IgeArrayRegister.ts\");\n/* harmony import */ var _engine_core_IgeDependencies__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/core/IgeDependencies */ \"./src/engine/core/IgeDependencies.ts\");\n/* harmony import */ var _engine_core_IgeMetrics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/engine/core/IgeMetrics */ \"./src/engine/core/IgeMetrics.ts\");\n/* harmony import */ var _engine_core_IgeObjectRegister__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/engine/core/IgeObjectRegister */ \"./src/engine/core/IgeObjectRegister.ts\");\n/* harmony import */ var _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/engine/core/IgePoint3d */ \"./src/engine/core/IgePoint3d.ts\");\n/* harmony import */ var _engine_core_IgeRouter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/engine/core/IgeRouter */ \"./src/engine/core/IgeRouter.ts\");\n/* harmony import */ var _engine_core_IgeTextureStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/engine/core/IgeTextureStore */ \"./src/engine/core/IgeTextureStore.ts\");\n/* harmony import */ var _engine_core_IgeTimeController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/engine/core/IgeTimeController */ \"./src/engine/core/IgeTimeController.ts\");\n/* harmony import */ var _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/engine/utils/clientServer */ \"./src/engine/utils/clientServer.ts\");\n/* harmony import */ var _engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/engine/utils/igeClassStore */ \"./src/engine/utils/igeClassStore.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst version = \"3.0.2\";\nclass Ige {\n    constructor() {\n        this.app = null;\n        // @ts-ignore\n        this.router = new _engine_core_IgeRouter__WEBPACK_IMPORTED_MODULE_7__.IgeRouter();\n        this.textures = new _engine_core_IgeTextureStore__WEBPACK_IMPORTED_MODULE_8__.IgeTextureStore();\n        this.input = new _engine_components_IgeInputComponent__WEBPACK_IMPORTED_MODULE_0__.IgeInputComponent();\n        this.time = new _engine_core_IgeTimeController__WEBPACK_IMPORTED_MODULE_9__.IgeTimeController();\n        this.register = new _engine_core_IgeObjectRegister__WEBPACK_IMPORTED_MODULE_5__.IgeObjectRegister();\n        this.categoryRegister = new _engine_core_IgeArrayRegister__WEBPACK_IMPORTED_MODULE_2__.IgeArrayRegister(\"_category\", \"_categoryRegistered\");\n        this.groupRegister = new _engine_core_IgeArrayRegister__WEBPACK_IMPORTED_MODULE_2__.IgeArrayRegister(\"_group\", \"_groupRegistered\");\n        this.dependencies = new _engine_core_IgeDependencies__WEBPACK_IMPORTED_MODULE_3__.IgeDependencies();\n        this.metrics = new _engine_core_IgeMetrics__WEBPACK_IMPORTED_MODULE_4__.IgeMetrics();\n        this.config = _engine_core_config__WEBPACK_IMPORTED_MODULE_1__.igeConfig;\n        this.version = version;\n        this.classStore = _engine_utils_igeClassStore__WEBPACK_IMPORTED_MODULE_11__.igeClassStore;\n        this._data = {};\n        this._watch = [];\n        this._drawBounds = false;\n        this._uses = [];\n        this._pointerPos = new _engine_core_IgePoint3d__WEBPACK_IMPORTED_MODULE_6__.IgePoint3d(); // Could probably be just {x: number, y: number}\n        // /**\n        //  * Returns an array of all objects that have been assigned\n        //  * the passed group name.\n        //  * @param {String} groupName The name of the group to return\n        //  * all objects for.\n        //  */\n        // $$$ (groupName: string) {\n        // \treturn this.groupRegister[groupName] || [];\n        // }\n        /**\n         * Adds a new watch expression to the watch list which will be\n         * displayed in the stats overlay during a call to _statsTick().\n         * @param {*} evalStringOrObject The expression to evaluate and\n         * display the result of in the stats overlay, or an object that\n         * contains a \"value\" property.\n         * @returns {number} The index of the new watch expression you\n         * just added to the watch array.\n         */\n        this.watchStart = (evalStringOrObject) => {\n            this._watch = this._watch || [];\n            this._watch.push(evalStringOrObject);\n            return this._watch.length - 1;\n        };\n        /**\n         * Removes a watch expression by its array index.\n         * @param {number} index The index of the watch expression to\n         * remove from the watch array.\n         */\n        this.watchStop = (index) => {\n            this._watch = this._watch || [];\n            this._watch.splice(index, 1);\n        };\n    }\n    init() {\n        // Output our header\n        console.log(\"-----------------------------------------\");\n        console.log(`Powered by Isogenic Engine`);\n        console.log(\"(C)opyright \" + new Date().getFullYear() + \" Irrelon Software Limited\");\n        console.log(\"https://www.isogenicengine.com\");\n        console.log(\"-----------------------------------------\");\n        this.uses(\"engine\");\n        this.uses(\"input\");\n        this.uses(\"time\");\n    }\n    uses(moduleName) {\n        this._uses.push(moduleName);\n        console.log(\"Using dependency:\", moduleName);\n        switch (moduleName) {\n            case \"input\":\n                this.dependencies.add(\"input\", this.input.isReady());\n                break;\n            case \"time\":\n                this.dependencies.add(\"time\", this.time.isReady());\n                break;\n            case \"engine\":\n                this.dependencies.add(\"engine\", Promise.all(/*! import() */[__webpack_require__.e(\"src_engine_core_IgeEntity_ts\"), __webpack_require__.e(\"src_engine_core_IgeTween_ts\"), __webpack_require__.e(\"src_engine_core_IgeViewport_ts\"), __webpack_require__.e(\"src_engine_core_IgeEngine_ts\")]).then(__webpack_require__.bind(__webpack_require__, /*! @/engine/core/IgeEngine */ \"./src/engine/core/IgeEngine.ts\")).then(({ IgeEngine: Module }) => {\n                    this.engine = new Module();\n                }));\n                break;\n            case \"network\":\n                if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_10__.isClient) {\n                    this.dependencies.add(\"network\", __webpack_require__.e(/*! import() */ \"src_engine_network_client_IgeNetIoClientController_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/engine/network/client/IgeNetIoClientController */ \"./src/engine/network/client/IgeNetIoClientController.ts\")).then(({ IgeNetIoClientController: Module }) => {\n                        this.network = new Module();\n                    }));\n                }\n                if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_10__.isServer) {\n                    this.dependencies.add(\"network\", __webpack_require__.e(/*! import() */ \"src_engine_network_server_IgeNetIoServerController_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/engine/network/server/IgeNetIoServerController */ \"./src/engine/network/server/IgeNetIoServerController.ts\")).then(({ IgeNetIoServerController: Module }) => {\n                        this.network = new Module();\n                    }));\n                }\n                break;\n            case \"audio\":\n                if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_10__.isClient && !_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_10__.isWorker) {\n                    this.dependencies.add(\"audio\", Promise.all(/*! import() */[__webpack_require__.e(\"src_engine_core_IgeEntity_ts\"), __webpack_require__.e(\"src_engine_components_audio_IgeAudioController_ts\")]).then(__webpack_require__.bind(__webpack_require__, /*! @/engine/components/audio/IgeAudioController */ \"./src/engine/components/audio/IgeAudioController.ts\")).then(({ IgeAudioController: Module }) => {\n                        this.audio = new Module();\n                        this.dependencies.add(\"audio\", this.audio.isReady());\n                    }));\n                }\n                else {\n                    this.dependencies.markAsSatisfied(\"audio\");\n                }\n                break;\n            case \"box2d\":\n                this.dependencies.add(\"box2d\", Promise.all(/*! import() */[__webpack_require__.e(\"src_engine_core_IgeEntity_ts\"), __webpack_require__.e(\"src_engine_components_physics_box2d_IgeBox2dController_ts\")]).then(__webpack_require__.bind(__webpack_require__, /*! @/engine/components/physics/box2d/IgeBox2dController */ \"./src/engine/components/physics/box2d/IgeBox2dController.ts\")).then(({ IgeBox2dController: Module }) => {\n                    this.box2d = new Module();\n                }));\n                break;\n            case \"tweening\":\n                this.dependencies.add(\"tweening\", __webpack_require__.e(/*! import() */ \"src_engine_core_IgeTweenController_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/engine/core/IgeTweenController */ \"./src/engine/core/IgeTweenController.ts\")).then(({ IgeTweenController: Module }) => {\n                    this.tween = new Module();\n                    this.dependencies.add(\"tween\", this.tween.isReady());\n                }));\n                break;\n            case \"ui\":\n                this.dependencies.add(\"ui\", __webpack_require__.e(/*! import() */ \"src_engine_core_IgeUiManagerController_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/engine/core/IgeUiManagerController */ \"./src/engine/core/IgeUiManagerController.ts\")).then(({ IgeUiManagerController: Module }) => {\n                    this.ui = new Module();\n                    this.dependencies.add(\"ui\", this.ui.isReady());\n                }));\n                break;\n            default:\n                throw new Error(`Unknown optional module \"${moduleName}\", please remove your call to ige.uses(\"${moduleName}\")`);\n        }\n    }\n    isReady() {\n        return new Promise((resolve) => {\n            // [\"network\", \"engine\", \"tween\", \"time\", \"ui\"]\n            console.log(\"Waiting for dependencies\", this._uses);\n            this.dependencies.waitFor(this._uses, resolve);\n        });\n    }\n    /**\n     * Returns an object from the engine's object register by\n     * the object's id. If the item passed is not a string id\n     * then the item is returned as is. If no item is passed\n     * the engine itself is returned. The object is returned\n     * by reference so mutations will affect any other references\n     * to the object. There is no mutation-safe version of this.\n     * @param {string | Object} item The id of the item to return,\n     * or if an object, returns the object as-is.\n     */\n    $(item) {\n        if (typeof item === \"string\") {\n            return this.register.get(item);\n        }\n        return item;\n    }\n    /**\n     * Returns an array of all objects that have been assigned\n     * the passed category name. By default, the returned array\n     * is by reference, so you only need to get this array once,\n     * and it will receive updates when other objects are added\n     * to a category. Use the `immutable` flag to control this.\n     * @param {String} categoryName The name of the category to return\n     * all objects for.\n     * @param {boolean} [immutable=false] If true, returns a mutation-safe\n     * array where mutations to the array will not affect the underlying\n     * reference.\n     */\n    $$(categoryName, immutable = false) {\n        if (immutable)\n            return (this.categoryRegister.getImmutable(categoryName) || []);\n        return (this.categoryRegister.get(categoryName) || []);\n    }\n    /**\n     * Gets / sets the boolean flag determining if this object should have\n     * its bounds drawn when the bounds for all objects are being drawn.\n     * In order for bounds to be drawn the viewport the object is being drawn\n     * to must also have draw bounds enabled.\n     * @example #Enable draw bounds\n     *     var entity = new IgeEntity();\n     *     entity.drawBounds(true);\n     * @example #Disable draw bounds\n     *     var entity = new IgeEntity();\n     *     entity.drawBounds(false);\n     * @example #Get the current flag value\n     *     console.log(entity.drawBounds());\n     */\n    drawBounds(val, recursive = true) {\n        if (val === undefined) {\n            return this._drawBounds;\n        }\n        this._drawBounds = val;\n        // Loop all the way down the scenegraph and enable bounds for all\n        this.engine.drawBounds(val, recursive);\n        return this;\n    }\n    data(key, value) {\n        if (value !== undefined) {\n            this._data = this._data || {};\n            this._data[key] = value;\n            return this;\n        }\n        if (this._data) {\n            return this._data[key];\n        }\n        return null;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/Ige.ts?");

/***/ }),

/***/ "./src/engine/core/IgeArrayRegister.ts":
/*!*********************************************!*\
  !*** ./src/engine/core/IgeArrayRegister.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeArrayRegister: () => (/* binding */ IgeArrayRegister)\n/* harmony export */ });\n/* harmony import */ var _engine_utils_arrays__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/utils/arrays */ \"./src/engine/utils/arrays.ts\");\n\nclass IgeArrayRegister {\n    constructor(field, registeredField) {\n        this._store = {};\n        this._field = \"\";\n        this._registeredField = \"\";\n        this._field = field;\n        this._registeredField = registeredField;\n    }\n    /**\n     * Returns the reference to the store array for the\n     * specified id. Warning, you are given the actual\n     * reference to the array so mutating it will affect\n     * all other references. Use getImmutable() to get\n     * a mutation-safe version.\n     * @param id\n     */\n    get(id) {\n        this._store[id] = this._store[id] || [];\n        return this._store[id];\n    }\n    /**\n     * Gets an array of the store data by id. The returned\n     * array is not by reference, so you can mutate it safely.\n     * @param id\n     */\n    getImmutable(id) {\n        return [...(this._store[id] || [])];\n    }\n    /**\n     * Register an object with the engine array register.\n     * @param {Object} obj The object to register.\n     * @return {*}\n     */\n    add(obj) {\n        const objFieldValue = obj[this._field];\n        this._store[objFieldValue] = this._store[objFieldValue] || [];\n        this._store[objFieldValue].push(obj);\n        // @ts-ignore\n        obj[this._registeredField] = true;\n        return this;\n    }\n    /**\n     * Un-register an object with the engine array register.\n     * @param {Object} obj The object to un-register.\n     * @return {*}\n     */\n    remove(obj) {\n        const objFieldValue = obj[this._field];\n        if (!this._store[objFieldValue]) {\n            return this;\n        }\n        (0,_engine_utils_arrays__WEBPACK_IMPORTED_MODULE_0__.arrPull)(this._store[objFieldValue], obj);\n        // @ts-ignore\n        obj[this._registeredField] = false;\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeArrayRegister.ts?");

/***/ }),

/***/ "./src/engine/core/IgeAssetRegister.ts":
/*!*********************************************!*\
  !*** ./src/engine/core/IgeAssetRegister.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeAssetRegister: () => (/* binding */ IgeAssetRegister)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n\nclass IgeAssetRegister extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__.IgeEventingClass {\n    constructor() {\n        super(...arguments);\n        this.classId = \"IgeAssetRegister\";\n        this._assetById = {};\n        this._assetsLoading = 0;\n        this._assetsTotal = 0;\n    }\n    exists(id) {\n        return Boolean(this._assetById[id]);\n    }\n    get(id) {\n        if (!this._assetById[id])\n            throw new Error(`No asset registered with the id: ${id}`);\n        return this._assetById[id];\n    }\n    add(id, item) {\n        if (this._assetById[id]) {\n            throw new Error(`Cannot add asset with id ${id} because one with this id already exists!`);\n        }\n        this._assetsTotal++;\n        this._assetById[id] = item;\n        if (item._loaded)\n            return;\n        this._assetsLoading++;\n        item.whenLoaded().then(() => {\n            this._assetsLoading--;\n        });\n    }\n    remove(id) {\n        this._assetsTotal--;\n        delete this._assetById[id];\n    }\n    addGroup(group) {\n        Object.keys(group).forEach((key) => {\n            this.add(key, group[key]);\n        });\n    }\n    removeGroup(group) {\n        Object.keys(group).forEach((key) => {\n            this.remove(key);\n        });\n    }\n    removeList(list) {\n        list.forEach((tmpAsset) => tmpAsset.destroy());\n    }\n    whenLoaded() {\n        const promiseArr = Object.values(this._assetById).map((tmpAsset) => {\n            return tmpAsset.whenLoaded();\n        });\n        return Promise.all(promiseArr);\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeAssetRegister.ts?");

/***/ }),

/***/ "./src/engine/core/IgeBaseClass.ts":
/*!*****************************************!*\
  !*** ./src/engine/core/IgeBaseClass.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeBaseClass: () => (/* binding */ IgeBaseClass)\n/* harmony export */ });\n/* harmony import */ var _engine_core_global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/_global */ \"./src/engine/core/_global.ts\");\n\nconst getIndentString = () => {\n    let indent = \"\";\n    if (_engine_core_global__WEBPACK_IMPORTED_MODULE_0__.global._globalLogIndent) {\n        indent = \"|\";\n    }\n    for (let i = 0; i < _engine_core_global__WEBPACK_IMPORTED_MODULE_0__.global._globalLogIndent; i++) {\n        indent += \"\";\n    }\n    if (_engine_core_global__WEBPACK_IMPORTED_MODULE_0__.global._globalLogIndent) {\n        indent += \" \";\n    }\n    return indent;\n};\nclass IgeBaseClass {\n    constructor() {\n        this.classId = \"IgeBaseClass\";\n        this._data = {};\n    }\n    /**\n     * Returns the class id. Primarily used to help identify\n     * what class an instance was instantiated with and is also\n     * output during the ige.scenegraph() method's console logging\n     * to show what class an object belongs to.\n     * @example #Get the class id of an object.\n     *     var entity = new IgeEntity();\n     *\n     *     // Will output \"IgeEntity\"\n     *     console.log(entity.classId);\n     */\n    getClassId() {\n        return this.classId;\n    }\n    /**\n     * Provides logging capabilities to all IgeBaseClass instances.\n     * @param message\n     * @param args\n     *\n     * @example #Log a message\n     *     var entity = new IgeEntity();\n     *\n     *     // Will output:\n     *     //     IGE *log* [IgeEntity] : hello\n     *     entity.log('Hello');\n     * @example #Log an info message with an optional parameter\n     *     var entity = new IgeEntity(),\n     *         param = 'moo';\n     *\n     *     // Will output:\n     *     //    moo\n     *     //    IGE *log* [IgeEntity] : hello\n     *     entity.log('Hello', 'info', param);\n     * @example #Log a warning message (which will cause a stack trace to be shown)\n     *     var entity = new IgeEntity();\n     *\n     *     // Will output (stack trace is just an example here, real one will be more useful):\n     *     //    Stack: {anonymous}()@<anonymous>:2:8\n     *     //    ---- Object.InjectedScript._evaluateOn (<anonymous>:444:39)\n     *     //    ---- Object.InjectedScript._evaluateAndWrap (<anonymous>:403:52)\n     *     //    ---- Object.InjectedScript.evaluate (<anonymous>:339:21)\n     *     //    IGE *warning* [IgeEntity] : A test warning\n     *     entity.log('A test warning', 'warning');\n     * @example #Log an error message (which will cause an exception to be raised and a stack trace to be shown)\n     *     var entity = new IgeEntity();\n     *\n     *     // Will output (stack trace is just an example here, real one will be more useful):\n     *     //    Stack: {anonymous}()@<anonymous>:2:8\n     *     //    ---- Object.InjectedScript._evaluateOn (<anonymous>:444:39)\n     *     //    ---- Object.InjectedScript._evaluateAndWrap (<anonymous>:403:52)\n     *     //    ---- Object.InjectedScript.evaluate (<anonymous>:339:21)\n     *     //    IGE *error* [IgeEntity] : An error message\n     *     entity.log('An error message', 'error');\n     *\n     */\n    log(message, ...args) {\n        return this.logInfo(message, ...args);\n    }\n    logInfo(message, ...args) {\n        const stack = new Error().stack || \"\";\n        const stackArr = stack.split(\"\\n\");\n        stackArr.shift();\n        console.log(getIndentString() + `(${this.classId}) ${message}`, ...args);\n        return this;\n    }\n    logWarn(message, ...args) {\n        const stack = new Error().stack || \"\";\n        const stackArr = stack.split(\"\\n\");\n        stackArr.shift();\n        console.warn(getIndentString() + `(${this.classId}) ${message}`, ...args);\n        stackArr.forEach((stackLine) => {\n            console.warn(stackLine);\n        });\n        return this;\n    }\n    logError(message, ...args) {\n        const stack = new Error().stack || \"\";\n        const stackArr = stack.split(\"\\n\");\n        stackArr.shift();\n        console.error(getIndentString() + `(${this.classId}) ${message}`, ...args);\n        stackArr.forEach((stackLine) => {\n            console.error(stackLine);\n        });\n        return this;\n    }\n    logIndent() {\n        _engine_core_global__WEBPACK_IMPORTED_MODULE_0__.global._globalLogIndent++;\n    }\n    logOutdent() {\n        _engine_core_global__WEBPACK_IMPORTED_MODULE_0__.global._globalLogIndent--;\n        if (_engine_core_global__WEBPACK_IMPORTED_MODULE_0__.global._globalLogIndent < 0)\n            _engine_core_global__WEBPACK_IMPORTED_MODULE_0__.global._globalLogIndent = 0;\n    }\n    data(key, value) {\n        if (value !== undefined) {\n            this._data = this._data || {};\n            this._data[key] = value;\n            return this;\n        }\n        if (this._data) {\n            return this._data[key];\n        }\n        return null;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeBaseClass.ts?");

/***/ }),

/***/ "./src/engine/core/IgeDependencies.ts":
/*!********************************************!*\
  !*** ./src/engine/core/IgeDependencies.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeDependencies: () => (/* binding */ IgeDependencies)\n/* harmony export */ });\nclass IgeDependencies {\n    constructor() {\n        this._dependencyFulfilled = {};\n        this._dependsOnArr = [];\n    }\n    add(dependencyName, dependencyPromise) {\n        dependencyPromise\n            .then(() => {\n            this._onDependencySatisfied(dependencyName);\n        })\n            .catch((err) => {\n            throw new Error(`Dependency \"${dependencyName}\" threw an error: ${err}`);\n        });\n    }\n    waitFor(dependencyList, actionToTake) {\n        if (this._isDependencyListSatisfied(dependencyList)) {\n            // All deps for this action are already fulfilled so call immediately\n            actionToTake();\n            return;\n        }\n        // Not all deps are fulfilled, add to the action array\n        this._dependsOnArr.push({ dependencyList, actionToTake });\n    }\n    markAsSatisfied(dependencyName) {\n        this._onDependencySatisfied(dependencyName);\n    }\n    _onDependencySatisfied(dependencyName) {\n        // Mark the dependency as satisfied\n        this._dependencyFulfilled[dependencyName] = true;\n        // Loop the pending action array and check if this\n        // has caused fully satisfied conditions for any actions. If they\n        // have been satisfied, the handler is informed and the item is\n        // removed from the array\n        this._dependsOnArr = this._dependsOnArr.filter((dependencyAction) => {\n            if (this._isDependencyListSatisfied(dependencyAction.dependencyList)) {\n                // Execute the action and return false so the filter removes the item\n                dependencyAction.actionToTake();\n                return false;\n            }\n            // Return true so the filter() keeps this actions\n            return true;\n        });\n    }\n    _isDependencyListSatisfied(dependencyList) {\n        return dependencyList.every((dependencyName) => this._dependencyFulfilled[dependencyName]);\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeDependencies.ts?");

/***/ }),

/***/ "./src/engine/core/IgeEventingClass.ts":
/*!*********************************************!*\
  !*** ./src/engine/core/IgeEventingClass.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeEventingClass: () => (/* binding */ IgeEventingClass)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeBaseClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeBaseClass */ \"./src/engine/core/IgeBaseClass.ts\");\n/* harmony import */ var _enums_IgeEventReturnFlag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/enums/IgeEventReturnFlag */ \"./src/enums/IgeEventReturnFlag.ts\");\n\n\n/**\n * Creates a new class with the capability to emit events.\n */\nclass IgeEventingClass extends _engine_core_IgeBaseClass__WEBPACK_IMPORTED_MODULE_0__.IgeBaseClass {\n    constructor() {\n        super(...arguments);\n        this._eventsEmitting = false;\n        this._eventRemovalQueue = [];\n        this._eventStaticEmitters = {};\n        this._eventsAllowDefer = false;\n        this._eventsDeferTimeouts = {};\n    }\n    /**\n     * Attach an event listener to the passed event only if the passed\n     * id matches the id for the event being fired.\n     * @param {string} eventName The name of the event to listen for.\n     * @param {string} id The id to match against.\n     * @param {function} listener The method to call when the event is fired.\n     * @returns {IgeEventingClass} The emitter instance.\n     */\n    _on(eventName, id, listener) {\n        const generateTimeout = (emitter) => {\n            setTimeout(() => {\n                listener(...emitter.args);\n            }, 1);\n        };\n        this._eventListeners = this._eventListeners || {};\n        this._eventListeners[eventName] = this._eventListeners[eventName] || {};\n        this._eventListeners[eventName][id] = this._eventListeners[eventName][id] || [];\n        this._eventListeners[eventName][id].push(listener);\n        // Check for any static emitters, and fire the event if any exist\n        if (!this._eventStaticEmitters ||\n            !this._eventStaticEmitters[eventName] ||\n            !this._eventStaticEmitters[eventName].length)\n            return this;\n        // Emit events for each emitter\n        for (let i = 0; i < this._eventStaticEmitters[eventName].length; i++) {\n            const emitter = this._eventStaticEmitters[eventName][i];\n            if (id === \"*\" || emitter.id === id) {\n                // Call the listener out of process so that any code that expects a listener\n                // to be called at some point in the future rather than immediately on registration\n                // will not fail\n                generateTimeout(emitter);\n            }\n        }\n        return this;\n    }\n    /**\n     * Attach an event listener to the passed event only if the passed\n     * id matches the document id for the event being fired.\n     * @param {String} eventName The name of the event to listen for.\n     * @param {*} id The id to match against.\n     * @param {Function} listener The method to call when the event is fired.\n     * @returns {IgeEventingClass} The emitter instance.\n     */\n    _once(eventName, id, listener) {\n        let fired = false;\n        const internalCallback = (...args) => {\n            if (fired)\n                return;\n            fired = true;\n            this.off(eventName, id, internalCallback);\n            listener(...args);\n        };\n        return this.on(eventName, id, internalCallback);\n    }\n    /**\n     * Cancels an event listener based on an event name, id and listener function.\n     * @param {String} eventName The event to cancel listener for.\n     * @param {String} id The ID of the event to cancel listening for.\n     * @param {Function} listener The event listener function used in the on()\n     * or once() call to cancel.\n     * @returns {IgeEventingClass} The emitter instance.\n     */\n    _off(eventName, id, listener) {\n        // If the event name doesn't have any listeners, exit early\n        if (!this._eventListeners || !this._eventListeners[eventName] || !this._eventListeners[eventName][id])\n            return this;\n        // If we are emitting events at the moment, don't remove this listener\n        // until the process has completed, so we queue for removal instead\n        if (this._eventsEmitting) {\n            this._eventRemovalQueue = this._eventRemovalQueue || [];\n            this._eventRemovalQueue.push(() => {\n                this.off(eventName, id, listener);\n            });\n            return this;\n        }\n        // Check if we have no specific listener... in this case\n        // we want to remove all listeners for an id\n        if (!listener) {\n            if (id === \"*\") {\n                // The id is \"all\" and no listener was provided so delete all\n                // event listeners for this event name\n                delete this._eventListeners[eventName];\n                return this;\n            }\n            // No listener provided, delete all listeners for this id\n            delete this._eventListeners[eventName][id];\n            return this;\n        }\n        const arr = this._eventListeners[eventName][id] || [];\n        const index = arr.indexOf(listener);\n        if (index > -1) {\n            arr.splice(index, 1);\n        }\n        return this;\n    }\n    on(eventName, ...rest) {\n        const restTypes = rest.map((arg) => typeof arg);\n        if (restTypes[0] === \"function\") {\n            return this._on(eventName, \"*\", rest[0]);\n        }\n        return this._on(eventName, rest[0], rest[1]);\n    }\n    once(eventName, ...rest) {\n        const restTypes = rest.map((arg) => typeof arg);\n        if (restTypes[0] === \"function\") {\n            return this._once(eventName, \"*\", rest[0]);\n        }\n        return this._once(eventName, rest[0], rest[1]);\n    }\n    overwrite(eventName, ...rest) {\n        const restTypes = rest.map((arg) => typeof arg);\n        if (restTypes[0] === \"function\") {\n            this.off(eventName);\n            return this._on(eventName, \"*\", rest[0]);\n        }\n        this.off(eventName, rest[0]);\n        return this._on(eventName, rest[0], rest[1]);\n    }\n    off(eventName, ...rest) {\n        if (rest.length === 0) {\n            // Only event was provided, use * as the id to mean \"any without\"\n            // a specific id\n            return this._off(eventName, \"*\");\n        }\n        const restTypes = rest.map((arg) => typeof arg);\n        if (restTypes[0] === \"function\") {\n            // The first arg after the event name was a function (listener)\n            // so remove listening for events for this specific listener\n            return this._off(eventName, \"*\", rest[0]);\n        }\n        // Both id and listener were provided, remove for the specific id\n        return this._off(eventName, rest[0], rest[1]);\n    }\n    /**\n     * Emit an event by name.\n     * @param {Object} eventName The name of the event to emit.\n     * @param {...any} data The arguments to send to any listening methods.\n     * If you are sending multiple arguments, separate them with a comma so\n     * that they are received by the function as separate arguments.\n     * @return {number}\n     * @example #Emit an Event\n     *     // Emit the event named \"hello\"\n     *     myEntity.emit('hello');\n     * @example #Emit an Event With Data Object\n     *     // Emit the event named \"hello\"\n     *     myEntity.emit('hello', {moo: true});\n     * @example #Emit an Event With Multiple Data Values\n     *     // Emit the event named \"hello\"\n     *     myEntity.emit('hello', {moo: true}, 'someString');\n     * @example #Listen for Event Data\n     *     // Set a listener to listen for the data (multiple values emitted\n     *     // from an event are passed as function arguments)\n     *     myEntity.on('hello', function (arg1, arg2) {\n     *         console.log(arg1, arg2);\n     *     }\n     *\n     *     // Emit the event named \"hello\"\n     *     myEntity.emit('hello', 'data1', 'data2');\n     *\n     *     // The console output is:\n     *     //    data1, data2\n     */\n    emit(eventName, ...data) {\n        if (!this._eventListeners) {\n            return _enums_IgeEventReturnFlag__WEBPACK_IMPORTED_MODULE_1__.IgeEventReturnFlag.none;\n        }\n        const id = \"*\";\n        let returnFlag = _enums_IgeEventReturnFlag__WEBPACK_IMPORTED_MODULE_1__.IgeEventReturnFlag.none;\n        this._eventsEmitting = true;\n        if (this._eventListeners[eventName] && this._eventListeners[eventName][id]) {\n            // Handle global emit\n            const arr = this._eventListeners[eventName][id];\n            const arrCount = arr.length;\n            for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                // Check we have a function to execute\n                const tmpFunc = arr[arrIndex];\n                if (typeof tmpFunc === \"function\") {\n                    const result = tmpFunc(...data);\n                    if (result) {\n                        returnFlag = _enums_IgeEventReturnFlag__WEBPACK_IMPORTED_MODULE_1__.IgeEventReturnFlag.cancel;\n                    }\n                }\n            }\n        }\n        this._eventsEmitting = false;\n        this._processRemovalQueue();\n        return returnFlag;\n    }\n    emitId(eventName, id, ...data) {\n        this._eventListeners = this._eventListeners || {};\n        this._eventsEmitting = true;\n        if (!this._eventListeners[eventName]) {\n            this._eventsEmitting = false;\n            this._processRemovalQueue();\n            return this;\n        }\n        // Handle id emit\n        if (this._eventListeners[eventName][id]) {\n            const arr = this._eventListeners[eventName][id];\n            const arrCount = arr.length;\n            for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                // Check we have a function to execute\n                const tmpFunc = arr[arrIndex];\n                if (typeof tmpFunc === \"function\") {\n                    tmpFunc.call(this, ...data);\n                }\n            }\n        }\n        // Handle global emit\n        if (this._eventListeners[eventName][\"*\"]) {\n            const arr = this._eventListeners[eventName][\"*\"];\n            const arrCount = arr.length;\n            for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                // Check we have a function to execute\n                const tmpFunc = arr[arrIndex];\n                if (typeof tmpFunc === \"function\") {\n                    tmpFunc.call(this, ...data);\n                }\n            }\n        }\n        this._eventsEmitting = false;\n        this._processRemovalQueue();\n        return this;\n    }\n    /**\n     * Handles emitting events, is an internal method not called directly.\n     * @param {String} eventName The name of the event to emit.\n     * @param {...any} data Optional arguments to emit with the event.\n     * @returns {IgeEventingClass} The emitter instance.\n     * @private\n     */\n    emitStatic(eventName, ...data) {\n        const id = \"*\";\n        this._eventListeners = this._eventListeners || {};\n        this._eventsEmitting = true;\n        if (this._eventListeners[eventName] && this._eventListeners[eventName][id]) {\n            // Handle global emit\n            const arr = this._eventListeners[eventName][id];\n            const arrCount = arr.length;\n            for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                // Check we have a function to execute\n                const tmpFunc = arr[arrIndex];\n                if (typeof tmpFunc === \"function\") {\n                    tmpFunc.call(this, ...data);\n                }\n            }\n        }\n        this._eventsEmitting = false;\n        this._eventStaticEmitters = this._eventStaticEmitters || {};\n        this._eventStaticEmitters[eventName] = this._eventStaticEmitters[eventName] || [];\n        this._eventStaticEmitters[eventName].push({\n            id: \"*\",\n            args: data\n        });\n        this._processRemovalQueue();\n        return this;\n    }\n    /**\n     * Handles emitting events, is an internal method not called directly.\n     * @param {String} eventName The name of the event to emit.\n     * @param {String} id The id of the event to emit.\n     * @param {...any} data Optional arguments to emit with the event.\n     * @returns {IgeEventingClass} The emitter instance.\n     * @private\n     */\n    emitStaticId(eventName, id, ...data) {\n        if (!id)\n            throw new Error(\"Missing id from emitId call!\");\n        this._eventListeners = this._eventListeners || {};\n        this._eventsEmitting = true;\n        if (this._eventListeners[eventName]) {\n            // Handle id emit\n            if (this._eventListeners[eventName][id]) {\n                const arr = this._eventListeners[eventName][id];\n                const arrCount = arr.length;\n                for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                    // Check we have a function to execute\n                    const tmpFunc = arr[arrIndex];\n                    if (typeof tmpFunc === \"function\") {\n                        tmpFunc.call(this, ...data);\n                    }\n                }\n            }\n            // Handle global emit\n            if (this._eventListeners[eventName][\"*\"]) {\n                const arr = this._eventListeners[eventName][\"*\"];\n                const arrCount = arr.length;\n                for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                    // Check we have a function to execute\n                    const tmpFunc = arr[arrIndex];\n                    if (typeof tmpFunc === \"function\") {\n                        tmpFunc.call(this, ...data);\n                    }\n                }\n            }\n        }\n        this._eventsEmitting = false;\n        this._eventStaticEmitters = this._eventStaticEmitters || {};\n        this._eventStaticEmitters[eventName] = this._eventStaticEmitters[eventName] || [];\n        this._eventStaticEmitters[eventName].push({\n            id,\n            args: data\n        });\n        this._processRemovalQueue();\n        return this;\n    }\n    /**\n     * Handles removing emitters, is an internal method not called directly.\n     * @param {String} eventName The event to remove static emitter for.\n     * @returns {IgeEventingClass} The emitter instance.\n     * @private\n     */\n    cancelStatic(eventName) {\n        this._eventStaticEmitters = this._eventStaticEmitters || {};\n        this._eventStaticEmitters[eventName] = [];\n        return this;\n    }\n    /**\n     * Checks if an event has any event listeners or not.\n     * @param {String} eventName The name of the event to check for.\n     * @returns {boolean} True if one or more event listeners are registered for\n     * the event. False if none are found.\n     */\n    willEmit(eventName) {\n        const id = \"*\";\n        if (!this._eventListeners || !this._eventListeners[eventName]) {\n            return false;\n        }\n        const arr = this._eventListeners[eventName][id];\n        const arrCount = arr.length;\n        for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n            // Check we have a function to execute\n            const tmpFunc = arr[arrIndex];\n            if (typeof tmpFunc === \"function\") {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks if an event has any event listeners or not based on the passed id.\n     * @param {String} eventName The name of the event to check for.\n     * @param {String} id The event ID to check for.\n     * @returns {boolean} True if one or more event listeners are registered for\n     * the event. False if none are found.\n     */\n    willEmitId(eventName, id) {\n        if (!this._eventListeners || !this._eventListeners[eventName]) {\n            return false;\n        }\n        // Handle id emit\n        if (this._eventListeners[eventName][id]) {\n            const arr = this._eventListeners[eventName][id];\n            const arrCount = arr.length;\n            for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                // Check we have a function to execute\n                const tmpFunc = arr[arrIndex];\n                if (typeof tmpFunc === \"function\") {\n                    return true;\n                }\n            }\n        }\n        // Handle global emit\n        if (this._eventListeners[eventName][\"*\"]) {\n            const arr = this._eventListeners[eventName][\"*\"];\n            const arrCount = arr.length;\n            for (let arrIndex = 0; arrIndex < arrCount; arrIndex++) {\n                // Check we have a function to execute\n                const tmpFunc = arr[arrIndex];\n                if (typeof tmpFunc === \"function\") {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Queues an event to be fired. This has automatic de-bouncing so that any\n     * events of the same type that occur within 100 milliseconds of a previous\n     * one will all be wrapped into a single emit rather than emitting tons of\n     * events for lots of chained inserts etc. Only the data from the last\n     * de-bounced event will be emitted.\n     * @param {String} eventName The name of the event to emit.\n     * @param {...any} data Optional arguments to emit with the event.\n     * @returns {IgeEventingClass} The emitter instance.\n     */\n    deferEmit(eventName, ...data) {\n        if (!this._eventsAllowDefer) {\n            // Check for an existing timeout\n            this._eventsDeferTimeouts = this._eventsDeferTimeouts || {};\n            if (this._eventsDeferTimeouts[eventName]) {\n                clearTimeout(this._eventsDeferTimeouts[eventName]);\n            }\n            // Set a timeout\n            this._eventsDeferTimeouts[eventName] = setTimeout(() => {\n                this.emit.call(this, eventName, ...data);\n            }, 1);\n        }\n        else {\n            this.emit.call(this, eventName, ...data);\n        }\n        return this;\n    }\n    /**\n     * If events are cleared with the off() method while the event emitter is\n     * actively processing any events then the off() calls get added to a\n     * queue to be executed after the event emitter is finished. This stops\n     * errors that might occur by potentially modifying the event queue while\n     * the emitter is running through them. This method is called after the\n     * event emitter is finished processing.\n     * @private\n     */\n    _processRemovalQueue() {\n        if (!this._eventRemovalQueue || !this._eventRemovalQueue.length) {\n            return;\n        }\n        // Execute each removal call\n        for (let i = 0; i < this._eventRemovalQueue.length; i++) {\n            this._eventRemovalQueue[i]();\n        }\n        // Clear the removal queue\n        this._eventRemovalQueue = [];\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeEventingClass.ts?");

/***/ }),

/***/ "./src/engine/core/IgeMetrics.ts":
/*!***************************************!*\
  !*** ./src/engine/core/IgeMetrics.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeMetrics: () => (/* binding */ IgeMetrics)\n/* harmony export */ });\nclass IgeMetrics {\n    constructor() {\n        this.drawCount = 0;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeMetrics.ts?");

/***/ }),

/***/ "./src/engine/core/IgeObjectRegister.ts":
/*!**********************************************!*\
  !*** ./src/engine/core/IgeObjectRegister.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeObjectRegister: () => (/* binding */ IgeObjectRegister)\n/* harmony export */ });\nclass IgeObjectRegister {\n    constructor() {\n        this._store = {};\n    }\n    get(id) {\n        return this._store[id];\n    }\n    all() {\n        return this._store;\n    }\n    /**\n     * Register an object with the engine object register. The\n     * register allows you to access an object by its id with\n     * a call to ige.$(objectId).\n     * @param {Object} obj The object to register.\n     * @return {*}\n     */\n    add(obj) {\n        if (this._store[obj.id()]) {\n            obj._idRegistered = false;\n            throw new Error(`Cannot add object id \"${obj.id()}\" to scenegraph because there is already another object in the graph with the same ID!`);\n        }\n        this._store[obj.id()] = obj;\n        obj._idRegistered = true;\n        return this;\n    }\n    /**\n     * Un-register an object with the engine object register. The\n     * object will no longer be accessible via ige.$().\n     * @param {Object} obj The object to un-register.\n     * @return {*}\n     */\n    remove(obj) {\n        // Check if the object is registered in the ID lookup\n        if (!this._store[obj.id()]) {\n            return;\n        }\n        delete this._store[obj.id()];\n        obj._idRegistered = false;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeObjectRegister.ts?");

/***/ }),

/***/ "./src/engine/core/IgePoint3d.ts":
/*!***************************************!*\
  !*** ./src/engine/core/IgePoint3d.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgePoint3d: () => (/* binding */ IgePoint3d)\n/* harmony export */ });\nlet IgeTweenModule;\n__webpack_require__.e(/*! import() */ \"src_engine_core_IgeTween_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/engine/core/IgeTween */ \"./src/engine/core/IgeTween.ts\")).then((module) => {\n    IgeTweenModule = module.IgeTween;\n}).catch(() => {\n    class IgeTweenFake {\n        constructor() {\n            throw new Error(\"Could not dynamically load IgeTween class!\");\n        }\n    }\n    IgeTweenModule = IgeTweenFake;\n});\n/**\n * Creates a new 3d point (x, y, z).\n */\nclass IgePoint3d {\n    constructor(x = 0, y = 0, z = 0, floor = false) {\n        this.classId = \"IgePoint3d\";\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.x2 = 0;\n        this.y2 = 0;\n        this.z2 = 0;\n        this._floor = false;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this._floor = floor;\n        if (this._floor) {\n            this.x2 = Math.floor(x / 2);\n            this.y2 = Math.floor(y / 2);\n            this.z2 = Math.floor(z / 2);\n            return this;\n        }\n        this.x2 = x / 2;\n        this.y2 = y / 2;\n        this.z2 = z / 2;\n    }\n    floor(val) {\n        if (val !== undefined) {\n            this._floor = val;\n            return this;\n        }\n        return this._floor;\n    }\n    /**\n     * Compares this point's x, y, z data with the passed point and returns\n     * true if they are the same and false if any is different.\n     * @param {IgePoint3d} point The point to compare data with.\n     * @return {boolean}\n     */\n    compare(point) {\n        return point && this.x === point.x && this.y === point.y && this.z === point.z;\n    }\n    /**\n     * Copies the x, y, z data from the passed point and overwrites this\n     * point's data with those values.\n     * @param {IgePoint3d} point The point to copy values from.\n     * @returns {*}\n     */\n    copy(point) {\n        this.x = point.x;\n        this.y = point.y;\n        this.z = point.z;\n        return this;\n    }\n    /**\n     * Converts the point's x, y, z to an isometric x, y 2d co-ordinate\n     * and returns an object whose x, y values are the result.\n     * @return IgePoint3d\n     */\n    toIso() {\n        return new IgePoint3d(this.x - this.y, -this.z * 1.2247 + (this.x + this.y) * 0.5, 0);\n    }\n    /**\n     * Converts this point's x, y, z data into isometric co-ordinate space\n     * and overwrites the previous x, y, z values with the result.\n     * @return {*}\n     */\n    thisToIso() {\n        const val = this.toIso();\n        this.x = val.x;\n        this.y = val.y;\n        return this;\n    }\n    /**\n     * Converts this point's x, y, z data into 2d co-ordinate space\n     * and returns an object whose x, y values are the result.\n     * @return IgePoint3d\n     */\n    to2d() {\n        return new IgePoint3d(this.y + this.x / 2, this.y - this.x / 2, 0);\n    }\n    /**\n     * Converts this point's x, y, z data into 2d co-ordinate space\n     * and overwrites the previous x, y, z values with the result.\n     * @return {*}\n     */\n    thisTo2d() {\n        const val = this.to2d();\n        this.x = val.x;\n        this.y = val.y;\n        this.z = 0;\n        return this;\n    }\n    /**\n     * Adds this point's data by the x, y, z, values specified\n     * and returns a new IgePoint3d whose values are the result.\n     * @param point\n     * @return {*}\n     */\n    addPoint(point) {\n        return new IgePoint3d(this.x + point.x, this.y + point.y, this.z + point.z);\n    }\n    /**\n     * Adds this point's data by the x, y, z values specified and\n     * overwrites the previous x, y, z values with the result.\n     * @param {IgePoint3d} point\n     * @return {*}\n     */\n    thisAddPoint(point) {\n        this.x += point.x;\n        this.y += point.y;\n        this.z += point.z;\n        return this;\n    }\n    /**\n     * Minuses this point's data by the x, y, z, values specified\n     * and returns a new IgePoint3d whose values are the result.\n     * @param point\n     * @return {*}\n     */\n    minusPoint(point) {\n        return new IgePoint3d(this.x - point.x, this.y - point.y, this.z - point.z);\n    }\n    /**\n     * Minuses this point's data by the x, y, z values specified and\n     * overwrites the previous x, y, z values with the result.\n     * @param point\n     * @return {*}\n     */\n    thisMinusPoint(point) {\n        this.x -= point.x;\n        this.y -= point.y;\n        this.z -= point.z;\n        return this;\n    }\n    /**\n     * Multiplies this point's data by the x, y, z, values specified\n     * and returns a new IgePoint3d whose values are the result.\n     * @param x\n     * @param y\n     * @param z\n     * @return {*}\n     */\n    multiply(x, y, z) {\n        return new IgePoint3d(this.x * x, this.y * y, this.z * z);\n    }\n    /**\n     * Multiplies this point's data by the point specified\n     * and returns a new IgePoint3d whose values are the result.\n     * @param {IgePoint3d} point\n     * @return {*}\n     */\n    multiplyPoint(point) {\n        return new IgePoint3d(this.x * point.x, this.y * point.y, this.z * point.z);\n    }\n    /**\n     * Multiplies this point's data by the x, y, z values specified and\n     * overwrites the previous x, y, z values with the result.\n     * @param x\n     * @param y\n     * @param z\n     * @return {*}\n     */\n    thisMultiply(x, y, z) {\n        this.x *= x;\n        this.y *= y;\n        this.z *= z;\n        return this;\n    }\n    /**\n     * Divides this point's data by the x, y, z, values specified\n     * and returns a new IgePoint3d whose values are the result.\n     * @param x\n     * @param y\n     * @param z\n     * @return {*}\n     */\n    divide(x, y, z) {\n        return new IgePoint3d(this.x / x, this.y / y, this.z / z);\n    }\n    /**\n     * Divides this point's data by the point specified\n     * and returns a new IgePoint3d whose values are the result.\n     * @param {IgePoint3d} point\n     * @return {*}\n     */\n    dividePoint(point) {\n        let newX = this.x, newY = this.y, newZ = this.z;\n        if (point.x) {\n            newX = this.x / point.x;\n        }\n        if (point.y) {\n            newY = this.y / point.y;\n        }\n        if (point.z) {\n            newZ = this.z / point.z;\n        }\n        return new IgePoint3d(newX, newY, newZ);\n    }\n    /**\n     * Divides this point's data by the x, y, z values specified and\n     * overwrites the previous x, y, z values with the result.\n     * @param x\n     * @param y\n     * @param z\n     * @return {*}\n     */\n    thisDivide(x, y, z) {\n        this.x /= x;\n        this.y /= y;\n        this.z /= z;\n        return this;\n    }\n    /**\n     * Returns a clone of this IgePoint3d's data as a new instance.\n     * @return {*}\n     */\n    clone() {\n        return new IgePoint3d(this.x, this.y, this.z);\n    }\n    /**\n     * Interpolates the x, y, z values of this point towards the endPoint's\n     * x, y, z values based on the passed time variables and returns a new\n     * IgePoint3d whose values are the result.\n     * @param {IgePoint2d} endPoint\n     * @param {number} startTime\n     * @param {number} currentTime\n     * @param {number} endTime\n     * @return {*}\n     */\n    interpolate(endPoint, startTime, currentTime, endTime) {\n        const totalX = endPoint.x - this.x, totalY = endPoint.y - this.y, totalZ = endPoint.z - this.z, totalTime = endTime - startTime, deltaTime = totalTime - (currentTime - startTime), timeRatio = deltaTime / totalTime;\n        return new IgePoint3d(endPoint.x - totalX * timeRatio, endPoint.y - totalY * timeRatio, endPoint.z - totalZ * timeRatio);\n    }\n    /**\n     * Rotates the point by the given radians.\n     * @param {number} radians Radians to rotate by.\n     * @return {IgePoint3d} A new point with the rotated x, y.\n     */\n    rotate(radians) {\n        const s = Math.sin(radians), c = Math.cos(radians), x = c * this.x - s * this.y, y = s * this.x - c * this.y;\n        return new IgePoint3d(x, y, this.z);\n    }\n    /**\n     * Rotates the point by the given radians and updates this point\n     * to the new x, y values.\n     * @param {number} radians Radians to rotate by.\n     * @return {IgePoint3d} This point.\n     */\n    thisRotate(radians) {\n        const s = Math.sin(radians), c = Math.cos(radians), { x, y } = this;\n        this.x = c * x - s * y;\n        this.y = s * x - c * y;\n        return this;\n    }\n    /**\n     * Returns a string representation of the point's x, y, z\n     * converting floating point values into fixed using the\n     * passed precision parameter. If no precision is specified\n     * then the precision defaults to 2.\n     * @param {number=} precision\n     * @return {string}\n     */\n    toString(precision = 2) {\n        return this.x.toFixed(precision) + \",\" + this.y.toFixed(precision) + \",\" + this.z.toFixed(precision);\n    }\n    tween(props, durationMs, options) {\n        const newTween = new IgeTweenModule().targetObj(this).properties(props).duration(durationMs);\n        if (options) {\n            if (options.beforeTween) {\n                newTween.beforeTween(options.beforeTween);\n            }\n            if (options.afterTween) {\n                newTween.afterTween(options.afterTween);\n            }\n            if (options.easing) {\n                newTween.easing(options.easing);\n            }\n            if (options.startTime) {\n                newTween.startTime(options.startTime);\n            }\n        }\n        return newTween;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgePoint3d.ts?");

/***/ }),

/***/ "./src/engine/core/IgeRouter.ts":
/*!**************************************!*\
  !*** ./src/engine/core/IgeRouter.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeRouter: () => (/* binding */ IgeRouter)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeBaseClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeBaseClass */ \"./src/engine/core/IgeBaseClass.ts\");\n/* harmony import */ var _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/utils/clientServer */ \"./src/engine/utils/clientServer.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst PATH_DELIMITER = \"/\";\nclass IgeRouter extends _engine_core_IgeBaseClass__WEBPACK_IMPORTED_MODULE_0__.IgeBaseClass {\n    constructor() {\n        super(...arguments);\n        this.classId = \"IgeRouter\";\n        this._routeLoad = {};\n        this._routeUnload = {};\n        this._currentRoutePath = \"\";\n        this._routeQueue = [];\n        this._executingSeries = false;\n    }\n    route(path, definition) {\n        if (path !== undefined) {\n            if (definition !== undefined) {\n                this._routeLoad = this._routeLoad || {};\n                this._routeLoad[path] = definition;\n                return this;\n            }\n            return this._routeLoad[path];\n        }\n        return this._routeLoad;\n    }\n    /**\n     * Navigate to a given path and execute the corresponding route handler(s).\n     *\n     * @param {string} path The path to navigate to.\n     * @param {...any} args Additional arguments to pass to the route handler(s).\n     * @throws {Error} If the route defined for the given path does not exist.\n     */\n    go(path, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Check for a route definition first\n            if (!this._routeLoad[path]) {\n                throw new Error(\"Attempt to navigate to undefined route: \" + path);\n            }\n            if (path === this._currentRoutePath)\n                return;\n            this.log(`Router navigating to: ${path}`);\n            const currentRoutePath = this._currentRoutePath;\n            const currentPathParts = currentRoutePath.split(PATH_DELIMITER);\n            const newPathParts = path.split(PATH_DELIMITER);\n            const commonPathParts = [];\n            // Remove the common path parts from both arrays\n            while (currentPathParts.length && newPathParts.length && currentPathParts[0] === newPathParts[0]) {\n                const part = currentPathParts.shift();\n                newPathParts.shift();\n                if (!part)\n                    continue;\n                commonPathParts.push(part);\n            }\n            const rootPath = commonPathParts.join(PATH_DELIMITER);\n            if (currentRoutePath) {\n                // Word backwards and call the unload function for each existing path\n                while (currentPathParts.length) {\n                    const unloadRoutePath = this._pathJoin(rootPath, currentPathParts.join(PATH_DELIMITER));\n                    this.logIndent();\n                    this.log(`Unloading route: \"${unloadRoutePath}\"`);\n                    this.logIndent();\n                    const routeUnloadHandler = this._routeUnload[unloadRoutePath];\n                    if (routeUnloadHandler) {\n                        yield routeUnloadHandler(...args);\n                    }\n                    this.logOutdent();\n                    this.logOutdent();\n                    currentPathParts.pop();\n                }\n            }\n            // Now work forwards on the new path parts and mount each route\n            // handler\n            const newPartsAggregate = [];\n            for (let i = 0; i < newPathParts.length; i++) {\n                newPartsAggregate.push(newPathParts[i]);\n                const loadRoutePath = this._pathJoin(rootPath, newPartsAggregate.join(PATH_DELIMITER));\n                const routeHandlerDefinition = this._routeLoad[loadRoutePath];\n                if (!routeHandlerDefinition) {\n                    continue;\n                }\n                let routeHandlerFunction;\n                if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_1__.isClient && routeHandlerDefinition.client) {\n                    routeHandlerFunction = routeHandlerDefinition.client;\n                }\n                if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_1__.isServer && routeHandlerDefinition.server) {\n                    routeHandlerFunction = routeHandlerDefinition.server;\n                }\n                if (routeHandlerFunction) {\n                    this.logIndent();\n                    this.log(`Loading route: \"${loadRoutePath}\"`);\n                    this.logIndent();\n                    this._routeUnload[loadRoutePath] = yield routeHandlerFunction(...args);\n                    this.logOutdent();\n                    this.logOutdent();\n                }\n            }\n            this._currentRoutePath = path;\n        });\n    }\n    _pathJoin(path1, path2) {\n        if (!path1 && !path2)\n            return \"\";\n        if (path1 && !path2)\n            return path1;\n        if (path2 && !path1)\n            return path2;\n        return path1 + PATH_DELIMITER + path2;\n    }\n    _routeAdd(path) {\n    }\n    _routeRemove(path) {\n    }\n    _processQueue() {\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeRouter.ts?");

/***/ }),

/***/ "./src/engine/core/IgeTextureStore.ts":
/*!********************************************!*\
  !*** ./src/engine/core/IgeTextureStore.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeTextureStore: () => (/* binding */ IgeTextureStore)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeAssetRegister__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeAssetRegister */ \"./src/engine/core/IgeAssetRegister.ts\");\n\nclass IgeTextureStore extends _engine_core_IgeAssetRegister__WEBPACK_IMPORTED_MODULE_0__.IgeAssetRegister {\n    constructor() {\n        super(...arguments);\n        this._textureImageStore = {};\n        this.haveAllTexturesLoaded = () => {\n            return this._assetsLoading === 0;\n        };\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeTextureStore.ts?");

/***/ }),

/***/ "./src/engine/core/IgeTimeController.ts":
/*!**********************************************!*\
  !*** ./src/engine/core/IgeTimeController.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeTimeController: () => (/* binding */ IgeTimeController)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_utils_arrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/utils/arrays */ \"./src/engine/utils/arrays.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\n\n\n\n\nclass IgeTimeController extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__.IgeEventingClass {\n    constructor() {\n        super(...arguments);\n        this.classId = \"IgeTimeController\";\n        this.componentId = \"time\";\n        this._updating = false;\n        this._timers = [];\n        this._additions = [];\n        this._removals = [];\n        this.addTimer = (timer) => {\n            if (timer) {\n                if (!this._updating) {\n                    this._timers.push(timer);\n                }\n                else {\n                    this._additions.push(timer);\n                }\n            }\n            return this;\n        };\n        this.removeTimer = (timer) => {\n            if (timer) {\n                if (!this._updating) {\n                    (0,_engine_utils_arrays__WEBPACK_IMPORTED_MODULE_2__.arrPull)(this._timers, timer);\n                }\n                else {\n                    this._removals.push(timer);\n                }\n            }\n            return this;\n        };\n        this._update = () => {\n            // Get the ige tick delta and tell our timers / intervals that an update has occurred\n            const delta = _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine._tickDelta;\n            const arr = this._timers;\n            let arrCount = arr.length;\n            while (arrCount--) {\n                arr[arrCount].addTime(delta).update();\n            }\n            // Process removing any timers that were scheduled for removal\n            this._processRemovals();\n            // Now process any additions to the timers that were scheduled to be added\n            this._processAdditions();\n            return this;\n        };\n        this._processAdditions = () => {\n            const arr = this._additions;\n            let arrCount = arr.length;\n            if (arrCount) {\n                while (arrCount--) {\n                    this._timers.push(arr[arrCount]);\n                }\n                this._additions = [];\n            }\n            return this;\n        };\n        this._processRemovals = () => {\n            const arr = this._removals;\n            let arrCount = arr.length;\n            if (arrCount) {\n                while (arrCount--) {\n                    (0,_engine_utils_arrays__WEBPACK_IMPORTED_MODULE_2__.arrPull)(this._timers, arr[arrCount]);\n                }\n                this._removals = [];\n            }\n            return this;\n        };\n    }\n    isReady() {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.dependencies.waitFor([\"engine\"], () => {\n                    // Add the time behaviour to the entity\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_1__.ige.engine.addBehaviour(_enums__WEBPACK_IMPORTED_MODULE_3__.IgeBehaviourType.preUpdate, \"time\", this._update);\n                    resolve();\n                });\n            }, 1);\n        });\n    }\n}\nIgeTimeController.componentTargetClass = \"Ige\";\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/IgeTimeController.ts?");

/***/ }),

/***/ "./src/engine/core/_global.ts":
/*!************************************!*\
  !*** ./src/engine/core/_global.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   global: () => (/* binding */ global)\n/* harmony export */ });\nconst global = {\n    _globalLogIndent: 0\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/_global.ts?");

/***/ }),

/***/ "./src/engine/core/config.ts":
/*!***********************************!*\
  !*** ./src/engine/core/config.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   igeConfig: () => (/* binding */ igeConfig)\n/* harmony export */ });\nconst igeConfig = {\n    debug: {\n        _enabled: true,\n        _timing: true\n    }\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/core/config.ts?");

/***/ }),

/***/ "./src/engine/instance.ts":
/*!********************************!*\
  !*** ./src/engine/instance.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ige: () => (/* binding */ ige)\n/* harmony export */ });\n/* harmony import */ var _engine_core_Ige__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/Ige */ \"./src/engine/core/Ige.ts\");\n/**\n * In this file we instantiate the IGE instance that all other classes and code will\n * talk to when dealing with the engine. At first, when coding version 2.x of the engine\n * I was passing the ige instance into every class as a constructor argument, but it got\n * mega tedious very quickly and I realised that I was adding a ton of complexity and\n * code in order to support a highly edge-case scenario where you might want more than\n * one engine instance to operate on at a time.\n */\n\nconst ige = new _engine_core_Ige__WEBPACK_IMPORTED_MODULE_0__.Ige();\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/instance.ts?");

/***/ }),

/***/ "./src/engine/utils/arrays.ts":
/*!************************************!*\
  !*** ./src/engine/utils/arrays.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrClone: () => (/* binding */ arrClone),\n/* harmony export */   arrPull: () => (/* binding */ arrPull),\n/* harmony export */   arrPullConditional: () => (/* binding */ arrPullConditional),\n/* harmony export */   pushUnique: () => (/* binding */ pushUnique)\n/* harmony export */ });\n/**\n * Removes the passed item from an array, the opposite of push().\n * @param arr\n * @param item\n * @return {number} The array item that was removed\n */\nconst arrPull = (arr, item) => {\n    const index = arr.indexOf(item);\n    if (index > -1) {\n        return arr.splice(index, 1);\n    }\n};\n/**\n * Removes the passed item from an array, the opposite of push().\n * @param arr\n * @param func\n * @return {number} The array index that was removed\n */\nconst arrPullConditional = (arr, func) => {\n    const index = arr.findIndex(func);\n    if (index > -1) {\n        return arr.splice(index, 1);\n    }\n};\n/**\n * Adds an item to an array, only if it does not already exist in the array.\n * @param arr\n * @param item\n * @return {boolean} True if the item was added, false if it already exists.\n */\nconst pushUnique = (arr, item) => {\n    const index = arr.indexOf(item);\n    if (index > -1) {\n        return false;\n    }\n    arr.push(item);\n    return true;\n};\n/**\n * Clones the array and returns a new non-referenced\n * array.\n * @param arr\n * @return {*}\n */\nconst arrClone = (arr) => {\n    const newArray = [];\n    for (const i in arr) {\n        if (arr.hasOwnProperty(i)) {\n            if (arr[i] instanceof Array) {\n                newArray[i] = arrClone(arr[i]);\n            }\n            else {\n                newArray[i] = arr[i];\n            }\n        }\n    }\n    return newArray;\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/arrays.ts?");

/***/ }),

/***/ "./src/engine/utils/clientServer.ts":
/*!******************************************!*\
  !*** ./src/engine/utils/clientServer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isClient: () => (/* binding */ isClient),\n/* harmony export */   isServer: () => (/* binding */ isServer),\n/* harmony export */   isWorker: () => (/* binding */ isWorker)\n/* harmony export */ });\n/// <reference lib=\"webworker\" />\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nconst isServer = typeof window === \"undefined\" && !isWorker;\nconst isClient = !isServer;\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/clientServer.ts?");

/***/ }),

/***/ "./src/engine/utils/general.ts":
/*!*************************************!*\
  !*** ./src/engine/utils/general.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   destroyAll: () => (/* binding */ destroyAll),\n/* harmony export */   getElementPosition: () => (/* binding */ getElementPosition),\n/* harmony export */   theSameAs: () => (/* binding */ theSameAs)\n/* harmony export */ });\n/**\n * Checks if the\n * property values of this object are equal to the property values\n * of the passed object. If they are the same then this method will\n * return true. Objects must not contain circular references!\n * @param {Object} obj1 The first object to compare to.\n * @param {Object} obj2 The other object to compare to.\n * @return {boolean}\n */\nconst theSameAs = (obj1, obj2) => {\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n};\n/**\n * Iterates through an array's items and calls each item's\n * destroy() method if it exists. Useful for destroying an\n * array of IgeEntity instances.\n */\nconst destroyAll = (arr) => {\n    const arrCount = arr.length;\n    for (let i = arrCount - 1; i >= 0; i--) {\n        if (typeof arr[i].destroy === \"function\") {\n            arr[i].destroy();\n        }\n    }\n};\n/**\n * Returns a promise that resolves in the given milliseconds.\n * @param ms\n */\nconst delay = (ms) => {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n};\n/**\n * Gets the bounding rectangle for the passed HTML element.\n * Uses DOM methods.\n */\nconst getElementPosition = (elem) => {\n    if (!elem) {\n        return {\n            top: 0,\n            left: 0\n        };\n    }\n    try {\n        return elem.getBoundingClientRect();\n    }\n    catch (e) {\n        return {\n            top: elem.offsetTop,\n            left: elem.offsetLeft\n        };\n    }\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/general.ts?");

/***/ }),

/***/ "./src/engine/utils/igeClassStore.ts":
/*!*******************************************!*\
  !*** ./src/engine/utils/igeClassStore.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   igeClassStore: () => (/* binding */ igeClassStore),\n/* harmony export */   registerClass: () => (/* binding */ registerClass)\n/* harmony export */ });\nconst igeClassStore = {};\nconst registerClass = (cls) => {\n    //console.log(`Registering class ${cls.name}`);\n    igeClassStore[cls.name] = cls;\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/igeClassStore.ts?");

/***/ }),

/***/ "./src/enums/IgeBehaviourType.ts":
/*!***************************************!*\
  !*** ./src/enums/IgeBehaviourType.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeBehaviourType: () => (/* binding */ IgeBehaviourType)\n/* harmony export */ });\nvar IgeBehaviourType;\n(function (IgeBehaviourType) {\n    IgeBehaviourType[\"preTick\"] = \"preTick\";\n    IgeBehaviourType[\"postTick\"] = \"postTick\";\n    IgeBehaviourType[\"preUpdate\"] = \"preUpdate\";\n    IgeBehaviourType[\"postUpdate\"] = \"postUpdate\";\n})(IgeBehaviourType || (IgeBehaviourType = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeBehaviourType.ts?");

/***/ }),

/***/ "./src/enums/IgeBox2dBodyType.ts":
/*!***************************************!*\
  !*** ./src/enums/IgeBox2dBodyType.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeBox2dBodyType: () => (/* binding */ IgeBox2dBodyType)\n/* harmony export */ });\nvar IgeBox2dBodyType;\n(function (IgeBox2dBodyType) {\n    IgeBox2dBodyType[IgeBox2dBodyType[\"static\"] = 0] = \"static\";\n    IgeBox2dBodyType[IgeBox2dBodyType[\"dynamic\"] = 1] = \"dynamic\";\n    IgeBox2dBodyType[IgeBox2dBodyType[\"kinematic\"] = 2] = \"kinematic\";\n})(IgeBox2dBodyType || (IgeBox2dBodyType = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeBox2dBodyType.ts?");

/***/ }),

/***/ "./src/enums/IgeBox2dFixtureShapeType.ts":
/*!***********************************************!*\
  !*** ./src/enums/IgeBox2dFixtureShapeType.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeBox2dFixtureShapeType: () => (/* binding */ IgeBox2dFixtureShapeType)\n/* harmony export */ });\nvar IgeBox2dFixtureShapeType;\n(function (IgeBox2dFixtureShapeType) {\n    IgeBox2dFixtureShapeType[IgeBox2dFixtureShapeType[\"box\"] = 0] = \"box\";\n    IgeBox2dFixtureShapeType[IgeBox2dFixtureShapeType[\"rectangle\"] = 1] = \"rectangle\";\n    IgeBox2dFixtureShapeType[IgeBox2dFixtureShapeType[\"circle\"] = 2] = \"circle\";\n    IgeBox2dFixtureShapeType[IgeBox2dFixtureShapeType[\"polygon\"] = 3] = \"polygon\";\n})(IgeBox2dFixtureShapeType || (IgeBox2dFixtureShapeType = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeBox2dFixtureShapeType.ts?");

/***/ }),

/***/ "./src/enums/IgeBox2dTimingMode.ts":
/*!*****************************************!*\
  !*** ./src/enums/IgeBox2dTimingMode.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeBox2dTimingMode: () => (/* binding */ IgeBox2dTimingMode)\n/* harmony export */ });\nvar IgeBox2dTimingMode;\n(function (IgeBox2dTimingMode) {\n    IgeBox2dTimingMode[IgeBox2dTimingMode[\"matchEngine\"] = 0] = \"matchEngine\";\n    IgeBox2dTimingMode[IgeBox2dTimingMode[\"constant\"] = 1] = \"constant\";\n})(IgeBox2dTimingMode || (IgeBox2dTimingMode = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeBox2dTimingMode.ts?");

/***/ }),

/***/ "./src/enums/IgeEngineState.ts":
/*!*************************************!*\
  !*** ./src/enums/IgeEngineState.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeEngineState: () => (/* binding */ IgeEngineState)\n/* harmony export */ });\nvar IgeEngineState;\n(function (IgeEngineState) {\n    IgeEngineState[IgeEngineState[\"stopped\"] = 0] = \"stopped\";\n    IgeEngineState[IgeEngineState[\"started\"] = 1] = \"started\";\n})(IgeEngineState || (IgeEngineState = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeEngineState.ts?");

/***/ }),

/***/ "./src/enums/IgeEntityRenderMode.ts":
/*!******************************************!*\
  !*** ./src/enums/IgeEntityRenderMode.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeEntityRenderMode: () => (/* binding */ IgeEntityRenderMode)\n/* harmony export */ });\nvar IgeEntityRenderMode;\n(function (IgeEntityRenderMode) {\n    IgeEntityRenderMode[IgeEntityRenderMode[\"flat\"] = 0] = \"flat\";\n    IgeEntityRenderMode[IgeEntityRenderMode[\"iso\"] = 1] = \"iso\";\n})(IgeEntityRenderMode || (IgeEntityRenderMode = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeEntityRenderMode.ts?");

/***/ }),

/***/ "./src/enums/IgeEventReturnFlag.ts":
/*!*****************************************!*\
  !*** ./src/enums/IgeEventReturnFlag.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeEventReturnFlag: () => (/* binding */ IgeEventReturnFlag)\n/* harmony export */ });\nvar IgeEventReturnFlag;\n(function (IgeEventReturnFlag) {\n    IgeEventReturnFlag[IgeEventReturnFlag[\"none\"] = 0] = \"none\";\n    IgeEventReturnFlag[IgeEventReturnFlag[\"cancel\"] = 1] = \"cancel\";\n})(IgeEventReturnFlag || (IgeEventReturnFlag = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeEventReturnFlag.ts?");

/***/ }),

/***/ "./src/enums/IgeFontAlign.ts":
/*!***********************************!*\
  !*** ./src/enums/IgeFontAlign.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeFontAlignX: () => (/* binding */ IgeFontAlignX),\n/* harmony export */   IgeFontAlignY: () => (/* binding */ IgeFontAlignY)\n/* harmony export */ });\nvar IgeFontAlignX;\n(function (IgeFontAlignX) {\n    IgeFontAlignX[IgeFontAlignX[\"left\"] = 0] = \"left\";\n    IgeFontAlignX[IgeFontAlignX[\"center\"] = 1] = \"center\";\n    IgeFontAlignX[IgeFontAlignX[\"right\"] = 2] = \"right\";\n})(IgeFontAlignX || (IgeFontAlignX = {}));\nvar IgeFontAlignY;\n(function (IgeFontAlignY) {\n    IgeFontAlignY[IgeFontAlignY[\"top\"] = 0] = \"top\";\n    IgeFontAlignY[IgeFontAlignY[\"middle\"] = 1] = \"middle\";\n    IgeFontAlignY[IgeFontAlignY[\"bottom\"] = 2] = \"bottom\";\n    IgeFontAlignY[IgeFontAlignY[\"multiLineMiddle\"] = 3] = \"multiLineMiddle\";\n})(IgeFontAlignY || (IgeFontAlignY = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeFontAlign.ts?");

/***/ }),

/***/ "./src/enums/IgeInputDeviceMap.ts":
/*!****************************************!*\
  !*** ./src/enums/IgeInputDeviceMap.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeInputDevice: () => (/* binding */ IgeInputDevice),\n/* harmony export */   IgeInputGamePadMap: () => (/* binding */ IgeInputGamePadMap),\n/* harmony export */   IgeInputKeyboardMap: () => (/* binding */ IgeInputKeyboardMap),\n/* harmony export */   IgeInputPointerMap: () => (/* binding */ IgeInputPointerMap)\n/* harmony export */ });\nvar IgeInputDevice;\n(function (IgeInputDevice) {\n    IgeInputDevice[IgeInputDevice[\"keyboard\"] = 0] = \"keyboard\";\n    IgeInputDevice[IgeInputDevice[\"pointer1\"] = 1] = \"pointer1\";\n    IgeInputDevice[IgeInputDevice[\"pointer2\"] = 2] = \"pointer2\";\n    IgeInputDevice[IgeInputDevice[\"pointer3\"] = 3] = \"pointer3\";\n    IgeInputDevice[IgeInputDevice[\"pointer4\"] = 4] = \"pointer4\";\n    IgeInputDevice[IgeInputDevice[\"pointer5\"] = 5] = \"pointer5\";\n    IgeInputDevice[IgeInputDevice[\"pointer6\"] = 6] = \"pointer6\";\n    IgeInputDevice[IgeInputDevice[\"pointer7\"] = 7] = \"pointer7\";\n    IgeInputDevice[IgeInputDevice[\"pointer8\"] = 8] = \"pointer8\";\n    IgeInputDevice[IgeInputDevice[\"pointer9\"] = 9] = \"pointer9\";\n    IgeInputDevice[IgeInputDevice[\"pointer10\"] = 10] = \"pointer10\";\n    IgeInputDevice[IgeInputDevice[\"pointer11\"] = 11] = \"pointer11\";\n    IgeInputDevice[IgeInputDevice[\"pointer12\"] = 12] = \"pointer12\";\n    IgeInputDevice[IgeInputDevice[\"gamePad1\"] = 13] = \"gamePad1\";\n    IgeInputDevice[IgeInputDevice[\"gamePad2\"] = 14] = \"gamePad2\";\n    IgeInputDevice[IgeInputDevice[\"gamePad3\"] = 15] = \"gamePad3\";\n    IgeInputDevice[IgeInputDevice[\"gamePad4\"] = 16] = \"gamePad4\";\n    IgeInputDevice[IgeInputDevice[\"gamePad5\"] = 17] = \"gamePad5\";\n    IgeInputDevice[IgeInputDevice[\"gamePad6\"] = 18] = \"gamePad6\";\n    IgeInputDevice[IgeInputDevice[\"gamePad7\"] = 19] = \"gamePad7\";\n    IgeInputDevice[IgeInputDevice[\"gamePad8\"] = 20] = \"gamePad8\";\n})(IgeInputDevice || (IgeInputDevice = {}));\nvar IgeInputGamePadMap;\n(function (IgeInputGamePadMap) {\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button1\"] = 0] = \"button1\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button2\"] = 1] = \"button2\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button3\"] = 2] = \"button3\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button4\"] = 3] = \"button4\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button5\"] = 4] = \"button5\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button6\"] = 5] = \"button6\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button7\"] = 6] = \"button7\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button8\"] = 7] = \"button8\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button9\"] = 8] = \"button9\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button10\"] = 9] = \"button10\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button11\"] = 10] = \"button11\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button12\"] = 11] = \"button12\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button13\"] = 12] = \"button13\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button14\"] = 13] = \"button14\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button15\"] = 14] = \"button15\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button16\"] = 15] = \"button16\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button17\"] = 16] = \"button17\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button18\"] = 17] = \"button18\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button19\"] = 18] = \"button19\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"button20\"] = 19] = \"button20\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"axisLeftX\"] = 20] = \"axisLeftX\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"axisLeftY\"] = 21] = \"axisLeftY\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"axisRightX\"] = 22] = \"axisRightX\";\n    IgeInputGamePadMap[IgeInputGamePadMap[\"axisRightY\"] = 23] = \"axisRightY\";\n})(IgeInputGamePadMap || (IgeInputGamePadMap = {}));\nvar IgeInputPointerMap;\n(function (IgeInputPointerMap) {\n    IgeInputPointerMap[IgeInputPointerMap[\"down\"] = 0] = \"down\";\n    IgeInputPointerMap[IgeInputPointerMap[\"up\"] = 1] = \"up\";\n    IgeInputPointerMap[IgeInputPointerMap[\"dblClick\"] = 2] = \"dblClick\";\n    IgeInputPointerMap[IgeInputPointerMap[\"move\"] = 3] = \"move\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheel\"] = 4] = \"wheel\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelX\"] = 5] = \"wheelX\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelY\"] = 6] = \"wheelY\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelZ\"] = 7] = \"wheelZ\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelUp\"] = 8] = \"wheelUp\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelDown\"] = 9] = \"wheelDown\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelLeft\"] = 10] = \"wheelLeft\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelRight\"] = 11] = \"wheelRight\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelForward\"] = 12] = \"wheelForward\";\n    IgeInputPointerMap[IgeInputPointerMap[\"wheelBackward\"] = 13] = \"wheelBackward\";\n    IgeInputPointerMap[IgeInputPointerMap[\"x\"] = 14] = \"x\";\n    IgeInputPointerMap[IgeInputPointerMap[\"y\"] = 15] = \"y\";\n    IgeInputPointerMap[IgeInputPointerMap[\"button0\"] = 16] = \"button0\";\n    IgeInputPointerMap[IgeInputPointerMap[\"button1\"] = 17] = \"button1\";\n    IgeInputPointerMap[IgeInputPointerMap[\"button2\"] = 18] = \"button2\";\n    IgeInputPointerMap[IgeInputPointerMap[\"button3\"] = 19] = \"button3\";\n    IgeInputPointerMap[IgeInputPointerMap[\"button4\"] = 20] = \"button4\";\n    IgeInputPointerMap[IgeInputPointerMap[\"button5\"] = 21] = \"button5\";\n})(IgeInputPointerMap || (IgeInputPointerMap = {}));\nvar IgeInputKeyboardMap;\n(function (IgeInputKeyboardMap) {\n    // Modifiers\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"ShiftLeft\"] = 0] = \"ShiftLeft\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"ShiftRight\"] = 1] = \"ShiftRight\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"ControlLeft\"] = 2] = \"ControlLeft\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"ControlRight\"] = 3] = \"ControlRight\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"MetaLeft\"] = 4] = \"MetaLeft\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"MetaRight\"] = 5] = \"MetaRight\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"AltLeft\"] = 6] = \"AltLeft\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"AltRight\"] = 7] = \"AltRight\";\n    // Extra Cluster\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Insert\"] = 8] = \"Insert\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Home\"] = 9] = \"Home\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"End\"] = 10] = \"End\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Delete\"] = 11] = \"Delete\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"PageUp\"] = 12] = \"PageUp\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"PageDown\"] = 13] = \"PageDown\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"ArrowUp\"] = 14] = \"ArrowUp\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"ArrowDown\"] = 15] = \"ArrowDown\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"ArrowLeft\"] = 16] = \"ArrowLeft\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"ArrowRight\"] = 17] = \"ArrowRight\";\n    // Keypad\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"NumLock\"] = 18] = \"NumLock\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"NumpadEnter\"] = 19] = \"NumpadEnter\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"NumpadMultiply\"] = 20] = \"NumpadMultiply\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"NumpadDivide\"] = 21] = \"NumpadDivide\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"NumpadAdd\"] = 22] = \"NumpadAdd\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"NumpadSubtract\"] = 23] = \"NumpadSubtract\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"NumpadDecimal\"] = 24] = \"NumpadDecimal\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad0\"] = 25] = \"Numpad0\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad1\"] = 26] = \"Numpad1\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad2\"] = 27] = \"Numpad2\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad3\"] = 28] = \"Numpad3\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad4\"] = 29] = \"Numpad4\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad5\"] = 30] = \"Numpad5\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad6\"] = 31] = \"Numpad6\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad7\"] = 32] = \"Numpad7\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad8\"] = 33] = \"Numpad8\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Numpad9\"] = 34] = \"Numpad9\";\n    // Main keyboard\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"IntlBackslash\"] = 35] = \"IntlBackslash\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Backslash\"] = 36] = \"Backslash\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Slash\"] = 37] = \"Slash\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Backspace\"] = 38] = \"Backspace\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Enter\"] = 39] = \"Enter\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Tab\"] = 40] = \"Tab\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Quote\"] = 41] = \"Quote\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Semicolon\"] = 42] = \"Semicolon\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Period\"] = 43] = \"Period\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Comma\"] = 44] = \"Comma\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Equal\"] = 45] = \"Equal\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Minus\"] = 46] = \"Minus\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"BracketLeft\"] = 47] = \"BracketLeft\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"BracketRight\"] = 48] = \"BracketRight\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Escape\"] = 49] = \"Escape\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit0\"] = 50] = \"Digit0\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit1\"] = 51] = \"Digit1\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit2\"] = 52] = \"Digit2\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit3\"] = 53] = \"Digit3\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit4\"] = 54] = \"Digit4\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit5\"] = 55] = \"Digit5\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit6\"] = 56] = \"Digit6\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit7\"] = 57] = \"Digit7\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit8\"] = 58] = \"Digit8\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"Digit9\"] = 59] = \"Digit9\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyA\"] = 60] = \"KeyA\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyB\"] = 61] = \"KeyB\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyC\"] = 62] = \"KeyC\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyD\"] = 63] = \"KeyD\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyE\"] = 64] = \"KeyE\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyF\"] = 65] = \"KeyF\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyG\"] = 66] = \"KeyG\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyH\"] = 67] = \"KeyH\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyI\"] = 68] = \"KeyI\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyJ\"] = 69] = \"KeyJ\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyK\"] = 70] = \"KeyK\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyL\"] = 71] = \"KeyL\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyM\"] = 72] = \"KeyM\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyN\"] = 73] = \"KeyN\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyO\"] = 74] = \"KeyO\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyP\"] = 75] = \"KeyP\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyQ\"] = 76] = \"KeyQ\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyR\"] = 77] = \"KeyR\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyS\"] = 78] = \"KeyS\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyT\"] = 79] = \"KeyT\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyU\"] = 80] = \"KeyU\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyV\"] = 81] = \"KeyV\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyW\"] = 82] = \"KeyW\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyX\"] = 83] = \"KeyX\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyY\"] = 84] = \"KeyY\";\n    IgeInputKeyboardMap[IgeInputKeyboardMap[\"KeyZ\"] = 85] = \"KeyZ\";\n})(IgeInputKeyboardMap || (IgeInputKeyboardMap = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeInputDeviceMap.ts?");

/***/ }),

/***/ "./src/enums/IgeIsometricDepthSortMode.ts":
/*!************************************************!*\
  !*** ./src/enums/IgeIsometricDepthSortMode.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeIsometricDepthSortMode: () => (/* binding */ IgeIsometricDepthSortMode)\n/* harmony export */ });\nvar IgeIsometricDepthSortMode;\n(function (IgeIsometricDepthSortMode) {\n    IgeIsometricDepthSortMode[IgeIsometricDepthSortMode[\"bounds3d\"] = 0] = \"bounds3d\";\n    IgeIsometricDepthSortMode[IgeIsometricDepthSortMode[\"cuboid\"] = 1] = \"cuboid\";\n    IgeIsometricDepthSortMode[IgeIsometricDepthSortMode[\"cube\"] = 2] = \"cube\";\n    IgeIsometricDepthSortMode[IgeIsometricDepthSortMode[\"none\"] = 3] = \"none\"; // No depth sorting applied\n})(IgeIsometricDepthSortMode || (IgeIsometricDepthSortMode = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeIsometricDepthSortMode.ts?");

/***/ }),

/***/ "./src/enums/IgeMountMode.ts":
/*!***********************************!*\
  !*** ./src/enums/IgeMountMode.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeMountMode: () => (/* binding */ IgeMountMode)\n/* harmony export */ });\nvar IgeMountMode;\n(function (IgeMountMode) {\n    IgeMountMode[IgeMountMode[\"flat\"] = 0] = \"flat\";\n    IgeMountMode[IgeMountMode[\"iso\"] = 1] = \"iso\";\n})(IgeMountMode || (IgeMountMode = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeMountMode.ts?");

/***/ }),

/***/ "./src/enums/IgeNetworkConstants.ts":
/*!******************************************!*\
  !*** ./src/enums/IgeNetworkConstants.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IGE_NETWORK_CHAT_JOIN_ROOM: () => (/* binding */ IGE_NETWORK_CHAT_JOIN_ROOM),\n/* harmony export */   IGE_NETWORK_CHAT_LEAVE_ROOM: () => (/* binding */ IGE_NETWORK_CHAT_LEAVE_ROOM),\n/* harmony export */   IGE_NETWORK_CHAT_LIST_ROOMS: () => (/* binding */ IGE_NETWORK_CHAT_LIST_ROOMS),\n/* harmony export */   IGE_NETWORK_CHAT_MSG: () => (/* binding */ IGE_NETWORK_CHAT_MSG),\n/* harmony export */   IGE_NETWORK_CHAT_ROOM_CREATED: () => (/* binding */ IGE_NETWORK_CHAT_ROOM_CREATED),\n/* harmony export */   IGE_NETWORK_CHAT_ROOM_LIST_USERS: () => (/* binding */ IGE_NETWORK_CHAT_ROOM_LIST_USERS),\n/* harmony export */   IGE_NETWORK_CHAT_ROOM_REMOVED: () => (/* binding */ IGE_NETWORK_CHAT_ROOM_REMOVED),\n/* harmony export */   IGE_NETWORK_JOIN_ROOM: () => (/* binding */ IGE_NETWORK_JOIN_ROOM),\n/* harmony export */   IGE_NETWORK_LEAVE_ROOM: () => (/* binding */ IGE_NETWORK_LEAVE_ROOM),\n/* harmony export */   IGE_NETWORK_REQUEST: () => (/* binding */ IGE_NETWORK_REQUEST),\n/* harmony export */   IGE_NETWORK_RESPONSE: () => (/* binding */ IGE_NETWORK_RESPONSE),\n/* harmony export */   IGE_NETWORK_STREAM_CREATE: () => (/* binding */ IGE_NETWORK_STREAM_CREATE),\n/* harmony export */   IGE_NETWORK_STREAM_DATA: () => (/* binding */ IGE_NETWORK_STREAM_DATA),\n/* harmony export */   IGE_NETWORK_STREAM_DESTROY: () => (/* binding */ IGE_NETWORK_STREAM_DESTROY),\n/* harmony export */   IGE_NETWORK_STREAM_TIME: () => (/* binding */ IGE_NETWORK_STREAM_TIME),\n/* harmony export */   IGE_NETWORK_TIME_SYNC: () => (/* binding */ IGE_NETWORK_TIME_SYNC)\n/* harmony export */ });\nconst IGE_NETWORK_STREAM_CREATE = \"_igeStreamCreate\";\nconst IGE_NETWORK_STREAM_DESTROY = \"_igeStreamDestroy\";\nconst IGE_NETWORK_STREAM_DATA = \"_igeStreamData\";\nconst IGE_NETWORK_STREAM_TIME = \"_igeStreamTime\";\nconst IGE_NETWORK_REQUEST = \"_igeRequest\";\nconst IGE_NETWORK_RESPONSE = \"_igeResponse\";\nconst IGE_NETWORK_TIME_SYNC = \"_igeNetTimeSync\";\nconst IGE_NETWORK_JOIN_ROOM = \"_igeNetJoinRoom\";\nconst IGE_NETWORK_LEAVE_ROOM = \"_igeNetLeaveRoom\";\nconst IGE_NETWORK_CHAT_MSG = \"_igeChatMsg\";\nconst IGE_NETWORK_CHAT_JOIN_ROOM = \"_igeChatJoinRoom\";\nconst IGE_NETWORK_CHAT_LEAVE_ROOM = \"_igeChatLeaveRoom\";\nconst IGE_NETWORK_CHAT_LIST_ROOMS = \"_igeChatRoomList\";\nconst IGE_NETWORK_CHAT_ROOM_LIST_USERS = \"_igeChatRoomUserList\";\nconst IGE_NETWORK_CHAT_ROOM_CREATED = \"_igeChatRoomCreated\";\nconst IGE_NETWORK_CHAT_ROOM_REMOVED = \"_igeChatRoomRemoved\";\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeNetworkConstants.ts?");

/***/ }),

/***/ "./src/enums/IgeStreamMode.ts":
/*!************************************!*\
  !*** ./src/enums/IgeStreamMode.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeStreamMode: () => (/* binding */ IgeStreamMode)\n/* harmony export */ });\nvar IgeStreamMode;\n(function (IgeStreamMode) {\n    IgeStreamMode[IgeStreamMode[\"none\"] = 0] = \"none\";\n    IgeStreamMode[IgeStreamMode[\"simple\"] = 1] = \"simple\";\n    IgeStreamMode[IgeStreamMode[\"advanced\"] = 2] = \"advanced\";\n})(IgeStreamMode || (IgeStreamMode = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeStreamMode.ts?");

/***/ }),

/***/ "./src/enums/IgeTextureRenderMode.ts":
/*!*******************************************!*\
  !*** ./src/enums/IgeTextureRenderMode.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeTextureRenderMode: () => (/* binding */ IgeTextureRenderMode)\n/* harmony export */ });\nvar IgeTextureRenderMode;\n(function (IgeTextureRenderMode) {\n    IgeTextureRenderMode[IgeTextureRenderMode[\"none\"] = 0] = \"none\";\n    IgeTextureRenderMode[IgeTextureRenderMode[\"image\"] = 1] = \"image\";\n    IgeTextureRenderMode[IgeTextureRenderMode[\"smartTexture\"] = 2] = \"smartTexture\";\n})(IgeTextureRenderMode || (IgeTextureRenderMode = {}));\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/IgeTextureRenderMode.ts?");

/***/ }),

/***/ "./src/enums/index.ts":
/*!****************************!*\
  !*** ./src/enums/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IGE_NETWORK_CHAT_JOIN_ROOM: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_CHAT_JOIN_ROOM),\n/* harmony export */   IGE_NETWORK_CHAT_LEAVE_ROOM: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_CHAT_LEAVE_ROOM),\n/* harmony export */   IGE_NETWORK_CHAT_LIST_ROOMS: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_CHAT_LIST_ROOMS),\n/* harmony export */   IGE_NETWORK_CHAT_MSG: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_CHAT_MSG),\n/* harmony export */   IGE_NETWORK_CHAT_ROOM_CREATED: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_CHAT_ROOM_CREATED),\n/* harmony export */   IGE_NETWORK_CHAT_ROOM_LIST_USERS: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_CHAT_ROOM_LIST_USERS),\n/* harmony export */   IGE_NETWORK_CHAT_ROOM_REMOVED: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_CHAT_ROOM_REMOVED),\n/* harmony export */   IGE_NETWORK_JOIN_ROOM: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_JOIN_ROOM),\n/* harmony export */   IGE_NETWORK_LEAVE_ROOM: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_LEAVE_ROOM),\n/* harmony export */   IGE_NETWORK_REQUEST: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_REQUEST),\n/* harmony export */   IGE_NETWORK_RESPONSE: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_RESPONSE),\n/* harmony export */   IGE_NETWORK_STREAM_CREATE: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_STREAM_CREATE),\n/* harmony export */   IGE_NETWORK_STREAM_DATA: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_STREAM_DATA),\n/* harmony export */   IGE_NETWORK_STREAM_DESTROY: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_STREAM_DESTROY),\n/* harmony export */   IGE_NETWORK_STREAM_TIME: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_STREAM_TIME),\n/* harmony export */   IGE_NETWORK_TIME_SYNC: () => (/* reexport safe */ _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__.IGE_NETWORK_TIME_SYNC),\n/* harmony export */   IgeBehaviourType: () => (/* reexport safe */ _IgeBehaviourType__WEBPACK_IMPORTED_MODULE_0__.IgeBehaviourType),\n/* harmony export */   IgeBox2dBodyType: () => (/* reexport safe */ _IgeBox2dBodyType__WEBPACK_IMPORTED_MODULE_1__.IgeBox2dBodyType),\n/* harmony export */   IgeBox2dFixtureShapeType: () => (/* reexport safe */ _IgeBox2dFixtureShapeType__WEBPACK_IMPORTED_MODULE_2__.IgeBox2dFixtureShapeType),\n/* harmony export */   IgeBox2dTimingMode: () => (/* reexport safe */ _IgeBox2dTimingMode__WEBPACK_IMPORTED_MODULE_3__.IgeBox2dTimingMode),\n/* harmony export */   IgeEngineState: () => (/* reexport safe */ _IgeEngineState__WEBPACK_IMPORTED_MODULE_4__.IgeEngineState),\n/* harmony export */   IgeEntityRenderMode: () => (/* reexport safe */ _IgeEntityRenderMode__WEBPACK_IMPORTED_MODULE_5__.IgeEntityRenderMode),\n/* harmony export */   IgeEventReturnFlag: () => (/* reexport safe */ _IgeEventReturnFlag__WEBPACK_IMPORTED_MODULE_6__.IgeEventReturnFlag),\n/* harmony export */   IgeFontAlignX: () => (/* reexport safe */ _IgeFontAlign__WEBPACK_IMPORTED_MODULE_7__.IgeFontAlignX),\n/* harmony export */   IgeFontAlignY: () => (/* reexport safe */ _IgeFontAlign__WEBPACK_IMPORTED_MODULE_7__.IgeFontAlignY),\n/* harmony export */   IgeInputDevice: () => (/* reexport safe */ _IgeInputDeviceMap__WEBPACK_IMPORTED_MODULE_8__.IgeInputDevice),\n/* harmony export */   IgeInputGamePadMap: () => (/* reexport safe */ _IgeInputDeviceMap__WEBPACK_IMPORTED_MODULE_8__.IgeInputGamePadMap),\n/* harmony export */   IgeInputKeyboardMap: () => (/* reexport safe */ _IgeInputDeviceMap__WEBPACK_IMPORTED_MODULE_8__.IgeInputKeyboardMap),\n/* harmony export */   IgeInputPointerMap: () => (/* reexport safe */ _IgeInputDeviceMap__WEBPACK_IMPORTED_MODULE_8__.IgeInputPointerMap),\n/* harmony export */   IgeIsometricDepthSortMode: () => (/* reexport safe */ _IgeIsometricDepthSortMode__WEBPACK_IMPORTED_MODULE_9__.IgeIsometricDepthSortMode),\n/* harmony export */   IgeMountMode: () => (/* reexport safe */ _IgeMountMode__WEBPACK_IMPORTED_MODULE_10__.IgeMountMode),\n/* harmony export */   IgeStreamMode: () => (/* reexport safe */ _IgeStreamMode__WEBPACK_IMPORTED_MODULE_12__.IgeStreamMode),\n/* harmony export */   IgeTextureRenderMode: () => (/* reexport safe */ _IgeTextureRenderMode__WEBPACK_IMPORTED_MODULE_13__.IgeTextureRenderMode)\n/* harmony export */ });\n/* harmony import */ var _IgeBehaviourType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IgeBehaviourType */ \"./src/enums/IgeBehaviourType.ts\");\n/* harmony import */ var _IgeBox2dBodyType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IgeBox2dBodyType */ \"./src/enums/IgeBox2dBodyType.ts\");\n/* harmony import */ var _IgeBox2dFixtureShapeType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IgeBox2dFixtureShapeType */ \"./src/enums/IgeBox2dFixtureShapeType.ts\");\n/* harmony import */ var _IgeBox2dTimingMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IgeBox2dTimingMode */ \"./src/enums/IgeBox2dTimingMode.ts\");\n/* harmony import */ var _IgeEngineState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IgeEngineState */ \"./src/enums/IgeEngineState.ts\");\n/* harmony import */ var _IgeEntityRenderMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IgeEntityRenderMode */ \"./src/enums/IgeEntityRenderMode.ts\");\n/* harmony import */ var _IgeEventReturnFlag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IgeEventReturnFlag */ \"./src/enums/IgeEventReturnFlag.ts\");\n/* harmony import */ var _IgeFontAlign__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IgeFontAlign */ \"./src/enums/IgeFontAlign.ts\");\n/* harmony import */ var _IgeInputDeviceMap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./IgeInputDeviceMap */ \"./src/enums/IgeInputDeviceMap.ts\");\n/* harmony import */ var _IgeIsometricDepthSortMode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./IgeIsometricDepthSortMode */ \"./src/enums/IgeIsometricDepthSortMode.ts\");\n/* harmony import */ var _IgeMountMode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./IgeMountMode */ \"./src/enums/IgeMountMode.ts\");\n/* harmony import */ var _IgeNetworkConstants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./IgeNetworkConstants */ \"./src/enums/IgeNetworkConstants.ts\");\n/* harmony import */ var _IgeStreamMode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./IgeStreamMode */ \"./src/enums/IgeStreamMode.ts\");\n/* harmony import */ var _IgeTextureRenderMode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./IgeTextureRenderMode */ \"./src/enums/IgeTextureRenderMode.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/enums/index.ts?");

/***/ }),

/***/ "./src/examples/threeJsRenderer/index.ts":
/*!***********************************************!*\
  !*** ./src/examples/threeJsRenderer/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Game: () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/utils/clientServer */ \"./src/engine/utils/clientServer.ts\");\n\n\nclass Game {\n    constructor(options) {\n        this.classId = \"Game\";\n        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.init();\n        _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.isReady().then(() => {\n            if (_engine_utils_clientServer__WEBPACK_IMPORTED_MODULE_1__.isClient) {\n                Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_three_build_three_module_js\"), __webpack_require__.e(\"src_engine_core_IgeEntity_ts\"), __webpack_require__.e(\"src_engine_core_IgeTween_ts\"), __webpack_require__.e(\"src_engine_core_IgeViewport_ts\"), __webpack_require__.e(\"src_examples_threeJsRenderer_client_ts\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./client */ \"./src/examples/threeJsRenderer/client.ts\")).then(({ Client: App }) => {\n                    _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.client = new App();\n                });\n            }\n        });\n    }\n}\nnew Game();\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/examples/threeJsRenderer/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "@irrelon/ige:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"index": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_irrelon_ige"] = self["webpackChunk_irrelon_ige"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/examples/threeJsRenderer/index.ts");
/******/ 	
/******/ })()
;