/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_irrelon_ige"] = self["webpackChunk_irrelon_ige"] || []).push([["src_engine_network_server_IgeNetIoServerController_ts"],{

/***/ "./node_modules/es5-ext/global.js":
/*!****************************************!*\
  !*** ./node_modules/es5-ext/global.js ***!
  \****************************************/
/***/ ((module) => {

eval("var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n\n\n//# sourceURL=webpack://@irrelon/ige/./node_modules/es5-ext/global.js?");

/***/ }),

/***/ "./src/engine/network/IgeNetIoBaseController.ts":
/*!******************************************************!*\
  !*** ./src/engine/network/IgeNetIoBaseController.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeNetIoBaseController: () => (/* binding */ IgeNetIoBaseController)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n\nclass IgeNetIoBaseController extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__.IgeEventingClass {\n    constructor() {\n        super(...arguments);\n        this.classId = \"IgeNetIoBaseController\";\n        this._networkCommandsIndex = []; // Maps a command name to an integer via the array index\n        this._networkCommandsLookup = {}; // Maps a command name to its index\n        this._debug = false;\n        this._debugCounter = 0;\n        this._debugMax = 100;\n        this._clientRooms = {};\n        this._socketsByRoomId = {};\n        this._timeSyncInterval = 10000; // Sync the client/server clocks every ten seconds by default\n        this._timeSyncLog = {};\n        this._latency = 0;\n        this._timeSyncStarted = false;\n        this._timeSyncTimer = 0;\n        this._sectionDesignator = \"¬\"; // Set the stream data section designator character\n    }\n    timeSyncInterval(val) {\n        if (val !== undefined) {\n            this._timeSyncInterval = val;\n            return this;\n        }\n        return this._timeSyncInterval;\n    }\n    timeToServerTime(time) {\n        if (time !== undefined) {\n            return time + this._latency;\n        }\n        return this._latency;\n    }\n    debug(val) {\n        if (val !== undefined) {\n            this._debug = val;\n            return this;\n        }\n        // Check the debug counter settings\n        if (this._debugMax > 0 && this._debugCounter >= this._debugMax) {\n            this._debug = false;\n            this._debugCounter = 0;\n            this.log(`Discontinuing further debug messages because we reached the maximum message count of ${this._debugMax}. Re-enable by running ige.network.debug(true);`);\n        }\n        return this._debug;\n    }\n    debugMax(val) {\n        if (val !== undefined) {\n            this._debugMax = val;\n            return this;\n        }\n        return this._debugMax;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/network/IgeNetIoBaseController.ts?");

/***/ }),

/***/ "./src/engine/network/server/IgeNetIoServer.ts":
/*!*****************************************************!*\
  !*** ./src/engine/network/server/IgeNetIoServer.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeNetIoServer: () => (/* binding */ IgeNetIoServer)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n/* harmony import */ var _engine_network_server_IgeNetIoSocket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/network/server/IgeNetIoSocket */ \"./src/engine/network/server/IgeNetIoSocket.ts\");\n/* harmony import */ var _engine_utils_arrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/utils/arrays */ \"./src/engine/utils/arrays.ts\");\n/* harmony import */ var _engine_utils_ids__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/utils/ids */ \"./src/engine/utils/ids.ts\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! http */ \"?0da1\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var websocket__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! websocket */ \"./node_modules/websocket/lib/browser.js\");\n/* harmony import */ var websocket__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(websocket__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\n// /**\n//  * Define the debug options object.\n//  * @type {Object}\n//  * @private\n//  */\n// NetIo._debug = {\n// \tnode: typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined',\n// \tlevel: ['log', 'warning', 'error'],\n// \tstacks: false,\n// \tthrowErrors: true,\n// \ttrace: {\n// \t\tsetup: false,\n// \t\tenabled: false,\n// \t\tmatch: ''\n// \t}\n// };\nclass IgeNetIoServer extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__.IgeEventingClass {\n    constructor(port, callback) {\n        super();\n        this.classId = \"IgeNetIoServer\";\n        this._sockets = [];\n        this._socketsById = {};\n        if (port === undefined)\n            return;\n        this.start(port, callback);\n    }\n    start(port, callback) {\n        this._port = port;\n        this._httpServer = http__WEBPACK_IMPORTED_MODULE_4___default().createServer(function (request, response) {\n            response.writeHead(404);\n            response.end();\n        });\n        this._socketServer = new (websocket__WEBPACK_IMPORTED_MODULE_5___default().server)({\n            httpServer: this._httpServer,\n            // You should not use autoAcceptConnections for production\n            // applications, as it defeats all standard cross-origin protection\n            // facilities built into the protocol and the browser.  You should\n            // *always* verify the connection's origin and decide whether\n            // to accept it.\n            autoAcceptConnections: false\n        });\n        // Setup listeners\n        this._socketServer.on(\"request\", (request) => {\n            // Make sure we only accept requests from an allowed origin\n            if (!this._originIsAllowed(request.origin)) {\n                request.reject();\n                this.log(\"Connection from origin \" + request.origin + \" rejected by origin check!\");\n                return;\n            }\n            this.log(\"Client connecting...\");\n            const connection = request.accept(\"netio1\", request.origin);\n            // Give the socket a unique ID\n            const id = (0,_engine_utils_ids__WEBPACK_IMPORTED_MODULE_3__.newIdHex)();\n            const socket = new _engine_network_server_IgeNetIoSocket__WEBPACK_IMPORTED_MODULE_1__.IgeNetIoSocket(connection, {\n                id,\n                encode: this._encode,\n                decode: this._decode\n            });\n            // Add the socket to the internal lookups\n            this._sockets.push(socket);\n            this._socketsById[id] = socket;\n            // Register a listener so that if the socket disconnects,\n            // we can remove it from the active socket lookups\n            socket.on(\"disconnect\", () => {\n                const index = this._sockets.indexOf(socket);\n                if (index > -1) {\n                    // Remove the socket from the array\n                    this._sockets.splice(index, 1);\n                }\n                delete this._socketsById[id];\n            });\n            // Tell the client their new ID\n            socket.send({\n                _netioCmd: \"id\",\n                data: id\n            });\n            this.emit(\"connection\", socket);\n        });\n        this._httpServer.on(\"error\", (err) => {\n            switch (err.code) {\n                // TODO: Add all the error codes and human readable error here!\n                case \"EADDRINUSE\":\n                    this.log(\"Cannot start server on port \" +\n                        this._port +\n                        \" because the port is already in use by another application!\", \"error\");\n                    break;\n                default:\n                    this.log(\"Cannot start server, error code: \" + err.code);\n                    break;\n            }\n        });\n        this._httpServer.listen(this._port, () => {\n            this.log(\"Server is listening on port \" + this._port);\n            if (typeof callback === \"function\") {\n                callback();\n            }\n        });\n    }\n    /**\n     * Sends a message. If the client id is not specified\n     * the message will be sent to all connected clients.\n     *\n     * @param {Object} data The JSON data to send.\n     * @param {*=} clientIdOrArrayOfIds The id of the client to send to, or an array of id's to send to.\n     */\n    send(data, clientIdOrArrayOfIds) {\n        // Pre-encode the data and then use _send to send raw\n        // instead of encoding for every socket\n        const encodedData = this._encode(data);\n        if (clientIdOrArrayOfIds === undefined) {\n            // No client id provided, send to all connected clients\n            this._sendToEach((0,_engine_utils_arrays__WEBPACK_IMPORTED_MODULE_2__.arrClone)(this._sockets), encodedData);\n            return;\n        }\n        if (typeof clientIdOrArrayOfIds === \"string\") {\n            // There is only one recipient\n            if (this._socketsById[clientIdOrArrayOfIds]) {\n                this._sendToEach([this._socketsById[clientIdOrArrayOfIds]], encodedData);\n                return;\n            }\n            this.log(`Cannot send data to socket \"${clientIdOrArrayOfIds}\", client disconnect before data could be processed?`, \"info\");\n            return;\n        }\n        // There is an array of recipients\n        const recipientArray = clientIdOrArrayOfIds.reduce((finalArr, clientId) => {\n            const clientSocket = this._socketsById[clientId];\n            if (clientSocket)\n                finalArr.push(clientSocket);\n            return finalArr;\n        }, []);\n        this._sendToEach(recipientArray, encodedData);\n    }\n    /**\n     * Sends an encoded data string to an array of client sockets.\n     * @param recipientArray An array of client sockets.\n     * @param encodedData The string encoded data to send each client.\n     */\n    _sendToEach(recipientArray, encodedData) {\n        let arrCount = recipientArray.length;\n        while (arrCount--) {\n            if (!recipientArray[arrCount])\n                continue;\n            recipientArray[arrCount]._send(encodedData);\n        }\n    }\n    /**\n     * Determines if the origin of a request should be allowed or denied.\n     * @param origin\n     * @return {boolean}\n     * @private\n     */\n    _originIsAllowed(origin) {\n        // TODO: Allow origins to be specified on startup and checked against here!\n        // put logic here to detect whether the specified origin is allowed.\n        return true;\n    }\n    /**\n     * Encodes the passed JSON data into a data packet.\n     * @param data\n     * @return {*}\n     * @private\n     */\n    _encode(data) {\n        return JSON.stringify(data);\n    }\n    /**\n     * Decodes a data packet back into JSON data.\n     * @param data\n     * @return {*}\n     * @private\n     */\n    _decode(data) {\n        return JSON.parse(data);\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/network/server/IgeNetIoServer.ts?");

/***/ }),

/***/ "./src/engine/network/server/IgeNetIoServerController.ts":
/*!***************************************************************!*\
  !*** ./src/engine/network/server/IgeNetIoServerController.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeNetIoServerController: () => (/* binding */ IgeNetIoServerController)\n/* harmony export */ });\n/* harmony import */ var _engine_instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/instance */ \"./src/engine/instance.ts\");\n/* harmony import */ var _engine_network_IgeNetIoBaseController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/engine/network/IgeNetIoBaseController */ \"./src/engine/network/IgeNetIoBaseController.ts\");\n/* harmony import */ var _engine_network_server_IgeNetIoServer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/engine/network/server/IgeNetIoServer */ \"./src/engine/network/server/IgeNetIoServer.ts\");\n/* harmony import */ var _engine_utils_arrays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/engine/utils/arrays */ \"./src/engine/utils/arrays.ts\");\n/* harmony import */ var _engine_utils_ids__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/engine/utils/ids */ \"./src/engine/utils/ids.ts\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/enums */ \"./src/enums/index.ts\");\n\n\n\n\n\n\nclass IgeNetIoServerController extends _engine_network_IgeNetIoBaseController__WEBPACK_IMPORTED_MODULE_1__.IgeNetIoBaseController {\n    constructor() {\n        super();\n        this._idCounter = 0;\n        this._networkCommands = {}; // Maps a command name to a command handler function\n        this._requests = {};\n        this._socketById = {};\n        this._port = 8000;\n        this._acceptConnections = false;\n        this._streamInterval = 50;\n        this._queuedData = {}; // Define the object that will hold the stream data queue\n        this._streamClientData = {}; // Set some stream data containers\n        this._streamClientCreated = {}; // Set some stream data containers\n        this._streamPropertyChange = {}; // Keep track of changes that need to be sent to clients\n        this._onJoinRoom = (data, clientId) => {\n            if (data[1]) {\n                // Remove client from all rooms first\n                this.clientLeaveAllRooms(clientId);\n            }\n            this.clientJoinRoom(clientId, data[0]);\n            console.log(\"Client requested to join room with data\", data);\n        };\n        this._onLeaveRoom = (data, clientId) => {\n            if (data) {\n                this.clientLeaveRoom(clientId, data[0]);\n            }\n            else {\n                this.clientLeaveAllRooms(clientId);\n            }\n            console.log(\"Client requested to leave room with data\", data);\n        };\n        /**\n         * Called on receipt of a request message from a client.\n         * @param data The data the client sent with the request.\n         * @param clientId The id of the client that sent the request.\n         */\n        this._onRequest = (data, clientId) => {\n            if (!clientId)\n                return;\n            const responseCallback = (...args) => {\n                this.response(data.id, args);\n            };\n            // The message is a network request so fire\n            // the command event with the request id and\n            // the request data\n            data.clientId = clientId;\n            this._requests[data.id] = data;\n            if (this.debug()) {\n                this.log(\"onRequest\", data);\n                this.log(\"emitting\", data.cmd, [data.id, data.data]);\n                this._debugCounter++;\n            }\n            const commandHandler = this._networkCommands[data.cmd];\n            if (commandHandler) {\n                commandHandler(data.data, clientId, responseCallback);\n            }\n            this.emit(data.cmd, data.data, clientId, responseCallback);\n        };\n        this._onResponse = (data, clientId) => {\n            if (!clientId)\n                return;\n            // The message is a network response\n            // to a request we sent earlier\n            const id = data.id;\n            // Get the original request object from\n            // the request id\n            const req = this._requests[id];\n            if (this.debug()) {\n                console.log(\"onResponse\", data);\n                this._debugCounter++;\n            }\n            if (req) {\n                // Fire the request callback!\n                req.callback(data.data.err, clientId, data.data.data);\n                // Delete the request from memory\n                delete this._requests[id];\n            }\n        };\n        this._onTimeSync = (data, clientId) => {\n            if (!clientId)\n                return;\n            const localTime = Math.floor(_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime);\n            const sendTime = parseInt(data[1], 10);\n            //const roundTrip = (localTime - parseInt(data[0], 10));\n            /*if (localTime < sendTime) {\n                direction = 'behind';\n            } else if (localTime > sendTime) {\n                direction = 'in front of';\n            } else {\n                direction = 'same as';\n            }\n    \n            this.log('Time sync, server clock ' + (localTime - sendTime) + 'ms ' + direction + ' client, roundtrip: ' + roundTrip + 'ms, send timestamp: ' + parseInt(data[0], 10) + ', local timestamp: ' + localTime);*/\n            this._timeSyncLog[clientId] = localTime - sendTime;\n        };\n        /**\n         * Called when the server receives a client connection request. Sets\n         * up event listeners on the socket and sends the client the initial\n         * networking data required to allow network commands to operate\n         * correctly over the connection.\n         * @param {Object} socket The client socket object.\n         * @private\n         */\n        this._onClientConnect = (socket) => {\n            if (!this._acceptConnections) {\n                this.log(`Rejecting connection with id \"${socket._id}\": We are not accepting connections at the moment!`);\n                socket.close();\n                return;\n            }\n            // Check if any listener cancels this\n            if (this.emit(\"connect\", socket) === _enums__WEBPACK_IMPORTED_MODULE_5__.IgeEventReturnFlag.cancel) {\n                // Reject the connection\n                socket.close();\n                return;\n            }\n            this.log(`Accepted connection with id \"${socket._id}\"`);\n            this._socketById[socket._id] = socket;\n            // Store a rooms array for this client\n            this._clientRooms[socket._id] = this._clientRooms[socket._id] || [];\n            socket.on(\"message\", (data) => {\n                this._onClientMessage(data, socket._id);\n            });\n            socket.on(\"disconnect\", (data) => {\n                this._onClientDisconnect(data, socket);\n            });\n            // Send an init message to the client\n            socket.send({\n                cmd: \"init\",\n                ncmds: this._networkCommandsLookup,\n                ts: _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeScale,\n                ct: _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime\n            });\n            // Send a clock sync command\n            this._sendTimeSync(socket._id);\n        };\n        /**\n         * Asks the server to send the data packets for all the queued stream\n         * data to the specified clients.\n         * @private\n         */\n        this._sendQueue = () => {\n            const st = new Date().getTime();\n            const queueObj = this._queuedData;\n            const network = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.network;\n            const currentTime = _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime;\n            const hasSentTimeDataByClientId = {};\n            // Send the stream data\n            for (const entityId in queueObj) {\n                const item = queueObj[entityId];\n                item[1].forEach((clientId) => {\n                    // Check if we've already sent this client the starting\n                    // time of the stream data\n                    // TODO: Commented this because the receiving client never uses this data at all!\n                    if (!hasSentTimeDataByClientId[clientId]) {\n                        // Send the stream start time\n                        network.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_TIME, currentTime, clientId);\n                        hasSentTimeDataByClientId[clientId] = true;\n                    }\n                    network.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_DATA, item[0], clientId);\n                    // Store the new data for later comparison\n                    this._streamClientData[entityId][clientId] = item[0];\n                });\n                delete queueObj[entityId];\n                if (this._streamPropertyChange) {\n                    delete this._streamPropertyChange[entityId];\n                }\n                const ct = new Date().getTime();\n                const dt = ct - st;\n                if (dt > this._streamInterval) {\n                    console.log(\"WARNING, Stream send is taking too long: \" + dt + \"ms\");\n                    break;\n                }\n            }\n        };\n        // Define the network stream commands\n        this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_CREATE);\n        this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_DESTROY);\n        this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_DATA);\n        this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_STREAM_TIME);\n    }\n    isReady() {\n        return Promise.resolve();\n    }\n    /**\n     * Starts the network for the server.\n     * @param {*} port The port to listen on.\n     * @param {Function=} callback A callback method to call once the\n     * network has started.\n     */\n    start(port, callback) {\n        return new Promise((resolve) => {\n            this._socketById = {};\n            this._socketsByRoomId = {};\n            if (typeof port !== \"undefined\") {\n                this._port = port;\n            }\n            // Start net.io\n            this.log(\"Starting net.io listener on port \" + this._port);\n            this._io = new _engine_network_server_IgeNetIoServer__WEBPACK_IMPORTED_MODULE_2__.IgeNetIoServer(this._port, () => {\n                if (callback) {\n                    callback();\n                }\n                resolve();\n            });\n            // Setup listeners\n            this._io.on(\"connection\", this._onClientConnect);\n            // Set up default commands\n            this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_REQUEST, this._onRequest);\n            this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_RESPONSE, this._onResponse);\n            this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_TIME_SYNC, this._onTimeSync);\n            this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_JOIN_ROOM, this._onJoinRoom);\n            this.define(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_LEAVE_ROOM, this._onLeaveRoom);\n            // Start network sync\n            this.timeSyncStart();\n            this.log(\"Starting delta stream...\");\n            this._streamTimer = setInterval(this._sendQueue, this._streamInterval);\n        });\n    }\n    timeSyncStart() {\n        this._timeSyncStarted = true;\n        // Send a time sync request now, so we\n        // have a starting value to work with\n        this._sendTimeSync();\n        this.log(\"Starting client/server clock sync...\");\n        this._timeSyncTimer = setInterval(() => {\n            this._sendTimeSync();\n        }, this._timeSyncInterval);\n        return this;\n    }\n    timeSyncStop() {\n        this.log(\"Stopping client/server clock sync...\");\n        clearInterval(this._timeSyncTimer);\n        this._timeSyncStarted = false;\n        return this;\n    }\n    /**\n     * Sets a network command and optional callback. When a network command\n     * is received by the server, the callback set up for that command will\n     * automatically be called and passed the data from the incoming network\n     * packet.\n     * @param {string} commandName The name of the command to define.\n     * @param {Function=} callback A function to call when the defined network\n     * command is received by the network.\n     * @return {*}\n     */\n    define(commandName, callback) {\n        this._networkCommands[commandName] = callback;\n        // Record reverse lookups\n        const index = this._networkCommandsIndex.length;\n        this._networkCommandsIndex[index] = commandName;\n        this._networkCommandsLookup[commandName] = index;\n        return this;\n    }\n    /**\n     * Adds a client to a room by id. All clients are added to room id\n     * \"ige\" by default when they connect to the server.\n     * @param {string} clientId The id of the client to add to the room.\n     * @param {string} roomId The id of the room to add the client to.\n     * @returns {*}\n     */\n    clientJoinRoom(clientId, roomId) {\n        this._clientRooms[clientId] = this._clientRooms[clientId] || [];\n        this._clientRooms[clientId].push(roomId);\n        this._socketsByRoomId[roomId] = this._socketsByRoomId[roomId] || {};\n        this._socketsByRoomId[roomId][clientId] = this._socketById[clientId];\n        if (this.debug()) {\n            this.log(\"Client \" + clientId + \" joined room \" + roomId);\n        }\n        return this;\n    }\n    /**\n     * Removes a client from a room by id. All clients are added to room id\n     * \"ige\" by default when they connect to the server and you can remove\n     * them from it if your game defines custom rooms etc.\n     * @param {string} clientId The id of the client to remove from the room.\n     * @param {string} roomId The id of the room to remove the client from.\n     * @returns {*}\n     */\n    clientLeaveRoom(clientId, roomId) {\n        if (this._clientRooms[clientId]) {\n            (0,_engine_utils_arrays__WEBPACK_IMPORTED_MODULE_3__.arrPull)(this._clientRooms[clientId], roomId);\n            delete this._socketsByRoomId[roomId][clientId];\n        }\n        return this;\n    }\n    /**\n     * Removes a client from all rooms that it is a member of.\n     * @param {string} clientId The client id to remove from all rooms.\n     * @returns {*}\n     */\n    clientLeaveAllRooms(clientId) {\n        const arr = this._clientRooms[clientId];\n        let arrCount = arr.length;\n        while (arrCount--) {\n            this.clientLeaveRoom(clientId, arr[arrCount]);\n        }\n        delete this._clientRooms[clientId];\n        return this;\n    }\n    /**\n     * Gets the array of room ids that the client has joined.\n     * @param clientId\n     * @returns {Array} An array of string ids for each room the client has joined.\n     */\n    clientRooms(clientId) {\n        return this._clientRooms[clientId] || [];\n    }\n    /**\n     * Returns an associative array of all connected clients\n     * by their ID.\n     * @param {string=} roomId Optional, if provided will only return clients\n     * that have joined room specified by the passed roomId.\n     * @return\n     */\n    clients(roomId) {\n        if (!roomId)\n            return this._socketById;\n        return this._socketsByRoomId[roomId] || {};\n    }\n    /**\n     * Returns the socket associated with the specified client id.\n     * @param {string=} clientId\n     * @return {*}\n     */\n    socket(clientId) {\n        return this._socketById[clientId];\n    }\n    /**\n     * Gets / sets the current flag that determines if client connections\n     * should be allowed to connect (true) or dropped instantly (false).\n     * @param {boolean} val Set to true to allow connections or false\n     * to drop any incoming connections.\n     * @return {*}\n     */\n    acceptConnections(val) {\n        if (typeof val === \"undefined\") {\n            return this._acceptConnections;\n        }\n        this._acceptConnections = val;\n        if (val) {\n            this.log(\"Server now accepting connections!\");\n        }\n        else {\n            this.log(\"Server no longer accepting connections!\");\n        }\n        return this;\n    }\n    /**\n     * Sends a message over the network.\n     * @param {string} commandName\n     * @param {Object} data\n     * @param {*=} clientIdOrArrayOfIds If specified, sets the recipient socket id or\n     * an array of socket ids to send to.\n     * @param callback\n     */\n    send(commandName, data, clientIdOrArrayOfIds, callback) {\n        var _a;\n        if (callback) {\n            if (!clientIdOrArrayOfIds) {\n                this.log(\"Attempted to send a request command without specifying the recipient clientId!\", \"error\");\n                return;\n            }\n            this.request(commandName, data, clientIdOrArrayOfIds, callback);\n            return;\n        }\n        const commandIndex = this._networkCommandsLookup[commandName];\n        if (commandIndex !== undefined) {\n            const encodedCommandIndex = String.fromCharCode(commandIndex);\n            (_a = this._io) === null || _a === void 0 ? void 0 : _a.send([encodedCommandIndex, data], clientIdOrArrayOfIds);\n            return this;\n        }\n        this.log(`Cannot send network packet with command \"${commandName}\" because the command has not been defined!`, \"error\");\n        return this;\n    }\n    /**\n     * Sends a network request. This is different from a standard\n     * call to send() because the recipient code will be able to\n     * respond by calling ige.network.response(). When the response\n     * is received, the callback method that was passed in the\n     * callback parameter will be fired with the response data.\n     * @param {string} commandName\n     * @param {Object} data\n     * @param clientIdOrArrayOfIds\n     * @param {Function} callback\n     */\n    request(cmd, data, clientIdOrArrayOfIds, callback) {\n        // Build the request object\n        const req = {\n            id: (0,_engine_utils_ids__WEBPACK_IMPORTED_MODULE_4__.newIdHex)(),\n            cmd,\n            data,\n            callback,\n            timestamp: new Date().getTime()\n        };\n        // Store the request object\n        this._requests[req.id] = req;\n        // Send the network request packet\n        this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_REQUEST, {\n            id: req.id,\n            cmd,\n            data: req.data\n        }, clientIdOrArrayOfIds);\n    }\n    /**\n     * Sends a response to a network request.\n     * @param {string} requestId\n     * @param {Object} data\n     */\n    response(requestId, data) {\n        // Grab the original request object\n        const req = this._requests[requestId];\n        if (!req) {\n            return;\n        }\n        this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_RESPONSE, {\n            id: requestId,\n            cmd: req.cmd,\n            data\n        }, req.clientId);\n        delete this._requests[requestId];\n    }\n    /**\n     * Determines if the origin of a request should be allowed or denied.\n     * @param origin\n     * @return {boolean}\n     * @private\n     */\n    _originIsAllowed(origin) {\n        // put logic here to detect whether the specified origin is allowed.\n        return true;\n    }\n    _sendTimeSync(clientId) {\n        // Send the time sync command\n        const data = [_engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._currentTime];\n        this.send(_enums__WEBPACK_IMPORTED_MODULE_5__.IGE_NETWORK_TIME_SYNC, data, clientId);\n    }\n    /**\n     * Called when the server receives a network message from a client.\n     * @param {Object} data The data sent by the client.\n     * @param {string} clientId The client socket id.\n     * @private\n     */\n    _onClientMessage(data, clientId) {\n        const ciDecoded = data[0].charCodeAt(0), commandName = this._networkCommandsIndex[ciDecoded];\n        const commandHandler = this._networkCommands[commandName];\n        if (commandHandler) {\n            commandHandler(data[1], clientId);\n        }\n        this.emit(commandName, data[1], clientId);\n    }\n    /**\n     * Called when a client disconnects from the server.\n     * @param {Object} data Any data sent along with the disconnect.\n     * @param {Object} socket The client socket object.\n     * @private\n     */\n    _onClientDisconnect(data, socket) {\n        this.log(`Client disconnected with id \"${socket._id}\"`);\n        this.emit(\"disconnect\", socket._id);\n        // Remove them from all rooms\n        this.clientLeaveAllRooms(socket._id);\n        delete this._socketById[socket._id];\n    }\n    /**\n     * Gets / sets the interval by which updates to the game world are packaged\n     * and transmitted to connected clients. The greater the value, the less\n     * updates are sent per second.\n     * @param {number=} ms The number of milliseconds between stream messages.\n     */\n    sendInterval(ms) {\n        if (ms !== undefined) {\n            this.log(\"Setting delta stream interval to \" + ms / _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeScale + \"ms\");\n            this._streamInterval = ms / _engine_instance__WEBPACK_IMPORTED_MODULE_0__.ige.engine._timeScale;\n            return this;\n        }\n        return this._streamInterval;\n    }\n    /**\n     * Stops the stream of world updates to connected clients.\n     */\n    stop() {\n        this.log(\"Stopping delta stream...\");\n        clearInterval(this._streamTimer);\n        return this;\n    }\n    /**\n     * Queues stream data to be sent during the next stream data interval.\n     * @param {string} entityId The id of the entity that this data belongs to.\n     * @param {string} data The data queued for delivery to the client.\n     * @param {string} clientId The client id this data is queued for.\n     * @return {*}\n     */\n    queue(entityId, data, clientId) {\n        this._queuedData[entityId] = [data, clientId];\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/network/server/IgeNetIoServerController.ts?");

/***/ }),

/***/ "./src/engine/network/server/IgeNetIoSocket.ts":
/*!*****************************************************!*\
  !*** ./src/engine/network/server/IgeNetIoSocket.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IgeNetIoSocket: () => (/* binding */ IgeNetIoSocket)\n/* harmony export */ });\n/* harmony import */ var _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/engine/core/IgeEventingClass */ \"./src/engine/core/IgeEventingClass.ts\");\n\nclass IgeNetIoSocket extends _engine_core_IgeEventingClass__WEBPACK_IMPORTED_MODULE_0__.IgeEventingClass {\n    constructor(connection, options) {\n        super();\n        this.classId = \"IgeNetIoSocket\";\n        this._id = options.id;\n        this._encode = options.encode;\n        this._decode = options.decode;\n        this._socket = connection;\n        this._socket.on(\"message\", (message) => {\n            if (message.type === \"utf8\") {\n                this.emit(\"message\", this._decode(message.utf8Data));\n                //socket.sendUTF(message.utf8Data);\n            }\n            else if (message.type === \"binary\") {\n                console.log(\"Binary data received, no support yet!\");\n                //socket.sendBytes(message.binaryData);\n            }\n        });\n        this._socket.on(\"close\", (reasonCode, description) => {\n            this.emit(\"disconnect\", {\n                socket: this._socket,\n                reason: description,\n                code: reasonCode\n            });\n        });\n    }\n    /**\n     * Encodes the passed JSON data and sends it.\n     * @param data\n     */\n    send(data) {\n        this._socket.sendUTF(this._encode(data));\n    }\n    /**\n     * Sends pre-encoded data without encoding it.\n     * @param data\n     * @private\n     */\n    _send(data) {\n        this._socket.sendUTF(data);\n    }\n    /**\n     * Closes the socket.\n     * @param reason\n     */\n    close(reason) {\n        this.send({\n            _netioCmd: \"close\",\n            data: reason\n        });\n        this._socket.close();\n    }\n}\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/network/server/IgeNetIoSocket.ts?");

/***/ }),

/***/ "./src/engine/utils/ids.ts":
/*!*********************************!*\
  !*** ./src/engine/utils/ids.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   newId: () => (/* binding */ newId),\n/* harmony export */   newIdHex: () => (/* binding */ newIdHex),\n/* harmony export */   newIdNumber: () => (/* binding */ newIdNumber)\n/* harmony export */ });\nlet _idCounter = 0;\n/**\n * Generates a new unique ID as a number.\n * @return {number}\n */\nconst newIdNumber = () => {\n    _idCounter++;\n    return (_idCounter +\n        (Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17) +\n            Math.random() * Math.pow(10, 17)));\n};\n/**\n * Generates a new unique ID string\n * @return {string}\n */\nconst newId = () => {\n    _idCounter++;\n    return newIdNumber().toString();\n};\n/**\n * Generates a new 16-character hexadecimal unique ID\n * @return {string}\n */\nconst newIdHex = () => {\n    return newIdNumber().toString(16);\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./src/engine/utils/ids.ts?");

/***/ }),

/***/ "./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = __webpack_require__(/*! es5-ext/global */ \"./node_modules/es5-ext/global.js\");\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = __webpack_require__(/*! ./version */ \"./node_modules/websocket/lib/version.js\");\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n\n\n//# sourceURL=webpack://@irrelon/ige/./node_modules/websocket/lib/browser.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../package.json */ \"./node_modules/websocket/package.json\").version;\n\n\n//# sourceURL=webpack://@irrelon/ige/./node_modules/websocket/lib/version.js?");

/***/ }),

/***/ "?0da1":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://@irrelon/ige/http_(ignored)?");

/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"name\":\"websocket\",\"description\":\"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\"keywords\":[\"websocket\",\"websockets\",\"socket\",\"networking\",\"comet\",\"push\",\"RFC-6455\",\"realtime\",\"server\",\"client\"],\"author\":\"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\",\"contributors\":[\"Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"],\"version\":\"1.0.34\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/theturtle32/WebSocket-Node.git\"},\"homepage\":\"https://github.com/theturtle32/WebSocket-Node\",\"engines\":{\"node\":\">=4.0.0\"},\"dependencies\":{\"bufferutil\":\"^4.0.1\",\"debug\":\"^2.2.0\",\"es5-ext\":\"^0.10.50\",\"typedarray-to-buffer\":\"^3.1.5\",\"utf-8-validate\":\"^5.0.2\",\"yaeti\":\"^0.0.6\"},\"devDependencies\":{\"buffer-equal\":\"^1.0.0\",\"gulp\":\"^4.0.2\",\"gulp-jshint\":\"^2.0.4\",\"jshint-stylish\":\"^2.2.1\",\"jshint\":\"^2.0.0\",\"tape\":\"^4.9.1\"},\"config\":{\"verbose\":false},\"scripts\":{\"test\":\"tape test/unit/*.js\",\"gulp\":\"gulp\"},\"main\":\"index\",\"directories\":{\"lib\":\"./lib\"},\"browser\":\"lib/browser.js\",\"license\":\"Apache-2.0\"}');\n\n//# sourceURL=webpack://@irrelon/ige/./node_modules/websocket/package.json?");

/***/ })

}]);